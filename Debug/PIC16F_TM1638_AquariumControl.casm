;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 8.01
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

#ifndef _PIC16F_TM1638_AquariumControl_H_
#define _PIC16F_TM1638_AquariumControl_H_

// Tasks
#define TASK_TIMER0 1
#define TASK_TIMER1 2

// Port bits
#define oneWireBus (portc.5)
#define oneWireTris (trisc.5)
#define tm1638dio (portb.1)
#define tm1638dioTris (trisb.1)
#define tm1638clk (portb.2)
#define tm1638strobe (portb.3)
#define WHITE_LED (portc.1)
#define BLUE_LED (portc.2)
#define FAN (porta.1)
#define HEATER (porta.0)

// Timer 0 preload
#define TMR0PRELOAD 61
// This means timer 1 will overflow when 1 cycle completes, generating the interrupt
#define TMR1HV 0xFF
#define TMR1LV 0xFF

// I2C initialisation for built in software handling
// i2c options
#define use_i2c_SW
// clock SCL on RA3, data SDA on RA4
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)
// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3


// I2C addresses (8 bit)
#define ds3231Addr 0xD0 // Left shifted 7 bit address 0x68
#define at24c32Addr 0xAE // Left shifted 7 bit address 0x57

// Time and date variables
char gBcdSecond = 0; // 0 to 0x59
09BF  1283  	BCF STATUS, RP0
09C0  1303  	BCF STATUS, RP1
09C1  01B5  	CLRF gbl_gBcdSecond

char gBcdMinute = 0; // 0 to 0x59
09C2  01B6  	CLRF gbl_gBcdMinute

char gBcdHour = 0; // 0 to 0x23 or 1 to 0x12. Also contains 12/24 setting at bit 6. If 12 hour, AM/PM uses bit 5
09C3  01B7  	CLRF gbl_gBcdHour

char gDayOfWeek = 1; // 1 to 7
09C4  3001  	MOVLW 0x01
09C5  00B8  	MOVWF gbl_gDayOfWeek

char gBcdDayOfMonth = 1; // 1 to 0x31
09C6  3001  	MOVLW 0x01
09C7  00B9  	MOVWF gbl_gBcdDayOfMonth

char gBcdMonth = 1; // 1 to 0x12 + century at bit 7
09C8  3001  	MOVLW 0x01
09C9  00BA  	MOVWF gbl_gBcdMonth

char gBcdYear = 0x23; // Init to 0x23
09CA  3023  	MOVLW 0x23
09CB  00BB  	MOVWF gbl_gBcdYear

// Days in each month
rom char *gDaysInMonth = {0x31, 0x28, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31};
09CC  3000  	MOVLW 0x00
09CD  00BC  	MOVWF gbl_gDaysInMonth

// List of leap years, where the Feb days will be 29 instead
rom char *gLeapYears = {0x04, 0x08, 0x12, 0x16, 0x20, 0x24, 0x28, 0x32, 0x36, 0x40, 0x44, 0x48, 0x52, 0x56, 0x60, 0x64, 0x68, 0x72, 0x76, 0x80, 0x84, 0x88, 0x92, 0x96};
09CE  3001  	MOVLW 0x01
09CF  00BD  	MOVWF gbl_gLeapYears


// Timer variables
char iTimer0Counts = 0;
09D0  01BE  	CLRF gbl_iTimer0Counts

char iFlashDigitOff = 0;
09D1  01BF  	CLRF gbl_iFlashDigitOff

char iDigitToFlash = 8; // 8 = no digit to flash
09D2  3008  	MOVLW 0x08
09D3  00C8  	MOVWF gbl_iDigitToFlash


// Hold the upper and lower bytes from the ds18b20
char cTempH = 1;
09D4  3001  	MOVLW 0x01
09D5  00C9  	MOVWF gbl_cTempH

char cTempL = 70;
09D6  3046  	MOVLW 0x46
09D7  00CA  	MOVWF gbl_cTempL

//char iDecimalPosition = 2;

int giDS3231ValueBCD = 0x0000;
09D8  01B3  	CLRF gbl_giDS3231ValueBCD
09D9  01B4  	CLRF gbl_giDS3231ValueBCD+D'1'

char giDS3231ValueTruncCBCD = 0x00;
09DA  01CB  	CLRF gbl_giDS3231ValueTruncCBCD

char gbDS3231IsMinus = 0;
09DB  01CC  	CLRF gbl_gbDS3231IsMinus


char cTask = 0; // Used for task scheduler
09DC  01CD  	CLRF gbl_cTask


// States
bool gbFanOn = 0;
09DD  104E  	BCF gbl_gbFanOn,0

bool gbHeaterOn = 0;
09DE  10CE  	BCF gbl_gbHeaterOn,1

char gcDisplayMode = 0;
09DF  01CF  	CLRF gbl_gcDisplayMode

char gcSetMode = 0;
09E0  01D0  	CLRF gbl_gcSetMode

char gcHourMode = 0;
09E1  01D1  	CLRF gbl_gcHourMode

char gcTriggerMode = 0;
09E2  01D2  	CLRF gbl_gcTriggerMode


// Triggers
char gBcdWhiteOnMinute = 0; // 0 to 59
09E3  01D3  	CLRF gbl_gBcdWhiteOnMinute

char gBcdWhiteOnHour = 0; // 0 to 23
09E4  01D4  	CLRF gbl_gBcdWhiteOnHour

char gBcdWhiteOffMinute = 0; // 0 to 59
09E5  01D5  	CLRF gbl_gBcdWhiteOffMinute

char gBcdWhiteOffHour = 0; // 0 to 23
09E6  01D6  	CLRF gbl_gBcdWhiteOffHour


char gBcdBlueOnMinute = 0; // 0 to 59
09E7  01D7  	CLRF gbl_gBcdBlueOnMinute

char gBcdBlueOnHour = 0; // 0 to 23
09E8  01D8  	CLRF gbl_gBcdBlueOnHour

char gBcdBlueOffMinute = 0; // 0 to 59
09E9  01D9  	CLRF gbl_gBcdBlueOffMinute

char gBcdBlueOffHour = 0; // 0 to 23
09EA  01DA  	CLRF gbl_gBcdBlueOffHour


char gBcdBlue2OnMinute = 0; // 0 to 59
09EB  01DB  	CLRF gbl_gBcdBlue2OnMinute

char gBcdBlue2OnHour = 0; // 0 to 23
09EC  01DC  	CLRF gbl_gBcdBlue2OnHour

char gBcdBlue2OffMinute = 0; // 0 to 59
09ED  01DD  	CLRF gbl_gBcdBlue2OffMinute

char gBcdBlue2OffHour = 0; // 0 to 23
09EE  01DE  	CLRF gbl_gBcdBlue2OffHour


char gBcdFanOnTemp = 0x28; // Degrees C
09EF  3028  	MOVLW 0x28
09F0  00DF  	MOVWF gbl_gBcdFanOnTemp

char gBcdFanOffTemp = 0x27; // Degrees C
09F1  3027  	MOVLW 0x27
09F2  00E0  	MOVWF gbl_gBcdFanOffTemp


char gBcdHeaterOnTemp = 0x24; // Degrees C
09F3  3024  	MOVLW 0x24
09F4  00E1  	MOVWF gbl_gBcdHeaterOnTemp

char gBcdHeaterOffTemp = 0x25; // Degrees C
09F5  3025  	MOVLW 0x25
09F6  00E2  	MOVWF gbl_gBcdHeaterOffTemp


// Used to output the segments from numbers
char tm1638MaxDigits = 8;
09F7  3008  	MOVLW 0x08
09F8  00E3  	MOVWF gbl_tm1638MaxDigits

rom char *tm1638DisplayNumtoSeg = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F};
09F9  3002  	MOVLW 0x02
09FA  00E4  	MOVWF gbl_tm1638DisplayNumtoSeg

char tm1638Dot = 0x80;
09FB  3080  	MOVLW 0x80
09FC  00E5  	MOVWF gbl_tm1638Dot

char tm1638Brightness = 7; // 0 to 7
09FD  3007  	MOVLW 0x07
09FE  00E6  	MOVWF gbl_tm1638Brightness

// 0x40 [01000000] = indicate command to display data
char tm1638ByteSetData = 0x40;
09FF  3040  	MOVLW 0x40
0A00  00E7  	MOVWF gbl_tm1638ByteSetData

// 0x42 [01000010] = indicate command to read data
char tm1638ByteReadData = 0x42;
0A01  3042  	MOVLW 0x42
0A02  00E8  	MOVWF gbl_tm1638ByteReadData

// 0xC0 [11000000] = write out all bytes
char tm1638ByteSetAddr = 0xC0;
0A03  30C0  	MOVLW 0xC0
0A04  00E9  	MOVWF gbl_tm1638ByteSetAddr

// 0x88 [10001000] - Display ON, plus brightness
char tm1638ByteSetOn = 0x88;
0A05  3088  	MOVLW 0x88
0A06  00EA  	MOVWF gbl_tm1638ByteSetOn


// Copy of the data to write / on the display
char tm1638Data[] = {0, 0, 0, 0, 0, 0, 0, 0};
0A07  01A0  	CLRF gbl_tm1638Data
0A08  01A1  	CLRF gbl_tm1638Data+D'1'
0A09  01A2  	CLRF gbl_tm1638Data+D'2'
0A0A  01A3  	CLRF gbl_tm1638Data+D'3'
0A0B  01A4  	CLRF gbl_tm1638Data+D'4'
0A0C  01A5  	CLRF gbl_tm1638Data+D'5'
0A0D  01A6  	CLRF gbl_tm1638Data+D'6'
0A0E  01A7  	CLRF gbl_tm1638Data+D'7'

// Copy of the LED status
char tm1638LEDs[] = {0, 0, 0, 0, 0, 0, 0, 0};
0A0F  01A8  	CLRF gbl_tm1638LEDs
0A10  01A9  	CLRF gbl_tm1638LEDs+D'1'
0A11  01AA  	CLRF gbl_tm1638LEDs+D'2'
0A12  01AB  	CLRF gbl_tm1638LEDs+D'3'
0A13  01AC  	CLRF gbl_tm1638LEDs+D'4'
0A14  01AD  	CLRF gbl_tm1638LEDs+D'5'
0A15  01AE  	CLRF gbl_tm1638LEDs+D'6'
0A16  01AF  	CLRF gbl_tm1638LEDs+D'7'

// Copy of the keys
char tm1638Keys = 0;
0A17  01EB  	CLRF gbl_tm1638Keys

char tm1638KeysOld = 0;
0A18  01EC  	CLRF gbl_tm1638KeysOld

// For printing
char iPrintStartDigit = 0;
0A19  01ED  	CLRF gbl_iPrintStartDigit

char iPrintDotDigit = 8;
0A1A  3008  	MOVLW 0x08
0A1B  00EE  	MOVWF gbl_iPrintDotDigit

// For adjusting bcd numbers up 1 or down !1
char iBcdAdjustment = 1;
0A1C  3001  	MOVLW 0x01
0A1D  00EF  	MOVWF gbl_iBcdAdjustment


// DS18B20 functions
char oneWireIsPresent = 0;
0A1E  01F0  	CLRF gbl_oneWireIsPresent

char oneWireResetStage = 0;
0A1F  01F1  	CLRF gbl_oneWireResetStage

void oneWireBusReset();
void oneWireTxByte(char data);
void oneWireTxBytes(char data, char data2);
char oneWireRxByte();

// AT24C32 (EEPROM)
void at24c32WriteAll();
void at24c32ReadAll();

// DS3231 functions
void ds3231Write(char ds3231Reg, char bWrite);
void ds3231Init();
void ds3231Start();
void ds3231Stop();
void ds3231WriteDateTime();
void ds3231ReadDateTime();
char ds3231ReadRegister(char cRegAddress);

// TM1638 functions
void tm1638ByteWrite(char bWrite);
void tm1638DisplayOn();
void nibbleTo7Seg(char bNibble);
void bcdTo7Seg(char iBcdIn);
void zeroToBlank(char iDigit);
void tm1638UpdateDisplay();
void tm1638ReadKeys();

// General functions
int binToBcd(int iBin);
void convertTemp();
void startTemp();
void readTemp();

char bcdAdjust(char bcd, char bcdMax, char bcdMin);
void adjustDateTime();
void adjustTrigger();
void processKeys();

#endif

#include <system.h>
#include <i2c_driver.h>
#include "PIC16F_TM1638_AquariumControl.h"

//Target PIC16F628A configuration word
#pragma DATA _CONFIG, _BODEN_OFF & _PWRTE_ON & _WDT_OFF & _CP_OFF & _XT_OSC // Brown out reset off, Power-up Timer on, Watchdog timer off, Code Protection off, XT oscillator

//Set clock frequency (for software delays) - 4MHz
#pragma CLOCK_FREQ	4000000

    
/*********************************************************************************************
  void oneWireBusReset()
  First part of the reset routine - drive the bus low for 500us
*********************************************************************************************/
void oneWireBusReset() {

    char isPresent;
    oneWireTris = 1; // start with high
0864  1683  	BSF STATUS, RP0
0865  1303  	BCF STATUS, RP1
0866  1687  	BSF gbl_trisc,5

    isPresent = 0;
0867  1283  	BCF STATUS, RP0
0868  01F2  	CLRF oneWireBus_00014_1_isPresent

    // Send the reset pulse - drive low for 500us
    oneWireBus = 0;      
0869  1287  	BCF gbl_portc,5

    oneWireTris = 0;
086A  1683  	BSF STATUS, RP0
086B  1287  	BCF gbl_trisc,5

    delay_10us(50);
086C  3032  	MOVLW 0x32
086D  1283  	BCF STATUS, RP0
086E  00F7  	MOVWF delay_10us_00000_arg_del
086F  118A  	BCF PCLATH,3
0870  2077  	CALL delay_10us_00000

    // Release line and wait 70us for PD Pulse
    oneWireTris = 1;
0871  1683  	BSF STATUS, RP0
0872  1687  	BSF gbl_trisc,5

    delay_10us(7);
0873  3007  	MOVLW 0x07
0874  1283  	BCF STATUS, RP0
0875  00F7  	MOVWF delay_10us_00000_arg_del
0876  2077  	CALL delay_10us_00000

    // Now sample, if there is a sensor on the bus, the line should be low
    if (oneWireBus) {
0877  1A87  	BTFSC gbl_portc,5

        oneWireIsPresent = 0; // no devices
0878  01F0  	CLRF gbl_oneWireIsPresent

    }
    delay_10us(50);
0879  3032  	MOVLW 0x32
087A  00F7  	MOVWF delay_10us_00000_arg_del
087B  2077  	CALL delay_10us_00000

}
087C  0008  	RETURN


/*********************************************************************************************
  void oneWireTxByte(char data)
  Transmits a single byte from the bus
*********************************************************************************************/
void oneWireTxByte(char cData) {

    char cTemp = 1;
017F  3001  	MOVLW 0x01
0180  00F5  	MOVWF oneWireTxB_00015_1_cTemp

    // Loop through the eight bits in the byte
    for (char i = 0; i < 8; i++) {
0181  01F6  	CLRF oneWireTxB_00015_2_i
0182        label26
0182  3008  	MOVLW 0x08
0183  0276  	SUBWF oneWireTxB_00015_2_i, W
0184  1803  	BTFSC STATUS,C
0199  0AF6  	INCF oneWireTxB_00015_2_i, F
019A  2982  	GOTO	label26

        // Send the LSB first

        // Drive the line low initially for 3us
        oneWireTris = 0;
0186  1683  	BSF STATUS, RP0
0187  1287  	BCF gbl_trisc,5

        oneWireBus = 0;
0188  1283  	BCF STATUS, RP0
0189  1287  	BCF gbl_portc,5


        // Delay not needed for 4MHz PIC
        //delay_us(3); // Delay 3us
        
        if (cData & cTemp) {
018A  0875  	MOVF oneWireTxB_00015_1_cTemp, W
018B  0574  	ANDWF oneWireTxB_00015_arg_cData, W
018C  1903  	BTFSC STATUS,Z
018D  2990  	GOTO	label27

            oneWireTris = 1; // Release the bus
018E  1683  	BSF STATUS, RP0
018F  1687  	BSF gbl_trisc,5

        }
        
        delay_10us(5); // Delay 60us - 50us works fine with code delays
0190  3005  	MOVLW 0x05
0191  1283  	BCF STATUS, RP0
0192  00F7  	MOVWF delay_10us_00000_arg_del
0193  2077  	CALL delay_10us_00000

        oneWireTris = 1; // Release the bus
0194  1683  	BSF STATUS, RP0
0195  1687  	BSF gbl_trisc,5

        
        // move the test bit
        cTemp <<= 1;
0196  1003  	BCF STATUS,C
0197  1283  	BCF STATUS, RP0
0198  0DF5  	RLF oneWireTxB_00015_1_cTemp, F

    }
}
0185  0008  	RETURN


/*********************************************************************************************
  void oneWireTxBytes(char data, char data2)
  Transmits a 2 bytes from the bus
*********************************************************************************************/
void oneWireTxBytes(char cData, char cData2) {

    // Reset first - done in main
    //oneWireBusReset();
    // Send first byte
    oneWireTxByte(cData);
04D0  0872  	MOVF oneWireTxB_00016_arg_cData, W
04D1  00F4  	MOVWF oneWireTxB_00015_arg_cData
04D2  217F  	CALL oneWireTxB_00015

    // Send second byte
    oneWireTxByte(cData2);
04D3  0873  	MOVF oneWireTxB_00016_arg_cData2, W
04D4  00F4  	MOVWF oneWireTxB_00015_arg_cData
04D5  217F  	CALL oneWireTxB_00015

}
04D6  0008  	RETURN


/*********************************************************************************************
  char oneWireRxByte()
  Receives a single byte from the bus
*********************************************************************************************/
char oneWireRxByte() {

    char cDataIn = 0;
04D7  1283  	BCF STATUS, RP0
04D8  1303  	BCF STATUS, RP1
04D9  01F2  	CLRF oneWireRxB_00017_1_cDataIn

    // Loop through the eight bits in the byte
    for(char i = 0; i < 8; i++) {
04DA  01F3  	CLRF oneWireRxB_00017_2_i
04DB        label99
04DB  3008  	MOVLW 0x08
04DC  0273  	SUBWF oneWireRxB_00017_2_i, W
04DD  1803  	BTFSC STATUS,C
04DE  2CF2  	GOTO	label100
04F0  0AF3  	INCF oneWireRxB_00017_2_i, F
04F1  2CDB  	GOTO	label99
04F2        label100

        // Bring bus low for 15us
        oneWireTris = 0;
04DF  1683  	BSF STATUS, RP0
04E0  1287  	BCF gbl_trisc,5

        oneWireBus = 0;
04E1  1283  	BCF STATUS, RP0
04E2  1287  	BCF gbl_portc,5


        // Delay not needed for 4MHz PIC
        //delay_us(15); // Delay 15us

        // Release bus for 6us, this is enough time for the slave to respond
        oneWireTris = 1;
04E3  1683  	BSF STATUS, RP0
04E4  1687  	BSF gbl_trisc,5

        delay_us(3); // Delay 6us
04E5  3003  	MOVLW 0x03
04E6  1283  	BCF STATUS, RP0
04E7  00F8  	MOVWF delay_us_00000_arg_del
04E8  2010  	CALL delay_us_00000

        
        // Shift data already received left
        cDataIn >>= 1;
04E9  1003  	BCF STATUS,C
04EA  0CF2  	RRF oneWireRxB_00017_1_cDataIn, F

        
        // Check the value of the onewire bus - set the MSB of cDataIn if so
        if (oneWireBus)
04EB  1A87  	BTFSC gbl_portc,5

            cDataIn.7 = 1;
04EC  17F2  	BSF oneWireRxB_00017_1_cDataIn,7


        // To finish time slot
        delay_10us(6); // 60us
04ED  3006  	MOVLW 0x06
04EE  00F7  	MOVWF delay_10us_00000_arg_del
04EF  2077  	CALL delay_10us_00000

    } 
    
    return cDataIn;
04F2  0872  	MOVF oneWireRxB_00017_1_cDataIn, W
04F3  00F3  	MOVWF CompTempVarRet549

}
04F4  0008  	RETURN




/*********************************************************************************************
  void at24c32WriteAll()
  Write multiple bytes
  from https://www.instructables.com/The-Most-Comprehensive-Guide-to-Programming-the-AT/
*********************************************************************************************/
void at24c32WriteAll() {

	i2c_start();
05C1  2126  	CALL i2c_START_00000

	i2c_write(at24c32Addr); // address + write
05C2  30AE  	MOVLW 0xAE
05C3  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05C4  20A5  	CALL i2c_WRITE_00000

	// start at address 0
	i2c_write(0); // First word address (only 4 bits of the 12 bit byte address)
05C5  01F5  	CLRF i2c_WRITE_00000_arg_i2c_data
05C6  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // Second word address 
05C7  01F5  	CLRF i2c_WRITE_00000_arg_i2c_data
05C8  20A5  	CALL i2c_WRITE_00000

	// Write data bytes
	// We're only writing 18 bytes here, so no need to worry about row rollover after 32 bytes
	i2c_write(0x44); // To indicate AT24C32 has been written to
05C9  3044  	MOVLW 0x44
05CA  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05CB  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdWhiteOnMinute);
05CC  0853  	MOVF gbl_gBcdWhiteOnMinute, W
05CD  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05CE  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOnHour);
05CF  0854  	MOVF gbl_gBcdWhiteOnHour, W
05D0  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05D1  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOffMinute);
05D2  0855  	MOVF gbl_gBcdWhiteOffMinute, W
05D3  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05D4  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOffHour);
05D5  0856  	MOVF gbl_gBcdWhiteOffHour, W
05D6  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05D7  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOnMinute);
05D8  0857  	MOVF gbl_gBcdBlueOnMinute, W
05D9  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05DA  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOnHour);
05DB  0858  	MOVF gbl_gBcdBlueOnHour, W
05DC  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05DD  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOffMinute);
05DE  0859  	MOVF gbl_gBcdBlueOffMinute, W
05DF  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05E0  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOffHour);
05E1  085A  	MOVF gbl_gBcdBlueOffHour, W
05E2  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05E3  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdFanOnTemp);
05E4  085F  	MOVF gbl_gBcdFanOnTemp, W
05E5  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05E6  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdFanOffTemp);
05E7  0860  	MOVF gbl_gBcdFanOffTemp, W
05E8  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05E9  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdHeaterOnTemp);
05EA  0861  	MOVF gbl_gBcdHeaterOnTemp, W
05EB  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05EC  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdHeaterOffTemp);
05ED  0862  	MOVF gbl_gBcdHeaterOffTemp, W
05EE  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05EF  20A5  	CALL i2c_WRITE_00000

    i2c_write(gcHourMode);
05F0  0851  	MOVF gbl_gcHourMode, W
05F1  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05F2  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlue2OnMinute);
05F3  085B  	MOVF gbl_gBcdBlue2OnMinute, W
05F4  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05F5  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlue2OnHour);
05F6  085C  	MOVF gbl_gBcdBlue2OnHour, W
05F7  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05F8  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlue2OffMinute);
05F9  085D  	MOVF gbl_gBcdBlue2OffMinute, W
05FA  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05FB  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlue2OffHour);
05FC  085E  	MOVF gbl_gBcdBlue2OffHour, W
05FD  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05FE  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
05FF  20F6  	CALL i2c_STOP_00000

	delay_ms(10); // Write Cycle Time
0600  300A  	MOVLW 0x0A
0601  00F3  	MOVWF delay_ms_00000_arg_del
0602  2081  	CALL delay_ms_00000

}
0603  0008  	RETURN


/*********************************************************************************************
  void at24c32ReadAll()
  Read all bytes
*********************************************************************************************/
void at24c32ReadAll() {

	i2c_start();
0604  2126  	CALL i2c_START_00000

	i2c_write(at24c32Addr); // address + write
0605  30AE  	MOVLW 0xAE
0606  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
0607  20A5  	CALL i2c_WRITE_00000

	// start at address 0
	i2c_write(0); // First word address (only 4 bits of the 12 bit byte address)
0608  01F5  	CLRF i2c_WRITE_00000_arg_i2c_data
0609  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // Second word address 
060A  01F5  	CLRF i2c_WRITE_00000_arg_i2c_data
060B  20A5  	CALL i2c_WRITE_00000

	i2c_stop(); // Don't actually write a byte, just stop
060C  20F6  	CALL i2c_STOP_00000

	
	i2c_start();
060D  2126  	CALL i2c_START_00000

	i2c_write(at24c32Addr + 1); // address + read
060E  30AF  	MOVLW 0xAF
060F  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
0610  20A5  	CALL i2c_WRITE_00000

	char hasWritten = i2c_read(0); // ack
0611  01F5  	CLRF i2c_READ_00000_arg_ack_status
0612  21DE  	CALL i2c_READ_00000
0613  0878  	MOVF CompTempVarRet551, W
0614  00F3  	MOVWF at24c32Rea_00019_1_hasWritten

	if (hasWritten != 0x44) {
0615  0873  	MOVF at24c32Rea_00019_1_hasWritten, W
0616  3A44  	XORLW 0x44
0617  1903  	BTFSC STATUS,Z
0618  2E1D  	GOTO	label103
061D        label103

		i2c_read(1); // nack
0619  3001  	MOVLW 0x01
061A  00F5  	MOVWF i2c_READ_00000_arg_ack_status
061B  21DE  	CALL i2c_READ_00000

	} else {
061C  2E62  	GOTO	label104
0662        label104

		gBcdWhiteOnMinute = i2c_read(0); // ack
061D  01F5  	CLRF i2c_READ_00000_arg_ack_status
061E  21DE  	CALL i2c_READ_00000
061F  0878  	MOVF CompTempVarRet551, W
0620  00D3  	MOVWF gbl_gBcdWhiteOnMinute

		gBcdWhiteOnHour = i2c_read(0); // ack
0621  01F5  	CLRF i2c_READ_00000_arg_ack_status
0622  21DE  	CALL i2c_READ_00000
0623  0878  	MOVF CompTempVarRet551, W
0624  00D4  	MOVWF gbl_gBcdWhiteOnHour

		gBcdWhiteOffMinute = i2c_read(0); // ack
0625  01F5  	CLRF i2c_READ_00000_arg_ack_status
0626  21DE  	CALL i2c_READ_00000
0627  0878  	MOVF CompTempVarRet551, W
0628  00D5  	MOVWF gbl_gBcdWhiteOffMinute

		gBcdWhiteOffHour = i2c_read(0); // ack
0629  01F5  	CLRF i2c_READ_00000_arg_ack_status
062A  21DE  	CALL i2c_READ_00000
062B  0878  	MOVF CompTempVarRet551, W
062C  00D6  	MOVWF gbl_gBcdWhiteOffHour

		gBcdBlueOnMinute = i2c_read(0); // ack
062D  01F5  	CLRF i2c_READ_00000_arg_ack_status
062E  21DE  	CALL i2c_READ_00000
062F  0878  	MOVF CompTempVarRet551, W
0630  00D7  	MOVWF gbl_gBcdBlueOnMinute

		gBcdBlueOnHour = i2c_read(0); // ack
0631  01F5  	CLRF i2c_READ_00000_arg_ack_status
0632  21DE  	CALL i2c_READ_00000
0633  0878  	MOVF CompTempVarRet551, W
0634  00D8  	MOVWF gbl_gBcdBlueOnHour

		gBcdBlueOffMinute = i2c_read(0); // ack
0635  01F5  	CLRF i2c_READ_00000_arg_ack_status
0636  21DE  	CALL i2c_READ_00000
0637  0878  	MOVF CompTempVarRet551, W
0638  00D9  	MOVWF gbl_gBcdBlueOffMinute

		gBcdBlueOffHour = i2c_read(0); // ack
0639  01F5  	CLRF i2c_READ_00000_arg_ack_status
063A  21DE  	CALL i2c_READ_00000
063B  0878  	MOVF CompTempVarRet551, W
063C  00DA  	MOVWF gbl_gBcdBlueOffHour

		gBcdFanOnTemp = i2c_read(0); // ack
063D  01F5  	CLRF i2c_READ_00000_arg_ack_status
063E  21DE  	CALL i2c_READ_00000
063F  0878  	MOVF CompTempVarRet551, W
0640  00DF  	MOVWF gbl_gBcdFanOnTemp

		gBcdFanOffTemp = i2c_read(0); // ack
0641  01F5  	CLRF i2c_READ_00000_arg_ack_status
0642  21DE  	CALL i2c_READ_00000
0643  0878  	MOVF CompTempVarRet551, W
0644  00E0  	MOVWF gbl_gBcdFanOffTemp

		gBcdHeaterOnTemp = i2c_read(0); // ack
0645  01F5  	CLRF i2c_READ_00000_arg_ack_status
0646  21DE  	CALL i2c_READ_00000
0647  0878  	MOVF CompTempVarRet551, W
0648  00E1  	MOVWF gbl_gBcdHeaterOnTemp

		gBcdHeaterOffTemp = i2c_read(0); // ack
0649  01F5  	CLRF i2c_READ_00000_arg_ack_status
064A  21DE  	CALL i2c_READ_00000
064B  0878  	MOVF CompTempVarRet551, W
064C  00E2  	MOVWF gbl_gBcdHeaterOffTemp

		gcHourMode = i2c_read(0); // ack
064D  01F5  	CLRF i2c_READ_00000_arg_ack_status
064E  21DE  	CALL i2c_READ_00000
064F  0878  	MOVF CompTempVarRet551, W
0650  00D1  	MOVWF gbl_gcHourMode

		gBcdBlue2OnMinute = i2c_read(0); // ack
0651  01F5  	CLRF i2c_READ_00000_arg_ack_status
0652  21DE  	CALL i2c_READ_00000
0653  0878  	MOVF CompTempVarRet551, W
0654  00DB  	MOVWF gbl_gBcdBlue2OnMinute

		gBcdBlue2OnHour = i2c_read(0); // ack
0655  01F5  	CLRF i2c_READ_00000_arg_ack_status
0656  21DE  	CALL i2c_READ_00000
0657  0878  	MOVF CompTempVarRet551, W
0658  00DC  	MOVWF gbl_gBcdBlue2OnHour

		gBcdBlue2OffMinute = i2c_read(0); // ack
0659  01F5  	CLRF i2c_READ_00000_arg_ack_status
065A  21DE  	CALL i2c_READ_00000
065B  0878  	MOVF CompTempVarRet551, W
065C  00DD  	MOVWF gbl_gBcdBlue2OffMinute

		gBcdBlue2OffHour = i2c_read(1); // nack
065D  3001  	MOVLW 0x01
065E  00F5  	MOVWF i2c_READ_00000_arg_ack_status
065F  21DE  	CALL i2c_READ_00000
0660  0878  	MOVF CompTempVarRet551, W
0661  00DE  	MOVWF gbl_gBcdBlue2OffHour

	}
	i2c_stop();
0662  20F6  	CALL i2c_STOP_00000

}
0663  0008  	RETURN



/*********************************************************************************************
  void ds3231Write(char ds3231Reg, char bWrite)
  Write one byte
*********************************************************************************************/
void ds3231Write(char ds3231Reg, char bWrite) {

	i2c_start();
0232  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
0233  30D0  	MOVLW 0xD0
0234  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
0235  20A5  	CALL i2c_WRITE_00000

	i2c_write(ds3231Reg); // start at address
0236  0873  	MOVF ds3231Writ_0001A_arg_ds3231Reg, W
0237  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
0238  20A5  	CALL i2c_WRITE_00000

	i2c_write(bWrite); // start at address
0239  0874  	MOVF ds3231Writ_0001A_arg_bWrite, W
023A  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
023B  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
023C  20F6  	CALL i2c_STOP_00000

}
023D  0008  	RETURN


/*********************************************************************************************
  void ds3231Init()
  Initialise the DS3231
  from https://github.com/adafruit/RTClib
*********************************************************************************************/
void ds3231Init() {

	/* control register 0Eh
    bit7 EOSC   Enable Oscillator (1 if oscillator must be stopped when on battery)
    bit6 BBSQW  Battery Backed Square Wave - 0 means square wave disabled when VCC falls below VPF (power fail voltage)
    bit5 CONV   Convert temperature (1 forces a conversion)
    bit4 RS2    Rate select - frequency of square wave output - NA for DS3231M
    bit3 RS1    Rate select - NA for DS3231M
    bit2 INTCN  Interrupt control (1 for use of the alarms and to disable square wave)
    bit1 A2IE   Alarm2 interrupt enable (1 to enable)
    bit0 A1IE   Alarm1 interrupt enable (1 to enable)
    */
	ds3231Write(0x0E, 0x00);
0539  300E  	MOVLW 0x0E
053A  1283  	BCF STATUS, RP0
053B  1303  	BCF STATUS, RP1
053C  00F3  	MOVWF ds3231Writ_0001A_arg_ds3231Reg
053D  01F4  	CLRF ds3231Writ_0001A_arg_bWrite
053E  2232  	CALL ds3231Writ_0001A

	/* Status Register 0Fh
    bit7 OSF     Oscillator stopped flag - clear oscillator stop flag at init
    bit3 EN32kHz Enable 32kHz Output - 0 for disabled
    bit2 BSY     Busy
    bit1 A2F     Alarm 2 Flag
    bit0 A1F     Alarm 1 Flag
    */
	ds3231Write(0x0F, 0x00);
053F  300F  	MOVLW 0x0F
0540  00F3  	MOVWF ds3231Writ_0001A_arg_ds3231Reg
0541  01F4  	CLRF ds3231Writ_0001A_arg_bWrite
0542  2232  	CALL ds3231Writ_0001A

}
0543  0008  	RETURN


/*********************************************************************************************
  void ds3231WriteDateTime()
  Write the date to the DS3231
*********************************************************************************************/
void ds3231WriteDateTime() {

	i2c_start();
0508  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
0509  30D0  	MOVLW 0xD0
050A  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
050B  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
050C  01F5  	CLRF i2c_WRITE_00000_arg_i2c_data
050D  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // seconds
050E  01F5  	CLRF i2c_WRITE_00000_arg_i2c_data
050F  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdMinute); // minutes
0510  0836  	MOVF gbl_gBcdMinute, W
0511  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
0512  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdHour); // hours
0513  0837  	MOVF gbl_gBcdHour, W
0514  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
0515  20A5  	CALL i2c_WRITE_00000

	i2c_write(gDayOfWeek); // day of week
0516  0838  	MOVF gbl_gDayOfWeek, W
0517  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
0518  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdDayOfMonth); // day of month
0519  0839  	MOVF gbl_gBcdDayOfMonth, W
051A  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
051B  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdMonth); // month + century
051C  083A  	MOVF gbl_gBcdMonth, W
051D  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
051E  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdYear); // year
051F  083B  	MOVF gbl_gBcdYear, W
0520  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
0521  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
0522  20F6  	CALL i2c_STOP_00000

}
0523  0008  	RETURN


/*********************************************************************************************
  void ds3231ReadDateTime()
  Write the date to the DS3231
*********************************************************************************************/
void ds3231ReadDateTime() {

	i2c_start();
08BC  118A  	BCF PCLATH,3
08BD  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
08BE  30D0  	MOVLW 0xD0
08BF  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
08C0  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
08C1  01F5  	CLRF i2c_WRITE_00000_arg_i2c_data
08C2  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
08C3  20F6  	CALL i2c_STOP_00000

	
	i2c_start();
08C4  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr + 1); // address + read
08C5  30D1  	MOVLW 0xD1
08C6  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
08C7  20A5  	CALL i2c_WRITE_00000

	gBcdSecond = i2c_read(0); // ack
08C8  01F5  	CLRF i2c_READ_00000_arg_ack_status
08C9  21DE  	CALL i2c_READ_00000
08CA  0878  	MOVF CompTempVarRet551, W
08CB  00B5  	MOVWF gbl_gBcdSecond

	gBcdMinute = i2c_read(0); // ack
08CC  01F5  	CLRF i2c_READ_00000_arg_ack_status
08CD  21DE  	CALL i2c_READ_00000
08CE  0878  	MOVF CompTempVarRet551, W
08CF  00B6  	MOVWF gbl_gBcdMinute

	gBcdHour = i2c_read(0); // ack
08D0  01F5  	CLRF i2c_READ_00000_arg_ack_status
08D1  21DE  	CALL i2c_READ_00000
08D2  0878  	MOVF CompTempVarRet551, W
08D3  00B7  	MOVWF gbl_gBcdHour

	gDayOfWeek = i2c_read(0); // ack
08D4  01F5  	CLRF i2c_READ_00000_arg_ack_status
08D5  21DE  	CALL i2c_READ_00000
08D6  0878  	MOVF CompTempVarRet551, W
08D7  00B8  	MOVWF gbl_gDayOfWeek

	gBcdDayOfMonth = i2c_read(0); // ack
08D8  01F5  	CLRF i2c_READ_00000_arg_ack_status
08D9  21DE  	CALL i2c_READ_00000
08DA  0878  	MOVF CompTempVarRet551, W
08DB  00B9  	MOVWF gbl_gBcdDayOfMonth

	gBcdMonth = i2c_read(0); // ack
08DC  01F5  	CLRF i2c_READ_00000_arg_ack_status
08DD  21DE  	CALL i2c_READ_00000
08DE  0878  	MOVF CompTempVarRet551, W
08DF  00BA  	MOVWF gbl_gBcdMonth

	gBcdYear = i2c_read(1); // nack
08E0  3001  	MOVLW 0x01
08E1  00F5  	MOVWF i2c_READ_00000_arg_ack_status
08E2  21DE  	CALL i2c_READ_00000
08E3  0878  	MOVF CompTempVarRet551, W
08E4  00BB  	MOVWF gbl_gBcdYear

	i2c_stop();
08E5  20F6  	CALL i2c_STOP_00000

}
08E6  0008  	RETURN


/*********************************************************************************************
  char ds3231ReadRegister(char cRegAddress)
  Read one byte from a given DS3231 register address
*********************************************************************************************/
char ds3231ReadRegister(char cRegAddress) {

	char cStatus;
	i2c_start();
0524  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
0525  30D0  	MOVLW 0xD0
0526  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
0527  20A5  	CALL i2c_WRITE_00000

	i2c_write(cRegAddress); // start at requested address
0528  0873  	MOVF ds3231Read_0001D_arg_cRegAddress, W
0529  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
052A  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
052B  20F6  	CALL i2c_STOP_00000

	
	i2c_start();
052C  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr + 1); // address + read
052D  30D1  	MOVLW 0xD1
052E  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
052F  20A5  	CALL i2c_WRITE_00000

	cStatus = i2c_read(1); // read the byte, then nack
0530  3001  	MOVLW 0x01
0531  00F5  	MOVWF i2c_READ_00000_arg_ack_status
0532  21DE  	CALL i2c_READ_00000
0533  0878  	MOVF CompTempVarRet551, W
0534  00F4  	MOVWF ds3231Read_0001D_1_cStatus

    i2c_stop();
0535  20F6  	CALL i2c_STOP_00000

    return cStatus;
0536  0874  	MOVF ds3231Read_0001D_1_cStatus, W
0537  00F5  	MOVWF CompTempVarRet552

}
0538  0008  	RETURN




/*********************************************************************************************
  void tm1638ByteWrite(char bWrite)
  Write one byte
  from http://www.piclearning.net/280/pic-and-tm1638-ledkey-module.php
*********************************************************************************************/
void tm1638ByteWrite(char bWrite) {

    for (char i = 0; i < 8; i++) {
016C  01F7  	CLRF tm1638Byte_0001E_2_i
016D        label25
016D  3008  	MOVLW 0x08
016E  0277  	SUBWF tm1638Byte_0001E_2_i, W
016F  1803  	BTFSC STATUS,C
017D  0AF7  	INCF tm1638Byte_0001E_2_i, F
017E  296D  	GOTO	label25

        tm1638dio = (bWrite & 0x01);
0171  3001  	MOVLW 0x01
0172  0576  	ANDWF tm1638Byte_0001E_arg_bWrite, W
0173  00F8  	MOVWF CompTempVar553
0174  1878  	BTFSC CompTempVar553,0
0175  1486  	BSF gbl_portb,1
0176  1C78  	BTFSS CompTempVar553,0
0177  1086  	BCF gbl_portb,1

        tm1638clk = 0;
0178  1106  	BCF gbl_portb,2

        bWrite = (bWrite >> 1);
0179  08F6  	MOVF tm1638Byte_0001E_arg_bWrite, F
017A  1003  	BCF STATUS,C
017B  0CF6  	RRF tm1638Byte_0001E_arg_bWrite, F

        tm1638clk = 1;
017C  1506  	BSF gbl_portb,2

    }
}
0170  0008  	RETURN


/*********************************************************************************************
  void tm1638DisplayOn()
  Turns the display on, with defined brightness
*********************************************************************************************/
void tm1638DisplayOn() {

    // Write 0x8F [10001000] to set display ON with pulse width 14/16
    tm1638strobe = 0;
04C8  1283  	BCF STATUS, RP0
04C9  1303  	BCF STATUS, RP1
04CA  1186  	BCF gbl_portb,3

    tm1638ByteWrite(0x88);
04CB  3088  	MOVLW 0x88
04CC  00F6  	MOVWF tm1638Byte_0001E_arg_bWrite
04CD  216C  	CALL tm1638Byte_0001E

    tm1638strobe = 1;
04CE  1586  	BSF gbl_portb,3

}
04CF  0008  	RETURN




/*********************************************************************************************
  void nibbleTo7Seg(char iNibble)
  Convert a single nibble into the 7-segment representation (two digits)
  7-segment digit to be written will be iPrintStartDigit, which is auto-incremented after
  If iPrintDotDigit matches, the dot on the display digit will be added
*********************************************************************************************/
void nibbleTo7Seg(char bNibble) {

	char s7SegDisplay = tm1638DisplayNumtoSeg[bNibble & 0x0F];
008D  0864  	MOVF gbl_tm1638DisplayNumtoSeg, W
008E  00FB  	MOVWF __rom_get_00000_arg_objNumb
008F  300F  	MOVLW 0x0F
0090  0579  	ANDWF nibbleTo7S_00020_arg_bNibble, W
0091  00FC  	MOVWF __rom_get_00000_arg_idx
0092  201A  	CALL __rom_get_00000
0093  00FA  	MOVWF nibbleTo7S_00020_1_s7SegDisplay

	if (iPrintStartDigit == iPrintDotDigit)
0094  086E  	MOVF gbl_iPrintDotDigit, W
0095  066D  	XORWF gbl_iPrintStartDigit, W
0096  118A  	BCF PCLATH,3
0097  120A  	BCF PCLATH,4
0098  1D03  	BTFSS STATUS,Z
0099  289C  	GOTO	label10
009C        label10

        s7SegDisplay |= tm1638Dot;
009A  0865  	MOVF gbl_tm1638Dot, W
009B  04FA  	IORWF nibbleTo7S_00020_1_s7SegDisplay, F

    tm1638Data[iPrintStartDigit] = s7SegDisplay;
009C  1383  	BCF	STATUS,IRP
009D  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
009E  0084  	MOVWF FSR
009F  086D  	MOVF gbl_iPrintStartDigit, W
00A0  0784  	ADDWF FSR, F
00A1  087A  	MOVF nibbleTo7S_00020_1_s7SegDisplay, W
00A2  0080  	MOVWF INDF

    iPrintStartDigit++;
00A3  0AED  	INCF gbl_iPrintStartDigit, F

}
00A4  0008  	RETURN


/*********************************************************************************************
  void bcdTo7Seg(char iBcdIn)
  Convert a single bcd byte into the 7-segment representation (two digits)
*********************************************************************************************/
void bcdTo7Seg(char iBcdIn) {

    nibbleTo7Seg(iBcdIn >> 4);
023E  0E78  	SWAPF bcdTo7Seg_00000_arg_iBcdIn, W
023F  390F  	ANDLW 0x0F
0240  00F9  	MOVWF nibbleTo7S_00020_arg_bNibble
0241  208D  	CALL nibbleTo7S_00020

    nibbleTo7Seg(iBcdIn);
0242  0878  	MOVF bcdTo7Seg_00000_arg_iBcdIn, W
0243  00F9  	MOVWF nibbleTo7S_00020_arg_bNibble
0244  208D  	CALL nibbleTo7S_00020

}
0245  0008  	RETURN


/*********************************************************************************************
  void zeroToBlank(char iDigit)
  For the given digit, change a zero to blank. Used for removing left filled zeroes
*********************************************************************************************/
void zeroToBlank(char iDigit) {

    // replace zero with blank
    if (tm1638Data[iDigit] == 0x3F)
015B  1383  	BCF	STATUS,IRP
015C  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
015D  0084  	MOVWF FSR
015E  0878  	MOVF zeroToBlan_00021_arg_iDigit, W
015F  0784  	ADDWF FSR, F
0160  0800  	MOVF INDF, W
0161  3A3F  	XORLW 0x3F
0162  1D03  	BTFSS STATUS,Z

        tm1638Data[iDigit] = 0;
0164  1383  	BCF	STATUS,IRP
0165  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
0166  0084  	MOVWF FSR
0167  0878  	MOVF zeroToBlan_00021_arg_iDigit, W
0168  0784  	ADDWF FSR, F
0169  3000  	MOVLW 0x00
016A  0080  	MOVWF INDF


}
0163  0008  	RETURN
016B  0008  	RETURN


/*********************************************************************************************
  void tm1638UpdateDisplay()
  Publish the tm1638Data and tm1638LEDs arrays to the display
*********************************************************************************************/
void tm1638UpdateDisplay() {

    
    // Display current temperature unless set, trigger or alt display mode is active
    if ((gcDisplayMode == 2) | gcSetMode | gcTriggerMode) {
02A4  1283  	BCF STATUS, RP0
02A5  1303  	BCF STATUS, RP1
02A6  01F3  	CLRF CompTempVar559
02A7  3002  	MOVLW 0x02
02A8  024F  	SUBWF gbl_gcDisplayMode, W
02A9  1903  	BTFSC STATUS,Z
02AA  0AF3  	INCF CompTempVar559, F
02AB  0850  	MOVF gbl_gcSetMode, W
02AC  04F3  	IORWF CompTempVar559, F
02AD  0852  	MOVF gbl_gcTriggerMode, W
02AE  0473  	IORWF CompTempVar559, W
02AF  1903  	BTFSC STATUS,Z
02B0  2C12  	GOTO	label81
0412        label81

        if (gcSetMode == 1) {
02B1  0350  	DECF gbl_gcSetMode, W
02B2  1D03  	BTFSS STATUS,Z
02B3  2AC0  	GOTO	label53
02C0        label53

            // Display year in the first 4 digits, for setting RTC year
            // Start printing from digit 0
            iDigitToFlash = 3; // 4th digit will flash
02B4  3003  	MOVLW 0x03
02B5  00C8  	MOVWF gbl_iDigitToFlash

            iPrintStartDigit = 0;
02B6  01ED  	CLRF gbl_iPrintStartDigit

            iPrintDotDigit = 3;
02B7  3003  	MOVLW 0x03
02B8  00EE  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(0x20); // Display 20 in digits 0 and 1 (no dot)
02B9  3020  	MOVLW 0x20
02BA  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02BB  223E  	CALL bcdTo7Seg_00000

            bcdTo7Seg(gBcdYear); // Display year in digits 2 and 3 (+dot on 3)
02BC  083B  	MOVF gbl_gBcdYear, W
02BD  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02BE  223E  	CALL bcdTo7Seg_00000

        } else if (gcSetMode == 4) {
02BF  2C40  	GOTO	label84
02C0  0850  	MOVF gbl_gcSetMode, W
02C1  3A04  	XORLW 0x04
02C2  1D03  	BTFSS STATUS,Z
02C3  2AD6  	GOTO	label54
02D6        label54

            // Display day of week - 'day' followed by number 1 to 7 on 4th digit, for setting RTC day of week
            iDigitToFlash = 3; // 4th digit will flash
02C4  3003  	MOVLW 0x03
02C5  00C8  	MOVWF gbl_iDigitToFlash

            tm1638Data[0] = 0x5E; // d
02C6  305E  	MOVLW 0x5E
02C7  00A0  	MOVWF gbl_tm1638Data

            tm1638Data[1] = 0x5F; // a
02C8  305F  	MOVLW 0x5F
02C9  00A1  	MOVWF gbl_tm1638Data+D'1'

            tm1638Data[2] = 0x6E; // y
02CA  306E  	MOVLW 0x6E
02CB  00A2  	MOVWF gbl_tm1638Data+D'2'

            tm1638Data[3] = tm1638DisplayNumtoSeg[gDayOfWeek] + tm1638Dot;
02CC  0864  	MOVF gbl_tm1638DisplayNumtoSeg, W
02CD  00FB  	MOVWF __rom_get_00000_arg_objNumb
02CE  0838  	MOVF gbl_gDayOfWeek, W
02CF  00FC  	MOVWF __rom_get_00000_arg_idx
02D0  201A  	CALL __rom_get_00000
02D1  0765  	ADDWF gbl_tm1638Dot, W
02D2  00A3  	MOVWF gbl_tm1638Data+D'3'

        } else if (gcSetMode == 5) {
02D3  118A  	BCF PCLATH,3
02D4  120A  	BCF PCLATH,4
02D5  2C40  	GOTO	label84
02D6  0850  	MOVF gbl_gcSetMode, W
02D7  3A05  	XORLW 0x05
02D8  1D03  	BTFSS STATUS,Z
02D9  2AEC  	GOTO	label57
02EC        label57

            // Display 24h or 12h setting in first 4 digits, for setting the time display preference
            iDigitToFlash = 1; // 2nd digit will flash
02DA  3001  	MOVLW 0x01
02DB  00C8  	MOVWF gbl_iDigitToFlash

            if (gcHourMode) {
02DC  08D1  	MOVF gbl_gcHourMode, F
02DD  1903  	BTFSC STATUS,Z
02DE  2AE4  	GOTO	label55
02E4        label55

				tm1638Data[0] = 0x06; // 1
02DF  3006  	MOVLW 0x06
02E0  00A0  	MOVWF gbl_tm1638Data

				tm1638Data[1] = 0x5B; // 2
02E1  305B  	MOVLW 0x5B
02E2  00A1  	MOVWF gbl_tm1638Data+D'1'

			} else {
02E3  2AE8  	GOTO	label56
02E8        label56

				tm1638Data[0] = 0x5B; // 2
02E4  305B  	MOVLW 0x5B
02E5  00A0  	MOVWF gbl_tm1638Data

				tm1638Data[1] = 0x66; // 4
02E6  3066  	MOVLW 0x66
02E7  00A1  	MOVWF gbl_tm1638Data+D'1'

			}
            tm1638Data[2] = 0x74; // h
02E8  3074  	MOVLW 0x74
02E9  00A2  	MOVWF gbl_tm1638Data+D'2'

            tm1638Data[3] = 0x00; // blank
02EA  01A3  	CLRF gbl_tm1638Data+D'3'

        } else if (gcTriggerMode) {
02EB  2C40  	GOTO	label84
02EC  08D2  	MOVF gbl_gcTriggerMode, F
02ED  1903  	BTFSC STATUS,Z
02EE  2BE5  	GOTO	label74
03E5        label74

            // Show relevant display of trigger time or temperature
            iPrintDotDigit = 5;
02EF  3005  	MOVLW 0x05
02F0  00EE  	MOVWF gbl_iPrintDotDigit

            switch (gcTriggerMode) {
0322  2C40  	GOTO	label84

                case 1:
02F1  0852  	MOVF gbl_gcTriggerMode, W
02F2  3A01  	XORLW 0x01
02F3  1903  	BTFSC STATUS,Z
02F4  2B23  	GOTO	label58
0323        label58

                    // White LED on hour, shows as 'L On' followed by hh:mm with 6th digit flashing
                    tm1638Data[0] = 0x38; // L
0323  3038  	MOVLW 0x38
0324  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x00; // space
0325  01A1  	CLRF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x3F; // O
0326  303F  	MOVLW 0x3F
0327  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x54; // n
0328  3054  	MOVLW 0x54
0329  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
032A  3005  	MOVLW 0x05
032B  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
032C  3004  	MOVLW 0x04
032D  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOnHour); // Display hour in digits 4 and 5 (dot on 5)
032E  0854  	MOVF gbl_gBcdWhiteOnHour, W
032F  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0330  223E  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdWhiteOnMinute); // Display minute in digits 6 and 7 (no dot)
0331  0853  	MOVF gbl_gBcdWhiteOnMinute, W
0332  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0333  223E  	CALL bcdTo7Seg_00000

                    break;
0334  2C40  	GOTO	label84

                case 2:
02F5  3A03  	XORLW 0x03
02F6  1903  	BTFSC STATUS,Z
02F7  2B35  	GOTO	label59
0335        label59

                    // White LED on minute, shows as 'L On' followed by hh:mm with 8th digit flashing
                    iDigitToFlash = 7;
0335  3007  	MOVLW 0x07
0336  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0337  3006  	MOVLW 0x06
0338  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOnMinute); // Display minute in digits 6 and 7 (no dot)
0339  0853  	MOVF gbl_gBcdWhiteOnMinute, W
033A  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
033B  223E  	CALL bcdTo7Seg_00000

                    break;
033C  2C40  	GOTO	label84

                case 3:
02F8  3A01  	XORLW 0x01
02F9  1903  	BTFSC STATUS,Z
02FA  2B3D  	GOTO	label60
033D        label60

                    // White LED off hour, shows as 'L OF' followed by hh:mm with 6th digit flashing
                    tm1638Data[3] = 0x71; // F
033D  3071  	MOVLW 0x71
033E  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
033F  3005  	MOVLW 0x05
0340  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
0341  3004  	MOVLW 0x04
0342  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOffHour); 
0343  0856  	MOVF gbl_gBcdWhiteOffHour, W
0344  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0345  223E  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdWhiteOffMinute); // Display minute in digits 6 and 7 (no dot)
0346  0855  	MOVF gbl_gBcdWhiteOffMinute, W
0347  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0348  223E  	CALL bcdTo7Seg_00000

                    break;
0349  2C40  	GOTO	label84

                case 4:
02FB  3A07  	XORLW 0x07
02FC  1903  	BTFSC STATUS,Z
02FD  2B4A  	GOTO	label61
034A        label61

                    // White LED off minute, shows as 'L OF' followed by hh:mm with 8th digit flashing
                    iDigitToFlash = 7;
034A  3007  	MOVLW 0x07
034B  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
034C  3006  	MOVLW 0x06
034D  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOffMinute); // Display minute in digits 6 and 7 (no dot)
034E  0855  	MOVF gbl_gBcdWhiteOffMinute, W
034F  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0350  223E  	CALL bcdTo7Seg_00000

                    break;
0351  2C40  	GOTO	label84

                case 5:
02FE  3A01  	XORLW 0x01
02FF  1903  	BTFSC STATUS,Z
0300  2B52  	GOTO	label62
0352        label62

                    // 1st Blue LED on hour, shows as 'b1On' followed by hh:mm with 6th digit flashing
                    tm1638Data[0] = 0x7C; // b
0352  307C  	MOVLW 0x7C
0353  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x06; // 1
0354  3006  	MOVLW 0x06
0355  00A1  	MOVWF gbl_tm1638Data+D'1'

                    //tm1638Data[2] = 0x3F; // O
                    tm1638Data[3] = 0x54; // n
0356  3054  	MOVLW 0x54
0357  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
0358  3005  	MOVLW 0x05
0359  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
035A  3004  	MOVLW 0x04
035B  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOnHour); // Display hour in digits 4 and 5 (dot on 5)
035C  0858  	MOVF gbl_gBcdBlueOnHour, W
035D  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
035E  223E  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlueOnMinute); // Display minute in digits 6 and 7 (no dot)
035F  0857  	MOVF gbl_gBcdBlueOnMinute, W
0360  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0361  223E  	CALL bcdTo7Seg_00000

                    break;
0362  2C40  	GOTO	label84

                case 6:
0301  3A03  	XORLW 0x03
0302  1903  	BTFSC STATUS,Z
0303  2B63  	GOTO	label63
0363        label63

                    // 1st Blue LED on minute, shows as 'b1On' followed by hh:mm with 8th digit flashing
                    iDigitToFlash = 7;
0363  3007  	MOVLW 0x07
0364  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0365  3006  	MOVLW 0x06
0366  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOnMinute); // Display minute in digits 6 and 7 (no dot)
0367  0857  	MOVF gbl_gBcdBlueOnMinute, W
0368  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0369  223E  	CALL bcdTo7Seg_00000

                    break;
036A  2C40  	GOTO	label84

                case 7:
0304  3A01  	XORLW 0x01
0305  1903  	BTFSC STATUS,Z
0306  2B6B  	GOTO	label64
036B        label64

                    // 1st Blue LED off hour, shows as 'b1OF' followed by hh:mm with 6th digit flashing
                    tm1638Data[3] = 0x71; // F
036B  3071  	MOVLW 0x71
036C  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
036D  3005  	MOVLW 0x05
036E  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
036F  3004  	MOVLW 0x04
0370  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOffHour); // Display hour in digits 4 and 5 (dot on 5)
0371  085A  	MOVF gbl_gBcdBlueOffHour, W
0372  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0373  223E  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlueOffMinute); // Display minute in digits 6 and 7 (no dot)
0374  0859  	MOVF gbl_gBcdBlueOffMinute, W
0375  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0376  223E  	CALL bcdTo7Seg_00000

                    break;
0377  2C40  	GOTO	label84

                case 8:
0307  3A0F  	XORLW 0x0F
0308  1903  	BTFSC STATUS,Z
0309  2B78  	GOTO	label65
0378        label65

                    // 1st Blue LED off minute, shows as 'b1OF' followed by hh:mm with 8th digit flashing
                    iDigitToFlash = 7;
0378  3007  	MOVLW 0x07
0379  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
037A  3006  	MOVLW 0x06
037B  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOffMinute); // Display minute in digits 6 and 7 (no dot)
037C  0859  	MOVF gbl_gBcdBlueOffMinute, W
037D  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
037E  223E  	CALL bcdTo7Seg_00000

                    break;
037F  2C40  	GOTO	label84

                case 9:
030A  3A01  	XORLW 0x01
030B  1903  	BTFSC STATUS,Z
030C  2B80  	GOTO	label66
0380        label66

                    // 2nd Blue LED on hour, shows as 'b2On' followed by hh:mm with 6th digit flashing
                    tm1638Data[0] = 0x7C; // b
0380  307C  	MOVLW 0x7C
0381  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x5B; // 2
0382  305B  	MOVLW 0x5B
0383  00A1  	MOVWF gbl_tm1638Data+D'1'

                    //tm1638Data[2] = 0x3F; // O
                    tm1638Data[3] = 0x54; // n
0384  3054  	MOVLW 0x54
0385  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
0386  3005  	MOVLW 0x05
0387  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
0388  3004  	MOVLW 0x04
0389  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlue2OnHour); // Display hour in digits 4 and 5 (dot on 5)
038A  085C  	MOVF gbl_gBcdBlue2OnHour, W
038B  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
038C  223E  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlue2OnMinute); // Display minute in digits 6 and 7 (no dot)
038D  085B  	MOVF gbl_gBcdBlue2OnMinute, W
038E  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
038F  223E  	CALL bcdTo7Seg_00000

                    break;
0390  2C40  	GOTO	label84

                case 10:
030D  3A03  	XORLW 0x03
030E  1903  	BTFSC STATUS,Z
030F  2B91  	GOTO	label67
0391        label67

                    // 2nd Blue LED on minute, shows as 'b2On' followed by hh:mm with 8th digit flashing
                    iDigitToFlash = 7;
0391  3007  	MOVLW 0x07
0392  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0393  3006  	MOVLW 0x06
0394  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlue2OnMinute); // Display minute in digits 6 and 7 (no dot)
0395  085B  	MOVF gbl_gBcdBlue2OnMinute, W
0396  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0397  223E  	CALL bcdTo7Seg_00000

                    break;
0398  2C40  	GOTO	label84

                case 11:
0310  3A01  	XORLW 0x01
0311  1903  	BTFSC STATUS,Z
0312  2B99  	GOTO	label68
0399        label68

                    // 2nd Blue LED off hour, shows as 'b2OF' followed by hh:mm with 6th digit flashing
                    tm1638Data[3] = 0x71; // F
0399  3071  	MOVLW 0x71
039A  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
039B  3005  	MOVLW 0x05
039C  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
039D  3004  	MOVLW 0x04
039E  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlue2OffHour); // Display hour in digits 4 and 5 (dot on 5)
039F  085E  	MOVF gbl_gBcdBlue2OffHour, W
03A0  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03A1  223E  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlue2OffMinute); // Display minute in digits 6 and 7 (no dot)
03A2  085D  	MOVF gbl_gBcdBlue2OffMinute, W
03A3  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03A4  223E  	CALL bcdTo7Seg_00000

                    break;
03A5  2C40  	GOTO	label84

                case 12:
0313  3A07  	XORLW 0x07
0314  1903  	BTFSC STATUS,Z
0315  2BA6  	GOTO	label69
03A6        label69

                    // 2nd Blue LED off minute, shows as 'b2OF' followed by hh:mm with 8th digit flashing
                    iDigitToFlash = 7;
03A6  3007  	MOVLW 0x07
03A7  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
03A8  3006  	MOVLW 0x06
03A9  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlue2OffMinute); // Display minute in digits 6 and 7 (no dot)
03AA  085D  	MOVF gbl_gBcdBlue2OffMinute, W
03AB  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03AC  223E  	CALL bcdTo7Seg_00000

                    break;
03AD  2C40  	GOTO	label84

                case 13:
0316  3A01  	XORLW 0x01
0317  1903  	BTFSC STATUS,Z
0318  2BAE  	GOTO	label70
03AE        label70

                    // Fan on temperature, shows as 'Fan On' followed by nn (temperature in degrees C) with 8th digit flashing
                    tm1638Data[0] = 0x71; // F
03AE  3071  	MOVLW 0x71
03AF  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x5F; // a
03B0  305F  	MOVLW 0x5F
03B1  00A1  	MOVWF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x54; // n
03B2  3054  	MOVLW 0x54
03B3  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x00; // space
03B4  01A3  	CLRF gbl_tm1638Data+D'3'

                    tm1638Data[4] = 0x3F; // O
03B5  303F  	MOVLW 0x3F
03B6  00A4  	MOVWF gbl_tm1638Data+D'4'

                    tm1638Data[5] = 0x54; // n
03B7  3054  	MOVLW 0x54
03B8  00A5  	MOVWF gbl_tm1638Data+D'5'

                    iDigitToFlash = 7;
03B9  3007  	MOVLW 0x07
03BA  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
03BB  3006  	MOVLW 0x06
03BC  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdFanOnTemp); // Display celcius in digits 6 and 7 (no dot)
03BD  085F  	MOVF gbl_gBcdFanOnTemp, W
03BE  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03BF  223E  	CALL bcdTo7Seg_00000

                    break;
03C0  2C40  	GOTO	label84

                case 14:
0319  3A03  	XORLW 0x03
031A  1903  	BTFSC STATUS,Z
031B  2BC1  	GOTO	label71
03C1        label71

                    // Fan off temperature, shows as 'Fan OF' followed by nn (temperature in degrees C) with 8th digit flashing
                    tm1638Data[5] = 0x71; // F
03C1  3071  	MOVLW 0x71
03C2  00A5  	MOVWF gbl_tm1638Data+D'5'

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
03C3  3006  	MOVLW 0x06
03C4  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdFanOffTemp); // Display celcius in digits 6 and 7 (no dot)
03C5  0860  	MOVF gbl_gBcdFanOffTemp, W
03C6  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03C7  223E  	CALL bcdTo7Seg_00000

                    break;
03C8  2C40  	GOTO	label84

                case 15:
031C  3A01  	XORLW 0x01
031D  1903  	BTFSC STATUS,Z
031E  2BC9  	GOTO	label72
03C9        label72

                    // Heater on temperature, shows as 'HeatOn' followed by nn (temperature in degrees C) with 8th digit flashing
                    tm1638Data[0] = 0x76; // H
03C9  3076  	MOVLW 0x76
03CA  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x7B; // e
03CB  307B  	MOVLW 0x7B
03CC  00A1  	MOVWF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x5F; // a
03CD  305F  	MOVLW 0x5F
03CE  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x78; // t
03CF  3078  	MOVLW 0x78
03D0  00A3  	MOVWF gbl_tm1638Data+D'3'

                    tm1638Data[4] = 0x3F; // O
03D1  303F  	MOVLW 0x3F
03D2  00A4  	MOVWF gbl_tm1638Data+D'4'

                    tm1638Data[5] = 0x54; // n
03D3  3054  	MOVLW 0x54
03D4  00A5  	MOVWF gbl_tm1638Data+D'5'

                    iDigitToFlash = 7;
03D5  3007  	MOVLW 0x07
03D6  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
03D7  3006  	MOVLW 0x06
03D8  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdHeaterOnTemp); // Display celcius in digits 6 and 7 (no dot)
03D9  0861  	MOVF gbl_gBcdHeaterOnTemp, W
03DA  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03DB  223E  	CALL bcdTo7Seg_00000

                    break;
03DC  2C40  	GOTO	label84

                case 16:
031F  3A1F  	XORLW 0x1F
0320  1903  	BTFSC STATUS,Z
0321  2BDD  	GOTO	label73
03DD        label73

                    // Heater off temperature, shows as 'HeatOF' followed by nn (temperature in degrees C) with 8th digit flashing
                    tm1638Data[5] = 0x71; // f
03DD  3071  	MOVLW 0x71
03DE  00A5  	MOVWF gbl_tm1638Data+D'5'

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
03DF  3006  	MOVLW 0x06
03E0  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdHeaterOffTemp); // Display celcius in digits 6 and 7 (no dot)
03E1  0862  	MOVF gbl_gBcdHeaterOffTemp, W
03E2  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03E3  223E  	CALL bcdTo7Seg_00000

                    break;
            }
        } else {
03E4  2C40  	GOTO	label84

            // If in set mode, set the relevant digit to flash
            switch (gcSetMode) {
0401        label80

                case 2:
03E5  0850  	MOVF gbl_gcSetMode, W
03E6  3A02  	XORLW 0x02
03E7  1903  	BTFSC STATUS,Z
03E8  2BF3  	GOTO	label75
03F3        label75

                    // Month
                    iDigitToFlash = 3;
03F3  3003  	MOVLW 0x03
03F4  00C8  	MOVWF gbl_iDigitToFlash

                    break;
03F5  2C01  	GOTO	label80

                case 3:
03E9  3A01  	XORLW 0x01
03EA  1903  	BTFSC STATUS,Z
03EB  2BF6  	GOTO	label76
03F6        label76

                    // Day of month
                    iDigitToFlash = 1;
03F6  3001  	MOVLW 0x01
03F7  00C8  	MOVWF gbl_iDigitToFlash

                    break;
03F8  2C01  	GOTO	label80

                case 6:
03EC  3A05  	XORLW 0x05
03ED  1903  	BTFSC STATUS,Z
03EE  2BF9  	GOTO	label77
03F9        label77

                    // Clock Hour
                    iDigitToFlash = 5;
03F9  3005  	MOVLW 0x05
03FA  00C8  	MOVWF gbl_iDigitToFlash

                    break;
03FB  2C01  	GOTO	label80

                case 7:
03EF  3A01  	XORLW 0x01
03F0  1903  	BTFSC STATUS,Z
03F1  2BFC  	GOTO	label78
03FC        label78

                    // Clock Minute
                    iDigitToFlash = 7;
03FC  3007  	MOVLW 0x07
03FD  00C8  	MOVWF gbl_iDigitToFlash

                    break;
03FE  2C01  	GOTO	label80

                default:
03F2  2BFF  	GOTO	label79
03FF        label79

                    iDigitToFlash = 8; // digit no flashing
03FF  3008  	MOVLW 0x08
0400  00C8  	MOVWF gbl_iDigitToFlash

            }
            // Display date in DD.MM format when in set mode or gcDisplayMode = 2
            iPrintStartDigit = 0;
0401  01ED  	CLRF gbl_iPrintStartDigit

            iPrintDotDigit = 1;
0402  3001  	MOVLW 0x01
0403  00EE  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(gBcdDayOfMonth); // Display day of month in digits 0 and 1 (+dot on 1)
0404  0839  	MOVF gbl_gBcdDayOfMonth, W
0405  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0406  223E  	CALL bcdTo7Seg_00000

            zeroToBlank(0); // left fill zero with blank
0407  01F8  	CLRF zeroToBlan_00021_arg_iDigit
0408  215B  	CALL zeroToBlan_00021


            iPrintDotDigit = 3;
0409  3003  	MOVLW 0x03
040A  00EE  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(gBcdMonth); // Display month in digits 2 and 3 (+dot on 3)
040B  083A  	MOVF gbl_gBcdMonth, W
040C  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
040D  223E  	CALL bcdTo7Seg_00000

            zeroToBlank(2); // left fill zero with blank
040E  3002  	MOVLW 0x02
040F  00F8  	MOVWF zeroToBlan_00021_arg_iDigit
0410  215B  	CALL zeroToBlan_00021

        }
    } else {
0411  2C40  	GOTO	label84

        iDigitToFlash = 8; // No flashing digit in normal mode
0412  3008  	MOVLW 0x08
0413  00C8  	MOVWF gbl_iDigitToFlash

        // translate DS3231 temperature to digit values
        iPrintDotDigit = 1;
0414  3001  	MOVLW 0x01
0415  00EE  	MOVWF gbl_iPrintDotDigit

        if (gcDisplayMode == 1) // no dot on the first two digits for fahrenheit
0416  034F  	DECF gbl_gcDisplayMode, W
0417  1D03  	BTFSS STATUS,Z
0418  2C1B  	GOTO	label82
041B        label82

			iPrintDotDigit = 2;
0419  3002  	MOVLW 0x02
041A  00EE  	MOVWF gbl_iPrintDotDigit

        // For -10 or below, shift digits right
        if (gbDS3231IsMinus && (giDS3231ValueBCD & 0xF000)) {
041B  08CC  	MOVF gbl_gbDS3231IsMinus, F
041C  1903  	BTFSC STATUS,Z
041D  2C30  	GOTO	label83
041E  30F0  	MOVLW 0xF0
041F  0534  	ANDWF gbl_giDS3231ValueBCD+D'1', W
0420  1903  	BTFSC STATUS,Z
0421  2C30  	GOTO	label83
0430        label83

            giDS3231ValueBCD >>= 4;
0422  0D34  	RLF gbl_giDS3231ValueBCD+D'1', W
0423  0CB4  	RRF gbl_giDS3231ValueBCD+D'1', F
0424  0CB3  	RRF gbl_giDS3231ValueBCD, F
0425  0D34  	RLF gbl_giDS3231ValueBCD+D'1', W
0426  0CB4  	RRF gbl_giDS3231ValueBCD+D'1', F
0427  0CB3  	RRF gbl_giDS3231ValueBCD, F
0428  0D34  	RLF gbl_giDS3231ValueBCD+D'1', W
0429  0CB4  	RRF gbl_giDS3231ValueBCD+D'1', F
042A  0CB3  	RRF gbl_giDS3231ValueBCD, F
042B  0D34  	RLF gbl_giDS3231ValueBCD+D'1', W
042C  0CB4  	RRF gbl_giDS3231ValueBCD+D'1', F
042D  0CB3  	RRF gbl_giDS3231ValueBCD, F

            iPrintDotDigit = 2;
042E  3002  	MOVLW 0x02
042F  00EE  	MOVWF gbl_iPrintDotDigit

        }
        // Display current temperature in digits 0 to 3 (+dot on digit 1 and 3)
        iPrintStartDigit = 0;
0430  01ED  	CLRF gbl_iPrintStartDigit

        bcdTo7Seg(giDS3231ValueBCD >> 8);
0431  0834  	MOVF gbl_giDS3231ValueBCD+D'1', W
0432  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0433  223E  	CALL bcdTo7Seg_00000

        bcdTo7Seg(giDS3231ValueBCD);
0434  0833  	MOVF gbl_giDS3231ValueBCD, W
0435  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0436  223E  	CALL bcdTo7Seg_00000

        // Also display dot on 4th digit (always)
		tm1638Data[3] |= tm1638Dot;
0437  0865  	MOVF gbl_tm1638Dot, W
0438  04A3  	IORWF gbl_tm1638Data+D'3', F

        // left fill zero with blank (1st digit)
        zeroToBlank(0);
0439  01F8  	CLRF zeroToBlan_00021_arg_iDigit
043A  215B  	CALL zeroToBlan_00021

        // If minus, overwrite left most digit with minus sign
        if (gbDS3231IsMinus)
043B  08CC  	MOVF gbl_gbDS3231IsMinus, F
043C  1903  	BTFSC STATUS,Z
043D  2C40  	GOTO	label84
0440        label84

            tm1638Data[0] = 0x40;
043E  3040  	MOVLW 0x40
043F  00A0  	MOVWF gbl_tm1638Data

    }

    // Display clock HH.MM in last 4 digits of TM1638 (unless in trigger mode)
    if (!gcTriggerMode) {
0440  08D2  	MOVF gbl_gcTriggerMode, F
0441  1D03  	BTFSS STATUS,Z
0442  2C7A  	GOTO	label90
047A        label90

        // Flash dot every second
        if (gBcdSecond.0)
0443  1C35  	BTFSS gbl_gBcdSecond,0
0444  2C48  	GOTO	label85
0448        label85

			iPrintDotDigit = 5;
0445  3005  	MOVLW 0x05
0446  00EE  	MOVWF gbl_iPrintDotDigit

		else
0447  2C4A  	GOTO	label86
044A        label86

			iPrintDotDigit = 8;
0448  3008  	MOVLW 0x08
0449  00EE  	MOVWF gbl_iPrintDotDigit

        
        char cBcdHourDisp = gBcdHour;
044A  0837  	MOVF gbl_gBcdHour, W
044B  00F7  	MOVWF tm1638Upda_00022_198_cBcdH_00024

        // 12h clock handling - convert from 24h
        if (gcHourMode && (gBcdHour > 0x12)) {
044C  08D1  	MOVF gbl_gcHourMode, F
044D  1903  	BTFSC STATUS,Z
044E  2C5E  	GOTO	label87
044F  0837  	MOVF gbl_gBcdHour, W
0450  3C12  	SUBLW 0x12
0451  1803  	BTFSC STATUS,C
0452  2C5E  	GOTO	label87

			// convert to 12h
			cBcdHourDisp -= 0x12;
0453  3012  	MOVLW 0x12
0454  02F7  	SUBWF tm1638Upda_00022_198_cBcdH_00024, F

			// For 8 and 9pm, take off another 6
			if ((cBcdHourDisp & 0x0F) > 7)
0455  300F  	MOVLW 0x0F
0456  0577  	ANDWF tm1638Upda_00022_198_cBcdH_00024, W
0457  00F8  	MOVWF CompTempVar599
0458  0878  	MOVF CompTempVar599, W
0459  3C07  	SUBLW 0x07
045A  1803  	BTFSC STATUS,C
045B  2C5E  	GOTO	label87
045E        label87

                cBcdHourDisp -= 6;
045C  3006  	MOVLW 0x06
045D  02F7  	SUBWF tm1638Upda_00022_198_cBcdH_00024, F

        }
        if (gcHourMode && gBcdHour == 0) {
045E  08D1  	MOVF gbl_gcHourMode, F
045F  1903  	BTFSC STATUS,Z
0460  2C66  	GOTO	label88
0461  08B7  	MOVF gbl_gBcdHour, F
0462  1D03  	BTFSS STATUS,Z
0463  2C66  	GOTO	label88
0466        label88

			cBcdHourDisp = 0x12; // 12am
0464  3012  	MOVLW 0x12
0465  00F7  	MOVWF tm1638Upda_00022_198_cBcdH_00024

        }
        iPrintStartDigit = 4;
0466  3004  	MOVLW 0x04
0467  00ED  	MOVWF gbl_iPrintStartDigit

        bcdTo7Seg(cBcdHourDisp); // Display hour in digits 4 and 5 (dot on 5)
0468  0877  	MOVF tm1638Upda_00022_198_cBcdH_00024, W
0469  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
046A  223E  	CALL bcdTo7Seg_00000

        // left fill zero with blank (for 5th digit)
        zeroToBlank(4);
046B  3004  	MOVLW 0x04
046C  00F8  	MOVWF zeroToBlan_00021_arg_iDigit
046D  215B  	CALL zeroToBlan_00021

        if (gcHourMode && (gBcdHour > 0x11)) {
046E  08D1  	MOVF gbl_gcHourMode, F
046F  1903  	BTFSC STATUS,Z
0470  2C77  	GOTO	label89
0471  0837  	MOVF gbl_gBcdHour, W
0472  3C11  	SUBLW 0x11
0473  1803  	BTFSC STATUS,C
0474  2C77  	GOTO	label89
0477        label89

			// PM dot
			iPrintDotDigit = 7;
0475  3007  	MOVLW 0x07
0476  00EE  	MOVWF gbl_iPrintDotDigit

        }
        bcdTo7Seg(gBcdMinute); // Display minute in digits 6 and 7 (no dot)
0477  0836  	MOVF gbl_gBcdMinute, W
0478  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0479  223E  	CALL bcdTo7Seg_00000

    }

    // Light LED for set mode
    char cCompareSetMode = gcSetMode;
047A  0850  	MOVF gbl_gcSetMode, W
047B  00F4  	MOVWF tm1638Upda_00022_1_cCompar_00023

    for (char i = 2; i < 8; i++) {
047C  3002  	MOVLW 0x02
047D  00F6  	MOVWF tm1638Upda_00022_3_i
047E        label91
047E  3008  	MOVLW 0x08
047F  0276  	SUBWF tm1638Upda_00022_3_i, W
0480  1803  	BTFSC STATUS,C
0481  2C97  	GOTO	label94
0495  0AF6  	INCF tm1638Upda_00022_3_i, F
0496  2C7E  	GOTO	label91
0497        label94

        if (i == cCompareSetMode)
0482  0874  	MOVF tm1638Upda_00022_1_cCompar_00023, W
0483  0676  	XORWF tm1638Upda_00022_3_i, W
0484  1D03  	BTFSS STATUS,Z
0485  2C8E  	GOTO	label92
048E        label92

            tm1638LEDs[i] = 1;
0486  1383  	BCF	STATUS,IRP
0487  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
0488  0084  	MOVWF FSR
0489  0876  	MOVF tm1638Upda_00022_3_i, W
048A  0784  	ADDWF FSR, F
048B  3001  	MOVLW 0x01
048C  0080  	MOVWF INDF

        else
048D  2C95  	GOTO	label93
0495        label93

            tm1638LEDs[i] = 0;
048E  1383  	BCF	STATUS,IRP
048F  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
0490  0084  	MOVWF FSR
0491  0876  	MOVF tm1638Upda_00022_3_i, W
0492  0784  	ADDWF FSR, F
0493  3000  	MOVLW 0x00
0494  0080  	MOVWF INDF

    }
    tm1638LEDs[0] = HEATER; // Light 1st LED if the heater is on
0497  01A8  	CLRF gbl_tm1638LEDs
0498  1805  	BTFSC gbl_porta,0
0499  0AA8  	INCF gbl_tm1638LEDs, F

    tm1638LEDs[1] = FAN; // Light 2nd LED if the fans are on
049A  01A9  	CLRF gbl_tm1638LEDs+D'1'
049B  1885  	BTFSC gbl_porta,1
049C  0AA9  	INCF gbl_tm1638LEDs+D'1', F


    // Now we have the data for the LED 7-segment display and LEDs, push these to the TM1638

    // Write 0x40 [01000000] (table 5.1) to indicate command to display data - [Write data to display register]
    tm1638strobe = 0;
049D  1186  	BCF gbl_portb,3

    tm1638ByteWrite(tm1638ByteSetData);
049E  0867  	MOVF gbl_tm1638ByteSetData, W
049F  00F6  	MOVWF tm1638Byte_0001E_arg_bWrite
04A0  216C  	CALL tm1638Byte_0001E

    tm1638strobe = 1;
04A1  1586  	BSF gbl_portb,3

    
    // Specify the display address 0xC0 [11000000] (table 5.2) [Display address 00H] then write out all 16 bytes
    tm1638strobe = 0;
04A2  1186  	BCF gbl_portb,3

    tm1638ByteWrite(tm1638ByteSetAddr);
04A3  0869  	MOVF gbl_tm1638ByteSetAddr, W
04A4  00F6  	MOVWF tm1638Byte_0001E_arg_bWrite
04A5  216C  	CALL tm1638Byte_0001E

    for (char i = 0; i < tm1638MaxDigits; i++) {
04A6  01F5  	CLRF tm1638Upda_00022_2_i
04A7        label95
04A7  0863  	MOVF gbl_tm1638MaxDigits, W
04A8  0275  	SUBWF tm1638Upda_00022_2_i, W
04A9  1803  	BTFSC STATUS,C
04AA  2CC6  	GOTO	label98
04C4  0AF5  	INCF tm1638Upda_00022_2_i, F
04C5  2CA7  	GOTO	label95
04C6        label98

        // display 7-segment digit first
        // If flashing the digit, alternate a blank output
        if (iFlashDigitOff.0 && (i == iDigitToFlash))
04AB  1C3F  	BTFSS gbl_iFlashDigitOff,0
04AC  2CB4  	GOTO	label96
04AD  0848  	MOVF gbl_iDigitToFlash, W
04AE  0675  	XORWF tm1638Upda_00022_2_i, W
04AF  1D03  	BTFSS STATUS,Z
04B0  2CB4  	GOTO	label96
04B4        label96

            tm1638ByteWrite(0);
04B1  01F6  	CLRF tm1638Byte_0001E_arg_bWrite
04B2  216C  	CALL tm1638Byte_0001E

        else
04B3  2CBC  	GOTO	label97
04BC        label97

            tm1638ByteWrite(tm1638Data[i]);
04B4  1383  	BCF	STATUS,IRP
04B5  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
04B6  0084  	MOVWF FSR
04B7  0875  	MOVF tm1638Upda_00022_2_i, W
04B8  0784  	ADDWF FSR, F
04B9  0800  	MOVF INDF, W
04BA  00F6  	MOVWF tm1638Byte_0001E_arg_bWrite
04BB  216C  	CALL tm1638Byte_0001E

        // then LED
        tm1638ByteWrite(tm1638LEDs[i]);
04BC  1383  	BCF	STATUS,IRP
04BD  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
04BE  0084  	MOVWF FSR
04BF  0875  	MOVF tm1638Upda_00022_2_i, W
04C0  0784  	ADDWF FSR, F
04C1  0800  	MOVF INDF, W
04C2  00F6  	MOVWF tm1638Byte_0001E_arg_bWrite
04C3  216C  	CALL tm1638Byte_0001E

    }
    tm1638strobe = 1;
04C6  1586  	BSF gbl_portb,3

}
04C7  0008  	RETURN


/*********************************************************************************************
  void tm1638ReadKeys()
  Reads the keys status into tm1638Keys
  from http://www.piclearning.net/280/pic-and-tm1638-ledkey-module.php
*********************************************************************************************/
void tm1638ReadKeys() {

    // Write 0x42 [01000010] to indicate command to read data
    tm1638strobe = 0;
07BC  1283  	BCF STATUS, RP0
07BD  1303  	BCF STATUS, RP1
07BE  1186  	BCF gbl_portb,3

    tm1638ByteWrite(tm1638ByteReadData);
07BF  0868  	MOVF gbl_tm1638ByteReadData, W
07C0  00F6  	MOVWF tm1638Byte_0001E_arg_bWrite
07C1  216C  	CALL tm1638Byte_0001E

    
    tm1638dioTris = 1; // Set data pin to input
07C2  1683  	BSF STATUS, RP0
07C3  1486  	BSF gbl_trisb,1

    char tm1638KeysTemp = 32;
07C4  3020  	MOVLW 0x20
07C5  1283  	BCF STATUS, RP0
07C6  00F2  	MOVWF tm1638Read_00025_1_tm1638K_00026

    // Read 4 bytes
    for (char i = 0; i < 32; i++) {
07C7  01F3  	CLRF tm1638Read_00025_2_i
07C8        label134
07C8  3020  	MOVLW 0x20
07C9  0273  	SUBWF tm1638Read_00025_2_i, W
07CA  1803  	BTFSC STATUS,C
07CB  2FD8  	GOTO	label136
07D6  0AF3  	INCF tm1638Read_00025_2_i, F
07D7  2FC8  	GOTO	label134
07D8        label136

        tm1638KeysTemp--;
07CC  03F2  	DECF tm1638Read_00025_1_tm1638K_00026, F

        tm1638clk = 0;
07CD  1106  	BCF gbl_portb,2

        delay_us(1);
07CE  3001  	MOVLW 0x01
07CF  00F8  	MOVWF delay_us_00000_arg_del
07D0  2010  	CALL delay_us_00000

        if(tm1638dio)
07D1  1C86  	BTFSS gbl_portb,1
07D2  2FD5  	GOTO	label135
07D5        label135

            tm1638KeysTemp <<= 1;
07D3  1003  	BCF STATUS,C
07D4  0DF2  	RLF tm1638Read_00025_1_tm1638K_00026, F

        tm1638clk = 1;
07D5  1506  	BSF gbl_portb,2

    }
    tm1638dioTris = 0; // Set data pin to output
07D8  1683  	BSF STATUS, RP0
07D9  1086  	BCF gbl_trisb,1

    tm1638strobe = 1;
07DA  1283  	BCF STATUS, RP0
07DB  1586  	BSF gbl_portb,3


    tm1638Keys = tm1638KeysTemp;
07DC  0872  	MOVF tm1638Read_00025_1_tm1638K_00026, W
07DD  00EB  	MOVWF gbl_tm1638Keys

    /*
    1F = 0001 1111
	17 = 0001 0111
	0F = 0000 1111
	07 = 0000 0111
	1B = 0001 1011
	13 = 0001 0011
	0B = 0000 1011
	03 = 0000 0111
	*/
}
07DE  0008  	RETURN


/*********************************************************************************************
  int intToBcd(int iValue)
  Used to split the 16 bit integer into bcd parts (max 9999)
*********************************************************************************************/
int intToBcd(int iValue) {

    int iBcdOut = 0;
019B  01FC  	CLRF intToBcd_00000_1_iBcdOut
019C  01FD  	CLRF intToBcd_00000_1_iBcdOut+D'1'

    // Split via loops = less program memory needed, may be slower executing
    // https://electronics.stackexchange.com/questions/158563/how-to-split-a-floating-point-number-into-individual-digits
    iBcdOut = 0;
019D  01FC  	CLRF intToBcd_00000_1_iBcdOut
019E  01FD  	CLRF intToBcd_00000_1_iBcdOut+D'1'


    // incrementing variables for each digit
    // determine to thousands digit
    while (iValue >= 1000) {
019F        label28
019F  3003  	MOVLW 0x03
01A0  027B  	SUBWF intToBcd_00000_arg_iValue+D'1', W
01A1  1D03  	BTFSS STATUS,Z
01A2  29A5  	GOTO	label29
01A3  30E8  	MOVLW 0xE8
01A4  027A  	SUBWF intToBcd_00000_arg_iValue, W
01A5        label29
01A5  1C03  	BTFSS STATUS,C
01A6  29B2  	GOTO	label30
01A7  1BFB  	BTFSC intToBcd_00000_arg_iValue+D'1',7
01A8  29B2  	GOTO	label30
01B1  299F  	GOTO	label28
01B2        label30

        iValue -= 1000;
01A9  30E8  	MOVLW 0xE8
01AA  02FA  	SUBWF intToBcd_00000_arg_iValue, F
01AB  3003  	MOVLW 0x03
01AC  1C03  	BTFSS STATUS,C
01AD  03FB  	DECF intToBcd_00000_arg_iValue+D'1', F
01AE  02FB  	SUBWF intToBcd_00000_arg_iValue+D'1', F

        // each time we take off 1000, the digit is incremented
        iBcdOut += 0x1000;
01AF  3010  	MOVLW 0x10
01B0  07FD  	ADDWF intToBcd_00000_1_iBcdOut+D'1', F

    }

    // determine to hundreds digit
    while (iValue >= 100) {
01B2  087B  	MOVF intToBcd_00000_arg_iValue+D'1', W
01B3  3A80  	XORLW 0x80
01B4  00FE  	MOVWF CompTempVar639
01B5  3080  	MOVLW 0x80
01B6  027E  	SUBWF CompTempVar639, W
01B7  1D03  	BTFSS STATUS,Z
01B8  29BB  	GOTO	label31
01B9  3064  	MOVLW 0x64
01BA  027A  	SUBWF intToBcd_00000_arg_iValue, W
01BB        label31
01BB  1C03  	BTFSS STATUS,C
01BC  29C3  	GOTO	label32
01C2  29B2  	GOTO	label30
01C3        label32

        iValue -= 100;
01BD  3064  	MOVLW 0x64
01BE  02FA  	SUBWF intToBcd_00000_arg_iValue, F
01BF  1C03  	BTFSS STATUS,C
01C0  03FB  	DECF intToBcd_00000_arg_iValue+D'1', F

        // each time we take off 100, the digit is incremented
        iBcdOut += 0x100;
01C1  0AFD  	INCF intToBcd_00000_1_iBcdOut+D'1', F

    }

    // determine to tens digit
    while (iValue >= 10) {
01C3  087B  	MOVF intToBcd_00000_arg_iValue+D'1', W
01C4  3A80  	XORLW 0x80
01C5  00FE  	MOVWF CompTempVar640
01C6  3080  	MOVLW 0x80
01C7  027E  	SUBWF CompTempVar640, W
01C8  1D03  	BTFSS STATUS,Z
01C9  29CC  	GOTO	label33
01CA  300A  	MOVLW 0x0A
01CB  027A  	SUBWF intToBcd_00000_arg_iValue, W
01CC        label33
01CC  1C03  	BTFSS STATUS,C
01CD  29D7  	GOTO	label34
01D6  29C3  	GOTO	label32
01D7        label34

        iValue -= 10;
01CE  300A  	MOVLW 0x0A
01CF  02FA  	SUBWF intToBcd_00000_arg_iValue, F
01D0  1C03  	BTFSS STATUS,C
01D1  03FB  	DECF intToBcd_00000_arg_iValue+D'1', F

        // each time we take off 10, the left most digit is incremented
        iBcdOut += 0x10;
01D2  3010  	MOVLW 0x10
01D3  07FC  	ADDWF intToBcd_00000_1_iBcdOut, F
01D4  1803  	BTFSC STATUS,C
01D5  0AFD  	INCF intToBcd_00000_1_iBcdOut+D'1', F

    }

    // the last digit is what's left on iValue
    iBcdOut += iValue;
01D7  087A  	MOVF intToBcd_00000_arg_iValue, W
01D8  07FC  	ADDWF intToBcd_00000_1_iBcdOut, F
01D9  087B  	MOVF intToBcd_00000_arg_iValue+D'1', W
01DA  1803  	BTFSC STATUS,C
01DB  0AFD  	INCF intToBcd_00000_1_iBcdOut+D'1', F
01DC  07FD  	ADDWF intToBcd_00000_1_iBcdOut+D'1', F

}
01DD  0008  	RETURN


/*********************************************************************************************
  void convertTemp()
  Used to convert the ds18b20 temperature to display values
*********************************************************************************************/
void convertTemp() {

    // convert both bytes to a 16bit int - e.g. 0000 0001 0100 0110 (1 and 70, gives 326)
    signed int iTemp = (cTempH << 8) | cTempL;
0544  1283  	BCF STATUS, RP0
0545  1303  	BCF STATUS, RP1
0546  01F2  	CLRF convertTem_00027_1_iTemp
0547  0849  	MOVF gbl_cTempH, W
0548  00F3  	MOVWF convertTem_00027_1_iTemp+D'1'
0549  084A  	MOVF gbl_cTempL, W
054A  04F2  	IORWF convertTem_00027_1_iTemp, F

    signed int iTemp2 = iTemp;
054B  0872  	MOVF convertTem_00027_1_iTemp, W
054C  00F4  	MOVWF convertTem_00027_1_iTemp2
054D  0873  	MOVF convertTem_00027_1_iTemp+D'1', W
054E  00F5  	MOVWF convertTem_00027_1_iTemp2+D'1'

    
    // this gets celcius * 100 - https://www.phanderson.com/PIC/PICC/sourceboost/ds18b20_1.html
    // Celcius value is always required for triggering
	gbDS3231IsMinus = (iTemp2 < 0);
054F  01CC  	CLRF gbl_gbDS3231IsMinus
0550  1BF5  	BTFSC convertTem_00027_1_iTemp2+D'1',7
0551  0ACC  	INCF gbl_gbDS3231IsMinus, F

	if (gbDS3231IsMinus) {
0552  08CC  	MOVF gbl_gbDS3231IsMinus, F
0553  1903  	BTFSC STATUS,Z
0554  2D5A  	GOTO	label101

		iTemp2 = ~iTemp2 + 1;
0555  09F4  	COMF convertTem_00027_1_iTemp2, F
0556  09F5  	COMF convertTem_00027_1_iTemp2+D'1', F
0557  0AF4  	INCF convertTem_00027_1_iTemp2, F
0558  1903  	BTFSC STATUS,Z
0559  0AF5  	INCF convertTem_00027_1_iTemp2+D'1', F
055A        label101

	}
    int iValueC = (6 * iTemp2) + (iTemp2 / 4);
055A  3006  	MOVLW 0x06
055B  00FA  	MOVWF __mul_16s__0000F_arg_a
055C  01FB  	CLRF __mul_16s__0000F_arg_a+D'1'
055D  0874  	MOVF convertTem_00027_1_iTemp2, W
055E  00FC  	MOVWF __mul_16s__0000F_arg_b
055F  0875  	MOVF convertTem_00027_1_iTemp2+D'1', W
0560  00FD  	MOVWF __mul_16s__0000F_arg_b+D'1'
0561  2270  	CALL __mul_16s__0000F
0562  1683  	BSF STATUS, RP0
0563  0822  	MOVF CompTempVarRet387, W
0564  1283  	BCF STATUS, RP0
0565  00F6  	MOVWF convertTem_00027_1_iValueC
0566  1683  	BSF STATUS, RP0
0567  0823  	MOVF CompTempVarRet387+D'1', W
0568  1283  	BCF STATUS, RP0
0569  00F9  	MOVWF CompTempVar617
056A  0874  	MOVF convertTem_00027_1_iTemp2, W
056B  00F8  	MOVWF CompTempVar614
056C  0875  	MOVF convertTem_00027_1_iTemp2+D'1', W
056D  00F7  	MOVWF convertTem_00027_1_iValueC+D'1'
056E  0D75  	RLF convertTem_00027_1_iTemp2+D'1', W
056F  0CF7  	RRF convertTem_00027_1_iValueC+D'1', F
0570  0CF8  	RRF CompTempVar614, F
0571  0D75  	RLF convertTem_00027_1_iTemp2+D'1', W
0572  0CF7  	RRF convertTem_00027_1_iValueC+D'1', F
0573  0CF8  	RRF CompTempVar614, F
0574  0878  	MOVF CompTempVar614, W
0575  07F6  	ADDWF convertTem_00027_1_iValueC, F
0576  0879  	MOVF CompTempVar617, W
0577  1803  	BTFSC STATUS,C
0578  0AF7  	INCF convertTem_00027_1_iValueC+D'1', F
0579  07F7  	ADDWF convertTem_00027_1_iValueC+D'1', F

    // Split the temperature reading into digits
    giDS3231ValueBCD = intToBcd(iValueC);
057A  0876  	MOVF convertTem_00027_1_iValueC, W
057B  00FA  	MOVWF intToBcd_00000_arg_iValue
057C  0877  	MOVF convertTem_00027_1_iValueC+D'1', W
057D  00FB  	MOVWF intToBcd_00000_arg_iValue+D'1'
057E  219B  	CALL intToBcd_00000
057F  087C  	MOVF CompTempVarRet638, W
0580  00B3  	MOVWF gbl_giDS3231ValueBCD
0581  087D  	MOVF CompTempVarRet638+D'1', W
0582  00B4  	MOVWF gbl_giDS3231ValueBCD+D'1'

    // Truncated value for triggering heater/fans
    giDS3231ValueTruncCBCD = giDS3231ValueBCD >> 8;
0583  0834  	MOVF gbl_giDS3231ValueBCD+D'1', W
0584  00CB  	MOVWF gbl_giDS3231ValueTruncCBCD

    
    if (gcDisplayMode == 1) {
0585  034F  	DECF gbl_gcDisplayMode, W
0586  1D03  	BTFSS STATUS,Z

		// -17.8125 (-285/65251) results in minus fahrenheit (-0.125), -17.75 (-284/65250) results in positive fahrenheit (1)
        // this gets Fahrenheit * 10 - https://www.electro-tech-online.com/threads/temperature-sensor-ds18b20-display-fahrenhiet.117377/
        iTemp2 = ((iTemp + 4) / 8) + iTemp + 320;
0588  3004  	MOVLW 0x04
0589  0772  	ADDWF convertTem_00027_1_iTemp, W
058A  00FB  	MOVWF CompTempVar629
058B  0873  	MOVF convertTem_00027_1_iTemp+D'1', W
058C  00FD  	MOVWF CompTempVar632
058D  1803  	BTFSC STATUS,C
058E  0AFD  	INCF CompTempVar632, F
058F  087D  	MOVF CompTempVar632, W
0590  00FA  	MOVWF CompTempVar626
0591  0D7D  	RLF CompTempVar632, W
0592  0CFA  	RRF CompTempVar626, F
0593  0CFB  	RRF CompTempVar629, F
0594  0D7D  	RLF CompTempVar632, W
0595  0CFA  	RRF CompTempVar626, F
0596  0CFB  	RRF CompTempVar629, F
0597  0D7D  	RLF CompTempVar632, W
0598  0CFA  	RRF CompTempVar626, F
0599  0CFB  	RRF CompTempVar629, F
059A  0872  	MOVF convertTem_00027_1_iTemp, W
059B  07FB  	ADDWF CompTempVar629, F
059C  0873  	MOVF convertTem_00027_1_iTemp+D'1', W
059D  00FC  	MOVWF CompTempVar630
059E  087A  	MOVF CompTempVar626, W
059F  1803  	BTFSC STATUS,C
05A0  0AFC  	INCF CompTempVar630, F
05A1  07FC  	ADDWF CompTempVar630, F
05A2  3040  	MOVLW 0x40
05A3  07FB  	ADDWF CompTempVar629, F
05A4  3001  	MOVLW 0x01
05A5  1803  	BTFSC STATUS,C
05A6  0AFC  	INCF CompTempVar630, F
05A7  07FC  	ADDWF CompTempVar630, F
05A8  087B  	MOVF CompTempVar629, W
05A9  00F4  	MOVWF convertTem_00027_1_iTemp2
05AA  087C  	MOVF CompTempVar630, W
05AB  00F5  	MOVWF convertTem_00027_1_iTemp2+D'1'

        // convert to absolute value
        gbDS3231IsMinus = (iTemp2 < 0);
05AC  01CC  	CLRF gbl_gbDS3231IsMinus
05AD  1BF5  	BTFSC convertTem_00027_1_iTemp2+D'1',7
05AE  0ACC  	INCF gbl_gbDS3231IsMinus, F

        if (gbDS3231IsMinus) {
05AF  08CC  	MOVF gbl_gbDS3231IsMinus, F
05B0  1903  	BTFSC STATUS,Z
05B1  2DB7  	GOTO	label102

            iTemp2 = ~iTemp2 + 1;
05B2  09F4  	COMF convertTem_00027_1_iTemp2, F
05B3  09F5  	COMF convertTem_00027_1_iTemp2+D'1', F
05B4  0AF4  	INCF convertTem_00027_1_iTemp2, F
05B5  1903  	BTFSC STATUS,Z
05B6  0AF5  	INCF convertTem_00027_1_iTemp2+D'1', F
05B7        label102

        }
        // Split the temperature reading into digits
        giDS3231ValueBCD = intToBcd(iTemp2);
05B7  0874  	MOVF convertTem_00027_1_iTemp2, W
05B8  00FA  	MOVWF intToBcd_00000_arg_iValue
05B9  0875  	MOVF convertTem_00027_1_iTemp2+D'1', W
05BA  00FB  	MOVWF intToBcd_00000_arg_iValue+D'1'
05BB  219B  	CALL intToBcd_00000
05BC  087C  	MOVF CompTempVarRet638, W
05BD  00B3  	MOVWF gbl_giDS3231ValueBCD
05BE  087D  	MOVF CompTempVarRet638+D'1', W
05BF  00B4  	MOVWF gbl_giDS3231ValueBCD+D'1'

	}
}
0587  0008  	RETURN
05C0  0008  	RETURN


/*********************************************************************************************
  void startTemp()
  Sends the Convert T [44h] function command to the ds18b20
*********************************************************************************************/
void startTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // 44 is the convert function
    oneWireTxBytes(0xCC, 0x44);
07DF  30CC  	MOVLW 0xCC
07E0  1283  	BCF STATUS, RP0
07E1  1303  	BCF STATUS, RP1
07E2  00F2  	MOVWF oneWireTxB_00016_arg_cData
07E3  3044  	MOVLW 0x44
07E4  00F3  	MOVWF oneWireTxB_00016_arg_cData2
07E5  24D0  	CALL oneWireTxB_00016

}
07E6  0008  	RETURN


/*********************************************************************************************
  void readTemp()
  Sends the Read Scratchpad [BEh] function command to the ds18b20
*********************************************************************************************/
void readTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // BE indicates to read scratchpad
    oneWireTxBytes(0xCC, 0xBE);
07E7  30CC  	MOVLW 0xCC
07E8  1283  	BCF STATUS, RP0
07E9  1303  	BCF STATUS, RP1
07EA  00F2  	MOVWF oneWireTxB_00016_arg_cData
07EB  30BE  	MOVLW 0xBE
07EC  00F3  	MOVWF oneWireTxB_00016_arg_cData2
07ED  24D0  	CALL oneWireTxB_00016

    // Now get the temperature from the scratchpad
    // This is in the first two bytes - so get those only and ignore the rest
    cTempL = oneWireRxByte();
07EE  24D7  	CALL oneWireRxB_00017
07EF  0873  	MOVF CompTempVarRet549, W
07F0  00CA  	MOVWF gbl_cTempL

    cTempH = oneWireRxByte();
07F1  24D7  	CALL oneWireRxB_00017
07F2  0873  	MOVF CompTempVarRet549, W
07F3  00C9  	MOVWF gbl_cTempH

}
07F4  0008  	RETURN


/*********************************************************************************************
  char bcdAdjust(char bcd, char bcdMax, char bcdMin)
  Increment or Decrement a BCD variable for sending to the DS3231, within a given range
  Must set iBcdAdjustment (up/down increment) first
*********************************************************************************************/
char bcdAdjust(char bcd, char bcdMax, char bcdMin) {

    if (iBcdAdjustment == 1) {
0246  036F  	DECF gbl_iBcdAdjustment, W
0247  1D03  	BTFSS STATUS,Z
0248  2A5C  	GOTO	label46
025C        label46

        // Increment
        // if at maximum, reset to minimum
        if (bcd == bcdMax)
0249  0875  	MOVF bcdAdjust_00000_arg_bcdMax, W
024A  0674  	XORWF bcdAdjust_00000_arg_bcd, W
024B  1D03  	BTFSS STATUS,Z
024C  2A50  	GOTO	label44
0250        label44

            bcd = bcdMin;
024D  0876  	MOVF bcdAdjust_00000_arg_bcdMin, W
024E  00F4  	MOVWF bcdAdjust_00000_arg_bcd

        else if ((bcd & 0x0F) == 9)
024F  2A6D  	GOTO	label49
0250  300F  	MOVLW 0x0F
0251  0574  	ANDWF bcdAdjust_00000_arg_bcd, W
0252  00F7  	MOVWF CompTempVar642
0253  0877  	MOVF CompTempVar642, W
0254  3A09  	XORLW 0x09
0255  1D03  	BTFSS STATUS,Z
0256  2A5A  	GOTO	label45
025A        label45

            bcd += 0x07; // add 0x10 (16), minus 9
0257  3007  	MOVLW 0x07
0258  07F4  	ADDWF bcdAdjust_00000_arg_bcd, F

        else
0259  2A6D  	GOTO	label49

            bcd++;
025A  0AF4  	INCF bcdAdjust_00000_arg_bcd, F

    } else {
025B  2A6D  	GOTO	label49

        // Decrement
        // if at minimum, reset to maximum
        if (bcd == bcdMin)
025C  0876  	MOVF bcdAdjust_00000_arg_bcdMin, W
025D  0674  	XORWF bcdAdjust_00000_arg_bcd, W
025E  1D03  	BTFSS STATUS,Z
025F  2A63  	GOTO	label47
0263        label47

            bcd = bcdMax;
0260  0875  	MOVF bcdAdjust_00000_arg_bcdMax, W
0261  00F4  	MOVWF bcdAdjust_00000_arg_bcd

        else if ((bcd & 0x0F) == 0)
0262  2A6D  	GOTO	label49
0263  300F  	MOVLW 0x0F
0264  0574  	ANDWF bcdAdjust_00000_arg_bcd, W
0265  00F7  	MOVWF CompTempVar643
0266  08F7  	MOVF CompTempVar643, F
0267  1D03  	BTFSS STATUS,Z
0268  2A6C  	GOTO	label48
026C        label48

            bcd -= 0x07; // minus 0x10 (16), add 9
0269  3007  	MOVLW 0x07
026A  02F4  	SUBWF bcdAdjust_00000_arg_bcd, F

        else
026B  2A6D  	GOTO	label49
026D        label49

            bcd--;
026C  03F4  	DECF bcdAdjust_00000_arg_bcd, F

    }
    return bcd;
026D  0874  	MOVF bcdAdjust_00000_arg_bcd, W
026E  00F7  	MOVWF CompTempVarRet641

}
026F  0008  	RETURN


/*********************************************************************************************
  void adjustDateTime()
  Increment or Decrement a BCD variable for sending to the DS3231, within a given range
  Must set iBcdAdjustment (up/down increment) first
*********************************************************************************************/
void adjustDateTime() {

    switch (gcSetMode) {

        case 1:
0737  1283  	BCF STATUS, RP0
0738  1303  	BCF STATUS, RP1
0739  0850  	MOVF gbl_gcSetMode, W
073A  3A01  	XORLW 0x01
073B  1903  	BTFSC STATUS,Z
073C  2F50  	GOTO	label123
0750        label123

            // Setting year - from 00 to 99
            gBcdYear = bcdAdjust(gBcdYear, 0x99, 0x00);
0750  083B  	MOVF gbl_gBcdYear, W
0751  00F4  	MOVWF bcdAdjust_00000_arg_bcd
0752  3099  	MOVLW 0x99
0753  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
0754  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
0755  2246  	CALL bcdAdjust_00000
0756  0877  	MOVF CompTempVarRet641, W
0757  00BB  	MOVWF gbl_gBcdYear

            break;
        case 2:
073D  3A03  	XORLW 0x03
073E  1903  	BTFSC STATUS,Z
073F  2F59  	GOTO	label124
0759        label124

            // Setting month - from 1 to 12
            gBcdMonth = bcdAdjust(gBcdMonth, 0x12, 0x01);
0759  083A  	MOVF gbl_gBcdMonth, W
075A  00F4  	MOVWF bcdAdjust_00000_arg_bcd
075B  3012  	MOVLW 0x12
075C  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
075D  3001  	MOVLW 0x01
075E  00F6  	MOVWF bcdAdjust_00000_arg_bcdMin
075F  2246  	CALL bcdAdjust_00000
0760  0877  	MOVF CompTempVarRet641, W
0761  00BA  	MOVWF gbl_gBcdMonth

            break;
        case 3:
0740  3A01  	XORLW 0x01
0741  1903  	BTFSC STATUS,Z
0742  2F63  	GOTO	label125
0763        label125

            // Setting day of month - from 1 to max days in month (i.e. 31, 30 or 28/29)
            char iMonth = gBcdMonth;
0763  083A  	MOVF gbl_gBcdMonth, W
0764  00F2  	MOVWF adjustDate_00028_1_iMonth

            if (iMonth & 0xF0)
0765  30F0  	MOVLW 0xF0
0766  0572  	ANDWF adjustDate_00028_1_iMonth, W
0767  1903  	BTFSC STATUS,Z
0768  2F6E  	GOTO	label126
076E        label126

                iMonth += (gBcdMonth >> 4);
0769  0E3A  	SWAPF gbl_gBcdMonth, W
076A  390F  	ANDLW 0x0F
076B  00F4  	MOVWF CompTempVar644
076C  0874  	MOVF CompTempVar644, W
076D  07F2  	ADDWF adjustDate_00028_1_iMonth, F

            iMonth--; // Make 0 to 11 index based
076E  03F2  	DECF adjustDate_00028_1_iMonth, F

            char bcdMaxDay = gDaysInMonth[iMonth]; 
076F  083C  	MOVF gbl_gDaysInMonth, W
0770  00FB  	MOVWF __rom_get_00000_arg_objNumb
0771  0872  	MOVF adjustDate_00028_1_iMonth, W
0772  00FC  	MOVWF __rom_get_00000_arg_idx
0773  201A  	CALL __rom_get_00000
0774  00F3  	MOVWF adjustDate_00028_1_bcdMaxDay

            // If February(1), adjust max days for leap years
            if (iMonth == 1) {
0775  0372  	DECF adjustDate_00028_1_iMonth, W
0776  118A  	BCF PCLATH,3
0777  120A  	BCF PCLATH,4
0778  1D03  	BTFSS STATUS,Z
0779  2F90  	GOTO	label129

                // See if the 24 leap years since 2000 match the current year
                for (char i = 0; i < 24; i++) {
077A  01F4  	CLRF adjustDate_00028_16_i
077B        label127
077B  3018  	MOVLW 0x18
077C  0274  	SUBWF adjustDate_00028_16_i, W
077D  1803  	BTFSC STATUS,C
077E  2F90  	GOTO	label129
078E  0AF4  	INCF adjustDate_00028_16_i, F
078F  2F7B  	GOTO	label127
0790        label129

                    if (gLeapYears[i] == gBcdYear) {
077F  083D  	MOVF gbl_gLeapYears, W
0780  00FB  	MOVWF __rom_get_00000_arg_objNumb
0781  0874  	MOVF adjustDate_00028_16_i, W
0782  00FC  	MOVWF __rom_get_00000_arg_idx
0783  201A  	CALL __rom_get_00000
0784  00F5  	MOVWF CompTempVar645
0785  083B  	MOVF gbl_gBcdYear, W
0786  0675  	XORWF CompTempVar645, W
0787  118A  	BCF PCLATH,3
0788  120A  	BCF PCLATH,4
0789  1D03  	BTFSS STATUS,Z
078A  2F8E  	GOTO	label128
078E        label128

                        bcdMaxDay = 0x29;
078B  3029  	MOVLW 0x29
078C  00F3  	MOVWF adjustDate_00028_1_bcdMaxDay

                        break;
078D  2F90  	GOTO	label129

                    }
                }
            }
            gBcdDayOfMonth = bcdAdjust(gBcdDayOfMonth, bcdMaxDay, 0x01);
0790  0839  	MOVF gbl_gBcdDayOfMonth, W
0791  00F4  	MOVWF bcdAdjust_00000_arg_bcd
0792  0873  	MOVF adjustDate_00028_1_bcdMaxDay, W
0793  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
0794  3001  	MOVLW 0x01
0795  00F6  	MOVWF bcdAdjust_00000_arg_bcdMin
0796  2246  	CALL bcdAdjust_00000
0797  0877  	MOVF CompTempVarRet641, W
0798  00B9  	MOVWF gbl_gBcdDayOfMonth

            break;
        case 4:
0743  3A07  	XORLW 0x07
0744  1903  	BTFSC STATUS,Z
0745  2F9A  	GOTO	label130
079A        label130

            // Setting day of week - from 1 to 7
            gDayOfWeek = bcdAdjust(gDayOfWeek, 0x07, 0x01);
079A  0838  	MOVF gbl_gDayOfWeek, W
079B  00F4  	MOVWF bcdAdjust_00000_arg_bcd
079C  3007  	MOVLW 0x07
079D  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
079E  3001  	MOVLW 0x01
079F  00F6  	MOVWF bcdAdjust_00000_arg_bcdMin
07A0  2246  	CALL bcdAdjust_00000
07A1  0877  	MOVF CompTempVarRet641, W
07A2  00B8  	MOVWF gbl_gDayOfWeek

            break;
        case 5:
0746  3A01  	XORLW 0x01
0747  1903  	BTFSC STATUS,Z
0748  2FA4  	GOTO	label131
07A4        label131

            // Setting 12h/24h
            gcHourMode++;
07A4  0AD1  	INCF gbl_gcHourMode, F

            if (gcHourMode > 2)
07A5  0851  	MOVF gbl_gcHourMode, W
07A6  3C02  	SUBLW 0x02
07A7  1C03  	BTFSS STATUS,C

				gcHourMode = 0;
07A8  01D1  	CLRF gbl_gcHourMode

            break;
        case 6:
0749  3A03  	XORLW 0x03
074A  1903  	BTFSC STATUS,Z
074B  2FAA  	GOTO	label132
07AA        label132

            // Setting hour - from 0 to 23
            gBcdHour = bcdAdjust(gBcdHour, 0x23, 0x00);
07AA  0837  	MOVF gbl_gBcdHour, W
07AB  00F4  	MOVWF bcdAdjust_00000_arg_bcd
07AC  3023  	MOVLW 0x23
07AD  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
07AE  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
07AF  2246  	CALL bcdAdjust_00000
07B0  0877  	MOVF CompTempVarRet641, W
07B1  00B7  	MOVWF gbl_gBcdHour

            break;
        case 7:
074C  3A01  	XORLW 0x01
074D  1903  	BTFSC STATUS,Z
074E  2FB3  	GOTO	label133
07B3        label133

            // Setting minute - from 0 to 59
            gBcdMinute = bcdAdjust(gBcdMinute, 0x59, 0x00);
07B3  0836  	MOVF gbl_gBcdMinute, W
07B4  00F4  	MOVWF bcdAdjust_00000_arg_bcd
07B5  3059  	MOVLW 0x59
07B6  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
07B7  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
07B8  2246  	CALL bcdAdjust_00000
07B9  0877  	MOVF CompTempVarRet641, W
07BA  00B6  	MOVWF gbl_gBcdMinute

            break;
    }
}
074F  0008  	RETURN
0758  0008  	RETURN
0762  0008  	RETURN
0799  0008  	RETURN
07A3  0008  	RETURN
07A9  0008  	RETURN
07B2  0008  	RETURN
07BB  0008  	RETURN


/*********************************************************************************************
  void adjustTrigger()
  Increment or Decrement a trigger time or temperate
  Must set iBcdAdjustment first
*********************************************************************************************/
void adjustTrigger() {

    switch (gcTriggerMode) {

        case 1:
0664  1283  	BCF STATUS, RP0
0665  1303  	BCF STATUS, RP1
0666  0852  	MOVF gbl_gcTriggerMode, W
0667  3A01  	XORLW 0x01
0668  1903  	BTFSC STATUS,Z
0669  2E98  	GOTO	label105
0698        label105

            // White LED on hour - from 0 to 23
            gBcdWhiteOnHour = bcdAdjust(gBcdWhiteOnHour, 0x23, 0x00);
0698  0854  	MOVF gbl_gBcdWhiteOnHour, W
0699  00F4  	MOVWF bcdAdjust_00000_arg_bcd
069A  3023  	MOVLW 0x23
069B  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
069C  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
069D  2246  	CALL bcdAdjust_00000
069E  0877  	MOVF CompTempVarRet641, W
069F  00D4  	MOVWF gbl_gBcdWhiteOnHour

            break;
        case 2:
066A  3A03  	XORLW 0x03
066B  1903  	BTFSC STATUS,Z
066C  2EA1  	GOTO	label106
06A1        label106

            // White LED on minute - from 0 to 59
            gBcdWhiteOnMinute = bcdAdjust(gBcdWhiteOnMinute, 0x59, 0x00);
06A1  0853  	MOVF gbl_gBcdWhiteOnMinute, W
06A2  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06A3  3059  	MOVLW 0x59
06A4  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06A5  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06A6  2246  	CALL bcdAdjust_00000
06A7  0877  	MOVF CompTempVarRet641, W
06A8  00D3  	MOVWF gbl_gBcdWhiteOnMinute

            break;
        case 3:
066D  3A01  	XORLW 0x01
066E  1903  	BTFSC STATUS,Z
066F  2EAA  	GOTO	label107
06AA        label107

            // White LED off hour - from 0 to 23
            gBcdWhiteOffHour = bcdAdjust(gBcdWhiteOffHour, 0x23, 0x00);
06AA  0856  	MOVF gbl_gBcdWhiteOffHour, W
06AB  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06AC  3023  	MOVLW 0x23
06AD  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06AE  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06AF  2246  	CALL bcdAdjust_00000
06B0  0877  	MOVF CompTempVarRet641, W
06B1  00D6  	MOVWF gbl_gBcdWhiteOffHour

            break;
        case 4:
0670  3A07  	XORLW 0x07
0671  1903  	BTFSC STATUS,Z
0672  2EB3  	GOTO	label108
06B3        label108

            // White LED off minute - from 0 to 59
            gBcdWhiteOffMinute = bcdAdjust(gBcdWhiteOffMinute, 0x59, 0x00);
06B3  0855  	MOVF gbl_gBcdWhiteOffMinute, W
06B4  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06B5  3059  	MOVLW 0x59
06B6  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06B7  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06B8  2246  	CALL bcdAdjust_00000
06B9  0877  	MOVF CompTempVarRet641, W
06BA  00D5  	MOVWF gbl_gBcdWhiteOffMinute

            break;
        case 5:
0673  3A01  	XORLW 0x01
0674  1903  	BTFSC STATUS,Z
0675  2EBC  	GOTO	label109
06BC        label109

            // 1st Blue LED on hour - from 0 to 23
            gBcdBlueOnHour = bcdAdjust(gBcdBlueOnHour, 0x23, 0x00);
06BC  0858  	MOVF gbl_gBcdBlueOnHour, W
06BD  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06BE  3023  	MOVLW 0x23
06BF  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06C0  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06C1  2246  	CALL bcdAdjust_00000
06C2  0877  	MOVF CompTempVarRet641, W
06C3  00D8  	MOVWF gbl_gBcdBlueOnHour

            break;
        case 6:
0676  3A03  	XORLW 0x03
0677  1903  	BTFSC STATUS,Z
0678  2EC5  	GOTO	label110
06C5        label110

            // 1st Blue LED on minute - from 0 to 59
            gBcdBlueOnMinute = bcdAdjust(gBcdBlueOnMinute, 0x59, 0x00);
06C5  0857  	MOVF gbl_gBcdBlueOnMinute, W
06C6  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06C7  3059  	MOVLW 0x59
06C8  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06C9  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06CA  2246  	CALL bcdAdjust_00000
06CB  0877  	MOVF CompTempVarRet641, W
06CC  00D7  	MOVWF gbl_gBcdBlueOnMinute

            break;
        case 7:
0679  3A01  	XORLW 0x01
067A  1903  	BTFSC STATUS,Z
067B  2ECE  	GOTO	label111
06CE        label111

            // 1st Blue LED off hour - from 0 to 23
            gBcdBlueOffHour = bcdAdjust(gBcdBlueOffHour, 0x23, 0x00);
06CE  085A  	MOVF gbl_gBcdBlueOffHour, W
06CF  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06D0  3023  	MOVLW 0x23
06D1  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06D2  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06D3  2246  	CALL bcdAdjust_00000
06D4  0877  	MOVF CompTempVarRet641, W
06D5  00DA  	MOVWF gbl_gBcdBlueOffHour

            break;
        case 8:
067C  3A0F  	XORLW 0x0F
067D  1903  	BTFSC STATUS,Z
067E  2ED7  	GOTO	label112
06D7        label112

            // 1st Blue LED off minute - from 0 to 59
            gBcdBlueOffMinute = bcdAdjust(gBcdBlueOffMinute, 0x59, 0x00);
06D7  0859  	MOVF gbl_gBcdBlueOffMinute, W
06D8  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06D9  3059  	MOVLW 0x59
06DA  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06DB  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06DC  2246  	CALL bcdAdjust_00000
06DD  0877  	MOVF CompTempVarRet641, W
06DE  00D9  	MOVWF gbl_gBcdBlueOffMinute

            break;
        case 9:
067F  3A01  	XORLW 0x01
0680  1903  	BTFSC STATUS,Z
0681  2EE0  	GOTO	label113
06E0        label113

            // 2nd Blue LED on hour - from 0 to 23
            gBcdBlue2OnHour = bcdAdjust(gBcdBlue2OnHour, 0x23, 0x00);
06E0  085C  	MOVF gbl_gBcdBlue2OnHour, W
06E1  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06E2  3023  	MOVLW 0x23
06E3  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06E4  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06E5  2246  	CALL bcdAdjust_00000
06E6  0877  	MOVF CompTempVarRet641, W
06E7  00DC  	MOVWF gbl_gBcdBlue2OnHour

            break;
        case 10:
0682  3A03  	XORLW 0x03
0683  1903  	BTFSC STATUS,Z
0684  2EE9  	GOTO	label114
06E9        label114

            // 2nd Blue LED on minute - from 0 to 59
            gBcdBlue2OnMinute = bcdAdjust(gBcdBlue2OnMinute, 0x59, 0x00);
06E9  085B  	MOVF gbl_gBcdBlue2OnMinute, W
06EA  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06EB  3059  	MOVLW 0x59
06EC  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06ED  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06EE  2246  	CALL bcdAdjust_00000
06EF  0877  	MOVF CompTempVarRet641, W
06F0  00DB  	MOVWF gbl_gBcdBlue2OnMinute

            break;
        case 11:
0685  3A01  	XORLW 0x01
0686  1903  	BTFSC STATUS,Z
0687  2EF2  	GOTO	label115
06F2        label115

            // 2nd Blue LED off hour - from 0 to 23
            gBcdBlue2OffHour = bcdAdjust(gBcdBlue2OffHour, 0x23, 0x00);
06F2  085E  	MOVF gbl_gBcdBlue2OffHour, W
06F3  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06F4  3023  	MOVLW 0x23
06F5  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06F6  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06F7  2246  	CALL bcdAdjust_00000
06F8  0877  	MOVF CompTempVarRet641, W
06F9  00DE  	MOVWF gbl_gBcdBlue2OffHour

            break;
        case 12:
0688  3A07  	XORLW 0x07
0689  1903  	BTFSC STATUS,Z
068A  2EFB  	GOTO	label116
06FB        label116

            // 2nd Blue LED off minute - from 0 to 59
            gBcdBlue2OffMinute = bcdAdjust(gBcdBlue2OffMinute, 0x59, 0x00);
06FB  085D  	MOVF gbl_gBcdBlue2OffMinute, W
06FC  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06FD  3059  	MOVLW 0x59
06FE  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06FF  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
0700  2246  	CALL bcdAdjust_00000
0701  0877  	MOVF CompTempVarRet641, W
0702  00DD  	MOVWF gbl_gBcdBlue2OffMinute

            break;
        case 13:
068B  3A01  	XORLW 0x01
068C  1903  	BTFSC STATUS,Z
068D  2F04  	GOTO	label117
0704        label117

            // Fan on temp - between 20 and 40 degrees C
            gBcdFanOnTemp = bcdAdjust(gBcdFanOnTemp, 0x40, 0x20);
0704  085F  	MOVF gbl_gBcdFanOnTemp, W
0705  00F4  	MOVWF bcdAdjust_00000_arg_bcd
0706  3040  	MOVLW 0x40
0707  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
0708  3020  	MOVLW 0x20
0709  00F6  	MOVWF bcdAdjust_00000_arg_bcdMin
070A  2246  	CALL bcdAdjust_00000
070B  0877  	MOVF CompTempVarRet641, W
070C  00DF  	MOVWF gbl_gBcdFanOnTemp

            break;
        case 14:
068E  3A03  	XORLW 0x03
068F  1903  	BTFSC STATUS,Z
0690  2F0E  	GOTO	label118
070E        label118

            // Fan off temp - off must be lower than on, min 20 degrees C
            if (gBcdFanOffTemp > gBcdFanOnTemp)
070E  0860  	MOVF gbl_gBcdFanOffTemp, W
070F  025F  	SUBWF gbl_gBcdFanOnTemp, W
0710  1803  	BTFSC STATUS,C
0711  2F14  	GOTO	label119
0714        label119

				gBcdFanOffTemp = gBcdFanOnTemp;
0712  085F  	MOVF gbl_gBcdFanOnTemp, W
0713  00E0  	MOVWF gbl_gBcdFanOffTemp

            gBcdFanOffTemp = bcdAdjust(gBcdFanOffTemp, gBcdFanOnTemp, 0x20);
0714  0860  	MOVF gbl_gBcdFanOffTemp, W
0715  00F4  	MOVWF bcdAdjust_00000_arg_bcd
0716  085F  	MOVF gbl_gBcdFanOnTemp, W
0717  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
0718  3020  	MOVLW 0x20
0719  00F6  	MOVWF bcdAdjust_00000_arg_bcdMin
071A  2246  	CALL bcdAdjust_00000
071B  0877  	MOVF CompTempVarRet641, W
071C  00E0  	MOVWF gbl_gBcdFanOffTemp

            break;
        case 15:
0691  3A01  	XORLW 0x01
0692  1903  	BTFSC STATUS,Z
0693  2F1E  	GOTO	label120
071E        label120

            // Heater on temp - between 0 and 40 degrees C
            gBcdHeaterOnTemp = bcdAdjust(gBcdHeaterOnTemp, 0x40, 0);
071E  0861  	MOVF gbl_gBcdHeaterOnTemp, W
071F  00F4  	MOVWF bcdAdjust_00000_arg_bcd
0720  3040  	MOVLW 0x40
0721  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
0722  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
0723  2246  	CALL bcdAdjust_00000
0724  0877  	MOVF CompTempVarRet641, W
0725  00E1  	MOVWF gbl_gBcdHeaterOnTemp

            break;
        case 16:
0694  3A1F  	XORLW 0x1F
0695  1903  	BTFSC STATUS,Z
0696  2F27  	GOTO	label121
0727        label121

            // Heater off temp - off must be equal or higher than on - max 40 degrees C
            if (gBcdHeaterOffTemp < gBcdHeaterOnTemp)
0727  0861  	MOVF gbl_gBcdHeaterOnTemp, W
0728  0262  	SUBWF gbl_gBcdHeaterOffTemp, W
0729  1803  	BTFSC STATUS,C
072A  2F2D  	GOTO	label122
072D        label122

				gBcdHeaterOffTemp = gBcdHeaterOnTemp;
072B  0861  	MOVF gbl_gBcdHeaterOnTemp, W
072C  00E2  	MOVWF gbl_gBcdHeaterOffTemp

            gBcdHeaterOffTemp = bcdAdjust(gBcdHeaterOffTemp, 0x40, gBcdHeaterOnTemp);
072D  0862  	MOVF gbl_gBcdHeaterOffTemp, W
072E  00F4  	MOVWF bcdAdjust_00000_arg_bcd
072F  3040  	MOVLW 0x40
0730  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
0731  0861  	MOVF gbl_gBcdHeaterOnTemp, W
0732  00F6  	MOVWF bcdAdjust_00000_arg_bcdMin
0733  2246  	CALL bcdAdjust_00000
0734  0877  	MOVF CompTempVarRet641, W
0735  00E2  	MOVWF gbl_gBcdHeaterOffTemp

            break;
    }
}
0697  0008  	RETURN
06A0  0008  	RETURN
06A9  0008  	RETURN
06B2  0008  	RETURN
06BB  0008  	RETURN
06C4  0008  	RETURN
06CD  0008  	RETURN
06D6  0008  	RETURN
06DF  0008  	RETURN
06E8  0008  	RETURN
06F1  0008  	RETURN
06FA  0008  	RETURN
0703  0008  	RETURN
070D  0008  	RETURN
071D  0008  	RETURN
0726  0008  	RETURN
0736  0008  	RETURN


/*********************************************************************************************
  void processKeys()
  Action a key press
*********************************************************************************************/
void processKeys() {

    // Key hex codes based on result from tm1638ReadKeys, from http://www.piclearning.net/280/pic-and-tm1638-ledkey-module.php
    switch (tm1638Keys) {

        case 0x1F:
07F5  1283  	BCF STATUS, RP0
07F6  1303  	BCF STATUS, RP1
07F7  086B  	MOVF gbl_tm1638Keys, W
07F8  3A1F  	XORLW 0x1F
07F9  158A  	BSF PCLATH,3
07FA  1903  	BTFSC STATUS,Z
07FB  2812  	GOTO	label137
0812        label137

            // Toggle white light on/off
            WHITE_LED = !WHITE_LED;
0812  01F2  	CLRF CompTempVar646
0813  1C87  	BTFSS gbl_portc,1
0814  0AF2  	INCF CompTempVar646, F
0815  1872  	BTFSC CompTempVar646,0
0816  1487  	BSF gbl_portc,1
0817  1C72  	BTFSS CompTempVar646,0
0818  1087  	BCF gbl_portc,1

            break;
        case 0x17:
07FC  3A08  	XORLW 0x08
07FD  1903  	BTFSC STATUS,Z
07FE  281A  	GOTO	label138
081A        label138

            // Toggle blue light on/off
            BLUE_LED = !BLUE_LED;
081A  01F2  	CLRF CompTempVar647
081B  1D07  	BTFSS gbl_portc,2
081C  0AF2  	INCF CompTempVar647, F
081D  1872  	BTFSC CompTempVar647,0
081E  1507  	BSF gbl_portc,2
081F  1C72  	BTFSS CompTempVar647,0
0820  1107  	BCF gbl_portc,2

            break;
        case 0x0F:
07FF  3A18  	XORLW 0x18
0800  1903  	BTFSC STATUS,Z
0801  2822  	GOTO	label139
0822        label139

            // Toggle fan on/off
            gbFanOn = !gbFanOn;
0822  01F2  	CLRF CompTempVar648
0823  1C4E  	BTFSS gbl_gbFanOn,0
0824  0AF2  	INCF CompTempVar648, F
0825  104E  	BCF gbl_gbFanOn,0
0826  0872  	MOVF CompTempVar648, W
0827  1D03  	BTFSS STATUS,Z
0828  144E  	BSF gbl_gbFanOn,0

            break;
        case 0x07:
0802  3A08  	XORLW 0x08
0803  1903  	BTFSC STATUS,Z
0804  282A  	GOTO	label140
082A        label140

            // Exit other modes
            if (gcTriggerMode)
082A  08D2  	MOVF gbl_gcTriggerMode, F
082C  1D03  	BTFSS STATUS,Z

                at24c32WriteAll(); // Exiting trigger mode, save the new triggers to EEPROM chip
082B  118A  	BCF PCLATH,3
082D  25C1  	CALL at24c32Wri_00018

            gcSetMode = 0;
082E  01D0  	CLRF gbl_gcSetMode

            gcTriggerMode = 0;
082F  01D2  	CLRF gbl_gcTriggerMode

            // Display temp C/temp F/date
            gcDisplayMode++;
0830  0ACF  	INCF gbl_gcDisplayMode, F

            if (gcDisplayMode > 3)
0831  084F  	MOVF gbl_gcDisplayMode, W
0832  3C03  	SUBLW 0x03
0833  1C03  	BTFSS STATUS,C

                gcDisplayMode = 0;
0834  01CF  	CLRF gbl_gcDisplayMode

            convertTemp(); // force conversion (no read)
0835  2544  	CALL convertTem_00027

            break;
        case 0x1B:
0805  3A1C  	XORLW 0x1C
0806  1903  	BTFSC STATUS,Z
0807  2837  	GOTO	label141
0837        label141

            // Exit other modes
            gcTriggerMode = 0;
0837  01D2  	CLRF gbl_gcTriggerMode

            // Adjust set mode
            gcSetMode++;
0838  0AD0  	INCF gbl_gcSetMode, F

            if (gcSetMode > 7) {
0839  0850  	MOVF gbl_gcSetMode, W
083A  3C07  	SUBLW 0x07
083B  1803  	BTFSC STATUS,C

                ds3231WriteDateTime();
083D  118A  	BCF PCLATH,3
083E  2508  	CALL ds3231Writ_0001B

                gcSetMode = 0;
083F  01D0  	CLRF gbl_gcSetMode

            }
            break;
        case 0x13:
0808  3A08  	XORLW 0x08
0809  1903  	BTFSC STATUS,Z
080A  2841  	GOTO	label142
0841        label142

            // Adjust down
            iBcdAdjustment = 0;
0841  01EF  	CLRF gbl_iBcdAdjustment

            if (gcSetMode) {
0842  08D0  	MOVF gbl_gcSetMode, F
0843  1903  	BTFSC STATUS,Z
0844  2848  	GOTO	label143
0848        label143

                adjustDateTime();
0845  118A  	BCF PCLATH,3
0846  2737  	CALL adjustDate_00028

            } else if (gcTriggerMode) {
0848  08D2  	MOVF gbl_gcTriggerMode, F
084A  1D03  	BTFSS STATUS,Z

                adjustTrigger();
0849  118A  	BCF PCLATH,3
084B  2664  	CALL adjustTrig_00029

            }
            break;
        case 0x0B:
080B  3A18  	XORLW 0x18
080C  1903  	BTFSC STATUS,Z
080D  284D  	GOTO	label144
084D        label144

            iBcdAdjustment = 1;
084D  3001  	MOVLW 0x01
084E  00EF  	MOVWF gbl_iBcdAdjustment

            // Adjust up
            if (gcSetMode) {
084F  08D0  	MOVF gbl_gcSetMode, F
0850  1903  	BTFSC STATUS,Z
0851  2855  	GOTO	label145
0855        label145

                adjustDateTime();
0852  118A  	BCF PCLATH,3
0853  2737  	CALL adjustDate_00028

            } else if (gcTriggerMode) {
0855  08D2  	MOVF gbl_gcTriggerMode, F
0857  1D03  	BTFSS STATUS,Z

                adjustTrigger();
0856  118A  	BCF PCLATH,3
0858  2664  	CALL adjustTrig_00029

            }
            break;
        case 0x03:
080E  3A08  	XORLW 0x08
080F  1903  	BTFSC STATUS,Z
0810  285A  	GOTO	label146
085A        label146

            // Exit set mode
            gcSetMode = 0;
085A  01D0  	CLRF gbl_gcSetMode

            // Adjust timer mode
            gcTriggerMode++;
085B  0AD2  	INCF gbl_gcTriggerMode, F

            if (gcTriggerMode > 16) {
085C  0852  	MOVF gbl_gcTriggerMode, W
085D  3C10  	SUBLW 0x10
085E  1803  	BTFSC STATUS,C

                at24c32WriteAll(); // Exiting trigger mode, save the new triggers to EEPROM chip
0860  118A  	BCF PCLATH,3
0861  25C1  	CALL at24c32Wri_00018

                gcTriggerMode = 0;
0862  01D2  	CLRF gbl_gcTriggerMode

            }
            break;
    }
}
0811  0008  	RETURN
0819  0008  	RETURN
0821  0008  	RETURN
0829  0008  	RETURN
0836  0008  	RETURN
083C  0008  	RETURN
0840  0008  	RETURN
0847  0008  	RETURN
084C  0008  	RETURN
0854  0008  	RETURN
0859  0008  	RETURN
085F  0008  	RETURN
0863  0008  	RETURN


/*********************************************************************************************
  void interrupt()
  Interrupt handler
*********************************************************************************************/
void interrupt() {

    // Interrupt on timer0 - flash digit delay
    if (intcon.T0IF) {
0A23  1D0B  	BTFSS gbl_intcon,2
0A24  2A2C  	GOTO	label173
0A2C        label173

        iTimer0Counts++;
0A25  1283  	BCF STATUS, RP0
0A26  1303  	BCF STATUS, RP1
0A27  0ABE  	INCF gbl_iTimer0Counts, F

        tmr0 = TMR0PRELOAD;
0A28  303D  	MOVLW 0x3D
0A29  0081  	MOVWF gbl_tmr0

        cTask.TASK_TIMER0 = 1;
0A2A  14CD  	BSF gbl_cTask,1

        // Clear interrupt flag
        intcon.T0IF = 0; 
0A2B  110B  	BCF gbl_intcon,2

    }
    // Handle timer1 interrupt - delay counter from DS3231
    if (pir1.TMR1IF) {
0A2C  1283  	BCF STATUS, RP0
0A2D  1303  	BCF STATUS, RP1
0A2E  1C0C  	BTFSS gbl_pir1,0
0A2F  2A35  	GOTO	label174
0A35        label174

        tmr1h = TMR1HV;      // preset for timer1 MSB register
0A30  30FF  	MOVLW 0xFF
0A31  008F  	MOVWF gbl_tmr1h

        tmr1l = TMR1LV;      // preset for timer1 LSB register
0A32  008E  	MOVWF gbl_tmr1l


        pir1.TMR1IF = 0;     // Clear interrupt flag
0A33  100C  	BCF gbl_pir1,0

        cTask.TASK_TIMER1 = 1;
0A34  154D  	BSF gbl_cTask,2

    }
}
0A35  0E32  	SWAPF Int1BContext+D'2', W
0A36  0084  	MOVWF FSR
0A37  0E31  	SWAPF Int1BContext+D'1', W
0A38  008A  	MOVWF PCLATH
0A39  0E30  	SWAPF Int1BContext, W
0A3A  0083  	MOVWF STATUS
0A3B  0EFF  	SWAPF Int1Context, F
0A3C  0E7F  	SWAPF Int1Context, W
0A3D  0009  	RETFIE


/*********************************************************************************************
  void initialise()
  Function called once only to initialise variables and
  setup the PIC registers
*********************************************************************************************/
void initialise() {

    //PIC16F73 doesn't have an internal oscillator
    //pcon.OSCF = 1; // 4MHz internal osc

    // Configure port A
    /*
    RA7     Doesn't exist
    RA6     Doesn't exist
    RA5     
    RA4     
    RA3     
    RA2     
    RA1     OUT FANS
    RA0     OUT HEATER
    */
    trisa = 0x00; // all outputs
087D  1683  	BSF STATUS, RP0
087E  1303  	BCF STATUS, RP1
087F  0185  	CLRF gbl_trisa

    porta = 0x00; // All off
0880  1283  	BCF STATUS, RP0
0881  0185  	CLRF gbl_porta

    
    // Configure port B
    /*      
    RB7     ICSP PGD
    RB6     ICSP PGC
    RB5     
    RB4     
    RB3     OUT TM1638 STB
    RB2     OUT TM1638 CLK
    RB1     IN/OUT TM1638 DIO
    RB0     
    */
    trisb = 0x00; // all outputs by default
0882  1683  	BSF STATUS, RP0
0883  0186  	CLRF gbl_trisb

    portb = 0x0E; // default TM1638 pins high
0884  300E  	MOVLW 0x0E
0885  1283  	BCF STATUS, RP0
0886  0086  	MOVWF gbl_portb


    // Configure port C
    /*      
    RC7     
    RC6     
    RC5     IN/OUT DS18B20
    RC4     IN/OUT DS3231M I2C SDA
    RC3     IN/OUT DS3231M I2C CLK
    RC2     OUT BLUE LIGHT PWM
    RC1     OUT WHITE LIGHT PWM
    RC0     IN SQW DS3231M
    */
    trisc = 0x21; // RC0 and RC5 inputs
0887  3021  	MOVLW 0x21
0888  1683  	BSF STATUS, RP0
0889  0087  	MOVWF gbl_trisc

    portc = 0x38; // default DS18B20 and DS3231 pins high
088A  3038  	MOVLW 0x38
088B  1283  	BCF STATUS, RP0
088C  0087  	MOVWF gbl_portc


    option_reg = 0;
088D  1683  	BSF STATUS, RP0
088E  0181  	CLRF gbl_option_reg

    option_reg.NOT_RBPU = 1; // disable port b pull ups
088F  1781  	BSF gbl_option_reg,7


    // ADC setup
    // PIC16F73 doesn't have comparators, setting cmcon may be needed for some PICs
    //cmcon = 7; // disable all comparators so port a is usable as digital io
    adcon1 = 7; // Set RA0,RA1,RA2,RA5,RA3 all to digital I/O
0890  3007  	MOVLW 0x07
0891  009F  	MOVWF gbl_adcon1



    // Setup timer 0, used for flashing display
    // Timer calculator: http://eng-serve.com/pic/pic_timer.html
    // Timer0 Registers Prescaler= 256 - TMR0 Preset = 61 - Freq = 20.03 Hz - Period = 0.049920 seconds
    //option_reg.T0CS = 0; // bit 5  TMR0 Clock Source Select bit...0 = Internal Clock (CLKO) 1 = Transition on T0CKI pin
    //option_reg.T0SE = 0; // bit 4 TMR0 Source Edge Select bit 0 = low/high 1 = high/low
    //option_reg.PSA = 0; // bit 3  Prescaler Assignment bit...0 = Prescaler is assigned to the Timer0
    option_reg.PS2 = 1; // bits 2-0  PS2:PS0: Prescaler Rate Select bits
0892  1501  	BSF gbl_option_reg,2

    option_reg.PS1 = 1;
0893  1481  	BSF gbl_option_reg,1

    option_reg.PS0 = 1;
0894  1401  	BSF gbl_option_reg,0

    tmr0 = TMR0PRELOAD; // preset for timer register (61)
0895  303D  	MOVLW 0x3D
0896  1283  	BCF STATUS, RP0
0897  0081  	MOVWF gbl_tmr0

    intcon.T0IF = 0; // Clear timer 1 interrupt flag bit
0898  110B  	BCF gbl_intcon,2

    intcon.T0IE = 1; // Timer 1 interrupt enabled
0899  168B  	BSF gbl_intcon,5


    // Setup timer 1, used to update clock display and periodically ask for a temperature reading
    // Timer 1 setup - interrupt on DS3231 SQW 1Hz
    // Timer1 Registers Prescaler= 1 - TMR1 Preset = 65535 - Freq = 1 Hz
    // Bits 5-4 T1CKPS1:T1CKPS0 = 00: Prescaler Rate Select bits, 00 = 1:1 prescaler
    // Bit 3 T1OSCEN = 0: Timer1 LP Oscillator Enable Control bit, 0 = off
    // Bit 2 NOT_T1SYNC = 1: Timer1 External Clock Input Synchronization Control bit, 1 = Do not synchronize external clock input
    // Bit 1 TMR1CS = 1: Timer1 Clock Source Select bit, 1 = External clock from T1OSO/T1CKI pin (on the rising edge)
    // Bit 0 TMR1ON = 0: Timer1 On Bit, 0 = off
    t1con = 0b00000111;
089A  3007  	MOVLW 0x07
089B  0090  	MOVWF gbl_t1con

    tmr1h = TMR1HV;      // preset for timer1 MSB register
089C  30FF  	MOVLW 0xFF
089D  008F  	MOVWF gbl_tmr1h

    tmr1l = TMR1LV;      // preset for timer1 LSB register
089E  008E  	MOVWF gbl_tmr1l

    pie1.TMR1IE = 1;     // Timer 1 interrupt
089F  1683  	BSF STATUS, RP0
08A0  140C  	BSF gbl_pie1,0

    
    // No task at initialisation
    cTask = 0;
08A1  1283  	BCF STATUS, RP0
08A2  01CD  	CLRF gbl_cTask

    
	// I2C Bus initialisation - baud rate divisor not applicable for software implementation
	i2c_init(1);
08A3  3001  	MOVLW 0x01
08A4  00F3  	MOVWF i2c_INIT_00000_arg_i2c_divisor
08A5  118A  	BCF PCLATH,3
08A6  24F5  	CALL i2c_INIT_00000

	
	// Startup delay
	delay_ms(500);
08A7  30F4  	MOVLW 0xF4
08A8  00F3  	MOVWF delay_ms_00000_arg_del
08A9  2081  	CALL delay_ms_00000


    // Read in variables from EEPROM
    at24c32ReadAll();
08AA  2604  	CALL at24c32Rea_00019


    // Check if the DS3231 needs initilising
    char cStatus = ds3231ReadRegister(0x0F); // Read the status register
08AB  300F  	MOVLW 0x0F
08AC  00F3  	MOVWF ds3231Read_0001D_arg_cRegAddress
08AD  2524  	CALL ds3231Read_0001D
08AE  0875  	MOVF CompTempVarRet552, W
08AF  00F2  	MOVWF initialise_00000_1_cStatus

    // If the oscillator (OSF bit in status register) has stopped, then init and write a default date/time
    // This is only expected first time, or backup battery not present/empty in DS3231M module
    if (cStatus.7) {
08B0  158A  	BSF PCLATH,3
08B1  1FF2  	BTFSS initialise_00000_1_cStatus,7
08B2  28B6  	GOTO	label147
08B6        label147

        ds3231Init();
08B3  118A  	BCF PCLATH,3
08B4  2539  	CALL ds3231Init_00000

        ds3231WriteDateTime();
08B5  2508  	CALL ds3231Writ_0001B

    }
    
	tm1638DisplayOn();
08B6  118A  	BCF PCLATH,3
08B7  24C8  	CALL tm1638Disp_0001F

    tm1638UpdateDisplay();
08B8  22A4  	CALL tm1638Upda_00022


    // Enable interrupts
    intcon.GIE = 1;
08B9  178B  	BSF gbl_intcon,7

    intcon.PEIE = 1;
08BA  170B  	BSF gbl_intcon,6

}
08BB  0008  	RETURN


/*********************************************************************************************
  void main()
  Entry method. Loops infinitely with a simple task scheduler.
*********************************************************************************************/
void main() {

    initialise();
08E7  207D  	CALL initialise_00000

    
    // Endless loop
    while(1) {
08E8        label148

        // Task scheduler
        // If there are tasks to be performed, find out the
        // most recent task from the array and execute it
        while (cTask > 0) {
08E8  084D  	MOVF gbl_cTask, W
08E9  3C00  	SUBLW 0x00
08EA  158A  	BSF PCLATH,3
08EB  1803  	BTFSC STATUS,C
08EC  28E8  	GOTO	label148

            if (cTask.TASK_TIMER1) {
08ED  1D4D  	BTFSS gbl_cTask,2
08EE  299E  	GOTO	label168
099E        label168

                if (!gcSetMode) {
08EF  08D0  	MOVF gbl_gcSetMode, F
08F0  1D03  	BTFSS STATUS,Z
08F1  292C  	GOTO	label154

                    // Don't read date/time when in set mode
                    ds3231ReadDateTime();
08F2  20BC  	CALL ds3231Read_0001C

                    if ((gBcdSecond == 0x29) || (gBcdSecond == 0x59)) {
08F3  0835  	MOVF gbl_gBcdSecond, W
08F4  3A29  	XORLW 0x29
08F5  158A  	BSF PCLATH,3
08F6  1903  	BTFSC STATUS,Z
08F7  28FC  	GOTO	label149
08F8  0835  	MOVF gbl_gBcdSecond, W
08F9  3A59  	XORLW 0x59
08FA  1D03  	BTFSS STATUS,Z
08FB  2900  	GOTO	label150
08FC        label149
0900        label150

                        // Ask to convert for temperature reading at 29 seconds or 59 seconds past the minute
                        oneWireBusReset();
08FC  2064  	CALL oneWireBus_00014

                        startTemp();
08FD  27DF  	CALL startTemp_00000

                    } else if ((gBcdSecond == 0) || (gBcdSecond == 0x30)) {
08FE  158A  	BSF PCLATH,3
08FF  290A  	GOTO	label152
0900  08B5  	MOVF gbl_gBcdSecond, F
0901  1903  	BTFSC STATUS,Z
0902  2907  	GOTO	label151
0903  0835  	MOVF gbl_gBcdSecond, W
0904  3A30  	XORLW 0x30
0905  1D03  	BTFSS STATUS,Z
0906  290A  	GOTO	label152
0907        label151
090A        label152
09BD  158A  	BSF PCLATH,3
09BE  28E8  	GOTO	label148

                        // 1 second later, read the converted temperature
                        oneWireBusReset();
0907  2064  	CALL oneWireBus_00014

                        readTemp(); 
0908  27E7  	CALL readTemp_00000

                        // store it in the array, next display refresh will pick it up
                        convertTemp();
0909  2544  	CALL convertTem_00027

                    }
                    // daylight savings time handling (UK/europe) - last sunday of March or October (this can fall between the 25th and the 31st)
                    if ((gBcdSecond == 0) && (gDayOfWeek == 7) && (gBcdDayOfMonth > 0x24)) {
090A  08B5  	MOVF gbl_gBcdSecond, F
090B  158A  	BSF PCLATH,3
090C  1D03  	BTFSS STATUS,Z
090D  292C  	GOTO	label154
090E  0838  	MOVF gbl_gDayOfWeek, W
090F  3A07  	XORLW 0x07
0910  1D03  	BTFSS STATUS,Z
0911  292C  	GOTO	label154
0912  0839  	MOVF gbl_gBcdDayOfMonth, W
0913  3C24  	SUBLW 0x24
0914  1803  	BTFSC STATUS,C
0915  292C  	GOTO	label154

						// In March, at 1AM, apply daylight savings time if appropriate 
						if ((gBcdHour == 1) && (gBcdMonth == 3)) {
0916  0337  	DECF gbl_gBcdHour, W
0917  1D03  	BTFSS STATUS,Z
0918  2920  	GOTO	label153
0919  083A  	MOVF gbl_gBcdMonth, W
091A  3A03  	XORLW 0x03
091B  1D03  	BTFSS STATUS,Z
091C  2920  	GOTO	label153
0920        label153

							gBcdHour++; // one hour forwards
091D  0AB7  	INCF gbl_gBcdHour, F

							ds3231WriteDateTime();
091E  118A  	BCF PCLATH,3
091F  2508  	CALL ds3231Writ_0001B

						}
						// In October, at 2AM, remove daylight savings time if appropriate (UK/europe) daylight savings time if appropriate (UK/europe) - last sunday of October
						if ((gBcdHour == 2) && (gBcdMonth == 0x10)) {
0920  0837  	MOVF gbl_gBcdHour, W
0921  3A02  	XORLW 0x02
0922  158A  	BSF PCLATH,3
0923  1D03  	BTFSS STATUS,Z
0924  292C  	GOTO	label154
0925  083A  	MOVF gbl_gBcdMonth, W
0926  3A10  	XORLW 0x10
0927  1D03  	BTFSS STATUS,Z
0928  292C  	GOTO	label154
092C        label154

							gBcdHour--; // one hour back
0929  03B7  	DECF gbl_gBcdHour, F

							ds3231WriteDateTime();
092A  118A  	BCF PCLATH,3
092B  2508  	CALL ds3231Writ_0001B

						}
					}
                }
                if (!gcTriggerMode) {
092C  08D2  	MOVF gbl_gcTriggerMode, F
092D  158A  	BSF PCLATH,3
092E  1D03  	BTFSS STATUS,Z
092F  2995  	GOTO	label166

					// Don't activate triggers when in trigger set mode
					// Trigger white led
					// Don't activate/deactivate if on and off set hour/min are the same
					if ((gBcdWhiteOnHour != gBcdWhiteOffHour) || (gBcdWhiteOnMinute != gBcdWhiteOffMinute)) {
0930  0856  	MOVF gbl_gBcdWhiteOffHour, W
0931  0654  	XORWF gbl_gBcdWhiteOnHour, W
0932  1D03  	BTFSS STATUS,Z
0933  2938  	GOTO	label155
0934  0855  	MOVF gbl_gBcdWhiteOffMinute, W
0935  0653  	XORWF gbl_gBcdWhiteOnMinute, W
0936  1903  	BTFSC STATUS,Z
0937  2948  	GOTO	label157
0938        label155

						if ((gBcdHour == gBcdWhiteOnHour) && (gBcdMinute == gBcdWhiteOnMinute)) {
0938  0854  	MOVF gbl_gBcdWhiteOnHour, W
0939  0637  	XORWF gbl_gBcdHour, W
093A  1D03  	BTFSS STATUS,Z
093B  2940  	GOTO	label156
093C  0853  	MOVF gbl_gBcdWhiteOnMinute, W
093D  0636  	XORWF gbl_gBcdMinute, W
093E  1903  	BTFSC STATUS,Z

							WHITE_LED = 1;
093F  1487  	BSF gbl_portc,1
0940        label156

						}
						if ((gBcdHour == gBcdWhiteOffHour) && (gBcdMinute == gBcdWhiteOffMinute)) {
0940  0856  	MOVF gbl_gBcdWhiteOffHour, W
0941  0637  	XORWF gbl_gBcdHour, W
0942  1D03  	BTFSS STATUS,Z
0943  2948  	GOTO	label157
0944  0855  	MOVF gbl_gBcdWhiteOffMinute, W
0945  0636  	XORWF gbl_gBcdMinute, W
0946  1903  	BTFSC STATUS,Z

							WHITE_LED = 0;
0947  1087  	BCF gbl_portc,1
0948        label157

						}
					}
					// Trigger blue led
					// Don't activate/deactivate if on and off set hour/min are the same
					if ((gBcdBlueOnHour != gBcdBlueOffHour) || (gBcdBlueOnMinute != gBcdBlueOffMinute)) {
0948  085A  	MOVF gbl_gBcdBlueOffHour, W
0949  0658  	XORWF gbl_gBcdBlueOnHour, W
094A  1D03  	BTFSS STATUS,Z
094B  2950  	GOTO	label158
094C  0859  	MOVF gbl_gBcdBlueOffMinute, W
094D  0657  	XORWF gbl_gBcdBlueOnMinute, W
094E  1903  	BTFSC STATUS,Z
094F  2960  	GOTO	label160
0950        label158

						if ((gBcdHour == gBcdBlueOnHour) && (gBcdMinute == gBcdBlueOnMinute)) {
0950  0858  	MOVF gbl_gBcdBlueOnHour, W
0951  0637  	XORWF gbl_gBcdHour, W
0952  1D03  	BTFSS STATUS,Z
0953  2958  	GOTO	label159
0954  0857  	MOVF gbl_gBcdBlueOnMinute, W
0955  0636  	XORWF gbl_gBcdMinute, W
0956  1903  	BTFSC STATUS,Z

							BLUE_LED = 1;
0957  1507  	BSF gbl_portc,2
0958        label159

						}
						if ((gBcdHour == gBcdBlueOffHour) && (gBcdMinute == gBcdBlueOffMinute)) {
0958  085A  	MOVF gbl_gBcdBlueOffHour, W
0959  0637  	XORWF gbl_gBcdHour, W
095A  1D03  	BTFSS STATUS,Z
095B  2960  	GOTO	label160
095C  0859  	MOVF gbl_gBcdBlueOffMinute, W
095D  0636  	XORWF gbl_gBcdMinute, W
095E  1903  	BTFSC STATUS,Z

							BLUE_LED = 0;
095F  1107  	BCF gbl_portc,2
0960        label160

						}
					}
					// 2nd Trigger blue led
					// Don't activate/deactivate if on and off set hour/min are the same
					if ((gBcdBlue2OnHour != gBcdBlue2OffHour) || (gBcdBlue2OnMinute != gBcdBlue2OffMinute)) {
0960  085E  	MOVF gbl_gBcdBlue2OffHour, W
0961  065C  	XORWF gbl_gBcdBlue2OnHour, W
0962  1D03  	BTFSS STATUS,Z
0963  2968  	GOTO	label161
0964  085D  	MOVF gbl_gBcdBlue2OffMinute, W
0965  065B  	XORWF gbl_gBcdBlue2OnMinute, W
0966  1903  	BTFSC STATUS,Z
0967  2978  	GOTO	label163
0968        label161

						if ((gBcdHour == gBcdBlue2OnHour) && (gBcdMinute == gBcdBlue2OnMinute)) {
0968  085C  	MOVF gbl_gBcdBlue2OnHour, W
0969  0637  	XORWF gbl_gBcdHour, W
096A  1D03  	BTFSS STATUS,Z
096B  2970  	GOTO	label162
096C  085B  	MOVF gbl_gBcdBlue2OnMinute, W
096D  0636  	XORWF gbl_gBcdMinute, W
096E  1903  	BTFSC STATUS,Z

							BLUE_LED = 1;
096F  1507  	BSF gbl_portc,2
0970        label162

						}
						if ((gBcdHour == gBcdBlue2OffHour) && (gBcdMinute == gBcdBlue2OffMinute)) {
0970  085E  	MOVF gbl_gBcdBlue2OffHour, W
0971  0637  	XORWF gbl_gBcdHour, W
0972  1D03  	BTFSS STATUS,Z
0973  2978  	GOTO	label163
0974  085D  	MOVF gbl_gBcdBlue2OffMinute, W
0975  0636  	XORWF gbl_gBcdMinute, W
0976  1903  	BTFSC STATUS,Z

							BLUE_LED = 0;
0977  1107  	BCF gbl_portc,2
0978        label163

						}
					}
					// Trigger fan
					// Don't activate/deactivate if on and off temperature are the same
					if (gBcdFanOnTemp != gBcdFanOffTemp) {
0978  0860  	MOVF gbl_gBcdFanOffTemp, W
0979  065F  	XORWF gbl_gBcdFanOnTemp, W
097A  1903  	BTFSC STATUS,Z
097B  2984  	GOTO	label164

						if (giDS3231ValueTruncCBCD >= gBcdFanOnTemp) {
097C  085F  	MOVF gbl_gBcdFanOnTemp, W
097D  024B  	SUBWF gbl_giDS3231ValueTruncCBCD, W
097E  1803  	BTFSC STATUS,C

							FAN = 1;
097F  1485  	BSF gbl_porta,1

						}
						if (giDS3231ValueTruncCBCD <= gBcdFanOffTemp) {
0980  084B  	MOVF gbl_giDS3231ValueTruncCBCD, W
0981  0260  	SUBWF gbl_gBcdFanOffTemp, W
0982  1803  	BTFSC STATUS,C

							FAN = 0;
0983  1085  	BCF gbl_porta,1
0984        label164

						}
					}
					// Forced on
					if (gbFanOn)
0984  184E  	BTFSC gbl_gbFanOn,0

						FAN = 1;
0985  1485  	BSF gbl_porta,1

					// Trigger heater
					// Don't activate/deactivate if on and off temperature are the same
					if (gBcdHeaterOnTemp != gBcdHeaterOffTemp) {
0986  0862  	MOVF gbl_gBcdHeaterOffTemp, W
0987  0661  	XORWF gbl_gBcdHeaterOnTemp, W
0988  1903  	BTFSC STATUS,Z
0989  2992  	GOTO	label165

						if (giDS3231ValueTruncCBCD <= gBcdHeaterOnTemp) {
098A  084B  	MOVF gbl_giDS3231ValueTruncCBCD, W
098B  0261  	SUBWF gbl_gBcdHeaterOnTemp, W
098C  1803  	BTFSC STATUS,C

							HEATER = 1;
098D  1405  	BSF gbl_porta,0

						}
						if (giDS3231ValueTruncCBCD >= gBcdHeaterOffTemp) {
098E  0862  	MOVF gbl_gBcdHeaterOffTemp, W
098F  024B  	SUBWF gbl_giDS3231ValueTruncCBCD, W
0990  1803  	BTFSC STATUS,C

							HEATER = 0;
0991  1005  	BCF gbl_porta,0
0992        label165

						}
					}
					// If temperature is minus, always trigger heater
					if (gbDS3231IsMinus)
0992  08CC  	MOVF gbl_gbDS3231IsMinus, F
0993  1D03  	BTFSS STATUS,Z

						HEATER = 1;
0994  1405  	BSF gbl_porta,0
0995        label166

				}
				// Display time and temperature or date on TM1638 after clock tick
				if (!gcTriggerMode && !gcSetMode) {
0995  08D2  	MOVF gbl_gcTriggerMode, F
0996  1D03  	BTFSS STATUS,Z
0997  299D  	GOTO	label167
0998  08D0  	MOVF gbl_gcSetMode, F
0999  1D03  	BTFSS STATUS,Z
099A  299D  	GOTO	label167
099D        label167

					tm1638UpdateDisplay();
099B  118A  	BCF PCLATH,3
099C  22A4  	CALL tm1638Upda_00022

                }
                
                cTask.TASK_TIMER1 = 0;
099D  114D  	BCF gbl_cTask,2

            }
            if (cTask.TASK_TIMER0) {
099E  158A  	BSF PCLATH,3
099F  1CCD  	BTFSS gbl_cTask,1
09A0  28E8  	GOTO	label148

				// Task should happen about every 50ms
                // Digit flashing - see if 10 counts has happened for an ~half second count
				if (iTimer0Counts > 9) {
09A1  083E  	MOVF gbl_iTimer0Counts, W
09A2  3C09  	SUBLW 0x09
09A3  1803  	BTFSC STATUS,C
09A4  29AF  	GOTO	label170

					iFlashDigitOff++;
09A5  0ABF  	INCF gbl_iFlashDigitOff, F

					iTimer0Counts = 0;					
09A6  01BE  	CLRF gbl_iTimer0Counts

					// If in set or trigger mode, update the display every ~half second to flash a digit
					if (gcSetMode || gcTriggerMode)
09A7  08D0  	MOVF gbl_gcSetMode, F
09A8  1D03  	BTFSS STATUS,Z
09A9  29AD  	GOTO	label169
09AA  08D2  	MOVF gbl_gcTriggerMode, F
09AB  1903  	BTFSC STATUS,Z
09AC  29AF  	GOTO	label170
09AD        label169

						tm1638UpdateDisplay();
09AD  118A  	BCF PCLATH,3
09AE  22A4  	CALL tm1638Upda_00022

				}
				// Poll keys
				tm1638ReadKeys();
09AF  118A  	BCF PCLATH,3
09B0  27BC  	CALL tm1638Read_00025

				// This isn't handling button holds for now
                if (tm1638Keys != tm1638KeysOld) {
09B1  086C  	MOVF gbl_tm1638KeysOld, W
09B2  066B  	XORWF gbl_tm1638Keys, W
09B3  158A  	BSF PCLATH,3
09B4  1903  	BTFSC STATUS,Z
09B5  29BC  	GOTO	label171
09BC        label171

					processKeys();
09B6  118A  	BCF PCLATH,3
09B7  27F5  	CALL processKey_0002A

					tm1638UpdateDisplay();
09B8  118A  	BCF PCLATH,3
09B9  22A4  	CALL tm1638Upda_00022

					tm1638KeysOld = tm1638Keys;
09BA  086B  	MOVF gbl_tm1638Keys, W
09BB  00EC  	MOVWF gbl_tm1638KeysOld

				}
                cTask.TASK_TIMER0 = 0;
09BC  10CD  	BCF gbl_cTask,1

            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
// I2C Communications Library for I2C MASTER
////////////////////////////////////////////////////////////////////////////
// Author(s): Andrew Smallridge
// Date 15 November 2004
//
// Copyright(C) 2004-2006 Andrew Smallridge
// Copyright(C) 2004-2010 Pavel Baranov
// Copyright(C) 2004-2010 David Hobday
// Existing constants predefined for i2c hardware driver and i2s software
// emulation for the PIC 18F2xx and 18F4xx processors. For hardware support
// on other PICs the constants must be mapped to the corresponding register
// map of the target device
////////////////////////////////////////////////////////////////////////////

/*
////////////////////////////////////////////////////////////////////////////
//	The following three sections should be copied to the user's program:
//		i2c master hardware / software mode definition
//		i2c software implementation template arguments and variables
// 		i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////
// i2c master hardware / software mode definition
//
// For i2c hardware support comment out the #define use_ic2_SW line
////////////////////////////////////////////////////////////////////////////
//#define use_i2c_SW

#if defined use_i2c_SW
////////////////////////////////////////////////////////////////////////////
// i2c software implementation template arguments and variables
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)

// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and software emalated i2c RAM locations. These constants are
// then used by the templated functions. When changing the address of an emulated
// register the corresponding constant mapping must also be changed.
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3					

#else
////////////////////////////////////////////////////////////////////////////
// i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP |i2c_HW)

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and PIC's i2c register locations. These constants are
// then used by the templated functions. 
#define PORTC		0x0f82
#define TRISC		0x0f94
#define e_SSPCON1	0xfc6
#define e_SSPCON2	0xfc5
#define e_SSPSTAT	0xfc7
#define e_SSPADD	0xfc8
#define e_SSPBUF	0xfc9
#define e_SSPIF_PIR	0xf9e
#define e_BCLIF_PIR	0xfa1
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3

#endif

*/


////////////////////////////////////////////////////////////////////////////
// Define the common i2c template structure
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL	template <unsigned char T_SCL_BIT, unsigned short T_SCL_PORT,	\
					unsigned short T_SCL_TRIS, unsigned char T_SDA_BIT, 			\
					unsigned short T_SDA_PORT, unsigned short T_SDA_TRIS,			\
					unsigned short T_i2c_SSPCON1, unsigned short T_i2c_SSPCON2, 	\
					unsigned short T_i2c_SSPSTAT, unsigned short T_i2c_SSPBUF, 		\
					unsigned char T_i2c_SSPIF_BIT, unsigned short T_i2c_SSPIF_PIR,	\
					unsigned char T_i2c_BCLIF_BIT, unsigned short T_i2c_BCLIF_PIR,	\
					unsigned char T_i2c_SMP_BIT, unsigned short T_i2c_SSPADD, 		\
					unsigned char T_MODE>

////////////////////////////////////////////////////////////////////////////
// Define the common i2c template parameters
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL_ARGS	T_SCL_BIT, T_SCL_PORT, T_SCL_TRIS, T_SDA_BIT, 			\
						T_SDA_PORT, T_SDA_TRIS, T_i2c_SSPCON1, T_i2c_SSPCON2, 	\
						T_i2c_SSPSTAT, T_i2c_SSPBUF, T_i2c_SSPIF_BIT, 			\
						T_i2c_SSPIF_PIR, T_i2c_BCLIF_BIT, T_i2c_BCLIF_PIR,		\
						T_i2c_SMP_BIT, T_i2c_SSPADD, T_MODE

////////////////////////////////////////////////////////////////////////////
// Helpers that hide template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_init	i2c_INIT<i2c_ARGS>
#define i2c_start	i2c_START<i2c_ARGS>
#define i2c_restart	i2c_RESTART<i2c_ARGS>
#define i2c_stop	i2c_STOP<i2c_ARGS>
#define i2c_read	i2c_READ<i2c_ARGS>
#define i2c_write	i2c_WRITE<i2c_ARGS>


////////////////////////////////////////////////////////////////////////////
// I2C Control Status Bits - Emulates the PIC18F hardware I2C implementation
////////////////////////////////////////////////////////////////////////////
// define I2C i2C_SSPCON1 control bits
#define	i2c_WCOL	7
#define	i2c_SSPOV	6
#define	i2c_SSPEN	5
#define	i2c_CKP		4
#define	i2c_SSPM3	3
#define	i2c_SSPM2	2
#define	i2c_SSPM1	1
#define	i2c_SSPM0	0

// define I2C SSPCON2 control bits
#define	i2c_GCEN 	7
#define	i2c_ACKSTAT	6
#define	i2c_ACKDT	5
#define	i2c_ACKEN	4
#define	i2c_RCEN	3
#define	i2c_PEN		2
#define	i2c_RSEN	1
#define	i2c_SEN		0

// define I2C SSPSTAT status bits
#define	i2c_DA		5
#define	i2c_P		4
#define	i2c_S		3
#define	i2c_RW		2
#define	i2c_UA		1
#define	i2c_BF		0


////////////////////////////////////////////////////////////////////////////
// I2C Control Flag Bits
////////////////////////////////////////////////////////////////////////////
// define I2C Mode bits
#define	i2c_HW			0x01
#define	i2c_400KHz		0x02	// 100KHz or 400KHz I2C clock (set = 400KHz)
#define	i2c_reset_wdt	0x04
#define i2c_SMP			0x80	


////////////////////////////////////////////////////////////////////////////
// I2C software constants
////////////////////////////////////////////////////////////////////////////
#define	dly 10	// number of 1us delay increments



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Start Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL 
void i2c_START(void)

{
	// Initiate the I2C START condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	delay_us(dly);
0126  300A  	MOVLW 0x0A
0127  1283  	BCF STATUS, RP0
0128  1303  	BCF STATUS, RP1
0129  00F8  	MOVWF delay_us_00000_arg_del
012A  2010  	CALL delay_us_00000

	l_bclif = 0; // initialise the collision flag for this command
012B  11C6  	BCF i2c_START_00000_1_l_bclif,3

	l_sspif = 0;
012C  11C5  	BCF i2c_START_00000_1_l_sspif,3

		
	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
			
		l_sen = 1; // initiate START condition	

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation			
		l_sen = 1; // initiate START condition
012D  1441  	BSF i2c_START_00000_1_l_sen,0

		l_scl_tris = 1; // ensure the SCL line is high
012E  1683  	BSF STATUS, RP0
012F  1587  	BSF i2c_START_00000_1_l_scl_tris,3

		l_sda_tris = 1; // ensure the SDA line is high	
0130  1607  	BSF i2c_START_00000_1_l_sda_tris,4

		l_scl = 0; // prepare to set SCL line low
0131  1283  	BCF STATUS, RP0
0132  1187  	BCF i2c_START_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low
0133  1207  	BCF i2c_START_00000_1_l_sda,4

		
		if (l_scl && l_sda)
0134  1D87  	BTFSS i2c_START_00000_1_l_scl,3
0135  2953  	GOTO	label24
0136  1E07  	BTFSS i2c_START_00000_1_l_sda,4
0137  2953  	GOTO	label24
0153        label24

		{
			// good sign - no collision detected
			delay_us(dly);
0138  300A  	MOVLW 0x0A
0139  00F8  	MOVWF delay_us_00000_arg_del
013A  2010  	CALL delay_us_00000

			
			if (!l_scl) // ensure the clock is still high
013B  1987  	BTFSC i2c_START_00000_1_l_scl,3
013C  2941  	GOTO	label23
0141        label23

			{
				l_bclif = 1;
013D  15C6  	BSF i2c_START_00000_1_l_bclif,3

				l_s = 1;
013E  15C2  	BSF i2c_START_00000_1_l_s,3

				l_sen = 0;
013F  1041  	BCF i2c_START_00000_1_l_sen,0

				return;
			}
					
			l_sda = 0; // prepare to set SDA line low
0141  1207  	BCF i2c_START_00000_1_l_sda,4

			l_sda_tris = 0; // SDA to output (driven low)
0142  1683  	BSF STATUS, RP0
0143  1207  	BCF i2c_START_00000_1_l_sda_tris,4


			delay_us(dly);					
0144  300A  	MOVLW 0x0A
0145  1283  	BCF STATUS, RP0
0146  00F8  	MOVWF delay_us_00000_arg_del
0147  2010  	CALL delay_us_00000

			l_scl = 0; // prepare to set SCL line low
0148  1187  	BCF i2c_START_00000_1_l_scl,3

			l_scl_tris = 0; // SCL to output (driven low)
0149  1683  	BSF STATUS, RP0
014A  1187  	BCF i2c_START_00000_1_l_scl_tris,3


			delay_us(dly);					
014B  300A  	MOVLW 0x0A
014C  1283  	BCF STATUS, RP0
014D  00F8  	MOVWF delay_us_00000_arg_del
014E  2010  	CALL delay_us_00000

			l_s = 1; // set 'S' bit flag (start bit detected)
014F  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0; // clear flag
0150  1041  	BCF i2c_START_00000_1_l_sen,0

			l_sspif = 1; // flag end of start condition interrupt	
0151  15C5  	BSF i2c_START_00000_1_l_sspif,3

		}
		else
		{
			// here is SDA or SCL are low at the start - indicates a bus collision
			l_bclif = 1;
0153  15C6  	BSF i2c_START_00000_1_l_bclif,3

			l_s = 1; // set 'S' bit flag (start bit detected)
0154  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0;
0155  1041  	BCF i2c_START_00000_1_l_sen,0

			l_rsen = 0;
0156  10C1  	BCF i2c_START_00000_1_l_rsen,1

			l_pen = 0;
0157  1141  	BCF i2c_START_00000_1_l_pen,2

			l_rcen = 0;								
0158  11C1  	BCF i2c_START_00000_1_l_rcen,3

			l_acken = 0;			
0159  1241  	BCF i2c_START_00000_1_l_acken,4

		}
	}
}
0140  0008  	RETURN
0152  0008  	RETURN
015A  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Restart Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_RESTART(void)
{
	// Initiate the I2C RESTART condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
			
	delay_us(dly);
	l_bclif = 0; // initialise the collision flag for this command
	l_sspif = 0;

	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_rsen = 1; // initiate RESTART condition
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation	
		l_rsen = 1;
		l_scl = 0;
		l_sda = 0;
		
		if (!l_scl)
		{
			// good sign - no other I2C activity in progress
			l_sda_tris = 1; // float SDA line high	(should already be in this condition)	
			delay_us(dly);
		
			// about to float the clock line
			// ensure the data line is still high
			if (!l_sda)
			{
				// problem - SDA is low, a bus collision has occurred				
				l_bclif = 1; // set the bus collision flag	
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_scl_tris = 1; // float SCL line (high)	
				return;
			}
												
			l_scl_tris = 1; // float SCL line (high)

			// wait until any clock stretching has finished
			while (!l_scl)
				if (T_MODE & i2c_reset_wdt)
					clear_wdt();	
			delay_us(dly);
			
			// here we are about to drive SDA low
			// first ensure SCL is still high
			if (!l_scl)
			{
				// problem - SCL is low, a bus collision has occurred
				l_bclif = 1; // set the bus collision flag
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_sda_tris = 1; // float SDA line (high)
				return;
			}
				
			l_sda_tris = 0; // drive SDA low
			l_s = 1; // set 'S' bit flag (start bit detected)

			delay_us(dly);
			l_scl_tris = 0; // drive SCL low
			l_rsen = 0;
			l_pen = 0;
			l_sen = 0;			
			l_rcen = 0;								
			l_acken = 0;			
			l_sspif = 1; // flag end of start condition interrupt
		}
		else
		{
			// SCL is high at the start
			// some other I2C activity in progress		
			l_rsen = 0; // clear flag
			// exit without further action
		}
	}
}



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Stop Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_STOP(void)

{ 
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_p@T_i2c_SSPSTAT.i2c_P; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;

	l_bclif = 0; // initialise the collision flag for this command
00F6  1283  	BCF STATUS, RP0
00F7  1303  	BCF STATUS, RP1
00F8  11C6  	BCF i2c_STOP_00000_1_l_bclif,3

	l_sspif = 0;
00F9  11C5  	BCF i2c_STOP_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_pen = 1; // initiate STOP condition on the I2C bus	
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
		
	}
	else
	{
		//	Software I2C implementation
		l_pen = 1; // initiate STOP condition on the I2C bus
00FA  1541  	BSF i2c_STOP_00000_1_l_pen,2

		delay_us(dly);
00FB  300A  	MOVLW 0x0A
00FC  00F8  	MOVWF delay_us_00000_arg_del
00FD  2010  	CALL delay_us_00000

		
		l_scl = 0; // prepare to set SCL line low
00FE  1187  	BCF i2c_STOP_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low
00FF  1207  	BCF i2c_STOP_00000_1_l_sda,4

		l_scl_tris = 0; // drive SCL line low (should already be low)
0100  1683  	BSF STATUS, RP0
0101  1187  	BCF i2c_STOP_00000_1_l_scl_tris,3

		l_sda_tris = 0; // drive SDA line low
0102  1207  	BCF i2c_STOP_00000_1_l_sda_tris,4


		delay_us(dly);		
0103  300A  	MOVLW 0x0A
0104  1283  	BCF STATUS, RP0
0105  00F8  	MOVWF delay_us_00000_arg_del
0106  2010  	CALL delay_us_00000

		l_scl_tris = 1; // float SCL line (high)
0107  1683  	BSF STATUS, RP0
0108  1587  	BSF i2c_STOP_00000_1_l_scl_tris,3

		
		// wait until any clock stretching has finished
		while (!l_scl)
0109        label19
0109  1283  	BCF STATUS, RP0
010A  1987  	BTFSC i2c_STOP_00000_1_l_scl,3
010B  290E  	GOTO	label20
010D  2909  	GOTO	label19
010E        label20

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
010C  0064  	CLRWDT

						
		delay_us(dly);
010E  300A  	MOVLW 0x0A
010F  00F8  	MOVWF delay_us_00000_arg_del
0110  2010  	CALL delay_us_00000

		l_sda_tris = 1; // float SDA line
0111  1683  	BSF STATUS, RP0
0112  1607  	BSF i2c_STOP_00000_1_l_sda_tris,4

		delay_us(dly);		
0113  300A  	MOVLW 0x0A
0114  1283  	BCF STATUS, RP0
0115  00F8  	MOVWF delay_us_00000_arg_del
0116  2010  	CALL delay_us_00000

		
		// here the SDA line should be high - if not a collision has occurred				
		if (!l_sda || !l_scl)
0117  1E07  	BTFSS i2c_STOP_00000_1_l_sda,4
0118  291B  	GOTO	label21
0119  1987  	BTFSC i2c_STOP_00000_1_l_scl,3
011A  291F  	GOTO	label22
011B        label21
011F        label22

		{
			// problem - SDA or SCL is low, a bus collision has occurred
			l_bclif = 1; // set the bus collision flag	
011B  15C6  	BSF i2c_STOP_00000_1_l_bclif,3

			l_s = 0; // clear 'S' bit flag
011C  11C2  	BCF i2c_STOP_00000_1_l_s,3

			l_pen = 0; // clear flag
011D  1141  	BCF i2c_STOP_00000_1_l_pen,2

		}
		else
		{		
			l_p = 1;
011F  1642  	BSF i2c_STOP_00000_1_l_p,4

			l_pen = 0;
0120  1141  	BCF i2c_STOP_00000_1_l_pen,2

			l_sen = 0;
0121  1041  	BCF i2c_STOP_00000_1_l_sen,0

			l_rsen = 0;			
0122  10C1  	BCF i2c_STOP_00000_1_l_rsen,1

			l_rcen = 0;								
0123  11C1  	BCF i2c_STOP_00000_1_l_rcen,3

			l_acken = 0;
0124  1241  	BCF i2c_STOP_00000_1_l_acken,4

		}
	}
}
011E  0008  	RETURN
0125  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Write Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_WRITE(unsigned char i2c_data)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;	
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
	
	char BitMask;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
00A5  11C6  	BCF i2c_WRITE_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
00A6  11C5  	BCF i2c_WRITE_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
				
		l_wcol = 0; // clear write collision flag	
		i2c_SSPBUF = i2c_data;

		// test if a write collision occurred
		if (l_wcol)
			return (1); // error exit	

		// wait until MSSP Tx register is empty
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
								
		return (0); // successful exit
	}

	// here for i2c software driver
	l_wcol = 0; // clear write collision flag	
00A7  13C0  	BCF i2c_WRITE_00000_1_l_wcol,7

	i2c_SSPBUF = i2c_data;
00A8  0875  	MOVF i2c_WRITE_00000_arg_i2c_data, W
00A9  00C4  	MOVWF i2c_WRITE_00000_1_i2c_SSPBUF

	
	l_scl = 0; // prepare to set SCL line low
00AA  1187  	BCF i2c_WRITE_00000_1_l_scl,3

	l_sda = 0; // prepare to set SDA line low
00AB  1207  	BCF i2c_WRITE_00000_1_l_sda,4

	l_rw = 0; // signal we are doing a write
00AC  1142  	BCF i2c_WRITE_00000_1_l_rw,2


	for (BitMask = 0x80; BitMask; BitMask>>=1)
00AD  3080  	MOVLW 0x80
00AE  00F6  	MOVWF i2c_WRITE_00000_1_BitMask
00AF        label11
00AF  08F6  	MOVF i2c_WRITE_00000_1_BitMask, F
00B0  1903  	BTFSC STATUS,Z
00B1  28D2  	GOTO	label16
00CF  1003  	BCF STATUS,C
00D0  0CF6  	RRF i2c_WRITE_00000_1_BitMask, F
00D1  28AF  	GOTO	label11
00D2        label16

	{
		if (i2c_data & BitMask)
00B2  0876  	MOVF i2c_WRITE_00000_1_BitMask, W
00B3  0575  	ANDWF i2c_WRITE_00000_arg_i2c_data, W
00B4  1903  	BTFSC STATUS,Z
00B5  28B9  	GOTO	label12
00B9        label12

			l_sda_tris = 1; // float SDA high	
00B6  1683  	BSF STATUS, RP0
00B7  1607  	BSF i2c_WRITE_00000_1_l_sda_tris,4

		else
00B8  28BB  	GOTO	label13
00BB        label13

			l_sda_tris = 0; // drive SDA low
00B9  1683  	BSF STATUS, RP0
00BA  1207  	BCF i2c_WRITE_00000_1_l_sda_tris,4

		delay_us(dly);
00BB  300A  	MOVLW 0x0A
00BC  1283  	BCF STATUS, RP0
00BD  00F8  	MOVWF delay_us_00000_arg_del
00BE  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
00BF  1683  	BSF STATUS, RP0
00C0  1587  	BSF i2c_WRITE_00000_1_l_scl_tris,3


		// wait until any clock stretching has finished
		while (!l_scl)
00C1        label14
00C1  1283  	BCF STATUS, RP0
00C2  1987  	BTFSC i2c_WRITE_00000_1_l_scl,3
00C3  28C6  	GOTO	label15
00C5  28C1  	GOTO	label14
00C6        label15

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
00C4  0064  	CLRWDT

		delay_us(dly);
00C6  300A  	MOVLW 0x0A
00C7  00F8  	MOVWF delay_us_00000_arg_del
00C8  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low	
00C9  1683  	BSF STATUS, RP0
00CA  1187  	BCF i2c_WRITE_00000_1_l_scl_tris,3

		delay_us(dly);
00CB  300A  	MOVLW 0x0A
00CC  1283  	BCF STATUS, RP0
00CD  00F8  	MOVWF delay_us_00000_arg_del
00CE  2010  	CALL delay_us_00000

	}
	// serialized out the data
	// now get the status		
	// set SSPIF
	l_sspif = 1;
00D2  15C5  	BSF i2c_WRITE_00000_1_l_sspif,3

	l_acken = 1;
00D3  1641  	BSF i2c_WRITE_00000_1_l_acken,4

	l_ackdt = 0;
00D4  12C1  	BCF i2c_WRITE_00000_1_l_ackdt,5

	l_sda_tris = 1; // float SDA high
00D5  1683  	BSF STATUS, RP0
00D6  1607  	BSF i2c_WRITE_00000_1_l_sda_tris,4

	
	delay_us(dly);
00D7  300A  	MOVLW 0x0A
00D8  1283  	BCF STATUS, RP0
00D9  00F8  	MOVWF delay_us_00000_arg_del
00DA  2010  	CALL delay_us_00000

	
	l_scl_tris = 1; // float SCL high
00DB  1683  	BSF STATUS, RP0
00DC  1587  	BSF i2c_WRITE_00000_1_l_scl_tris,3

	
	// wait until any clock stretching has finished
	while (!l_scl)
00DD        label17
00DD  1283  	BCF STATUS, RP0
00DE  1987  	BTFSC i2c_WRITE_00000_1_l_scl,3
00DF  28E2  	GOTO	label18
00E1  28DD  	GOTO	label17
00E2        label18

		if (T_MODE & i2c_reset_wdt)
			clear_wdt();	
00E0  0064  	CLRWDT

	delay_us(dly);
00E2  300A  	MOVLW 0x0A
00E3  00F8  	MOVWF delay_us_00000_arg_del
00E4  2010  	CALL delay_us_00000


	// get the status bit
	local_ack = l_sda;
00E5  1077  	BCF i2c_WRITE_00000_1_local_ack,0
00E6  1A07  	BTFSC i2c_WRITE_00000_1_l_sda,4
00E7  1477  	BSF i2c_WRITE_00000_1_local_ack,0

	delay_us(dly);
00E8  300A  	MOVLW 0x0A
00E9  00F8  	MOVWF delay_us_00000_arg_del
00EA  2010  	CALL delay_us_00000


	l_scl_tris = 0; // drive SCL low	
00EB  1683  	BSF STATUS, RP0
00EC  1187  	BCF i2c_WRITE_00000_1_l_scl_tris,3

	l_acken = 0;
00ED  1283  	BCF STATUS, RP0
00EE  1241  	BCF i2c_WRITE_00000_1_l_acken,4

	delay_us(dly);
00EF  300A  	MOVLW 0x0A
00F0  00F8  	MOVWF delay_us_00000_arg_del
00F1  2010  	CALL delay_us_00000

	return(local_ack);
00F2  01F8  	CLRF CompTempVarRet550
00F3  1877  	BTFSC i2c_WRITE_00000_1_local_ack,0
00F4  0AF8  	INCF CompTempVarRet550, F

}
00F5  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Read Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_READ(char ack_status)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	char BitMask;
	char i2c_data;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
01DE  11C6  	BCF i2c_READ_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
01DF  11C5  	BCF i2c_READ_00000_1_l_sspif,3

	l_wcol = 0; // clear write collision flag	
01E0  13C0  	BCF i2c_READ_00000_1_l_wcol,7


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// enable master for 1 byte reception	
		l_rcen = 1;

		// wait until byte received
		while(!l_sspif || !l_bf)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// read the byte from the Rx register
		i2c_data = i2c_SSPBUF;			
			
		// wait until the bus is idle		
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		if (ack_status)
			l_ackdt = 1; // preset ack bit
		else
			l_ackdt = 0; // preset ack bit

		l_sspif = 0;
		l_acken = 1; // acknowledge sequence enable

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();								
	}
	else
	{
		// here for i2c software driver
		l_rcen = 1;
01E1  15C1  	BSF i2c_READ_00000_1_l_rcen,3

		l_ackdt = ack_status;
01E2  1875  	BTFSC i2c_READ_00000_arg_ack_status,0
01E3  16C1  	BSF i2c_READ_00000_1_l_ackdt,5
01E4  1C75  	BTFSS i2c_READ_00000_arg_ack_status,0
01E5  12C1  	BCF i2c_READ_00000_1_l_ackdt,5

		l_rw = 1;
01E6  1542  	BSF i2c_READ_00000_1_l_rw,2

		l_scl = 0; // prepare to set SCL line low
01E7  1187  	BCF i2c_READ_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low	
01E8  1207  	BCF i2c_READ_00000_1_l_sda,4


		// prepare to serialize in the byte
		l_sda_tris = 1; // float SDA
01E9  1683  	BSF STATUS, RP0
01EA  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

		delay_us(dly);
01EB  300A  	MOVLW 0x0A
01EC  1283  	BCF STATUS, RP0
01ED  00F8  	MOVWF delay_us_00000_arg_del
01EE  2010  	CALL delay_us_00000

		i2c_data = 0;
01EF  01F7  	CLRF i2c_READ_00000_1_i2c_data

		for (BitMask = 0x80; BitMask; BitMask>>=1)
01F0  3080  	MOVLW 0x80
01F1  00F6  	MOVWF i2c_READ_00000_1_BitMask
01F2        label35
01F2  08F6  	MOVF i2c_READ_00000_1_BitMask, F
01F3  1903  	BTFSC STATUS,Z
01F4  2A0F  	GOTO	label39
020C  1003  	BCF STATUS,C
020D  0CF6  	RRF i2c_READ_00000_1_BitMask, F
020E  29F2  	GOTO	label35
020F        label39

		{
			l_scl_tris = 1; // float SCL high
01F5  1683  	BSF STATUS, RP0
01F6  1587  	BSF i2c_READ_00000_1_l_scl_tris,3

			// wait until any clock stretching has finished
			while (!l_scl)
01F7        label36
01F7  1283  	BCF STATUS, RP0
01F8  1987  	BTFSC i2c_READ_00000_1_l_scl,3
01F9  29FC  	GOTO	label37
01FB  29F7  	GOTO	label36
01FC        label37

				if (T_MODE & i2c_reset_wdt)
					clear_wdt();		
01FA  0064  	CLRWDT

			delay_us(dly);
01FC  300A  	MOVLW 0x0A
01FD  00F8  	MOVWF delay_us_00000_arg_del
01FE  2010  	CALL delay_us_00000


			// read the current bit
			l_sda_tris = 1; // float SDA
01FF  1683  	BSF STATUS, RP0
0200  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

			if (l_sda)
0201  1283  	BCF STATUS, RP0
0202  1E07  	BTFSS i2c_READ_00000_1_l_sda,4
0203  2A06  	GOTO	label38
0206        label38

				i2c_data |= BitMask;
0204  0876  	MOVF i2c_READ_00000_1_BitMask, W
0205  04F7  	IORWF i2c_READ_00000_1_i2c_data, F

			l_scl_tris = 0; // drive SCL low
0206  1683  	BSF STATUS, RP0
0207  1187  	BCF i2c_READ_00000_1_l_scl_tris,3

			delay_us(dly);
0208  300A  	MOVLW 0x0A
0209  1283  	BCF STATUS, RP0
020A  00F8  	MOVWF delay_us_00000_arg_del
020B  2010  	CALL delay_us_00000

		}
		// flag receive complete			
		l_sspif = 1;
020F  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		l_rcen = 0;
0210  11C1  	BCF i2c_READ_00000_1_l_rcen,3

		
		// set the ACK state
		if (ack_status)	
0211  08F5  	MOVF i2c_READ_00000_arg_ack_status, F
0212  1903  	BTFSC STATUS,Z
0213  2A17  	GOTO	label40
0217        label40

			l_sda_tris = 1; // float SDA high
0214  1683  	BSF STATUS, RP0
0215  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

		else
0216  2A19  	GOTO	label41
0219        label41

			l_sda_tris = 0; // drive SDA low
0217  1683  	BSF STATUS, RP0
0218  1207  	BCF i2c_READ_00000_1_l_sda_tris,4

		delay_us(dly);
0219  300A  	MOVLW 0x0A
021A  1283  	BCF STATUS, RP0
021B  00F8  	MOVWF delay_us_00000_arg_del
021C  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
021D  1683  	BSF STATUS, RP0
021E  1587  	BSF i2c_READ_00000_1_l_scl_tris,3


		// wait until any clock stretching has finished
		while (!l_scl)
021F        label42
021F  1283  	BCF STATUS, RP0
0220  1987  	BTFSC i2c_READ_00000_1_l_scl,3
0221  2A24  	GOTO	label43
0223  2A1F  	GOTO	label42
0224        label43

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
0222  0064  	CLRWDT

	
		l_sspif = 0; // clear SSPIF
0224  11C5  	BCF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
0225  300A  	MOVLW 0x0A
0226  00F8  	MOVWF delay_us_00000_arg_del
0227  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low		
0228  1683  	BSF STATUS, RP0
0229  1187  	BCF i2c_READ_00000_1_l_scl_tris,3

		l_sspif = 1;
022A  1283  	BCF STATUS, RP0
022B  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
022C  300A  	MOVLW 0x0A
022D  00F8  	MOVWF delay_us_00000_arg_del
022E  2010  	CALL delay_us_00000

	}
	return(i2c_data);
022F  0877  	MOVF i2c_READ_00000_1_i2c_data, W
0230  00F8  	MOVWF CompTempVarRet551

}
0231  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Initialization
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_INIT(unsigned char i2c_divisor)

{
	volatile unsigned char i2c_SSPADD@T_i2c_SSPADD, i2c_SSPSTAT@T_i2c_SSPSTAT;
	volatile unsigned char i2c_SSPCON1@T_i2c_SSPCON1,i2c_SSPCON2@T_i2c_SSPCON2;

	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_sspen@T_i2c_SSPCON1.i2c_SSPEN, l_smp@T_i2c_SSPSTAT.T_i2c_SMP_BIT;

	l_sda_tris = 1;
04F5  1683  	BSF STATUS, RP0
04F6  1607  	BSF i2c_INIT_00000_1_l_sda_tris,4

	l_scl_tris = 1;
04F7  1587  	BSF i2c_INIT_00000_1_l_scl_tris,3

	
	i2c_SSPCON1 = 0x00; // initialise the I2C control register (mirrors HW SSPCON1)	
04F8  1283  	BCF STATUS, RP0
04F9  01C0  	CLRF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPADD = i2c_divisor; // get the I2C baud rate divisor
04FA  0873  	MOVF i2c_INIT_00000_arg_i2c_divisor, W
04FB  00C3  	MOVWF i2c_INIT_00000_1_i2c_SSPADD

	i2c_SSPCON1 = 0x08; // initialise the I2C control register (mirrors HW SSPCON1)	
04FC  3008  	MOVLW 0x08
04FD  00C0  	MOVWF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPCON2 = 0x00; // initialise the I2C control register (mirrors HW SSPCON2)	
04FE  01C1  	CLRF i2c_INIT_00000_1_i2c_SSPCON2

	
	i2c_SSPSTAT = 0x00; // initialise the I2C status register (mirrors HW SSPSTAT)
04FF  01C2  	CLRF i2c_INIT_00000_1_i2c_SSPSTAT

	
	if (T_MODE & i2c_SMP)
		l_smp = 1;
0500  17C2  	BSF i2c_INIT_00000_1_l_smp,7


	l_sspif = 0; // initialise the I2C SSP interrupt status
0501  11C5  	BCF i2c_INIT_00000_1_l_sspif,3

	l_bclif = 0; // initialise the I2C BCL interrupt status
0502  11C6  	BCF i2c_INIT_00000_1_l_bclif,3

	l_sda = 0;
0503  1207  	BCF i2c_INIT_00000_1_l_sda,4

	l_scl = 0;
0504  1187  	BCF i2c_INIT_00000_1_l_scl,3

	l_sspen = 1; // enable I2C
0505  16C0  	BSF i2c_INIT_00000_1_l_sspen,5

	
	i2c_STOP<_I2C_TEMPL_ARGS>();
0506  20F6  	CALL i2c_STOP_00000

}
0507  0008  	RETURN







////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  158A  	BSF PCLATH,3
0001  29BF  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B0  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00B1  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00B2  	MOVWF Int1BContext+D'2'
000D  158A  	BSF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2A23  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010  3003  	MOVLW 0x03
0011  07F8  	ADDWF delay_us_00000_arg_del, F
0012  0CF8  	RRF delay_us_00000_arg_del, F
0013  0CF8  	RRF delay_us_00000_arg_del, F
0014  307F  	MOVLW 0x7F
0015  05F8  	ANDWF delay_us_00000_arg_del, F
0016        label1
0016  0000  	NOP
0017  0BF8  	DECFSZ delay_us_00000_arg_del, F
0018  2816  	GOTO	label1
0019  0008  	RETURN
001A        ; } delay_us function end

001A        __rom_get_00000
001A        ; { __rom_get ; function begin
001A  087B  	MOVF __rom_get_00000_arg_objNumb, W
001B  00FE  	MOVWF __rom_get_00000_1_romAddr+D'1'
001C  01FD  	CLRF __rom_get_00000_1_romAddr
001D  1003  	BCF STATUS,C
001E  0DFE  	RLF __rom_get_00000_1_romAddr+D'1', F
001F  0DFD  	RLF __rom_get_00000_1_romAddr, F
0020  0DFE  	RLF __rom_get_00000_1_romAddr+D'1', F
0021  0DFD  	RLF __rom_get_00000_1_romAddr, F
0022  07FE  	ADDWF __rom_get_00000_1_romAddr+D'1', F
0023  1803  	BTFSC STATUS,C
0024  0AFD  	INCF __rom_get_00000_1_romAddr, F
0025  07FE  	ADDWF __rom_get_00000_1_romAddr+D'1', F
0026  1803  	BTFSC STATUS,C
0027  0AFD  	INCF __rom_get_00000_1_romAddr, F
0028  3033  	MOVLW	LOW( label2 )
0029  07FE  	ADDWF __rom_get_00000_1_romAddr+D'1', F
002A  1803  	BTFSC STATUS,C
002B  0AFD  	INCF __rom_get_00000_1_romAddr, F
002C  3000  	MOVLW	HIGH( label2 )
002D  077D  	ADDWF __rom_get_00000_1_romAddr, W
002E  008A  	MOVWF PCLATH
002F  087C  	MOVF __rom_get_00000_arg_idx, W
0030  00FD  	MOVWF __rom_get_00000_1_romAddr
0031  087E  	MOVF __rom_get_00000_1_romAddr+D'1', W
0032  0082  	MOVWF PCL
0033        label2
0033  3000  	MOVLW	HIGH( label3 )
0034  008A  	MOVWF PCLATH
0035  3000  	MOVLW	HIGH( label4 )
0036  00FE  	MOVWF __rom_get_00000_1_romAddr+D'1'
0037  3049  	MOVLW	LOW( label4 )
0038  2842  	GOTO	label3
0039  3000  	MOVLW	HIGH( label3 )
003A  008A  	MOVWF PCLATH
003B  3000  	MOVLW	HIGH( label5 )
003C  00FE  	MOVWF __rom_get_00000_1_romAddr+D'1'
003D  3055  	MOVLW	LOW( label5 )
003E  2842  	GOTO	label3
003F  3000  	MOVLW	HIGH( label6 )
0040  00FE  	MOVWF __rom_get_00000_1_romAddr+D'1'
0041  306D  	MOVLW	LOW( label6 )
0042        label3
0042  07FD  	ADDWF __rom_get_00000_1_romAddr, F
0043  1803  	BTFSC STATUS,C
0044  0AFE  	INCF __rom_get_00000_1_romAddr+D'1', F
0045  087E  	MOVF __rom_get_00000_1_romAddr+D'1', W
0046  008A  	MOVWF PCLATH
0047  087D  	MOVF __rom_get_00000_1_romAddr, W
0048  0082  	MOVWF PCL
0049        label4
0049  3431  	RETLW 0x31
004A  3428  	RETLW 0x28
004B  3431  	RETLW 0x31
004C  3430  	RETLW 0x30
004D  3431  	RETLW 0x31
004E  3430  	RETLW 0x30
004F  3431  	RETLW 0x31
0050  3431  	RETLW 0x31
0051  3430  	RETLW 0x30
0052  3431  	RETLW 0x31
0053  3430  	RETLW 0x30
0054  3431  	RETLW 0x31
0055        label5
0055  3404  	RETLW 0x04
0056  3408  	RETLW 0x08
0057  3412  	RETLW 0x12
0058  3416  	RETLW 0x16
0059  3420  	RETLW 0x20
005A  3424  	RETLW 0x24
005B  3428  	RETLW 0x28
005C  3432  	RETLW 0x32
005D  3436  	RETLW 0x36
005E  3440  	RETLW 0x40
005F  3444  	RETLW 0x44
0060  3448  	RETLW 0x48
0061  3452  	RETLW 0x52
0062  3456  	RETLW 0x56
0063  3460  	RETLW 0x60
0064  3464  	RETLW 0x64
0065  3468  	RETLW 0x68
0066  3472  	RETLW 0x72
0067  3476  	RETLW 0x76
0068  3480  	RETLW 0x80
0069  3484  	RETLW 0x84
006A  3488  	RETLW 0x88
006B  3492  	RETLW 0x92
006C  3496  	RETLW 0x96
006D        label6
006D  343F  	RETLW 0x3F
006E  3406  	RETLW 0x06
006F  345B  	RETLW 0x5B
0070  344F  	RETLW 0x4F
0071  3466  	RETLW 0x66
0072  346D  	RETLW 0x6D
0073  347D  	RETLW 0x7D
0074  3407  	RETLW 0x07
0075  347F  	RETLW 0x7F
0076  346F  	RETLW 0x6F
0077        ; } __rom_get function end

0077        delay_10us_00000
0077        ; { delay_10us ; function begin
0077        label7
0077  0000  	NOP
0078  0000  	NOP
0079  0000  	NOP
007A  0000  	NOP
007B  0000  	NOP
007C  0000  	NOP
007D  0000  	NOP
007E  0BF7  	DECFSZ delay_10us_00000_arg_del, F
007F  2877  	GOTO	label7
0080  0008  	RETURN
0081        ; } delay_10us function end

0081        delay_ms_00000
0081        ; { delay_ms ; function begin
0081  08F3  	MOVF delay_ms_00000_arg_del, F
0082  1D03  	BTFSS STATUS,Z
0083  2885  	GOTO	label8
0084  0008  	RETURN
0085        label8
0085  30F9  	MOVLW 0xF9
0086        label9
0086  3EFF  	ADDLW 0xFF
0087  1D03  	BTFSS STATUS,Z
0088  2886  	GOTO	label9
0089  0000  	NOP
008A  0BF3  	DECFSZ delay_ms_00000_arg_del, F
008B  2885  	GOTO	label8
008C  0008  	RETURN
008D        ; } delay_ms function end











0270        __mul_16s__0000F
0270        ; { __mul_16s_16s__16 ; function begin
0270  01FE  	CLRF __mul_16s__0000F_1_i
0271  1683  	BSF STATUS, RP0
0272  01A2  	CLRF CompTempVarRet387
0273  01A3  	CLRF CompTempVarRet387+D'1'
0274  1283  	BCF STATUS, RP0
0275  087A  	MOVF __mul_16s__0000F_arg_a, W
0276  1683  	BSF STATUS, RP0
0277  00A0  	MOVWF __mul_16s__0000F_1_t
0278  1283  	BCF STATUS, RP0
0279  087B  	MOVF __mul_16s__0000F_arg_a+D'1', W
027A  1683  	BSF STATUS, RP0
027B  00A1  	MOVWF __mul_16s__0000F_1_t+D'1'
027C  1283  	BCF STATUS, RP0
027D  1FFD  	BTFSS __mul_16s__0000F_arg_b+D'1',7
027E  2A85  	GOTO	label50
027F  17FE  	BSF __mul_16s__0000F_1_i,7
0280  09FC  	COMF __mul_16s__0000F_arg_b, F
0281  09FD  	COMF __mul_16s__0000F_arg_b+D'1', F
0282  0AFC  	INCF __mul_16s__0000F_arg_b, F
0283  1903  	BTFSC gbl_status,2
0284  0AFD  	INCF __mul_16s__0000F_arg_b+D'1', F
0285        label50
0285  1A7E  	BTFSC __mul_16s__0000F_1_i,4
0286  2A9B  	GOTO	label52
0287  1C7C  	BTFSS __mul_16s__0000F_arg_b,0
0288  2A90  	GOTO	label51
0289  1683  	BSF STATUS, RP0
028A  0820  	MOVF __mul_16s__0000F_1_t, W
028B  07A2  	ADDWF CompTempVarRet387, F
028C  0821  	MOVF __mul_16s__0000F_1_t+D'1', W
028D  1803  	BTFSC gbl_status,0
028E  0F21  	INCFSZ __mul_16s__0000F_1_t+D'1', W
028F  07A3  	ADDWF CompTempVarRet387+D'1', F
0290        label51
0290  1003  	BCF gbl_status,0
0291  1283  	BCF STATUS, RP0
0292  0CFD  	RRF __mul_16s__0000F_arg_b+D'1', F
0293  0CFC  	RRF __mul_16s__0000F_arg_b, F
0294  1003  	BCF gbl_status,0
0295  1683  	BSF STATUS, RP0
0296  0DA0  	RLF __mul_16s__0000F_1_t, F
0297  0DA1  	RLF __mul_16s__0000F_1_t+D'1', F
0298  1283  	BCF STATUS, RP0
0299  0AFE  	INCF __mul_16s__0000F_1_i, F
029A  2A85  	GOTO	label50
029B        label52
029B  1FFE  	BTFSS __mul_16s__0000F_1_i,7
029C  0008  	RETURN
029D  1683  	BSF STATUS, RP0
029E  09A2  	COMF CompTempVarRet387, F
029F  09A3  	COMF CompTempVarRet387+D'1', F
02A0  0AA2  	INCF CompTempVarRet387, F
02A1  1903  	BTFSC gbl_status,2
02A2  0AA3  	INCF CompTempVarRet387+D'1', F
02A3  0008  	RETURN
02A4        ; } __mul_16s_16s__16 function end





































09BF        _startup

0A20  158A  	BSF PCLATH,3
0A21  120A  	BCF PCLATH,4
0A22  28E7  	GOTO	main

2007  3FB1  	DW 0x3FB1
