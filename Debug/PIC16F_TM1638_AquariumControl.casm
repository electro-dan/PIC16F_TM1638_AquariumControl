;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 8.01
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

#ifndef _PIC16F_TM1638_AquariumControl_H_
#define _PIC16F_TM1638_AquariumControl_H_

#define TASK_TIMER0 1
#define TASK_TIMER1 2

#define oneWireBus (portc.5)
#define oneWireTris (trisc.5)
#define tm1638dio (portb.1)
#define tm1638dioTris (trisb.1)
#define tm1638clk (portb.2)
#define tm1638strobe (portb.3)
#define WHITE_LED (portc.1)
#define BLUE_LED (portc.2)
#define FAN (porta.1)
#define HEATER (porta.0)

// Timer 0 preload

#define TMR0PRELOAD 61
// This means timer 1 will overflow when 1 cycle completes, generating the interrupt
#define TMR1HV 0xFF
#define TMR1LV 0xFF

// i2c options
#define use_i2c_SW
// clock SCL on RA3, data SDA on RA4
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)
// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3

#define ds3231Addr 0xD0 // Left shifted 7 bit address 0x68
#define at24c32Addr 0xAE // Left shifted 7 bit address 0x57

// Time and date variables
char gBcdSecond = 0; // 0 to 0x59
08E3  1283  	BCF STATUS, RP0
08E4  1303  	BCF STATUS, RP1
08E5  01B5  	CLRF gbl_gBcdSecond

char gBcdMinute = 0; // 0 to 0x59
08E6  01B6  	CLRF gbl_gBcdMinute

char gBcdHour = 0; // 0 to 0x23 or 1 to 0x12. Also contains 12/24 setting at bit 6. If 12 hour, AM/PM uses bit 5
08E7  01B7  	CLRF gbl_gBcdHour

char gDayOfWeek = 1; // 1 to 7
08E8  3001  	MOVLW 0x01
08E9  00B8  	MOVWF gbl_gDayOfWeek

char gBcdDayOfMonth = 1; // 1 to 0x31
08EA  3001  	MOVLW 0x01
08EB  00B9  	MOVWF gbl_gBcdDayOfMonth

char gBcdMonth = 1; // 1 to 0x12 + century at bit 7
08EC  3001  	MOVLW 0x01
08ED  00BA  	MOVWF gbl_gBcdMonth

char gBcdYear = 0x23; // Init to 0x23
08EE  3023  	MOVLW 0x23
08EF  00BB  	MOVWF gbl_gBcdYear

rom char *gDaysInMonth = {0x31, 0x28, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31}; // Days in each month
08F0  3000  	MOVLW 0x00
08F1  00BC  	MOVWF gbl_gDaysInMonth

rom char *gLeapYears = {0x04, 0x08, 0x12, 0x16, 0x20, 0x24, 0x28, 0x32, 0x36, 0x40, 0x44, 0x48, 0x52, 0x56, 0x60, 0x64, 0x68, 0x72, 0x76, 0x80, 0x84, 0x88, 0x92, 0x96}; // List of leap years
08F2  3001  	MOVLW 0x01
08F3  00BD  	MOVWF gbl_gLeapYears


// Timer variables
char iTimer0Counts = 0;
08F4  01BE  	CLRF gbl_iTimer0Counts

char iFlashDigitOff = 0;
08F5  01BF  	CLRF gbl_iFlashDigitOff

char iDigitToFlash = 8; // 8 = no digit to flash
08F6  3008  	MOVLW 0x08
08F7  00C8  	MOVWF gbl_iDigitToFlash


// Hold the upper and lower bytes from the ds18b20
char cTempH = 1;
08F8  3001  	MOVLW 0x01
08F9  00C9  	MOVWF gbl_cTempH

char cTempL = 70;
08FA  3046  	MOVLW 0x46
08FB  00CA  	MOVWF gbl_cTempL

//char iDecimalPosition = 2;

int giDS3231ValueBCD = 0x0000;
08FC  01B3  	CLRF gbl_giDS3231ValueBCD
08FD  01B4  	CLRF gbl_giDS3231ValueBCD+D'1'

char giDS3231ValueTruncCBCD = 0x00;
08FE  01CB  	CLRF gbl_giDS3231ValueTruncCBCD

char gbDS3231IsMinus = 0;
08FF  01CC  	CLRF gbl_gbDS3231IsMinus


char cTask = 0; // Used for task scheduler
0900  01CD  	CLRF gbl_cTask


// States
bool gbWhiteOn = 0;
0901  104E  	BCF gbl_gbWhiteOn,0

bool gbBlueOn = 0;
0902  10CE  	BCF gbl_gbBlueOn,1

bool gbFanOn = 0;
0903  114E  	BCF gbl_gbFanOn,2

bool gbHeaterOn = 0;
0904  11CE  	BCF gbl_gbHeaterOn,3

bool gbFlashOff = 0;
0905  124E  	BCF gbl_gbFlashOff,4

char gcDisplayMode = 0;
0906  01CF  	CLRF gbl_gcDisplayMode

char gcSetMode = 0;
0907  01D0  	CLRF gbl_gcSetMode

char gcHourMode = 0;
0908  01D1  	CLRF gbl_gcHourMode

char gcTriggerMode = 0;
0909  01D2  	CLRF gbl_gcTriggerMode


// Triggers
char gBcdWhiteOnMinute = 0; // 0 to 59
090A  01D3  	CLRF gbl_gBcdWhiteOnMinute

char gBcdWhiteOnHour = 0; // 0 to 23
090B  01D4  	CLRF gbl_gBcdWhiteOnHour

char gBcdWhiteOffMinute = 0; // 0 to 59
090C  01D5  	CLRF gbl_gBcdWhiteOffMinute

char gBcdWhiteOffHour = 0; // 0 to 23
090D  01D6  	CLRF gbl_gBcdWhiteOffHour


char gBcdBlueOnMinute = 0; // 0 to 59
090E  01D7  	CLRF gbl_gBcdBlueOnMinute

char gBcdBlueOnHour = 0; // 0 to 23
090F  01D8  	CLRF gbl_gBcdBlueOnHour

char gBcdBlueOffMinute = 0; // 0 to 59
0910  01D9  	CLRF gbl_gBcdBlueOffMinute

char gBcdBlueOffHour = 0; // 0 to 23
0911  01DA  	CLRF gbl_gBcdBlueOffHour


char gBcdFanOnTemp = 0x28; // Degrees C
0912  3028  	MOVLW 0x28
0913  00DB  	MOVWF gbl_gBcdFanOnTemp

char gBcdFanOffTemp = 0x27; // Degrees C
0914  3027  	MOVLW 0x27
0915  00DC  	MOVWF gbl_gBcdFanOffTemp


char gBcdHeaterOnTemp = 0x24; // Degrees C
0916  3024  	MOVLW 0x24
0917  00DD  	MOVWF gbl_gBcdHeaterOnTemp

char gBcdHeaterOffTemp = 0x25; // Degrees C
0918  3025  	MOVLW 0x25
0919  00DE  	MOVWF gbl_gBcdHeaterOffTemp


// Used to output the segments from numbers
char tm1638MaxDigits = 8;
091A  3008  	MOVLW 0x08
091B  00DF  	MOVWF gbl_tm1638MaxDigits

rom char *tm1638DisplayNumtoSeg = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f};
091C  3002  	MOVLW 0x02
091D  00E0  	MOVWF gbl_tm1638DisplayNumtoSeg

char tm1638Dot = 0x80;
091E  3080  	MOVLW 0x80
091F  00E1  	MOVWF gbl_tm1638Dot

char tm1638Brightness = 7; // 0 to 7
0920  3007  	MOVLW 0x07
0921  00E2  	MOVWF gbl_tm1638Brightness

// 0x40 [01000000] = indicate command to display data
char tm1638ByteSetData = 0x40;
0922  3040  	MOVLW 0x40
0923  00E3  	MOVWF gbl_tm1638ByteSetData

// 0x42 [01000010] = indicate command to read data
char tm1638ByteReadData = 0x42;
0924  3042  	MOVLW 0x42
0925  00E4  	MOVWF gbl_tm1638ByteReadData

// 0xC0 [11000000] = write out all bytes
char tm1638ByteSetAddr = 0xC0;
0926  30C0  	MOVLW 0xC0
0927  00E5  	MOVWF gbl_tm1638ByteSetAddr

// 0x88 [10001000] - Display ON, plus brightness
char tm1638ByteSetOn = 0x88;
0928  3088  	MOVLW 0x88
0929  00E6  	MOVWF gbl_tm1638ByteSetOn


// Copy of the data to write / on the display
char tm1638Data[] = {0, 0, 0, 0, 0, 0, 0, 0};
092A  01A0  	CLRF gbl_tm1638Data
092B  01A1  	CLRF gbl_tm1638Data+D'1'
092C  01A2  	CLRF gbl_tm1638Data+D'2'
092D  01A3  	CLRF gbl_tm1638Data+D'3'
092E  01A4  	CLRF gbl_tm1638Data+D'4'
092F  01A5  	CLRF gbl_tm1638Data+D'5'
0930  01A6  	CLRF gbl_tm1638Data+D'6'
0931  01A7  	CLRF gbl_tm1638Data+D'7'

// Copy of the LED status
char tm1638LEDs[] = {0, 0, 0, 0, 0, 0, 0, 0};
0932  01A8  	CLRF gbl_tm1638LEDs
0933  01A9  	CLRF gbl_tm1638LEDs+D'1'
0934  01AA  	CLRF gbl_tm1638LEDs+D'2'
0935  01AB  	CLRF gbl_tm1638LEDs+D'3'
0936  01AC  	CLRF gbl_tm1638LEDs+D'4'
0937  01AD  	CLRF gbl_tm1638LEDs+D'5'
0938  01AE  	CLRF gbl_tm1638LEDs+D'6'
0939  01AF  	CLRF gbl_tm1638LEDs+D'7'

// Copy of the keys
char tm1638Keys = 0;
093A  01E7  	CLRF gbl_tm1638Keys

char tm1638KeysOld = 0;
093B  01E8  	CLRF gbl_tm1638KeysOld

// For printing
char iPrintStartDigit = 0;
093C  01E9  	CLRF gbl_iPrintStartDigit

char iPrintDotDigit = 8;
093D  3008  	MOVLW 0x08
093E  00EA  	MOVWF gbl_iPrintDotDigit

// For adjusting bcd numbers up 1 or down !1
char iBcdAdjustment = 1;
093F  3001  	MOVLW 0x01
0940  00EB  	MOVWF gbl_iBcdAdjustment


// DS18B20 functions
char oneWireIsPresent = 0;
0941  01EC  	CLRF gbl_oneWireIsPresent

char oneWireResetStage = 0;
0942  01ED  	CLRF gbl_oneWireResetStage

void oneWireBusReset();
void oneWireTxByte(char data);
void oneWireTxBytes(char data, char data2);
char oneWireRxByte();

// EEPROM functions
void eepromWriteAll();
char eepromWrite(char address, char data);
void eepromReadAll();
char eepromRead(char address);

// DS3231 functions
void ds3231Write(char ds3231Reg, char bWrite);
void ds3231Init();
void ds3231Start();
void ds3231Stop();
void ds3231WriteDateTime();
void ds3231ReadDateTime();
char ds3231ReadRegister(char cRegAddress);

// TM1638 functions
void tm1638ByteWrite(char bWrite);
void bcdTo7Seg(char iBcdIn);
void tm1638DisplayOn();
void tm1638UpdateDisplay();
void tm1638ReadKeys();

// General functions
int binToBcd(int iBin);
void startTemp();
void readTemp();

char bcdAdjust(char bcd, char bcdMax, char bcdMin);
void adjustDateTime();
void adjustTrigger();
void processKeys();

#endif

#include <system.h>
#include <i2c_driver.h>
#include "PIC16F_TM1638_AquariumControl.h"

//Target PIC16F628A configuration word
#pragma DATA _CONFIG, _BODEN_OFF & _PWRTE_ON & _WDT_OFF & _CP_OFF & _XT_OSC // Brown out reset off, Power-up Timer on, Watchdog timer off, Code Protection off, XT oscillator

//Set clock frequency (for software delays) - 4MHz
#pragma CLOCK_FREQ	4000000

    
/*********************************************************************************************
  void oneWireBusReset()
  First part of the reset routine - drive the bus low for 500us
*********************************************************************************************/
void oneWireBusReset() {

    char isPresent;
    oneWireTris = 1; // start with high
07A6  1683  	BSF STATUS, RP0
07A7  1303  	BCF STATUS, RP1
07A8  1687  	BSF gbl_trisc,5

    isPresent = 0;
07A9  1283  	BCF STATUS, RP0
07AA  01EE  	CLRF oneWireBus_00017_1_isPresent

    // Send the reset pulse - drive low for 500us
    oneWireBus = 0;      
07AB  1287  	BCF gbl_portc,5

    oneWireTris = 0;
07AC  1683  	BSF STATUS, RP0
07AD  1287  	BCF gbl_trisc,5

    delay_10us(50);
07AE  3032  	MOVLW 0x32
07AF  1283  	BCF STATUS, RP0
07B0  00F3  	MOVWF delay_10us_00000_arg_del
07B1  2077  	CALL delay_10us_00000

    // Release line and wait 70us for PD Pulse
    oneWireTris = 1;
07B2  1683  	BSF STATUS, RP0
07B3  1687  	BSF gbl_trisc,5

    delay_10us(7);
07B4  3007  	MOVLW 0x07
07B5  1283  	BCF STATUS, RP0
07B6  00F3  	MOVWF delay_10us_00000_arg_del
07B7  2077  	CALL delay_10us_00000

    // Now sample, if there is a sensor on the bus, the line should be low
    if (oneWireBus) {
07B8  1A87  	BTFSC gbl_portc,5

        oneWireIsPresent = 0; // no devices
07B9  01EC  	CLRF gbl_oneWireIsPresent

    }
    delay_10us(50);
07BA  3032  	MOVLW 0x32
07BB  00F3  	MOVWF delay_10us_00000_arg_del
07BC  2077  	CALL delay_10us_00000

}
07BD  0008  	RETURN


/*********************************************************************************************
  void oneWireTxByte(char data)
  Transmits a single byte from the bus
*********************************************************************************************/
void oneWireTxByte(char cData) {

    char cTemp = 1;
016E  3001  	MOVLW 0x01
016F  00F1  	MOVWF oneWireTxB_00018_1_cTemp

    // Loop through the eight bits in the byte
    for (char i = 0; i < 8; i++) {
0170  01F2  	CLRF oneWireTxB_00018_2_i
0171        label26
0171  3008  	MOVLW 0x08
0172  0272  	SUBWF oneWireTxB_00018_2_i, W
0173  1803  	BTFSC STATUS,C
0188  0AF2  	INCF oneWireTxB_00018_2_i, F
0189  2971  	GOTO	label26

        // Send the LSB first

        // Drive the line low initially for 3us
        oneWireTris = 0;
0175  1683  	BSF STATUS, RP0
0176  1287  	BCF gbl_trisc,5

        oneWireBus = 0;
0177  1283  	BCF STATUS, RP0
0178  1287  	BCF gbl_portc,5


        // Delay not needed for 4MHz PIC
        //delay_us(3); // Delay 3us
        
        if (cData & cTemp) {
0179  0871  	MOVF oneWireTxB_00018_1_cTemp, W
017A  0570  	ANDWF oneWireTxB_00018_arg_cData, W
017B  1903  	BTFSC STATUS,Z
017C  297F  	GOTO	label27

            oneWireTris = 1; // Release the bus
017D  1683  	BSF STATUS, RP0
017E  1687  	BSF gbl_trisc,5

        }
        
        delay_10us(5); // Delay 60us - 50us works fine with code delays
017F  3005  	MOVLW 0x05
0180  1283  	BCF STATUS, RP0
0181  00F3  	MOVWF delay_10us_00000_arg_del
0182  2077  	CALL delay_10us_00000

        oneWireTris = 1; // Release the bus
0183  1683  	BSF STATUS, RP0
0184  1687  	BSF gbl_trisc,5

        
        // move the test bit
        cTemp <<= 1;
0185  1003  	BCF STATUS,C
0186  1283  	BCF STATUS, RP0
0187  0DF1  	RLF oneWireTxB_00018_1_cTemp, F

    }
}
0174  0008  	RETURN


/*********************************************************************************************
  void oneWireTxBytes(char data, char data2)
  Transmits a 2 bytes from the bus
*********************************************************************************************/
void oneWireTxBytes(char cData, char cData2) {

    // Reset first - done in main
    //oneWireBusReset();
    // Send first byte
    oneWireTxByte(cData);
046D  086E  	MOVF oneWireTxB_00019_arg_cData, W
046E  00F0  	MOVWF oneWireTxB_00018_arg_cData
046F  216E  	CALL oneWireTxB_00018

    // Send second byte
    oneWireTxByte(cData2);
0470  086F  	MOVF oneWireTxB_00019_arg_cData2, W
0471  00F0  	MOVWF oneWireTxB_00018_arg_cData
0472  216E  	CALL oneWireTxB_00018

}
0473  0008  	RETURN


/*********************************************************************************************
  char oneWireRxByte()
  Receives a single byte from the bus
*********************************************************************************************/
char oneWireRxByte() {

    char cDataIn = 0;
0474  1283  	BCF STATUS, RP0
0475  1303  	BCF STATUS, RP1
0476  01EE  	CLRF oneWireRxB_0001A_1_cDataIn

    // Loop through the eight bits in the byte
    for(char i = 0; i < 8; i++) {
0477  01EF  	CLRF oneWireRxB_0001A_2_i
0478        label95
0478  3008  	MOVLW 0x08
0479  026F  	SUBWF oneWireRxB_0001A_2_i, W
047A  1803  	BTFSC STATUS,C
047B  2C8F  	GOTO	label96
048D  0AEF  	INCF oneWireRxB_0001A_2_i, F
048E  2C78  	GOTO	label95
048F        label96

        // Bring bus low for 15us
        oneWireTris = 0;
047C  1683  	BSF STATUS, RP0
047D  1287  	BCF gbl_trisc,5

        oneWireBus = 0;
047E  1283  	BCF STATUS, RP0
047F  1287  	BCF gbl_portc,5


        // Delay not needed for 4MHz PIC
        //delay_us(15); // Delay 15us

        // Release bus for 6us, this is enough time for the slave to respond
        oneWireTris = 1;
0480  1683  	BSF STATUS, RP0
0481  1687  	BSF gbl_trisc,5

        delay_us(3); // Delay 6us
0482  3003  	MOVLW 0x03
0483  1283  	BCF STATUS, RP0
0484  00F4  	MOVWF delay_us_00000_arg_del
0485  2010  	CALL delay_us_00000

        
        // Shift data already received left
        cDataIn >>= 1;
0486  1003  	BCF STATUS,C
0487  0CEE  	RRF oneWireRxB_0001A_1_cDataIn, F

        
        // Check the value of the onewire bus - set the MSB of cDataIn if so
        if (oneWireBus)
0488  1A87  	BTFSC gbl_portc,5

            cDataIn.7 = 1;
0489  17EE  	BSF oneWireRxB_0001A_1_cDataIn,7


        // To finish time slot
        delay_10us(6); // 60us
048A  3006  	MOVLW 0x06
048B  00F3  	MOVWF delay_10us_00000_arg_del
048C  2077  	CALL delay_10us_00000

    } 
    
    return cDataIn;
048F  086E  	MOVF oneWireRxB_0001A_1_cDataIn, W
0490  00EF  	MOVWF CompTempVarRet551

}
0491  0008  	RETURN


/*********************************************************************************************
  void at24c32WriteAll()
  Write multiple bytes
*********************************************************************************************/
void at24c32WriteAll() {

	// https://www.instructables.com/The-Most-Comprehensive-Guide-to-Programming-the-AT/
	i2c_start();
055A  2126  	CALL i2c_START_00000

	i2c_write(at24c32Addr); // address + write
055B  30AE  	MOVLW 0xAE
055C  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
055D  20A5  	CALL i2c_WRITE_00000

	// start at address 0
	i2c_write(0); // First word address (only 4 bits of the 12 bit byte address)
055E  01F1  	CLRF i2c_WRITE_00000_arg_i2c_data
055F  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // Second word address 
0560  01F1  	CLRF i2c_WRITE_00000_arg_i2c_data
0561  20A5  	CALL i2c_WRITE_00000

	// Write data bytes
	// We're only writing 14 bytes here, so no need to worry about row rollover after 32 bytes
	i2c_write(0x44); // To indicate AT24C32 has been written to
0562  3044  	MOVLW 0x44
0563  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
0564  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdWhiteOnMinute);
0565  0853  	MOVF gbl_gBcdWhiteOnMinute, W
0566  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
0567  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOnHour);
0568  0854  	MOVF gbl_gBcdWhiteOnHour, W
0569  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
056A  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOffMinute);
056B  0855  	MOVF gbl_gBcdWhiteOffMinute, W
056C  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
056D  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOffHour);
056E  0856  	MOVF gbl_gBcdWhiteOffHour, W
056F  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
0570  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOnMinute);
0571  0857  	MOVF gbl_gBcdBlueOnMinute, W
0572  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
0573  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOnHour);
0574  0858  	MOVF gbl_gBcdBlueOnHour, W
0575  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
0576  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOffMinute);
0577  0859  	MOVF gbl_gBcdBlueOffMinute, W
0578  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
0579  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOffHour);
057A  085A  	MOVF gbl_gBcdBlueOffHour, W
057B  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
057C  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdFanOnTemp);
057D  085B  	MOVF gbl_gBcdFanOnTemp, W
057E  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
057F  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdFanOffTemp);
0580  085C  	MOVF gbl_gBcdFanOffTemp, W
0581  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
0582  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdHeaterOnTemp);
0583  085D  	MOVF gbl_gBcdHeaterOnTemp, W
0584  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
0585  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdHeaterOffTemp);
0586  085E  	MOVF gbl_gBcdHeaterOffTemp, W
0587  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
0588  20A5  	CALL i2c_WRITE_00000

    i2c_write(gcHourMode);
0589  0851  	MOVF gbl_gcHourMode, W
058A  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
058B  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
058C  20F6  	CALL i2c_STOP_00000

	delay_ms(10); // Write Cycle Time
058D  300A  	MOVLW 0x0A
058E  00EE  	MOVWF delay_ms_00000_arg_del
058F  2081  	CALL delay_ms_00000

}
0590  0008  	RETURN


/*********************************************************************************************
  void at24c32ReadAll()
  Read all bytes
*********************************************************************************************/
void at24c32ReadAll() {

	i2c_start();
0591  2126  	CALL i2c_START_00000

	i2c_write(at24c32Addr); // address + write
0592  30AE  	MOVLW 0xAE
0593  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
0594  20A5  	CALL i2c_WRITE_00000

	// start at address 0
	i2c_write(0); // First word address (only 4 bits of the 12 bit byte address)
0595  01F1  	CLRF i2c_WRITE_00000_arg_i2c_data
0596  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // Second word address 
0597  01F1  	CLRF i2c_WRITE_00000_arg_i2c_data
0598  20A5  	CALL i2c_WRITE_00000

	i2c_stop(); // Don't actually write a byte, just stop
0599  20F6  	CALL i2c_STOP_00000

	
	i2c_start();
059A  2126  	CALL i2c_START_00000

	i2c_write(at24c32Addr + 1); // address + read
059B  30AF  	MOVLW 0xAF
059C  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
059D  20A5  	CALL i2c_WRITE_00000

	char hasWritten = i2c_read(0); // ack
059E  01F1  	CLRF i2c_READ_00000_arg_ack_status
059F  21CD  	CALL i2c_READ_00000
05A0  0874  	MOVF CompTempVarRet553, W
05A1  00EF  	MOVWF at24c32Rea_0002C_1_hasWritten

	if (hasWritten != 0x44) {
05A2  086F  	MOVF at24c32Rea_0002C_1_hasWritten, W
05A3  3A44  	XORLW 0x44
05A4  1903  	BTFSC STATUS,Z
05A5  2DAA  	GOTO	label99
05AA        label99

		i2c_read(1); // nack
05A6  3001  	MOVLW 0x01
05A7  00F1  	MOVWF i2c_READ_00000_arg_ack_status
05A8  21CD  	CALL i2c_READ_00000

	} else {
05A9  2DDF  	GOTO	label100
05DF        label100

		gBcdWhiteOnMinute = i2c_read(0); // ack
05AA  01F1  	CLRF i2c_READ_00000_arg_ack_status
05AB  21CD  	CALL i2c_READ_00000
05AC  0874  	MOVF CompTempVarRet553, W
05AD  00D3  	MOVWF gbl_gBcdWhiteOnMinute

		gBcdWhiteOnHour = i2c_read(0); // ack
05AE  01F1  	CLRF i2c_READ_00000_arg_ack_status
05AF  21CD  	CALL i2c_READ_00000
05B0  0874  	MOVF CompTempVarRet553, W
05B1  00D4  	MOVWF gbl_gBcdWhiteOnHour

		gBcdWhiteOffMinute = i2c_read(0); // ack
05B2  01F1  	CLRF i2c_READ_00000_arg_ack_status
05B3  21CD  	CALL i2c_READ_00000
05B4  0874  	MOVF CompTempVarRet553, W
05B5  00D5  	MOVWF gbl_gBcdWhiteOffMinute

		gBcdWhiteOffHour = i2c_read(0); // ack
05B6  01F1  	CLRF i2c_READ_00000_arg_ack_status
05B7  21CD  	CALL i2c_READ_00000
05B8  0874  	MOVF CompTempVarRet553, W
05B9  00D6  	MOVWF gbl_gBcdWhiteOffHour

		gBcdBlueOnMinute = i2c_read(0); // ack
05BA  01F1  	CLRF i2c_READ_00000_arg_ack_status
05BB  21CD  	CALL i2c_READ_00000
05BC  0874  	MOVF CompTempVarRet553, W
05BD  00D7  	MOVWF gbl_gBcdBlueOnMinute

		gBcdBlueOnHour = i2c_read(0); // ack
05BE  01F1  	CLRF i2c_READ_00000_arg_ack_status
05BF  21CD  	CALL i2c_READ_00000
05C0  0874  	MOVF CompTempVarRet553, W
05C1  00D8  	MOVWF gbl_gBcdBlueOnHour

		gBcdBlueOffMinute = i2c_read(0); // ack
05C2  01F1  	CLRF i2c_READ_00000_arg_ack_status
05C3  21CD  	CALL i2c_READ_00000
05C4  0874  	MOVF CompTempVarRet553, W
05C5  00D9  	MOVWF gbl_gBcdBlueOffMinute

		gBcdBlueOffHour = i2c_read(0); // ack
05C6  01F1  	CLRF i2c_READ_00000_arg_ack_status
05C7  21CD  	CALL i2c_READ_00000
05C8  0874  	MOVF CompTempVarRet553, W
05C9  00DA  	MOVWF gbl_gBcdBlueOffHour

		gBcdFanOnTemp = i2c_read(0); // ack
05CA  01F1  	CLRF i2c_READ_00000_arg_ack_status
05CB  21CD  	CALL i2c_READ_00000
05CC  0874  	MOVF CompTempVarRet553, W
05CD  00DB  	MOVWF gbl_gBcdFanOnTemp

		gBcdFanOffTemp = i2c_read(0); // ack
05CE  01F1  	CLRF i2c_READ_00000_arg_ack_status
05CF  21CD  	CALL i2c_READ_00000
05D0  0874  	MOVF CompTempVarRet553, W
05D1  00DC  	MOVWF gbl_gBcdFanOffTemp

		gBcdHeaterOnTemp = i2c_read(0); // ack
05D2  01F1  	CLRF i2c_READ_00000_arg_ack_status
05D3  21CD  	CALL i2c_READ_00000
05D4  0874  	MOVF CompTempVarRet553, W
05D5  00DD  	MOVWF gbl_gBcdHeaterOnTemp

		gBcdHeaterOffTemp = i2c_read(0); // ack
05D6  01F1  	CLRF i2c_READ_00000_arg_ack_status
05D7  21CD  	CALL i2c_READ_00000
05D8  0874  	MOVF CompTempVarRet553, W
05D9  00DE  	MOVWF gbl_gBcdHeaterOffTemp

		gcHourMode = i2c_read(1); // nack
05DA  3001  	MOVLW 0x01
05DB  00F1  	MOVWF i2c_READ_00000_arg_ack_status
05DC  21CD  	CALL i2c_READ_00000
05DD  0874  	MOVF CompTempVarRet553, W
05DE  00D1  	MOVWF gbl_gcHourMode

	}
	i2c_stop();
05DF  20F6  	CALL i2c_STOP_00000

}
05E0  0008  	RETURN



/*********************************************************************************************
  void ds3231Write(char ds3231Reg, char bWrite)
  Write one byte
*********************************************************************************************/
void ds3231Write(char ds3231Reg, char bWrite) {

	i2c_start();
0221  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
0222  30D0  	MOVLW 0xD0
0223  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
0224  20A5  	CALL i2c_WRITE_00000

	i2c_write(ds3231Reg); // start at address
0225  086F  	MOVF ds3231Writ_0001B_arg_ds3231Reg, W
0226  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
0227  20A5  	CALL i2c_WRITE_00000

	i2c_write(bWrite); // start at address
0228  0870  	MOVF ds3231Writ_0001B_arg_bWrite, W
0229  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
022A  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
022B  20F6  	CALL i2c_STOP_00000

}
022C  0008  	RETURN


/*********************************************************************************************
  void ds3231Init()
  Initialise the DS3231
*********************************************************************************************/
void ds3231Init() {

	/* control register 0Eh
    bit7 EOSC   Enable Oscillator (1 if oscillator must be stopped when on battery)
    bit6 BBSQW  Battery Backed Square Wave - 0 means square wave disabled when VCC falls below VPF (power fail voltage)
    bit5 CONV   Convert temperature (1 forces a conversion)
    bit4 RS2    Rate select - frequency of square wave output - NA for DS3231M
    bit3 RS1    Rate select - NA for DS3231M
    bit2 INTCN  Interrupt control (1 for use of the alarms and to disable square wave)
    bit1 A2IE   Alarm2 interrupt enable (1 to enable)
    bit0 A1IE   Alarm1 interrupt enable (1 to enable)
    */
	ds3231Write(0x0E, 0x00);
04D6  300E  	MOVLW 0x0E
04D7  1283  	BCF STATUS, RP0
04D8  1303  	BCF STATUS, RP1
04D9  00EF  	MOVWF ds3231Writ_0001B_arg_ds3231Reg
04DA  01F0  	CLRF ds3231Writ_0001B_arg_bWrite
04DB  2221  	CALL ds3231Writ_0001B

	/* Status Register 0Fh
    bit7 OSF     Oscillator stopped flag - clear oscillator stop flag at init
    bit3 EN32kHz Enable 32kHz Output - 0 for disabled
    bit2 BSY     Busy
    bit1 A2F     Alarm 2 Flag
    bit0 A1F     Alarm 1 Flag
    */
	ds3231Write(0x0F, 0x00);
04DC  300F  	MOVLW 0x0F
04DD  00EF  	MOVWF ds3231Writ_0001B_arg_ds3231Reg
04DE  01F0  	CLRF ds3231Writ_0001B_arg_bWrite
04DF  2221  	CALL ds3231Writ_0001B

}
04E0  0008  	RETURN


/*********************************************************************************************
  void ds3231WriteDateTime()
  Write the date to the DS3231
*********************************************************************************************/
void ds3231WriteDateTime() {

	i2c_start();
04A5  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
04A6  30D0  	MOVLW 0xD0
04A7  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
04A8  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
04A9  01F1  	CLRF i2c_WRITE_00000_arg_i2c_data
04AA  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // seconds
04AB  01F1  	CLRF i2c_WRITE_00000_arg_i2c_data
04AC  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdMinute); // minutes
04AD  0836  	MOVF gbl_gBcdMinute, W
04AE  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
04AF  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdHour); // hours
04B0  0837  	MOVF gbl_gBcdHour, W
04B1  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
04B2  20A5  	CALL i2c_WRITE_00000

	i2c_write(gDayOfWeek); // day of week
04B3  0838  	MOVF gbl_gDayOfWeek, W
04B4  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
04B5  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdDayOfMonth); // day of month
04B6  0839  	MOVF gbl_gBcdDayOfMonth, W
04B7  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
04B8  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdMonth); // month + century
04B9  083A  	MOVF gbl_gBcdMonth, W
04BA  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
04BB  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdYear); // year
04BC  083B  	MOVF gbl_gBcdYear, W
04BD  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
04BE  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
04BF  20F6  	CALL i2c_STOP_00000

}
04C0  0008  	RETURN


/*********************************************************************************************
  void ds3231ReadDateTime()
  Write the date to the DS3231
*********************************************************************************************/
void ds3231ReadDateTime() {

	i2c_start();
07F6  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
07F7  30D0  	MOVLW 0xD0
07F8  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
07F9  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
07FA  01F1  	CLRF i2c_WRITE_00000_arg_i2c_data
07FB  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
07FC  20F6  	CALL i2c_STOP_00000

	
	i2c_start();
07FD  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr + 1); // address + read
07FE  30D1  	MOVLW 0xD1
07FF  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
0800  20A5  	CALL i2c_WRITE_00000

	gBcdSecond = i2c_read(0); // ack
0801  01F1  	CLRF i2c_READ_00000_arg_ack_status
0802  21CD  	CALL i2c_READ_00000
0803  0874  	MOVF CompTempVarRet553, W
0804  00B5  	MOVWF gbl_gBcdSecond

	gBcdMinute = i2c_read(0); // ack
0805  01F1  	CLRF i2c_READ_00000_arg_ack_status
0806  21CD  	CALL i2c_READ_00000
0807  0874  	MOVF CompTempVarRet553, W
0808  00B6  	MOVWF gbl_gBcdMinute

	gBcdHour = i2c_read(0); // ack
0809  01F1  	CLRF i2c_READ_00000_arg_ack_status
080A  21CD  	CALL i2c_READ_00000
080B  0874  	MOVF CompTempVarRet553, W
080C  00B7  	MOVWF gbl_gBcdHour

	gDayOfWeek = i2c_read(0); // ack
080D  01F1  	CLRF i2c_READ_00000_arg_ack_status
080E  21CD  	CALL i2c_READ_00000
080F  0874  	MOVF CompTempVarRet553, W
0810  00B8  	MOVWF gbl_gDayOfWeek

	gBcdDayOfMonth = i2c_read(0); // ack
0811  01F1  	CLRF i2c_READ_00000_arg_ack_status
0812  21CD  	CALL i2c_READ_00000
0813  0874  	MOVF CompTempVarRet553, W
0814  00B9  	MOVWF gbl_gBcdDayOfMonth

	gBcdMonth = i2c_read(0); // ack
0815  01F1  	CLRF i2c_READ_00000_arg_ack_status
0816  21CD  	CALL i2c_READ_00000
0817  0874  	MOVF CompTempVarRet553, W
0818  00BA  	MOVWF gbl_gBcdMonth

	gBcdYear = i2c_read(1); // nack
0819  3001  	MOVLW 0x01
081A  00F1  	MOVWF i2c_READ_00000_arg_ack_status
081B  21CD  	CALL i2c_READ_00000
081C  0874  	MOVF CompTempVarRet553, W
081D  00BB  	MOVWF gbl_gBcdYear

	i2c_stop();
081E  20F6  	CALL i2c_STOP_00000

}
081F  0008  	RETURN


/*********************************************************************************************
  char ds3231ReadRegister(char cRegAddress)
  Read one byte from a given DS3231 register address
*********************************************************************************************/
char ds3231ReadRegister(char cRegAddress) {

	char cStatus;
	i2c_start();
04C1  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
04C2  30D0  	MOVLW 0xD0
04C3  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
04C4  20A5  	CALL i2c_WRITE_00000

	i2c_write(cRegAddress); // start at requested address
04C5  086F  	MOVF ds3231Read_0001E_arg_cRegAddress, W
04C6  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
04C7  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
04C8  20F6  	CALL i2c_STOP_00000

	
	i2c_start();
04C9  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr + 1); // address + read
04CA  30D1  	MOVLW 0xD1
04CB  00F1  	MOVWF i2c_WRITE_00000_arg_i2c_data
04CC  20A5  	CALL i2c_WRITE_00000

	cStatus = i2c_read(1); // read the byte, then nack
04CD  3001  	MOVLW 0x01
04CE  00F1  	MOVWF i2c_READ_00000_arg_ack_status
04CF  21CD  	CALL i2c_READ_00000
04D0  0874  	MOVF CompTempVarRet553, W
04D1  00F0  	MOVWF ds3231Read_0001E_1_cStatus

    i2c_stop();
04D2  20F6  	CALL i2c_STOP_00000

    return cStatus;
04D3  0870  	MOVF ds3231Read_0001E_1_cStatus, W
04D4  00F1  	MOVWF CompTempVarRet554

}
04D5  0008  	RETURN


/*********************************************************************************************
  void tm1638ByteWrite(char bWrite)
  Write one byte
*********************************************************************************************/
void tm1638ByteWrite(char bWrite) {

    for (char i = 0; i < 8; i++) {
015B  01F3  	CLRF tm1638Byte_0001F_2_i
015C        label25
015C  3008  	MOVLW 0x08
015D  0273  	SUBWF tm1638Byte_0001F_2_i, W
015E  1803  	BTFSC STATUS,C
016C  0AF3  	INCF tm1638Byte_0001F_2_i, F
016D  295C  	GOTO	label25

        tm1638dio = (bWrite & 0x01);
0160  3001  	MOVLW 0x01
0161  0572  	ANDWF tm1638Byte_0001F_arg_bWrite, W
0162  00F4  	MOVWF CompTempVar555
0163  1874  	BTFSC CompTempVar555,0
0164  1486  	BSF gbl_portb,1
0165  1C74  	BTFSS CompTempVar555,0
0166  1086  	BCF gbl_portb,1

        tm1638clk = 0;
0167  1106  	BCF gbl_portb,2

        bWrite = (bWrite >> 1);
0168  08F2  	MOVF tm1638Byte_0001F_arg_bWrite, F
0169  1003  	BCF STATUS,C
016A  0CF2  	RRF tm1638Byte_0001F_arg_bWrite, F

        tm1638clk = 1;
016B  1506  	BSF gbl_portb,2

    }
}
015F  0008  	RETURN


/*********************************************************************************************
  void tm1638DisplayOn()
  Turns the display on, with defined brightness
*********************************************************************************************/
void tm1638DisplayOn() {

    // Write 0x8F [10001000] to set display ON with pulse width 14/16
    tm1638strobe = 0;
0465  1283  	BCF STATUS, RP0
0466  1303  	BCF STATUS, RP1
0467  1186  	BCF gbl_portb,3

    tm1638ByteWrite(0x88);
0468  3088  	MOVLW 0x88
0469  00F2  	MOVWF tm1638Byte_0001F_arg_bWrite
046A  215B  	CALL tm1638Byte_0001F

    tm1638strobe = 1;
046B  1586  	BSF gbl_portb,3

}
046C  0008  	RETURN


/*********************************************************************************************
  void nibbleTo7Seg(char iNibble)
  Convert a single nibble into the 7-segment representation (two digits)
  7-segment digit to be written will be iPrintStartDigit, which is auto-incremented after
  If iPrintDotDigit matches, the dot on the display digit will be added
*********************************************************************************************/
void nibbleTo7Seg(char bNibble) {

	char s7SegDisplay = tm1638DisplayNumtoSeg[bNibble & 0x0F];
008D  0860  	MOVF gbl_tm1638DisplayNumtoSeg, W
008E  00F7  	MOVWF __rom_get_00000_arg_objNumb
008F  300F  	MOVLW 0x0F
0090  0575  	ANDWF nibbleTo7S_00020_arg_bNibble, W
0091  00F8  	MOVWF __rom_get_00000_arg_idx
0092  201A  	CALL __rom_get_00000
0093  00F6  	MOVWF nibbleTo7S_00020_1_s7SegDisplay

	if (iPrintStartDigit == iPrintDotDigit)
0094  086A  	MOVF gbl_iPrintDotDigit, W
0095  0669  	XORWF gbl_iPrintStartDigit, W
0096  118A  	BCF PCLATH,3
0097  120A  	BCF PCLATH,4
0098  1D03  	BTFSS STATUS,Z
0099  289C  	GOTO	label10
009C        label10

        s7SegDisplay |= tm1638Dot;
009A  0861  	MOVF gbl_tm1638Dot, W
009B  04F6  	IORWF nibbleTo7S_00020_1_s7SegDisplay, F

    tm1638Data[iPrintStartDigit] = s7SegDisplay;
009C  1383  	BCF	STATUS,IRP
009D  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
009E  0084  	MOVWF FSR
009F  0869  	MOVF gbl_iPrintStartDigit, W
00A0  0784  	ADDWF FSR, F
00A1  0876  	MOVF nibbleTo7S_00020_1_s7SegDisplay, W
00A2  0080  	MOVWF INDF

    iPrintStartDigit++;
00A3  0AE9  	INCF gbl_iPrintStartDigit, F

}
00A4  0008  	RETURN


/*********************************************************************************************
  void bcdTo7Seg(char iBcdIn)
  Convert a single bcd byte into the 7-segment representation (two digits)
*********************************************************************************************/
void bcdTo7Seg(char iBcdIn) {

    nibbleTo7Seg(iBcdIn >> 4);
022D  0E74  	SWAPF bcdTo7Seg_00000_arg_iBcdIn, W
022E  390F  	ANDLW 0x0F
022F  00F5  	MOVWF nibbleTo7S_00020_arg_bNibble
0230  208D  	CALL nibbleTo7S_00020

    nibbleTo7Seg(iBcdIn);
0231  0874  	MOVF bcdTo7Seg_00000_arg_iBcdIn, W
0232  00F5  	MOVWF nibbleTo7S_00020_arg_bNibble
0233  208D  	CALL nibbleTo7S_00020

}
0234  0008  	RETURN


/*********************************************************************************************
  void tm1638UpdateDisplay()
  Publish the tm1638Data and tm1638LEDs arrays to the display
*********************************************************************************************/
void tm1638UpdateDisplay() {

    
    // Display current temperature unless set, trigger or alt display mode is active
    if ((gcDisplayMode == 2) | gcSetMode | gcTriggerMode) {
0288  1283  	BCF STATUS, RP0
0289  1303  	BCF STATUS, RP1
028A  01EF  	CLRF CompTempVar559
028B  3002  	MOVLW 0x02
028C  024F  	SUBWF gbl_gcDisplayMode, W
028D  1903  	BTFSC STATUS,Z
028E  0AEF  	INCF CompTempVar559, F
028F  0850  	MOVF gbl_gcSetMode, W
0290  04EF  	IORWF CompTempVar559, F
0291  0852  	MOVF gbl_gcTriggerMode, W
0292  046F  	IORWF CompTempVar559, W
0293  1903  	BTFSC STATUS,Z
0294  2BB5  	GOTO	label77
03B5        label77

        if (gcSetMode == 1) {
0295  0350  	DECF gbl_gcSetMode, W
0296  1D03  	BTFSS STATUS,Z
0297  2AA4  	GOTO	label53
02A4        label53

            iDigitToFlash = 3;
0298  3003  	MOVLW 0x03
0299  00C8  	MOVWF gbl_iDigitToFlash

            // Display year
            // Start printing from digit 0
            iPrintStartDigit = 0;
029A  01E9  	CLRF gbl_iPrintStartDigit

            iPrintDotDigit = 3;
029B  3003  	MOVLW 0x03
029C  00EA  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(0x20); // Display 20 in digits 0 and 1 (no dot)
029D  3020  	MOVLW 0x20
029E  00F4  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
029F  222D  	CALL bcdTo7Seg_00000

            bcdTo7Seg(gBcdYear); // Display year in digits 2 and 3 (+dot on 3)
02A0  083B  	MOVF gbl_gBcdYear, W
02A1  00F4  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02A2  222D  	CALL bcdTo7Seg_00000

        } else if (gcSetMode == 4) {
02A3  2BE5  	GOTO	label80
02A4  0850  	MOVF gbl_gcSetMode, W
02A5  3A04  	XORLW 0x04
02A6  1D03  	BTFSS STATUS,Z
02A7  2ABA  	GOTO	label54
02BA        label54

            iDigitToFlash = 3;
02A8  3003  	MOVLW 0x03
02A9  00C8  	MOVWF gbl_iDigitToFlash

            // Display day of week
            tm1638Data[0] = 0x5E; // d
02AA  305E  	MOVLW 0x5E
02AB  00A0  	MOVWF gbl_tm1638Data

            tm1638Data[1] = 0x5F; // a
02AC  305F  	MOVLW 0x5F
02AD  00A1  	MOVWF gbl_tm1638Data+D'1'

            tm1638Data[2] = 0x6E; // y
02AE  306E  	MOVLW 0x6E
02AF  00A2  	MOVWF gbl_tm1638Data+D'2'

            tm1638Data[3] = tm1638DisplayNumtoSeg[gDayOfWeek] + tm1638Dot;
02B0  0860  	MOVF gbl_tm1638DisplayNumtoSeg, W
02B1  00F7  	MOVWF __rom_get_00000_arg_objNumb
02B2  0838  	MOVF gbl_gDayOfWeek, W
02B3  00F8  	MOVWF __rom_get_00000_arg_idx
02B4  201A  	CALL __rom_get_00000
02B5  0761  	ADDWF gbl_tm1638Dot, W
02B6  00A3  	MOVWF gbl_tm1638Data+D'3'

        } else if (gcSetMode == 5) {
02B7  118A  	BCF PCLATH,3
02B8  120A  	BCF PCLATH,4
02B9  2BE5  	GOTO	label80
02BA  0850  	MOVF gbl_gcSetMode, W
02BB  3A05  	XORLW 0x05
02BC  1D03  	BTFSS STATUS,Z
02BD  2AD0  	GOTO	label57
02D0        label57

            iDigitToFlash = 1;
02BE  3001  	MOVLW 0x01
02BF  00C8  	MOVWF gbl_iDigitToFlash

            // Display day of week
            if (gcHourMode) {
02C0  08D1  	MOVF gbl_gcHourMode, F
02C1  1903  	BTFSC STATUS,Z
02C2  2AC8  	GOTO	label55
02C8        label55

				tm1638Data[0] = 0x06; // 1
02C3  3006  	MOVLW 0x06
02C4  00A0  	MOVWF gbl_tm1638Data

				tm1638Data[1] = 0x5b; // 2
02C5  305B  	MOVLW 0x5B
02C6  00A1  	MOVWF gbl_tm1638Data+D'1'

			} else {
02C7  2ACC  	GOTO	label56
02CC        label56

				tm1638Data[0] = 0x5b; // 2
02C8  305B  	MOVLW 0x5B
02C9  00A0  	MOVWF gbl_tm1638Data

				tm1638Data[1] = 0x66; // 4
02CA  3066  	MOVLW 0x66
02CB  00A1  	MOVWF gbl_tm1638Data+D'1'

			}
            tm1638Data[2] = 0x74; // h
02CC  3074  	MOVLW 0x74
02CD  00A2  	MOVWF gbl_tm1638Data+D'2'

            tm1638Data[3] = 0x00; // blank
02CE  01A3  	CLRF gbl_tm1638Data+D'3'

        } else if (gcTriggerMode) {
02CF  2BE5  	GOTO	label80
02D0  08D2  	MOVF gbl_gcTriggerMode, F
02D1  1903  	BTFSC STATUS,Z
02D2  2B8D  	GOTO	label70
038D        label70

            iPrintDotDigit = 5;
02D3  3005  	MOVLW 0x05
02D4  00EA  	MOVWF gbl_iPrintDotDigit

            switch (gcTriggerMode) {
02FA  2BE5  	GOTO	label80

                case 1:
02D5  0852  	MOVF gbl_gcTriggerMode, W
02D6  3A01  	XORLW 0x01
02D7  1903  	BTFSC STATUS,Z
02D8  2AFB  	GOTO	label58
02FB        label58

                    // White LED on hour
                    tm1638Data[0] = 0x38; // L
02FB  3038  	MOVLW 0x38
02FC  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x00; // space
02FD  01A1  	CLRF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x3f; // O
02FE  303F  	MOVLW 0x3F
02FF  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x54; // n
0300  3054  	MOVLW 0x54
0301  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
0302  3005  	MOVLW 0x05
0303  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
0304  3004  	MOVLW 0x04
0305  00E9  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOnHour); // Display hour in digits 4 and 5 (dot on 5)
0306  0854  	MOVF gbl_gBcdWhiteOnHour, W
0307  00F4  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0308  222D  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdWhiteOnMinute); // Display minute in digits 6 and 7 (no dot)
0309  0853  	MOVF gbl_gBcdWhiteOnMinute, W
030A  00F4  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
030B  222D  	CALL bcdTo7Seg_00000

                    break;
030C  2BE5  	GOTO	label80

                case 2:
02D9  3A03  	XORLW 0x03
02DA  1903  	BTFSC STATUS,Z
02DB  2B0D  	GOTO	label59
030D        label59

                    // White LED on minute
                    iDigitToFlash = 7;
030D  3007  	MOVLW 0x07
030E  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
030F  3006  	MOVLW 0x06
0310  00E9  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOnMinute); // Display minute in digits 6 and 7 (no dot)
0311  0853  	MOVF gbl_gBcdWhiteOnMinute, W
0312  00F4  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0313  222D  	CALL bcdTo7Seg_00000

                    break;
0314  2BE5  	GOTO	label80

                case 3:
02DC  3A01  	XORLW 0x01
02DD  1903  	BTFSC STATUS,Z
02DE  2B15  	GOTO	label60
0315        label60

                    // White LED off hour
                    tm1638Data[3] = 0x71; // F
0315  3071  	MOVLW 0x71
0316  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
0317  3005  	MOVLW 0x05
0318  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
0319  3004  	MOVLW 0x04
031A  00E9  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOffHour); 
031B  0856  	MOVF gbl_gBcdWhiteOffHour, W
031C  00F4  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
031D  222D  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdWhiteOffMinute); // Display minute in digits 6 and 7 (no dot)
031E  0855  	MOVF gbl_gBcdWhiteOffMinute, W
031F  00F4  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0320  222D  	CALL bcdTo7Seg_00000

                    break;
0321  2BE5  	GOTO	label80

                case 4:
02DF  3A07  	XORLW 0x07
02E0  1903  	BTFSC STATUS,Z
02E1  2B22  	GOTO	label61
0322        label61

                    // White LED off minute
                    iDigitToFlash = 7;
0322  3007  	MOVLW 0x07
0323  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0324  3006  	MOVLW 0x06
0325  00E9  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOffMinute); // Display minute in digits 6 and 7 (no dot)
0326  0855  	MOVF gbl_gBcdWhiteOffMinute, W
0327  00F4  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0328  222D  	CALL bcdTo7Seg_00000

                    break;
0329  2BE5  	GOTO	label80

                case 5:
02E2  3A01  	XORLW 0x01
02E3  1903  	BTFSC STATUS,Z
02E4  2B2A  	GOTO	label62
032A        label62

                    // Blue LED on hour
                    tm1638Data[0] = 0x7C; // b
032A  307C  	MOVLW 0x7C
032B  00A0  	MOVWF gbl_tm1638Data

                    //tm1638Data[1] = 0x30; // l
                    //tm1638Data[2] = 0x3f; // O
                    tm1638Data[3] = 0x54; // n
032C  3054  	MOVLW 0x54
032D  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
032E  3005  	MOVLW 0x05
032F  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
0330  3004  	MOVLW 0x04
0331  00E9  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOnHour); // Display hour in digits 4 and 5 (dot on 5)
0332  0858  	MOVF gbl_gBcdBlueOnHour, W
0333  00F4  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0334  222D  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlueOnMinute); // Display minute in digits 6 and 7 (no dot)
0335  0857  	MOVF gbl_gBcdBlueOnMinute, W
0336  00F4  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0337  222D  	CALL bcdTo7Seg_00000

                    break;
0338  2BE5  	GOTO	label80

                case 6:
02E5  3A03  	XORLW 0x03
02E6  1903  	BTFSC STATUS,Z
02E7  2B39  	GOTO	label63
0339        label63

                    // Blue LED on minute
                    iDigitToFlash = 7;
0339  3007  	MOVLW 0x07
033A  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
033B  3006  	MOVLW 0x06
033C  00E9  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOnMinute); // Display minute in digits 6 and 7 (no dot)
033D  0857  	MOVF gbl_gBcdBlueOnMinute, W
033E  00F4  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
033F  222D  	CALL bcdTo7Seg_00000

                    break;
0340  2BE5  	GOTO	label80

                case 7:
02E8  3A01  	XORLW 0x01
02E9  1903  	BTFSC STATUS,Z
02EA  2B41  	GOTO	label64
0341        label64

                    // Blue LED off hour
                    tm1638Data[3] = 0x71; // F
0341  3071  	MOVLW 0x71
0342  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
0343  3005  	MOVLW 0x05
0344  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
0345  3004  	MOVLW 0x04
0346  00E9  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOffHour); // Display hour in digits 4 and 5 (dot on 5)
0347  085A  	MOVF gbl_gBcdBlueOffHour, W
0348  00F4  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0349  222D  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlueOffMinute); // Display minute in digits 6 and 7 (no dot)
034A  0859  	MOVF gbl_gBcdBlueOffMinute, W
034B  00F4  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
034C  222D  	CALL bcdTo7Seg_00000

                    break;
034D  2BE5  	GOTO	label80

                case 8:
02EB  3A0F  	XORLW 0x0F
02EC  1903  	BTFSC STATUS,Z
02ED  2B4E  	GOTO	label65
034E        label65

                    // Blue LED off minute
                    iDigitToFlash = 7;
034E  3007  	MOVLW 0x07
034F  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0350  3006  	MOVLW 0x06
0351  00E9  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOffMinute); // Display minute in digits 6 and 7 (no dot)
0352  0859  	MOVF gbl_gBcdBlueOffMinute, W
0353  00F4  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0354  222D  	CALL bcdTo7Seg_00000

                    break;
0355  2BE5  	GOTO	label80

                case 9:
02EE  3A01  	XORLW 0x01
02EF  1903  	BTFSC STATUS,Z
02F0  2B56  	GOTO	label66
0356        label66

                    // Fan on temperature
                    tm1638Data[0] = 0x71; // F
0356  3071  	MOVLW 0x71
0357  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x5F; // a
0358  305F  	MOVLW 0x5F
0359  00A1  	MOVWF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x54; // n
035A  3054  	MOVLW 0x54
035B  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x00; // space
035C  01A3  	CLRF gbl_tm1638Data+D'3'

                    tm1638Data[4] = 0x3f; // O
035D  303F  	MOVLW 0x3F
035E  00A4  	MOVWF gbl_tm1638Data+D'4'

                    tm1638Data[5] = 0x54; // n
035F  3054  	MOVLW 0x54
0360  00A5  	MOVWF gbl_tm1638Data+D'5'

                    iDigitToFlash = 7;
0361  3007  	MOVLW 0x07
0362  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0363  3006  	MOVLW 0x06
0364  00E9  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdFanOnTemp); // Display celcius in digits 6 and 7 (no dot)
0365  085B  	MOVF gbl_gBcdFanOnTemp, W
0366  00F4  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0367  222D  	CALL bcdTo7Seg_00000

                    break;
0368  2BE5  	GOTO	label80

                case 10:
02F1  3A03  	XORLW 0x03
02F2  1903  	BTFSC STATUS,Z
02F3  2B69  	GOTO	label67
0369        label67

                    // Fan off temperature
                    tm1638Data[5] = 0x71; // f
0369  3071  	MOVLW 0x71
036A  00A5  	MOVWF gbl_tm1638Data+D'5'

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
036B  3006  	MOVLW 0x06
036C  00E9  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdFanOffTemp); // Display celcius in digits 6 and 7 (no dot)
036D  085C  	MOVF gbl_gBcdFanOffTemp, W
036E  00F4  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
036F  222D  	CALL bcdTo7Seg_00000

                    break;
0370  2BE5  	GOTO	label80

                case 11:
02F4  3A01  	XORLW 0x01
02F5  1903  	BTFSC STATUS,Z
02F6  2B71  	GOTO	label68
0371        label68

                    // Heater on temperature
                    tm1638Data[0] = 0x76; // H
0371  3076  	MOVLW 0x76
0372  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x7B; // e
0373  307B  	MOVLW 0x7B
0374  00A1  	MOVWF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x5F; // a
0375  305F  	MOVLW 0x5F
0376  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x78; // t
0377  3078  	MOVLW 0x78
0378  00A3  	MOVWF gbl_tm1638Data+D'3'

                    tm1638Data[4] = 0x3f; // O
0379  303F  	MOVLW 0x3F
037A  00A4  	MOVWF gbl_tm1638Data+D'4'

                    tm1638Data[5] = 0x54; // n
037B  3054  	MOVLW 0x54
037C  00A5  	MOVWF gbl_tm1638Data+D'5'

                    iDigitToFlash = 7;
037D  3007  	MOVLW 0x07
037E  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
037F  3006  	MOVLW 0x06
0380  00E9  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdHeaterOnTemp); // Display celcius in digits 6 and 7 (no dot)
0381  085D  	MOVF gbl_gBcdHeaterOnTemp, W
0382  00F4  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0383  222D  	CALL bcdTo7Seg_00000

                    break;
0384  2BE5  	GOTO	label80

                case 12:
02F7  3A07  	XORLW 0x07
02F8  1903  	BTFSC STATUS,Z
02F9  2B85  	GOTO	label69
0385        label69

                    // Heater off temperature
                    tm1638Data[5] = 0x71; // f
0385  3071  	MOVLW 0x71
0386  00A5  	MOVWF gbl_tm1638Data+D'5'

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0387  3006  	MOVLW 0x06
0388  00E9  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdHeaterOffTemp); // Display celcius in digits 6 and 7 (no dot)
0389  085E  	MOVF gbl_gBcdHeaterOffTemp, W
038A  00F4  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
038B  222D  	CALL bcdTo7Seg_00000

                    break;
            }
        } else {
038C  2BE5  	GOTO	label80

            switch (gcSetMode) {
03A9        label76

                case 2:
038D  0850  	MOVF gbl_gcSetMode, W
038E  3A02  	XORLW 0x02
038F  1903  	BTFSC STATUS,Z
0390  2B9B  	GOTO	label71
039B        label71

                    iDigitToFlash = 3;
039B  3003  	MOVLW 0x03
039C  00C8  	MOVWF gbl_iDigitToFlash

                    break;
039D  2BA9  	GOTO	label76

                case 3:
0391  3A01  	XORLW 0x01
0392  1903  	BTFSC STATUS,Z
0393  2B9E  	GOTO	label72
039E        label72

                    iDigitToFlash = 1;
039E  3001  	MOVLW 0x01
039F  00C8  	MOVWF gbl_iDigitToFlash

                    break;
03A0  2BA9  	GOTO	label76

                case 6:
0394  3A05  	XORLW 0x05
0395  1903  	BTFSC STATUS,Z
0396  2BA1  	GOTO	label73
03A1        label73

                    iDigitToFlash = 5;
03A1  3005  	MOVLW 0x05
03A2  00C8  	MOVWF gbl_iDigitToFlash

                    break;
03A3  2BA9  	GOTO	label76

                case 7:
0397  3A01  	XORLW 0x01
0398  1903  	BTFSC STATUS,Z
0399  2BA4  	GOTO	label74
03A4        label74

                    iDigitToFlash = 7;
03A4  3007  	MOVLW 0x07
03A5  00C8  	MOVWF gbl_iDigitToFlash

                    break;
03A6  2BA9  	GOTO	label76

                default:
039A  2BA7  	GOTO	label75
03A7        label75

                    iDigitToFlash = 8;
03A7  3008  	MOVLW 0x08
03A8  00C8  	MOVWF gbl_iDigitToFlash

            }
            // Display date DD.MM
            iPrintStartDigit = 0;
03A9  01E9  	CLRF gbl_iPrintStartDigit

            iPrintDotDigit = 1;
03AA  3001  	MOVLW 0x01
03AB  00EA  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(gBcdDayOfMonth); // Display day of month in digits 0 and 1 (+dot on 1)
03AC  0839  	MOVF gbl_gBcdDayOfMonth, W
03AD  00F4  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03AE  222D  	CALL bcdTo7Seg_00000

            iPrintDotDigit = 3;
03AF  3003  	MOVLW 0x03
03B0  00EA  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(gBcdMonth); // Display month in digits 2 and 3 (+dot on 3)
03B1  083A  	MOVF gbl_gBcdMonth, W
03B2  00F4  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03B3  222D  	CALL bcdTo7Seg_00000

        }
    } else {
03B4  2BE5  	GOTO	label80

        iDigitToFlash = 8; // No flashing digit in this mode
03B5  3008  	MOVLW 0x08
03B6  00C8  	MOVWF gbl_iDigitToFlash

        // translate DS3231 temperature to digit values
        iPrintDotDigit = 1;
03B7  3001  	MOVLW 0x01
03B8  00EA  	MOVWF gbl_iPrintDotDigit

        if (gcDisplayMode == 1) // no dot on the first two digits for fahrenheit
03B9  034F  	DECF gbl_gcDisplayMode, W
03BA  1D03  	BTFSS STATUS,Z
03BB  2BBE  	GOTO	label78
03BE        label78

			iPrintDotDigit = 2;
03BC  3002  	MOVLW 0x02
03BD  00EA  	MOVWF gbl_iPrintDotDigit

        // For -10 or below, shift digits right
        if (gbDS3231IsMinus && (giDS3231ValueBCD & 0xF000)) {
03BE  08CC  	MOVF gbl_gbDS3231IsMinus, F
03BF  1903  	BTFSC STATUS,Z
03C0  2BD3  	GOTO	label79
03C1  30F0  	MOVLW 0xF0
03C2  0534  	ANDWF gbl_giDS3231ValueBCD+D'1', W
03C3  1903  	BTFSC STATUS,Z
03C4  2BD3  	GOTO	label79
03D3        label79

            giDS3231ValueBCD >>= 4;
03C5  0D34  	RLF gbl_giDS3231ValueBCD+D'1', W
03C6  0CB4  	RRF gbl_giDS3231ValueBCD+D'1', F
03C7  0CB3  	RRF gbl_giDS3231ValueBCD, F
03C8  0D34  	RLF gbl_giDS3231ValueBCD+D'1', W
03C9  0CB4  	RRF gbl_giDS3231ValueBCD+D'1', F
03CA  0CB3  	RRF gbl_giDS3231ValueBCD, F
03CB  0D34  	RLF gbl_giDS3231ValueBCD+D'1', W
03CC  0CB4  	RRF gbl_giDS3231ValueBCD+D'1', F
03CD  0CB3  	RRF gbl_giDS3231ValueBCD, F
03CE  0D34  	RLF gbl_giDS3231ValueBCD+D'1', W
03CF  0CB4  	RRF gbl_giDS3231ValueBCD+D'1', F
03D0  0CB3  	RRF gbl_giDS3231ValueBCD, F

            iPrintDotDigit = 2;
03D1  3002  	MOVLW 0x02
03D2  00EA  	MOVWF gbl_iPrintDotDigit

        }
        // Display current temperature in digits 0 to 3 (+dot on digit 1 and 3)
        iPrintStartDigit = 0;
03D3  01E9  	CLRF gbl_iPrintStartDigit

        bcdTo7Seg(giDS3231ValueBCD >> 8);
03D4  0834  	MOVF gbl_giDS3231ValueBCD+D'1', W
03D5  00F4  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03D6  222D  	CALL bcdTo7Seg_00000

        bcdTo7Seg(giDS3231ValueBCD);
03D7  0833  	MOVF gbl_giDS3231ValueBCD, W
03D8  00F4  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03D9  222D  	CALL bcdTo7Seg_00000

        // Also display dot on 4th digit (always)
		//tm1638Data[3] = tm1638Data[3] + tm1638Dot;
		tm1638Data[3] |= tm1638Dot;
03DA  0861  	MOVF gbl_tm1638Dot, W
03DB  04A3  	IORWF gbl_tm1638Data+D'3', F


        // left fill zero with blank
        if (tm1638Data[0] == 0x3f)
03DC  0820  	MOVF gbl_tm1638Data, W
03DD  3A3F  	XORLW 0x3F
03DE  1903  	BTFSC STATUS,Z

            tm1638Data[0] = 0;
03DF  01A0  	CLRF gbl_tm1638Data

        // If minus, overwrite left most digit with minus sign
        if (gbDS3231IsMinus)
03E0  08CC  	MOVF gbl_gbDS3231IsMinus, F
03E1  1903  	BTFSC STATUS,Z
03E2  2BE5  	GOTO	label80
03E5        label80

            tm1638Data[0] = 0x40;
03E3  3040  	MOVLW 0x40
03E4  00A0  	MOVWF gbl_tm1638Data

    }

    // HH.MM in last 4 digits of TM1638
    if (!gcTriggerMode) {
03E5  08D2  	MOVF gbl_gcTriggerMode, F
03E6  1D03  	BTFSS STATUS,Z
03E7  2C17  	GOTO	label86
0417        label86

        iPrintStartDigit = 4;
03E8  3004  	MOVLW 0x04
03E9  00E9  	MOVWF gbl_iPrintStartDigit

        // Flash dot every second
        if (gBcdSecond.0)
03EA  1C35  	BTFSS gbl_gBcdSecond,0
03EB  2BEF  	GOTO	label81
03EF        label81

			iPrintDotDigit = 5;
03EC  3005  	MOVLW 0x05
03ED  00EA  	MOVWF gbl_iPrintDotDigit

		else
03EE  2BF1  	GOTO	label82
03F1        label82

			iPrintDotDigit = 8;
03EF  3008  	MOVLW 0x08
03F0  00EA  	MOVWF gbl_iPrintDotDigit

        char cBcdHourDisp = gBcdHour;
03F1  0837  	MOVF gbl_gBcdHour, W
03F2  00F3  	MOVWF tm1638Upda_00022_159_cBcdH_00024

        if (gcHourMode && (gBcdHour > 0x12)) {
03F3  08D1  	MOVF gbl_gcHourMode, F
03F4  1903  	BTFSC STATUS,Z
03F5  2BFC  	GOTO	label83
03F6  0837  	MOVF gbl_gBcdHour, W
03F7  3C12  	SUBLW 0x12
03F8  1803  	BTFSC STATUS,C
03F9  2BFC  	GOTO	label83
03FC        label83

			// convert to 12h
			cBcdHourDisp -= 0x12;
03FA  3012  	MOVLW 0x12
03FB  02F3  	SUBWF tm1638Upda_00022_159_cBcdH_00024, F

        }
        if (gcHourMode && gBcdHour == 0) {
03FC  08D1  	MOVF gbl_gcHourMode, F
03FD  1903  	BTFSC STATUS,Z
03FE  2C04  	GOTO	label84
03FF  08B7  	MOVF gbl_gBcdHour, F
0400  1D03  	BTFSS STATUS,Z
0401  2C04  	GOTO	label84
0404        label84

			cBcdHourDisp = 0x12; // 12am
0402  3012  	MOVLW 0x12
0403  00F3  	MOVWF tm1638Upda_00022_159_cBcdH_00024

        }
        bcdTo7Seg(cBcdHourDisp); // Display hour in digits 4 and 5 (dot on 5)
0404  0873  	MOVF tm1638Upda_00022_159_cBcdH_00024, W
0405  00F4  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0406  222D  	CALL bcdTo7Seg_00000

        // left fill zero with blank
        if (tm1638Data[4] == 0x3f)
0407  0824  	MOVF gbl_tm1638Data+D'4', W
0408  3A3F  	XORLW 0x3F
0409  1903  	BTFSC STATUS,Z

            tm1638Data[4] = 0;
040A  01A4  	CLRF gbl_tm1638Data+D'4'

        if (gcHourMode && (gBcdHour > 0x11)) {
040B  08D1  	MOVF gbl_gcHourMode, F
040C  1903  	BTFSC STATUS,Z
040D  2C14  	GOTO	label85
040E  0837  	MOVF gbl_gBcdHour, W
040F  3C11  	SUBLW 0x11
0410  1803  	BTFSC STATUS,C
0411  2C14  	GOTO	label85
0414        label85

			// PM dot
			iPrintDotDigit = 7;
0412  3007  	MOVLW 0x07
0413  00EA  	MOVWF gbl_iPrintDotDigit

        }
        bcdTo7Seg(gBcdMinute); // Display minute in digits 6 and 7 (no dot)
0414  0836  	MOVF gbl_gBcdMinute, W
0415  00F4  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0416  222D  	CALL bcdTo7Seg_00000

    }

    // Light LED for set mode
    char cCompareSetMode = gcSetMode;
0417  0850  	MOVF gbl_gcSetMode, W
0418  00F0  	MOVWF tm1638Upda_00022_1_cCompar_00023

    for (char i = 2; i < 8; i++) {
0419  3002  	MOVLW 0x02
041A  00F2  	MOVWF tm1638Upda_00022_3_i
041B        label87
041B  3008  	MOVLW 0x08
041C  0272  	SUBWF tm1638Upda_00022_3_i, W
041D  1803  	BTFSC STATUS,C
041E  2C34  	GOTO	label90
0432  0AF2  	INCF tm1638Upda_00022_3_i, F
0433  2C1B  	GOTO	label87
0434        label90

        if (i == cCompareSetMode)
041F  0870  	MOVF tm1638Upda_00022_1_cCompar_00023, W
0420  0672  	XORWF tm1638Upda_00022_3_i, W
0421  1D03  	BTFSS STATUS,Z
0422  2C2B  	GOTO	label88
042B        label88

            tm1638LEDs[i] = 1;
0423  1383  	BCF	STATUS,IRP
0424  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
0425  0084  	MOVWF FSR
0426  0872  	MOVF tm1638Upda_00022_3_i, W
0427  0784  	ADDWF FSR, F
0428  3001  	MOVLW 0x01
0429  0080  	MOVWF INDF

        else
042A  2C32  	GOTO	label89
0432        label89

            tm1638LEDs[i] = 0;
042B  1383  	BCF	STATUS,IRP
042C  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
042D  0084  	MOVWF FSR
042E  0872  	MOVF tm1638Upda_00022_3_i, W
042F  0784  	ADDWF FSR, F
0430  3000  	MOVLW 0x00
0431  0080  	MOVWF INDF

    }
    tm1638LEDs[0] = HEATER;
0434  01A8  	CLRF gbl_tm1638LEDs
0435  1805  	BTFSC gbl_porta,0
0436  0AA8  	INCF gbl_tm1638LEDs, F

    tm1638LEDs[1] = FAN;
0437  01A9  	CLRF gbl_tm1638LEDs+D'1'
0438  1885  	BTFSC gbl_porta,1
0439  0AA9  	INCF gbl_tm1638LEDs+D'1', F


    // Write 0x40 [01000000] (table 5.1) to indicate command to display data - [Write data to display register]
    tm1638strobe = 0;
043A  1186  	BCF gbl_portb,3

    tm1638ByteWrite(tm1638ByteSetData);
043B  0863  	MOVF gbl_tm1638ByteSetData, W
043C  00F2  	MOVWF tm1638Byte_0001F_arg_bWrite
043D  215B  	CALL tm1638Byte_0001F

    tm1638strobe = 1;
043E  1586  	BSF gbl_portb,3

    
    tm1638strobe = 0;
043F  1186  	BCF gbl_portb,3

    // Specify the display address 0xC0 [11000000] (table 5.2) [Display address 00H] then write out all 16 bytes
    tm1638ByteWrite(tm1638ByteSetAddr);
0440  0865  	MOVF gbl_tm1638ByteSetAddr, W
0441  00F2  	MOVWF tm1638Byte_0001F_arg_bWrite
0442  215B  	CALL tm1638Byte_0001F

    for (char i = 0; i < tm1638MaxDigits; i++) {
0443  01F1  	CLRF tm1638Upda_00022_2_i
0444        label91
0444  085F  	MOVF gbl_tm1638MaxDigits, W
0445  0271  	SUBWF tm1638Upda_00022_2_i, W
0446  1803  	BTFSC STATUS,C
0447  2C63  	GOTO	label94
0461  0AF1  	INCF tm1638Upda_00022_2_i, F
0462  2C44  	GOTO	label91
0463        label94

        // display digit first
        if (iFlashDigitOff.0 && (i == iDigitToFlash))
0448  1C3F  	BTFSS gbl_iFlashDigitOff,0
0449  2C51  	GOTO	label92
044A  0848  	MOVF gbl_iDigitToFlash, W
044B  0671  	XORWF tm1638Upda_00022_2_i, W
044C  1D03  	BTFSS STATUS,Z
044D  2C51  	GOTO	label92
0451        label92

            tm1638ByteWrite(0);
044E  01F2  	CLRF tm1638Byte_0001F_arg_bWrite
044F  215B  	CALL tm1638Byte_0001F

        else
0450  2C59  	GOTO	label93
0459        label93

            tm1638ByteWrite(tm1638Data[i]);
0451  1383  	BCF	STATUS,IRP
0452  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
0453  0084  	MOVWF FSR
0454  0871  	MOVF tm1638Upda_00022_2_i, W
0455  0784  	ADDWF FSR, F
0456  0800  	MOVF INDF, W
0457  00F2  	MOVWF tm1638Byte_0001F_arg_bWrite
0458  215B  	CALL tm1638Byte_0001F

        // then LED
        tm1638ByteWrite(tm1638LEDs[i]);
0459  1383  	BCF	STATUS,IRP
045A  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
045B  0084  	MOVWF FSR
045C  0871  	MOVF tm1638Upda_00022_2_i, W
045D  0784  	ADDWF FSR, F
045E  0800  	MOVF INDF, W
045F  00F2  	MOVWF tm1638Byte_0001F_arg_bWrite
0460  215B  	CALL tm1638Byte_0001F

    }
    tm1638strobe = 1;
0463  1586  	BSF gbl_portb,3

}
0464  0008  	RETURN


/*********************************************************************************************
  void tm1638ReadKeys()
  Reads the keys status into tm1638Keys
*********************************************************************************************/
void tm1638ReadKeys() {

    // Write 0x42 [01000010] to indicate command to read data
    tm1638strobe = 0;
0709  1283  	BCF STATUS, RP0
070A  1303  	BCF STATUS, RP1
070B  1186  	BCF gbl_portb,3

    tm1638ByteWrite(tm1638ByteReadData);
070C  0864  	MOVF gbl_tm1638ByteReadData, W
070D  00F2  	MOVWF tm1638Byte_0001F_arg_bWrite
070E  215B  	CALL tm1638Byte_0001F

    
    tm1638dioTris = 1; // Set data pin to input
070F  1683  	BSF STATUS, RP0
0710  1486  	BSF gbl_trisb,1

    char tm1638KeysTemp = 32;
0711  3020  	MOVLW 0x20
0712  1283  	BCF STATUS, RP0
0713  00EE  	MOVWF tm1638Read_00025_1_tm1638K_00026

    // Read 4 bytes
    for (char i = 0; i < 32; i++) {
0714  01EF  	CLRF tm1638Read_00025_2_i
0715        label126
0715  3020  	MOVLW 0x20
0716  026F  	SUBWF tm1638Read_00025_2_i, W
0717  1803  	BTFSC STATUS,C
0718  2F25  	GOTO	label128
0723  0AEF  	INCF tm1638Read_00025_2_i, F
0724  2F15  	GOTO	label126
0725        label128

        tm1638KeysTemp--;
0719  03EE  	DECF tm1638Read_00025_1_tm1638K_00026, F

        tm1638clk = 0;
071A  1106  	BCF gbl_portb,2

        delay_us(1);
071B  3001  	MOVLW 0x01
071C  00F4  	MOVWF delay_us_00000_arg_del
071D  2010  	CALL delay_us_00000

        if(tm1638dio)
071E  1C86  	BTFSS gbl_portb,1
071F  2F22  	GOTO	label127
0722        label127

            tm1638KeysTemp <<= 1;
0720  1003  	BCF STATUS,C
0721  0DEE  	RLF tm1638Read_00025_1_tm1638K_00026, F

        tm1638clk = 1;
0722  1506  	BSF gbl_portb,2

    }
    tm1638dioTris = 0; // Set data pin to output
0725  1683  	BSF STATUS, RP0
0726  1086  	BCF gbl_trisb,1

    tm1638strobe = 1;
0727  1283  	BCF STATUS, RP0
0728  1586  	BSF gbl_portb,3


    tm1638Keys = tm1638KeysTemp;
0729  086E  	MOVF tm1638Read_00025_1_tm1638K_00026, W
072A  00E7  	MOVWF gbl_tm1638Keys

    /*
    1F = 0001 1111
	17 = 0001 0111
	0F = 0000 1111
	07 = 0000 0111
	1B = 0001 1011
	13 = 0001 0011
	0B = 0000 1011
	03 = 0000 0111
	*/
}
072B  0008  	RETURN


/*********************************************************************************************
  int intToBcd(int iValue)
  Used to split the 16 bit integer into bcd parts (max 9999)
*********************************************************************************************/
int intToBcd(int iValue) {

    int iBcdOut = 0;
018A  01F8  	CLRF intToBcd_00000_1_iBcdOut
018B  01F9  	CLRF intToBcd_00000_1_iBcdOut+D'1'

    // simple way, but more program memory needed for PIC12 or PIC16 (more than 100 words more)
    //iBcdOut = iValue / 1000;
    //iOutput += (iValue / 100) % 10;
    //iBcdOut += (iValue / 10) % 10;
    //iBcdOut += iValue % 10;
    
    // Double Dabble
    // Less program memory needed - may be slower executing
    // https://www.electro-tech-online.com/threads/32bit-bin2bcd-casting.126235/#post-1047937
    // Init the 16-bit BCD value to zero - output only supporting an input value up to 9999 in this implementation
    /*iBcdOut = 0;
    int iMask;
    // 48 loops
    // Shift 12 times
    for(char i = 0; i < 12; i++){
        // Check if any nibble is 5 or greater
        // Start with the right most nibble (digit), shifting 4 bits each time
        //for(; iMask != 0; iMask >>= 4){
        iMask = 0xF000; // Start checking the thousands digit 10^3
        for (char j = 0; j < 4; j++) {
            // For the digit we're checking, if bcd value is greater than or equal to 5, add 3
            if ((iMask & iBcdOut) >= (iMask & 0x5555))
                iBcdOut += (iMask & 0x3333); // Add 3
            iMask = iMask >> 4; // Shift the mask byte 4 bits (one nibble) right
        }
        // Shift bcd value
        iBcdOut <<= 1;
        // Increment bcd value (right most bit) if left most bit is set in the input byte
        if (iValue & 0x8000)
            iBcdOut++;
        // Shift input value
        iValue <<= 1;
    }*/
    
    // less program memory needed - may be slower executing
    // https://electronics.stackexchange.com/questions/158563/how-to-split-a-floating-point-number-into-individual-digits
    iBcdOut = 0;
018C  01F8  	CLRF intToBcd_00000_1_iBcdOut
018D  01F9  	CLRF intToBcd_00000_1_iBcdOut+D'1'


    // incrementing variables for each digit
    // determine to thousands digit
    while (iValue >= 1000) {
018E        label28
018E  3003  	MOVLW 0x03
018F  0277  	SUBWF intToBcd_00000_arg_iValue+D'1', W
0190  1D03  	BTFSS STATUS,Z
0191  2994  	GOTO	label29
0192  30E8  	MOVLW 0xE8
0193  0276  	SUBWF intToBcd_00000_arg_iValue, W
0194        label29
0194  1C03  	BTFSS STATUS,C
0195  29A1  	GOTO	label30
0196  1BF7  	BTFSC intToBcd_00000_arg_iValue+D'1',7
0197  29A1  	GOTO	label30
01A0  298E  	GOTO	label28
01A1        label30

        iValue -= 1000;
0198  30E8  	MOVLW 0xE8
0199  02F6  	SUBWF intToBcd_00000_arg_iValue, F
019A  3003  	MOVLW 0x03
019B  1C03  	BTFSS STATUS,C
019C  03F7  	DECF intToBcd_00000_arg_iValue+D'1', F
019D  02F7  	SUBWF intToBcd_00000_arg_iValue+D'1', F

        // each time we take off 1000, the digit is incremented
        iBcdOut += 0x1000;
019E  3010  	MOVLW 0x10
019F  07F9  	ADDWF intToBcd_00000_1_iBcdOut+D'1', F

    }

    // determine to hundreds digit
    while (iValue >= 100) {
01A1  0877  	MOVF intToBcd_00000_arg_iValue+D'1', W
01A2  3A80  	XORLW 0x80
01A3  00FA  	MOVWF CompTempVar645
01A4  3080  	MOVLW 0x80
01A5  027A  	SUBWF CompTempVar645, W
01A6  1D03  	BTFSS STATUS,Z
01A7  29AA  	GOTO	label31
01A8  3064  	MOVLW 0x64
01A9  0276  	SUBWF intToBcd_00000_arg_iValue, W
01AA        label31
01AA  1C03  	BTFSS STATUS,C
01AB  29B2  	GOTO	label32
01B1  29A1  	GOTO	label30
01B2        label32

        iValue -= 100;
01AC  3064  	MOVLW 0x64
01AD  02F6  	SUBWF intToBcd_00000_arg_iValue, F
01AE  1C03  	BTFSS STATUS,C
01AF  03F7  	DECF intToBcd_00000_arg_iValue+D'1', F

        // each time we take off 100, the digit is incremented
        iBcdOut += 0x100;
01B0  0AF9  	INCF intToBcd_00000_1_iBcdOut+D'1', F

    }

    // determine to tens digit
    while (iValue >= 10) {
01B2  0877  	MOVF intToBcd_00000_arg_iValue+D'1', W
01B3  3A80  	XORLW 0x80
01B4  00FA  	MOVWF CompTempVar646
01B5  3080  	MOVLW 0x80
01B6  027A  	SUBWF CompTempVar646, W
01B7  1D03  	BTFSS STATUS,Z
01B8  29BB  	GOTO	label33
01B9  300A  	MOVLW 0x0A
01BA  0276  	SUBWF intToBcd_00000_arg_iValue, W
01BB        label33
01BB  1C03  	BTFSS STATUS,C
01BC  29C6  	GOTO	label34
01C5  29B2  	GOTO	label32
01C6        label34

        iValue -= 10;
01BD  300A  	MOVLW 0x0A
01BE  02F6  	SUBWF intToBcd_00000_arg_iValue, F
01BF  1C03  	BTFSS STATUS,C
01C0  03F7  	DECF intToBcd_00000_arg_iValue+D'1', F

        // each time we take off 10, the left most digit is incremented
        iBcdOut += 0x10;
01C1  3010  	MOVLW 0x10
01C2  07F8  	ADDWF intToBcd_00000_1_iBcdOut, F
01C3  1803  	BTFSC STATUS,C
01C4  0AF9  	INCF intToBcd_00000_1_iBcdOut+D'1', F

    }

    // the last digit is what's left on iValue
    iBcdOut += iValue;
01C6  0876  	MOVF intToBcd_00000_arg_iValue, W
01C7  07F8  	ADDWF intToBcd_00000_1_iBcdOut, F
01C8  0877  	MOVF intToBcd_00000_arg_iValue+D'1', W
01C9  1803  	BTFSC STATUS,C
01CA  0AF9  	INCF intToBcd_00000_1_iBcdOut+D'1', F
01CB  07F9  	ADDWF intToBcd_00000_1_iBcdOut+D'1', F

}
01CC  0008  	RETURN


/*********************************************************************************************
  void convertTemp()
  Used to convert the ds18b20 temperature to display values
*********************************************************************************************/
void convertTemp() {

    // convert both bytes to a 16bit int - e.g. 0000 0001 0100 0110 (1 and 70, gives 326)
    signed int iTemp = (cTempH << 8) | cTempL;
04E1  1283  	BCF STATUS, RP0
04E2  1303  	BCF STATUS, RP1
04E3  01EE  	CLRF convertTem_0002A_1_iTemp
04E4  0849  	MOVF gbl_cTempH, W
04E5  00EF  	MOVWF convertTem_0002A_1_iTemp+D'1'
04E6  084A  	MOVF gbl_cTempL, W
04E7  04EE  	IORWF convertTem_0002A_1_iTemp, F

    signed int iTemp2 = iTemp;
04E8  086E  	MOVF convertTem_0002A_1_iTemp, W
04E9  00F0  	MOVWF convertTem_0002A_1_iTemp2
04EA  086F  	MOVF convertTem_0002A_1_iTemp+D'1', W
04EB  00F1  	MOVWF convertTem_0002A_1_iTemp2+D'1'

    
    // this gets celcius * 100 - https://www.phanderson.com/PIC/PICC/sourceboost/ds18b20_1.html
    // Celcius value is always required for triggering
	gbDS3231IsMinus = (iTemp2 < 0);
04EC  01CC  	CLRF gbl_gbDS3231IsMinus
04ED  1BF1  	BTFSC convertTem_0002A_1_iTemp2+D'1',7
04EE  0ACC  	INCF gbl_gbDS3231IsMinus, F

	if (gbDS3231IsMinus) {
04EF  08CC  	MOVF gbl_gbDS3231IsMinus, F
04F0  1903  	BTFSC STATUS,Z
04F1  2CF7  	GOTO	label97

		iTemp2 = ~iTemp2 + 1;
04F2  09F0  	COMF convertTem_0002A_1_iTemp2, F
04F3  09F1  	COMF convertTem_0002A_1_iTemp2+D'1', F
04F4  0AF0  	INCF convertTem_0002A_1_iTemp2, F
04F5  1903  	BTFSC STATUS,Z
04F6  0AF1  	INCF convertTem_0002A_1_iTemp2+D'1', F
04F7        label97

	}
    int iValueC = (6 * iTemp2) + (iTemp2 / 4);
04F7  3006  	MOVLW 0x06
04F8  00F6  	MOVWF __mul_16s__0000F_arg_a
04F9  01F7  	CLRF __mul_16s__0000F_arg_a+D'1'
04FA  0870  	MOVF convertTem_0002A_1_iTemp2, W
04FB  00F8  	MOVWF __mul_16s__0000F_arg_b
04FC  0871  	MOVF convertTem_0002A_1_iTemp2+D'1', W
04FD  00F9  	MOVWF __mul_16s__0000F_arg_b+D'1'
04FE  225F  	CALL __mul_16s__0000F
04FF  087D  	MOVF CompTempVarRet389, W
0500  00F2  	MOVWF convertTem_0002A_1_iValueC
0501  087E  	MOVF CompTempVarRet389+D'1', W
0502  00F5  	MOVWF CompTempVar623
0503  0870  	MOVF convertTem_0002A_1_iTemp2, W
0504  00F4  	MOVWF CompTempVar620
0505  0871  	MOVF convertTem_0002A_1_iTemp2+D'1', W
0506  00F3  	MOVWF convertTem_0002A_1_iValueC+D'1'
0507  0D71  	RLF convertTem_0002A_1_iTemp2+D'1', W
0508  0CF3  	RRF convertTem_0002A_1_iValueC+D'1', F
0509  0CF4  	RRF CompTempVar620, F
050A  0D71  	RLF convertTem_0002A_1_iTemp2+D'1', W
050B  0CF3  	RRF convertTem_0002A_1_iValueC+D'1', F
050C  0CF4  	RRF CompTempVar620, F
050D  0874  	MOVF CompTempVar620, W
050E  07F2  	ADDWF convertTem_0002A_1_iValueC, F
050F  0875  	MOVF CompTempVar623, W
0510  1803  	BTFSC STATUS,C
0511  0AF3  	INCF convertTem_0002A_1_iValueC+D'1', F
0512  07F3  	ADDWF convertTem_0002A_1_iValueC+D'1', F

    // Split the temperature reading into digits
    giDS3231ValueBCD = intToBcd(iValueC);
0513  0872  	MOVF convertTem_0002A_1_iValueC, W
0514  00F6  	MOVWF intToBcd_00000_arg_iValue
0515  0873  	MOVF convertTem_0002A_1_iValueC+D'1', W
0516  00F7  	MOVWF intToBcd_00000_arg_iValue+D'1'
0517  218A  	CALL intToBcd_00000
0518  0878  	MOVF CompTempVarRet644, W
0519  00B3  	MOVWF gbl_giDS3231ValueBCD
051A  0879  	MOVF CompTempVarRet644+D'1', W
051B  00B4  	MOVWF gbl_giDS3231ValueBCD+D'1'

    // Truncated value for triggering heater/fans
    giDS3231ValueTruncCBCD = giDS3231ValueBCD >> 8;
051C  0834  	MOVF gbl_giDS3231ValueBCD+D'1', W
051D  00CB  	MOVWF gbl_giDS3231ValueTruncCBCD

    
    if (gcDisplayMode == 1) {
051E  034F  	DECF gbl_gcDisplayMode, W
051F  1D03  	BTFSS STATUS,Z

		// -17.8125 (-285/65251) results in minus fahrenheit (-0.125), -17.75 (-284/65250) results in positive fahrenheit (1)
        // this gets Fahrenheit * 10 - https://www.electro-tech-online.com/threads/temperature-sensor-ds18b20-display-fahrenhiet.117377/
        iTemp2 = ((iTemp + 4) / 8) + iTemp + 320;
0521  3004  	MOVLW 0x04
0522  076E  	ADDWF convertTem_0002A_1_iTemp, W
0523  00F7  	MOVWF CompTempVar635
0524  086F  	MOVF convertTem_0002A_1_iTemp+D'1', W
0525  00F9  	MOVWF CompTempVar638
0526  1803  	BTFSC STATUS,C
0527  0AF9  	INCF CompTempVar638, F
0528  0879  	MOVF CompTempVar638, W
0529  00F6  	MOVWF CompTempVar632
052A  0D79  	RLF CompTempVar638, W
052B  0CF6  	RRF CompTempVar632, F
052C  0CF7  	RRF CompTempVar635, F
052D  0D79  	RLF CompTempVar638, W
052E  0CF6  	RRF CompTempVar632, F
052F  0CF7  	RRF CompTempVar635, F
0530  0D79  	RLF CompTempVar638, W
0531  0CF6  	RRF CompTempVar632, F
0532  0CF7  	RRF CompTempVar635, F
0533  086E  	MOVF convertTem_0002A_1_iTemp, W
0534  07F7  	ADDWF CompTempVar635, F
0535  086F  	MOVF convertTem_0002A_1_iTemp+D'1', W
0536  00F8  	MOVWF CompTempVar636
0537  0876  	MOVF CompTempVar632, W
0538  1803  	BTFSC STATUS,C
0539  0AF8  	INCF CompTempVar636, F
053A  07F8  	ADDWF CompTempVar636, F
053B  3040  	MOVLW 0x40
053C  07F7  	ADDWF CompTempVar635, F
053D  3001  	MOVLW 0x01
053E  1803  	BTFSC STATUS,C
053F  0AF8  	INCF CompTempVar636, F
0540  07F8  	ADDWF CompTempVar636, F
0541  0877  	MOVF CompTempVar635, W
0542  00F0  	MOVWF convertTem_0002A_1_iTemp2
0543  0878  	MOVF CompTempVar636, W
0544  00F1  	MOVWF convertTem_0002A_1_iTemp2+D'1'

        // convert to absolute value
        gbDS3231IsMinus = (iTemp2 < 0);
0545  01CC  	CLRF gbl_gbDS3231IsMinus
0546  1BF1  	BTFSC convertTem_0002A_1_iTemp2+D'1',7
0547  0ACC  	INCF gbl_gbDS3231IsMinus, F

        if (gbDS3231IsMinus) {
0548  08CC  	MOVF gbl_gbDS3231IsMinus, F
0549  1903  	BTFSC STATUS,Z
054A  2D50  	GOTO	label98

            iTemp2 = ~iTemp2 + 1;
054B  09F0  	COMF convertTem_0002A_1_iTemp2, F
054C  09F1  	COMF convertTem_0002A_1_iTemp2+D'1', F
054D  0AF0  	INCF convertTem_0002A_1_iTemp2, F
054E  1903  	BTFSC STATUS,Z
054F  0AF1  	INCF convertTem_0002A_1_iTemp2+D'1', F
0550        label98

        }
        // Split the temperature reading into digits
        giDS3231ValueBCD = intToBcd(iTemp2);
0550  0870  	MOVF convertTem_0002A_1_iTemp2, W
0551  00F6  	MOVWF intToBcd_00000_arg_iValue
0552  0871  	MOVF convertTem_0002A_1_iTemp2+D'1', W
0553  00F7  	MOVWF intToBcd_00000_arg_iValue+D'1'
0554  218A  	CALL intToBcd_00000
0555  0878  	MOVF CompTempVarRet644, W
0556  00B3  	MOVWF gbl_giDS3231ValueBCD
0557  0879  	MOVF CompTempVarRet644+D'1', W
0558  00B4  	MOVWF gbl_giDS3231ValueBCD+D'1'

	}
}
0520  0008  	RETURN
0559  0008  	RETURN


/*********************************************************************************************
  void startTemp()
  Sends the Convert T [44h] function command to the ds18b20
*********************************************************************************************/
void startTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // 44 is the convert function
    oneWireTxBytes(0xCC, 0x44);
072C  30CC  	MOVLW 0xCC
072D  1283  	BCF STATUS, RP0
072E  1303  	BCF STATUS, RP1
072F  00EE  	MOVWF oneWireTxB_00019_arg_cData
0730  3044  	MOVLW 0x44
0731  00EF  	MOVWF oneWireTxB_00019_arg_cData2
0732  246D  	CALL oneWireTxB_00019

}
0733  0008  	RETURN


/*********************************************************************************************
  void startTemp()
  Sends the Read Scratchpad [BEh] function command to the ds18b20
*********************************************************************************************/
void readTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // BE indicates to read scratchpad
    oneWireTxBytes(0xCC, 0xBE);
0734  30CC  	MOVLW 0xCC
0735  1283  	BCF STATUS, RP0
0736  1303  	BCF STATUS, RP1
0737  00EE  	MOVWF oneWireTxB_00019_arg_cData
0738  30BE  	MOVLW 0xBE
0739  00EF  	MOVWF oneWireTxB_00019_arg_cData2
073A  246D  	CALL oneWireTxB_00019

    // Now get the temperature from the scratchpad
    // This is in the first two bytes - so get those only and ignore the rest
    cTempL = oneWireRxByte();
073B  2474  	CALL oneWireRxB_0001A
073C  086F  	MOVF CompTempVarRet551, W
073D  00CA  	MOVWF gbl_cTempL

    cTempH = oneWireRxByte();
073E  2474  	CALL oneWireRxB_0001A
073F  086F  	MOVF CompTempVarRet551, W
0740  00C9  	MOVWF gbl_cTempH

}
0741  0008  	RETURN


/*********************************************************************************************
  char bcdAdjust(char bcd, char bcdMax, char bcdMin)
  Increment or Decrement a BCD variable for sending to the DS3231, within a given range
  Must set iBcdAdjustment first
*********************************************************************************************/
char bcdAdjust(char bcd, char bcdMax, char bcdMin) {

    if (iBcdAdjustment == 1) {
0235  036B  	DECF gbl_iBcdAdjustment, W
0236  1D03  	BTFSS STATUS,Z
0237  2A4B  	GOTO	label46
024B        label46

        // Increment
        // if at maximum, reset to minimum
        if (bcd == bcdMax)
0238  0871  	MOVF bcdAdjust_00000_arg_bcdMax, W
0239  0670  	XORWF bcdAdjust_00000_arg_bcd, W
023A  1D03  	BTFSS STATUS,Z
023B  2A3F  	GOTO	label44
023F        label44

            bcd = bcdMin;
023C  0872  	MOVF bcdAdjust_00000_arg_bcdMin, W
023D  00F0  	MOVWF bcdAdjust_00000_arg_bcd

        else if ((bcd & 0x0F) == 9)
023E  2A5C  	GOTO	label49
023F  300F  	MOVLW 0x0F
0240  0570  	ANDWF bcdAdjust_00000_arg_bcd, W
0241  00F3  	MOVWF CompTempVar609
0242  0873  	MOVF CompTempVar609, W
0243  3A09  	XORLW 0x09
0244  1D03  	BTFSS STATUS,Z
0245  2A49  	GOTO	label45
0249        label45

            bcd += 0x07; // add 0x10 (16), minus 9
0246  3007  	MOVLW 0x07
0247  07F0  	ADDWF bcdAdjust_00000_arg_bcd, F

        else
0248  2A5C  	GOTO	label49

            bcd++;
0249  0AF0  	INCF bcdAdjust_00000_arg_bcd, F

    } else {
024A  2A5C  	GOTO	label49

        // Decrement
        // if at minimum, reset to maximum
        if (bcd == bcdMin)
024B  0872  	MOVF bcdAdjust_00000_arg_bcdMin, W
024C  0670  	XORWF bcdAdjust_00000_arg_bcd, W
024D  1D03  	BTFSS STATUS,Z
024E  2A52  	GOTO	label47
0252        label47

            bcd = bcdMax;
024F  0871  	MOVF bcdAdjust_00000_arg_bcdMax, W
0250  00F0  	MOVWF bcdAdjust_00000_arg_bcd

        else if ((bcd & 0x0F) == 0)
0251  2A5C  	GOTO	label49
0252  300F  	MOVLW 0x0F
0253  0570  	ANDWF bcdAdjust_00000_arg_bcd, W
0254  00F3  	MOVWF CompTempVar610
0255  08F3  	MOVF CompTempVar610, F
0256  1D03  	BTFSS STATUS,Z
0257  2A5B  	GOTO	label48
025B        label48

            bcd -= 0x07; // minus 0x10 (16), add 9
0258  3007  	MOVLW 0x07
0259  02F0  	SUBWF bcdAdjust_00000_arg_bcd, F

        else
025A  2A5C  	GOTO	label49
025C        label49

            bcd--;
025B  03F0  	DECF bcdAdjust_00000_arg_bcd, F

    }
    return bcd;
025C  0870  	MOVF bcdAdjust_00000_arg_bcd, W
025D  00F3  	MOVWF CompTempVarRet608

}
025E  0008  	RETURN


/*********************************************************************************************
  void adjustDateTime()
  Increment or Decrement a BCD variable for sending to the DS3231, within a given range
  Must set iBcdAdjustment first
*********************************************************************************************/
void adjustDateTime() {

    switch (gcSetMode) {

        case 1:
0684  1283  	BCF STATUS, RP0
0685  1303  	BCF STATUS, RP1
0686  0850  	MOVF gbl_gcSetMode, W
0687  3A01  	XORLW 0x01
0688  1903  	BTFSC STATUS,Z
0689  2E9D  	GOTO	label115
069D        label115

            // Setting year
            gBcdYear = bcdAdjust(gBcdYear, 0x99, 0x00);
069D  083B  	MOVF gbl_gBcdYear, W
069E  00F0  	MOVWF bcdAdjust_00000_arg_bcd
069F  3099  	MOVLW 0x99
06A0  00F1  	MOVWF bcdAdjust_00000_arg_bcdMax
06A1  01F2  	CLRF bcdAdjust_00000_arg_bcdMin
06A2  2235  	CALL bcdAdjust_00000
06A3  0873  	MOVF CompTempVarRet608, W
06A4  00BB  	MOVWF gbl_gBcdYear

            break;
        case 2:
068A  3A03  	XORLW 0x03
068B  1903  	BTFSC STATUS,Z
068C  2EA6  	GOTO	label116
06A6        label116

            // Setting month
            gBcdMonth = bcdAdjust(gBcdMonth, 0x12, 0x01);
06A6  083A  	MOVF gbl_gBcdMonth, W
06A7  00F0  	MOVWF bcdAdjust_00000_arg_bcd
06A8  3012  	MOVLW 0x12
06A9  00F1  	MOVWF bcdAdjust_00000_arg_bcdMax
06AA  3001  	MOVLW 0x01
06AB  00F2  	MOVWF bcdAdjust_00000_arg_bcdMin
06AC  2235  	CALL bcdAdjust_00000
06AD  0873  	MOVF CompTempVarRet608, W
06AE  00BA  	MOVWF gbl_gBcdMonth

            break;
        case 3:
068D  3A01  	XORLW 0x01
068E  1903  	BTFSC STATUS,Z
068F  2EB0  	GOTO	label117
06B0        label117

            // Setting day of month
            char iMonth = gBcdMonth;
06B0  083A  	MOVF gbl_gBcdMonth, W
06B1  00EE  	MOVWF adjustDate_00027_1_iMonth

            if (iMonth & 0xF0)
06B2  30F0  	MOVLW 0xF0
06B3  056E  	ANDWF adjustDate_00027_1_iMonth, W
06B4  1903  	BTFSC STATUS,Z
06B5  2EBB  	GOTO	label118
06BB        label118

                iMonth += (gBcdMonth >> 4);
06B6  0E3A  	SWAPF gbl_gBcdMonth, W
06B7  390F  	ANDLW 0x0F
06B8  00F0  	MOVWF CompTempVar611
06B9  0870  	MOVF CompTempVar611, W
06BA  07EE  	ADDWF adjustDate_00027_1_iMonth, F

            iMonth--; // Make 0 to 11 index based
06BB  03EE  	DECF adjustDate_00027_1_iMonth, F

            char bcdMaxDay = gDaysInMonth[iMonth]; 
06BC  083C  	MOVF gbl_gDaysInMonth, W
06BD  00F7  	MOVWF __rom_get_00000_arg_objNumb
06BE  086E  	MOVF adjustDate_00027_1_iMonth, W
06BF  00F8  	MOVWF __rom_get_00000_arg_idx
06C0  201A  	CALL __rom_get_00000
06C1  00EF  	MOVWF adjustDate_00027_1_bcdMaxDay

            // If February, adjust max days for leap years
            if (iMonth == 1) {
06C2  036E  	DECF adjustDate_00027_1_iMonth, W
06C3  118A  	BCF PCLATH,3
06C4  120A  	BCF PCLATH,4
06C5  1D03  	BTFSS STATUS,Z
06C6  2EDD  	GOTO	label121

                // See if the 24 leap years since 2000 match the current year
                for (char i = 0; i < 24; i++) {
06C7  01F0  	CLRF adjustDate_00027_16_i
06C8        label119
06C8  3018  	MOVLW 0x18
06C9  0270  	SUBWF adjustDate_00027_16_i, W
06CA  1803  	BTFSC STATUS,C
06CB  2EDD  	GOTO	label121
06DB  0AF0  	INCF adjustDate_00027_16_i, F
06DC  2EC8  	GOTO	label119
06DD        label121

                    if (gLeapYears[i] == gBcdYear) {
06CC  083D  	MOVF gbl_gLeapYears, W
06CD  00F7  	MOVWF __rom_get_00000_arg_objNumb
06CE  0870  	MOVF adjustDate_00027_16_i, W
06CF  00F8  	MOVWF __rom_get_00000_arg_idx
06D0  201A  	CALL __rom_get_00000
06D1  00F1  	MOVWF CompTempVar612
06D2  083B  	MOVF gbl_gBcdYear, W
06D3  0671  	XORWF CompTempVar612, W
06D4  118A  	BCF PCLATH,3
06D5  120A  	BCF PCLATH,4
06D6  1D03  	BTFSS STATUS,Z
06D7  2EDB  	GOTO	label120
06DB        label120

                        bcdMaxDay = 0x29;
06D8  3029  	MOVLW 0x29
06D9  00EF  	MOVWF adjustDate_00027_1_bcdMaxDay

                        break;
06DA  2EDD  	GOTO	label121

                    }
                }
            }
            gBcdDayOfMonth = bcdAdjust(gBcdDayOfMonth, bcdMaxDay, 0x01);
06DD  0839  	MOVF gbl_gBcdDayOfMonth, W
06DE  00F0  	MOVWF bcdAdjust_00000_arg_bcd
06DF  086F  	MOVF adjustDate_00027_1_bcdMaxDay, W
06E0  00F1  	MOVWF bcdAdjust_00000_arg_bcdMax
06E1  3001  	MOVLW 0x01
06E2  00F2  	MOVWF bcdAdjust_00000_arg_bcdMin
06E3  2235  	CALL bcdAdjust_00000
06E4  0873  	MOVF CompTempVarRet608, W
06E5  00B9  	MOVWF gbl_gBcdDayOfMonth

            break;
        case 4:
0690  3A07  	XORLW 0x07
0691  1903  	BTFSC STATUS,Z
0692  2EE7  	GOTO	label122
06E7        label122

            // Setting day of week
            gDayOfWeek = bcdAdjust(gDayOfWeek, 0x07, 0x01);
06E7  0838  	MOVF gbl_gDayOfWeek, W
06E8  00F0  	MOVWF bcdAdjust_00000_arg_bcd
06E9  3007  	MOVLW 0x07
06EA  00F1  	MOVWF bcdAdjust_00000_arg_bcdMax
06EB  3001  	MOVLW 0x01
06EC  00F2  	MOVWF bcdAdjust_00000_arg_bcdMin
06ED  2235  	CALL bcdAdjust_00000
06EE  0873  	MOVF CompTempVarRet608, W
06EF  00B8  	MOVWF gbl_gDayOfWeek

            break;
        case 5:
0693  3A01  	XORLW 0x01
0694  1903  	BTFSC STATUS,Z
0695  2EF1  	GOTO	label123
06F1        label123

            // Setting 12h/24h
            gcHourMode++;
06F1  0AD1  	INCF gbl_gcHourMode, F

            if (gcHourMode > 2)
06F2  0851  	MOVF gbl_gcHourMode, W
06F3  3C02  	SUBLW 0x02
06F4  1C03  	BTFSS STATUS,C

				gcHourMode = 0;
06F5  01D1  	CLRF gbl_gcHourMode

            break;
        case 6:
0696  3A03  	XORLW 0x03
0697  1903  	BTFSC STATUS,Z
0698  2EF7  	GOTO	label124
06F7        label124

            // Setting hour
            gBcdHour = bcdAdjust(gBcdHour, 0x23, 0x00);
06F7  0837  	MOVF gbl_gBcdHour, W
06F8  00F0  	MOVWF bcdAdjust_00000_arg_bcd
06F9  3023  	MOVLW 0x23
06FA  00F1  	MOVWF bcdAdjust_00000_arg_bcdMax
06FB  01F2  	CLRF bcdAdjust_00000_arg_bcdMin
06FC  2235  	CALL bcdAdjust_00000
06FD  0873  	MOVF CompTempVarRet608, W
06FE  00B7  	MOVWF gbl_gBcdHour

            break;
        case 7:
0699  3A01  	XORLW 0x01
069A  1903  	BTFSC STATUS,Z
069B  2F00  	GOTO	label125
0700        label125

            // Setting minute
            gBcdMinute = bcdAdjust(gBcdMinute, 0x59, 0x00);
0700  0836  	MOVF gbl_gBcdMinute, W
0701  00F0  	MOVWF bcdAdjust_00000_arg_bcd
0702  3059  	MOVLW 0x59
0703  00F1  	MOVWF bcdAdjust_00000_arg_bcdMax
0704  01F2  	CLRF bcdAdjust_00000_arg_bcdMin
0705  2235  	CALL bcdAdjust_00000
0706  0873  	MOVF CompTempVarRet608, W
0707  00B6  	MOVWF gbl_gBcdMinute

            break;
    }
}
069C  0008  	RETURN
06A5  0008  	RETURN
06AF  0008  	RETURN
06E6  0008  	RETURN
06F0  0008  	RETURN
06F6  0008  	RETURN
06FF  0008  	RETURN
0708  0008  	RETURN


/*********************************************************************************************
  void adjustTrigger()
  Increment or Decrement a trigger time or temperate
  Must set iBcdAdjustment first
*********************************************************************************************/
void adjustTrigger() {

    switch (gcTriggerMode) {

        case 1:
05E1  1283  	BCF STATUS, RP0
05E2  1303  	BCF STATUS, RP1
05E3  0852  	MOVF gbl_gcTriggerMode, W
05E4  3A01  	XORLW 0x01
05E5  1903  	BTFSC STATUS,Z
05E6  2E09  	GOTO	label101
0609        label101

            // White LED on hour
            gBcdWhiteOnHour = bcdAdjust(gBcdWhiteOnHour, 0x23, 0x00);
0609  0854  	MOVF gbl_gBcdWhiteOnHour, W
060A  00F0  	MOVWF bcdAdjust_00000_arg_bcd
060B  3023  	MOVLW 0x23
060C  00F1  	MOVWF bcdAdjust_00000_arg_bcdMax
060D  01F2  	CLRF bcdAdjust_00000_arg_bcdMin
060E  2235  	CALL bcdAdjust_00000
060F  0873  	MOVF CompTempVarRet608, W
0610  00D4  	MOVWF gbl_gBcdWhiteOnHour

            break;
        case 2:
05E7  3A03  	XORLW 0x03
05E8  1903  	BTFSC STATUS,Z
05E9  2E12  	GOTO	label102
0612        label102

            // White LED on minute
            gBcdWhiteOnMinute = bcdAdjust(gBcdWhiteOnMinute, 0x59, 0x00);
0612  0853  	MOVF gbl_gBcdWhiteOnMinute, W
0613  00F0  	MOVWF bcdAdjust_00000_arg_bcd
0614  3059  	MOVLW 0x59
0615  00F1  	MOVWF bcdAdjust_00000_arg_bcdMax
0616  01F2  	CLRF bcdAdjust_00000_arg_bcdMin
0617  2235  	CALL bcdAdjust_00000
0618  0873  	MOVF CompTempVarRet608, W
0619  00D3  	MOVWF gbl_gBcdWhiteOnMinute

            break;
        case 3:
05EA  3A01  	XORLW 0x01
05EB  1903  	BTFSC STATUS,Z
05EC  2E1B  	GOTO	label103
061B        label103

            // White LED off hour
            gBcdWhiteOffHour = bcdAdjust(gBcdWhiteOffHour, 0x23, 0x00);
061B  0856  	MOVF gbl_gBcdWhiteOffHour, W
061C  00F0  	MOVWF bcdAdjust_00000_arg_bcd
061D  3023  	MOVLW 0x23
061E  00F1  	MOVWF bcdAdjust_00000_arg_bcdMax
061F  01F2  	CLRF bcdAdjust_00000_arg_bcdMin
0620  2235  	CALL bcdAdjust_00000
0621  0873  	MOVF CompTempVarRet608, W
0622  00D6  	MOVWF gbl_gBcdWhiteOffHour

            break;
        case 4:
05ED  3A07  	XORLW 0x07
05EE  1903  	BTFSC STATUS,Z
05EF  2E24  	GOTO	label104
0624        label104

            // White LED off minute
            gBcdWhiteOffMinute = bcdAdjust(gBcdWhiteOffMinute, 0x59, 0x00);
0624  0855  	MOVF gbl_gBcdWhiteOffMinute, W
0625  00F0  	MOVWF bcdAdjust_00000_arg_bcd
0626  3059  	MOVLW 0x59
0627  00F1  	MOVWF bcdAdjust_00000_arg_bcdMax
0628  01F2  	CLRF bcdAdjust_00000_arg_bcdMin
0629  2235  	CALL bcdAdjust_00000
062A  0873  	MOVF CompTempVarRet608, W
062B  00D5  	MOVWF gbl_gBcdWhiteOffMinute

            break;
        case 5:
05F0  3A01  	XORLW 0x01
05F1  1903  	BTFSC STATUS,Z
05F2  2E2D  	GOTO	label105
062D        label105

            // Blue LED on hour
            gBcdBlueOnHour = bcdAdjust(gBcdBlueOnHour, 0x23, 0x00);
062D  0858  	MOVF gbl_gBcdBlueOnHour, W
062E  00F0  	MOVWF bcdAdjust_00000_arg_bcd
062F  3023  	MOVLW 0x23
0630  00F1  	MOVWF bcdAdjust_00000_arg_bcdMax
0631  01F2  	CLRF bcdAdjust_00000_arg_bcdMin
0632  2235  	CALL bcdAdjust_00000
0633  0873  	MOVF CompTempVarRet608, W
0634  00D8  	MOVWF gbl_gBcdBlueOnHour

            break;
        case 6:
05F3  3A03  	XORLW 0x03
05F4  1903  	BTFSC STATUS,Z
05F5  2E36  	GOTO	label106
0636        label106

            // Blue LED on minute
            gBcdBlueOnMinute = bcdAdjust(gBcdBlueOnMinute, 0x59, 0x00);
0636  0857  	MOVF gbl_gBcdBlueOnMinute, W
0637  00F0  	MOVWF bcdAdjust_00000_arg_bcd
0638  3059  	MOVLW 0x59
0639  00F1  	MOVWF bcdAdjust_00000_arg_bcdMax
063A  01F2  	CLRF bcdAdjust_00000_arg_bcdMin
063B  2235  	CALL bcdAdjust_00000
063C  0873  	MOVF CompTempVarRet608, W
063D  00D7  	MOVWF gbl_gBcdBlueOnMinute

            break;
        case 7:
05F6  3A01  	XORLW 0x01
05F7  1903  	BTFSC STATUS,Z
05F8  2E3F  	GOTO	label107
063F        label107

            // Blue LED off hour
            gBcdBlueOffHour = bcdAdjust(gBcdBlueOffHour, 0x23, 0x00);
063F  085A  	MOVF gbl_gBcdBlueOffHour, W
0640  00F0  	MOVWF bcdAdjust_00000_arg_bcd
0641  3023  	MOVLW 0x23
0642  00F1  	MOVWF bcdAdjust_00000_arg_bcdMax
0643  01F2  	CLRF bcdAdjust_00000_arg_bcdMin
0644  2235  	CALL bcdAdjust_00000
0645  0873  	MOVF CompTempVarRet608, W
0646  00DA  	MOVWF gbl_gBcdBlueOffHour

            break;
        case 8:
05F9  3A0F  	XORLW 0x0F
05FA  1903  	BTFSC STATUS,Z
05FB  2E48  	GOTO	label108
0648        label108

            // Blue LED off minute
            gBcdBlueOffMinute = bcdAdjust(gBcdBlueOffMinute, 0x59, 0x00);
0648  0859  	MOVF gbl_gBcdBlueOffMinute, W
0649  00F0  	MOVWF bcdAdjust_00000_arg_bcd
064A  3059  	MOVLW 0x59
064B  00F1  	MOVWF bcdAdjust_00000_arg_bcdMax
064C  01F2  	CLRF bcdAdjust_00000_arg_bcdMin
064D  2235  	CALL bcdAdjust_00000
064E  0873  	MOVF CompTempVarRet608, W
064F  00D9  	MOVWF gbl_gBcdBlueOffMinute

            break;
        case 9:
05FC  3A01  	XORLW 0x01
05FD  1903  	BTFSC STATUS,Z
05FE  2E51  	GOTO	label109
0651        label109

            // Fan on temp - between 20 and 40 degrees C
            gBcdFanOnTemp = bcdAdjust(gBcdFanOnTemp, 0x40, 0x20);
0651  085B  	MOVF gbl_gBcdFanOnTemp, W
0652  00F0  	MOVWF bcdAdjust_00000_arg_bcd
0653  3040  	MOVLW 0x40
0654  00F1  	MOVWF bcdAdjust_00000_arg_bcdMax
0655  3020  	MOVLW 0x20
0656  00F2  	MOVWF bcdAdjust_00000_arg_bcdMin
0657  2235  	CALL bcdAdjust_00000
0658  0873  	MOVF CompTempVarRet608, W
0659  00DB  	MOVWF gbl_gBcdFanOnTemp

            break;
        case 10:
05FF  3A03  	XORLW 0x03
0600  1903  	BTFSC STATUS,Z
0601  2E5B  	GOTO	label110
065B        label110

            // Fan off temp - off must be lower than on, min 20 degrees C
            if (gBcdFanOffTemp > gBcdFanOnTemp)
065B  085C  	MOVF gbl_gBcdFanOffTemp, W
065C  025B  	SUBWF gbl_gBcdFanOnTemp, W
065D  1803  	BTFSC STATUS,C
065E  2E61  	GOTO	label111
0661        label111

				gBcdFanOffTemp = gBcdFanOnTemp;
065F  085B  	MOVF gbl_gBcdFanOnTemp, W
0660  00DC  	MOVWF gbl_gBcdFanOffTemp

            gBcdFanOffTemp = bcdAdjust(gBcdFanOffTemp, gBcdFanOnTemp, 0x20);
0661  085C  	MOVF gbl_gBcdFanOffTemp, W
0662  00F0  	MOVWF bcdAdjust_00000_arg_bcd
0663  085B  	MOVF gbl_gBcdFanOnTemp, W
0664  00F1  	MOVWF bcdAdjust_00000_arg_bcdMax
0665  3020  	MOVLW 0x20
0666  00F2  	MOVWF bcdAdjust_00000_arg_bcdMin
0667  2235  	CALL bcdAdjust_00000
0668  0873  	MOVF CompTempVarRet608, W
0669  00DC  	MOVWF gbl_gBcdFanOffTemp

            break;
        case 11:
0602  3A01  	XORLW 0x01
0603  1903  	BTFSC STATUS,Z
0604  2E6B  	GOTO	label112
066B        label112

            // Heater on temp - between 0 and 40 degrees C
            gBcdHeaterOnTemp = bcdAdjust(gBcdHeaterOnTemp, 0x40, 0);
066B  085D  	MOVF gbl_gBcdHeaterOnTemp, W
066C  00F0  	MOVWF bcdAdjust_00000_arg_bcd
066D  3040  	MOVLW 0x40
066E  00F1  	MOVWF bcdAdjust_00000_arg_bcdMax
066F  01F2  	CLRF bcdAdjust_00000_arg_bcdMin
0670  2235  	CALL bcdAdjust_00000
0671  0873  	MOVF CompTempVarRet608, W
0672  00DD  	MOVWF gbl_gBcdHeaterOnTemp

            break;
        case 12:
0605  3A07  	XORLW 0x07
0606  1903  	BTFSC STATUS,Z
0607  2E74  	GOTO	label113
0674        label113

            // Heater off temp - off must be equal or higher than on - max 40 degrees C
            if (gBcdHeaterOffTemp < gBcdHeaterOnTemp)
0674  085D  	MOVF gbl_gBcdHeaterOnTemp, W
0675  025E  	SUBWF gbl_gBcdHeaterOffTemp, W
0676  1803  	BTFSC STATUS,C
0677  2E7A  	GOTO	label114
067A        label114

				gBcdHeaterOffTemp = gBcdHeaterOnTemp;
0678  085D  	MOVF gbl_gBcdHeaterOnTemp, W
0679  00DE  	MOVWF gbl_gBcdHeaterOffTemp

            gBcdHeaterOffTemp = bcdAdjust(gBcdHeaterOffTemp, 0x40, gBcdHeaterOnTemp);
067A  085E  	MOVF gbl_gBcdHeaterOffTemp, W
067B  00F0  	MOVWF bcdAdjust_00000_arg_bcd
067C  3040  	MOVLW 0x40
067D  00F1  	MOVWF bcdAdjust_00000_arg_bcdMax
067E  085D  	MOVF gbl_gBcdHeaterOnTemp, W
067F  00F2  	MOVWF bcdAdjust_00000_arg_bcdMin
0680  2235  	CALL bcdAdjust_00000
0681  0873  	MOVF CompTempVarRet608, W
0682  00DE  	MOVWF gbl_gBcdHeaterOffTemp

            break;
    }
}
0608  0008  	RETURN
0611  0008  	RETURN
061A  0008  	RETURN
0623  0008  	RETURN
062C  0008  	RETURN
0635  0008  	RETURN
063E  0008  	RETURN
0647  0008  	RETURN
0650  0008  	RETURN
065A  0008  	RETURN
066A  0008  	RETURN
0673  0008  	RETURN
0683  0008  	RETURN


/*********************************************************************************************
  void processKeys()
  Action a key press
*********************************************************************************************/
void processKeys() {

    switch (tm1638Keys) {

        case 0x1F:
0742  1283  	BCF STATUS, RP0
0743  1303  	BCF STATUS, RP1
0744  0867  	MOVF gbl_tm1638Keys, W
0745  3A1F  	XORLW 0x1F
0746  1903  	BTFSC STATUS,Z
0747  2F5E  	GOTO	label129
075E        label129

            // Toggle white light on/off
            WHITE_LED = !WHITE_LED;
075E  01EE  	CLRF CompTempVar613
075F  1C87  	BTFSS gbl_portc,1
0760  0AEE  	INCF CompTempVar613, F
0761  186E  	BTFSC CompTempVar613,0
0762  1487  	BSF gbl_portc,1
0763  1C6E  	BTFSS CompTempVar613,0
0764  1087  	BCF gbl_portc,1

            break;
        case 0x17:
0748  3A08  	XORLW 0x08
0749  1903  	BTFSC STATUS,Z
074A  2F66  	GOTO	label130
0766        label130

            // Toggle blue light on/off
            BLUE_LED = !BLUE_LED;
0766  01EE  	CLRF CompTempVar614
0767  1D07  	BTFSS gbl_portc,2
0768  0AEE  	INCF CompTempVar614, F
0769  186E  	BTFSC CompTempVar614,0
076A  1507  	BSF gbl_portc,2
076B  1C6E  	BTFSS CompTempVar614,0
076C  1107  	BCF gbl_portc,2

            break;
        case 0x0F:
074B  3A18  	XORLW 0x18
074C  1903  	BTFSC STATUS,Z
074D  2F6E  	GOTO	label131
076E        label131

            // Toggle fan on/off
            gbFanOn = !gbFanOn;
076E  01EE  	CLRF CompTempVar615
076F  1D4E  	BTFSS gbl_gbFanOn,2
0770  0AEE  	INCF CompTempVar615, F
0771  114E  	BCF gbl_gbFanOn,2
0772  086E  	MOVF CompTempVar615, W
0773  1D03  	BTFSS STATUS,Z
0774  154E  	BSF gbl_gbFanOn,2

            break;
        case 0x07:
074E  3A08  	XORLW 0x08
074F  1903  	BTFSC STATUS,Z
0750  2F76  	GOTO	label132
0776        label132

            // Exit other modes
            gcSetMode = 0;
0776  01D0  	CLRF gbl_gcSetMode

            gcTriggerMode = 0;
0777  01D2  	CLRF gbl_gcTriggerMode

            // Display temp C/temp F/date
            gcDisplayMode++;
0778  0ACF  	INCF gbl_gcDisplayMode, F

            if (gcDisplayMode > 3)
0779  084F  	MOVF gbl_gcDisplayMode, W
077A  3C03  	SUBLW 0x03
077B  1C03  	BTFSS STATUS,C

                gcDisplayMode = 0;
077C  01CF  	CLRF gbl_gcDisplayMode

            convertTemp(); // force conversion (no read)
077D  24E1  	CALL convertTem_0002A

            break;
        case 0x1B:
0751  3A1C  	XORLW 0x1C
0752  1903  	BTFSC STATUS,Z
0753  2F7F  	GOTO	label133
077F        label133

            // Exit other modes
            gcTriggerMode = 0;
077F  01D2  	CLRF gbl_gcTriggerMode

            // Adjust set mode
            gcSetMode++;
0780  0AD0  	INCF gbl_gcSetMode, F

            if (gcSetMode > 7) {
0781  0850  	MOVF gbl_gcSetMode, W
0782  3C07  	SUBLW 0x07
0783  1803  	BTFSC STATUS,C

                ds3231WriteDateTime();
0785  24A5  	CALL ds3231Writ_0001C

                gcSetMode = 0;
0786  01D0  	CLRF gbl_gcSetMode

            }
            break;
        case 0x13:
0754  3A08  	XORLW 0x08
0755  1903  	BTFSC STATUS,Z
0756  2F88  	GOTO	label134
0788        label134

            // Adjust down
            iBcdAdjustment = 0;
0788  01EB  	CLRF gbl_iBcdAdjustment

            if (gcSetMode) {
0789  08D0  	MOVF gbl_gcSetMode, F
078A  1903  	BTFSC STATUS,Z
078B  2F8E  	GOTO	label135
078E        label135

                adjustDateTime();
078C  2684  	CALL adjustDate_00027

            } else if (gcTriggerMode) {
078E  08D2  	MOVF gbl_gcTriggerMode, F
078F  1D03  	BTFSS STATUS,Z

                adjustTrigger();
0790  25E1  	CALL adjustTrig_00028

            }
            break;
        case 0x0B:
0757  3A18  	XORLW 0x18
0758  1903  	BTFSC STATUS,Z
0759  2F92  	GOTO	label136
0792        label136

            iBcdAdjustment = 1;
0792  3001  	MOVLW 0x01
0793  00EB  	MOVWF gbl_iBcdAdjustment

            // Adjust up
            if (gcSetMode) {
0794  08D0  	MOVF gbl_gcSetMode, F
0795  1903  	BTFSC STATUS,Z
0796  2F99  	GOTO	label137
0799        label137

                adjustDateTime();
0797  2684  	CALL adjustDate_00027

            } else if (gcTriggerMode) {
0799  08D2  	MOVF gbl_gcTriggerMode, F
079A  1D03  	BTFSS STATUS,Z

                adjustTrigger();
079B  25E1  	CALL adjustTrig_00028

            }
            break;
        case 0x03:
075A  3A08  	XORLW 0x08
075B  1903  	BTFSC STATUS,Z
075C  2F9D  	GOTO	label138
079D        label138

            // Exit set mode
            gcSetMode = 0;
079D  01D0  	CLRF gbl_gcSetMode

            // Adjust timer mode
            gcTriggerMode++;
079E  0AD2  	INCF gbl_gcTriggerMode, F

            if (gcTriggerMode > 12) {
079F  0852  	MOVF gbl_gcTriggerMode, W
07A0  3C0C  	SUBLW 0x0C
07A1  1803  	BTFSC STATUS,C

                gcTriggerMode = 0;
07A3  01D2  	CLRF gbl_gcTriggerMode

                at24c32WriteAll(); // Exiting trigger mode, save the new triggers to EEPROM chip
07A4  255A  	CALL at24c32Wri_0002B

            }
            break;
    }
}
075D  0008  	RETURN
0765  0008  	RETURN
076D  0008  	RETURN
0775  0008  	RETURN
077E  0008  	RETURN
0784  0008  	RETURN
0787  0008  	RETURN
078D  0008  	RETURN
0791  0008  	RETURN
0798  0008  	RETURN
079C  0008  	RETURN
07A2  0008  	RETURN
07A5  0008  	RETURN


/*********************************************************************************************
  void interrupt()
  Interrupt handler
*********************************************************************************************/
void interrupt() {

    // Interrupt on timer0 - flash digit delay
    if (intcon.T0IF) {
0946  1D0B  	BTFSS gbl_intcon,2
0947  294F  	GOTO	label162
094F        label162

        iTimer0Counts++;
0948  1283  	BCF STATUS, RP0
0949  1303  	BCF STATUS, RP1
094A  0ABE  	INCF gbl_iTimer0Counts, F

        tmr0 = TMR0PRELOAD;
094B  303D  	MOVLW 0x3D
094C  0081  	MOVWF gbl_tmr0

        cTask.TASK_TIMER0 = 1;
094D  14CD  	BSF gbl_cTask,1

        // Clear interrupt flag
        intcon.T0IF = 0; 
094E  110B  	BCF gbl_intcon,2

    }
    // Handle timer1 interrupt - delay counter from DS3231
    if (pir1.TMR1IF) {
094F  1283  	BCF STATUS, RP0
0950  1303  	BCF STATUS, RP1
0951  1C0C  	BTFSS gbl_pir1,0
0952  2958  	GOTO	label163
0958        label163

        tmr1h = TMR1HV;      // preset for timer1 MSB register
0953  30FF  	MOVLW 0xFF
0954  008F  	MOVWF gbl_tmr1h

        tmr1l = TMR1LV;      // preset for timer1 LSB register
0955  008E  	MOVWF gbl_tmr1l


        pir1.TMR1IF = 0;     // Clear interrupt flag
0956  100C  	BCF gbl_pir1,0

        cTask.TASK_TIMER1 = 1;
0957  154D  	BSF gbl_cTask,2

    }
}
0958  0E32  	SWAPF Int1BContext+D'2', W
0959  0084  	MOVWF FSR
095A  0E31  	SWAPF Int1BContext+D'1', W
095B  008A  	MOVWF PCLATH
095C  0E30  	SWAPF Int1BContext, W
095D  0083  	MOVWF STATUS
095E  0EFF  	SWAPF Int1Context, F
095F  0E7F  	SWAPF Int1Context, W
0960  0009  	RETFIE


/*********************************************************************************************
  void initialise()
  Function called once only to initialise variables and
  setup the PIC registers
*********************************************************************************************/
void initialise() {

    //PIC16F73 doesn't have an internal oscillator
    //pcon.OSCF = 1; // 4MHz internal osc

    // Configure port A
    /*
    RA7     Doesn't exist
    RA6     Doesn't exist
    RA5     
    RA4     
    RA3     
    RA2     
    RA1     OUT FANS
    RA0     OUT HEATER
    */
    trisa = 0x00; // all outputs
07BE  1683  	BSF STATUS, RP0
07BF  1303  	BCF STATUS, RP1
07C0  0185  	CLRF gbl_trisa

    porta = 0x00; // All off
07C1  1283  	BCF STATUS, RP0
07C2  0185  	CLRF gbl_porta

    
    // Configure port B
    /*      
    RB7     ICSP PGD
    RB6     ICSP PGC
    RB5     
    RB4     
    RB3     OUT TM1638 STB
    RB2     OUT TM1638 CLK
    RB1     IN/OUT TM1638 DIO
    RB0     
    */
    trisb = 0x00; // all outputs by default
07C3  1683  	BSF STATUS, RP0
07C4  0186  	CLRF gbl_trisb

    portb = 0x0E; // default TM1638 pins high
07C5  300E  	MOVLW 0x0E
07C6  1283  	BCF STATUS, RP0
07C7  0086  	MOVWF gbl_portb


    // Configure port C
    /*      
    RC7     
    RC6     
    RC5     IN/OUT DS18B20
    RC4     IN/OUT DS3231M I2C SDA
    RC3     IN/OUT DS3231M I2C CLK
    RC2     OUT BLUE LIGHT PWM
    RC1     OUT WHITE LIGHT PWM
    RC0     IN SQW DS3231M
    */
    trisc = 0x21; // RC0 and RC5 inputs
07C8  3021  	MOVLW 0x21
07C9  1683  	BSF STATUS, RP0
07CA  0087  	MOVWF gbl_trisc

    portc = 0x38; // default DS18B20 and DS3231 pins high
07CB  3038  	MOVLW 0x38
07CC  1283  	BCF STATUS, RP0
07CD  0087  	MOVWF gbl_portc


    option_reg = 0;
07CE  1683  	BSF STATUS, RP0
07CF  0181  	CLRF gbl_option_reg

    option_reg.NOT_RBPU = 1; // disable port b pull ups
07D0  1781  	BSF gbl_option_reg,7


    // ADC setup
    // PIC16F73 doesn't have comparators
    //cmcon = 7; // disable all comparators so port a is usable as digital io
    adcon1 = 7; // Set RA0,RA1,RA2,RA5,RA3 all to digital I/O
07D1  3007  	MOVLW 0x07
07D2  009F  	MOVWF gbl_adcon1



    // Setup timer 0, used for flashing display
    // Timer calculator: http://eng-serve.com/pic/pic_timer.html
    // Timer0 Registers Prescaler= 256 - TMR0 Preset = 61 - Freq = 20.03 Hz - Period = 0.049920 seconds
    //option_reg.T0CS = 0; // bit 5  TMR0 Clock Source Select bit...0 = Internal Clock (CLKO) 1 = Transition on T0CKI pin
    //option_reg.T0SE = 0; // bit 4 TMR0 Source Edge Select bit 0 = low/high 1 = high/low
    //option_reg.PSA = 0; // bit 3  Prescaler Assignment bit...0 = Prescaler is assigned to the Timer0
    option_reg.PS2 = 1; // bits 2-0  PS2:PS0: Prescaler Rate Select bits
07D3  1501  	BSF gbl_option_reg,2

    option_reg.PS1 = 1;
07D4  1481  	BSF gbl_option_reg,1

    option_reg.PS0 = 1;
07D5  1401  	BSF gbl_option_reg,0

    tmr0 = TMR0PRELOAD; // preset for timer register (61)
07D6  303D  	MOVLW 0x3D
07D7  1283  	BCF STATUS, RP0
07D8  0081  	MOVWF gbl_tmr0

    intcon.T0IF = 0; // Clear timer 1 interrupt flag bit
07D9  110B  	BCF gbl_intcon,2

    intcon.T0IE = 1; // Timer 1 interrupt enabled
07DA  168B  	BSF gbl_intcon,5


    // Setup timer 1, used to update clock display and periodically ask for a temperature reading
    // Timer 1 setup - interrupt on DS3231 SQW 1Hz
    // Timer1 Registers Prescaler= 1 - TMR1 Preset = 65535 - Freq = 1 Hz
    // Bits 5-4 T1CKPS1:T1CKPS0 = 00: Prescaler Rate Select bits, 00 = 1:1 prescaler
    // Bit 3 T1OSCEN = 0: Timer1 LP Oscillator Enable Control bit, 0 = off
    // Bit 2 NOT_T1SYNC = 1: Timer1 External Clock Input Synchronization Control bit, 1 = Do not synchronize external clock input
    // Bit 1 TMR1CS = 1: Timer1 Clock Source Select bit, 1 = External clock from T1OSO/T1CKI pin (on the rising edge)
    // Bit 0 TMR1ON = 0: Timer1 On Bit, 0 = off
    t1con = 0b00000111;
07DB  3007  	MOVLW 0x07
07DC  0090  	MOVWF gbl_t1con

    tmr1h = TMR1HV;      // preset for timer1 MSB register
07DD  30FF  	MOVLW 0xFF
07DE  008F  	MOVWF gbl_tmr1h

    tmr1l = TMR1LV;      // preset for timer1 LSB register
07DF  008E  	MOVWF gbl_tmr1l

    pie1.TMR1IE = 1;     // Timer 1 interrupt
07E0  1683  	BSF STATUS, RP0
07E1  140C  	BSF gbl_pie1,0

    
    // No task at initialisation
    cTask = 0;
07E2  1283  	BCF STATUS, RP0
07E3  01CD  	CLRF gbl_cTask

    
    // Enable interrupts
    intcon.GIE = 1;
07E4  178B  	BSF gbl_intcon,7

    intcon.PEIE = 1;
07E5  170B  	BSF gbl_intcon,6


	// I2C Bus initialisation - baud rate divisor not applicable for software implementation
	i2c_init(1); 
07E6  3001  	MOVLW 0x01
07E7  00EF  	MOVWF i2c_INIT_00000_arg_i2c_divisor
07E8  2492  	CALL i2c_INIT_00000


    // Read in variables from EEPROM
    at24c32ReadAll();
07E9  2591  	CALL at24c32Rea_0002C


    // Check if the DS3231 needs initilising
    char cStatus = ds3231ReadRegister(0x0F); // Read the status register
07EA  300F  	MOVLW 0x0F
07EB  00EF  	MOVWF ds3231Read_0001E_arg_cRegAddress
07EC  24C1  	CALL ds3231Read_0001E
07ED  0871  	MOVF CompTempVarRet554, W
07EE  00EE  	MOVWF initialise_00000_1_cStatus

    // If the oscillator (OSF bit in status register) has stopped, then init and write a default date/time
    if (cStatus.7) {
07EF  1FEE  	BTFSS initialise_00000_1_cStatus,7
07F0  2FF3  	GOTO	label139
07F3        label139

        ds3231Init();
07F1  24D6  	CALL ds3231Init_00000

        ds3231WriteDateTime();
07F2  24A5  	CALL ds3231Writ_0001C

    }
    
	tm1638DisplayOn();
07F3  2465  	CALL tm1638Disp_00021

    tm1638UpdateDisplay();
07F4  2288  	CALL tm1638Upda_00022

}
07F5  0008  	RETURN


/*********************************************************************************************
  void main()
  Entry method. Loops infinitely with a simple task scheduler.
*********************************************************************************************/
void main() {

    initialise();
0820  118A  	BCF PCLATH,3
0821  27BE  	CALL initialise_00000

    
    // Endless loop
    while(1) {
0822        label140

        // Task scheduler
        // If there are tasks to be performed, find out the
        // most recent task from the array and execute it
        while (cTask > 0) {
0822  084D  	MOVF gbl_cTask, W
0823  3C00  	SUBLW 0x00
0824  158A  	BSF PCLATH,3
0825  1803  	BTFSC STATUS,C
0826  2822  	GOTO	label140

            if (cTask.TASK_TIMER1) {
0827  1D4D  	BTFSS gbl_cTask,2
0828  28C3  	GOTO	label157
08C3        label157

                if (!gcSetMode) {
0829  08D0  	MOVF gbl_gcSetMode, F
082A  1D03  	BTFSS STATUS,Z
082B  2869  	GOTO	label146

                    // Don't read date/time when in set mode
                    ds3231ReadDateTime();
082C  118A  	BCF PCLATH,3
082D  27F6  	CALL ds3231Read_0001D

                    if ((gBcdSecond == 0x29) || (gBcdSecond == 0x59)) {
082E  0835  	MOVF gbl_gBcdSecond, W
082F  3A29  	XORLW 0x29
0830  158A  	BSF PCLATH,3
0831  1903  	BTFSC STATUS,Z
0832  2837  	GOTO	label141
0833  0835  	MOVF gbl_gBcdSecond, W
0834  3A59  	XORLW 0x59
0835  1D03  	BTFSS STATUS,Z
0836  283C  	GOTO	label142
0837        label141
083C        label142

                        // Ask to convert for temperature reading at 29 seconds or 59 seconds past the minute
                        oneWireBusReset();
0837  118A  	BCF PCLATH,3
0838  27A6  	CALL oneWireBus_00017

                        startTemp();
0839  272C  	CALL startTemp_00000

                    } else if ((gBcdSecond == 0) || (gBcdSecond == 0x30)) {
083A  158A  	BSF PCLATH,3
083B  2847  	GOTO	label144
083C  08B5  	MOVF gbl_gBcdSecond, F
083D  1903  	BTFSC STATUS,Z
083E  2843  	GOTO	label143
083F  0835  	MOVF gbl_gBcdSecond, W
0840  3A30  	XORLW 0x30
0841  1D03  	BTFSS STATUS,Z
0842  2847  	GOTO	label144
0843        label143
0847        label144
08E1  158A  	BSF PCLATH,3
08E2  2822  	GOTO	label140

                        // 1 second later, read the converted temperature
                        oneWireBusReset();
0843  118A  	BCF PCLATH,3
0844  27A6  	CALL oneWireBus_00017

                        readTemp(); 
0845  2734  	CALL readTemp_00000

                        // store it in the array, next display refresh will pick it up
                        convertTemp();
0846  24E1  	CALL convertTem_0002A

                    }
                    // daylight savings time handling (UK/europe) - last sunday of March or October (this can fall between the 25th and the 31st)
                    if ((gBcdSecond == 0) && (gDayOfWeek == 7) && (gBcdDayOfMonth > 0x24)) {
0847  08B5  	MOVF gbl_gBcdSecond, F
0848  158A  	BSF PCLATH,3
0849  1D03  	BTFSS STATUS,Z
084A  2869  	GOTO	label146
084B  0838  	MOVF gbl_gDayOfWeek, W
084C  3A07  	XORLW 0x07
084D  1D03  	BTFSS STATUS,Z
084E  2869  	GOTO	label146
084F  0839  	MOVF gbl_gBcdDayOfMonth, W
0850  3C24  	SUBLW 0x24
0851  1803  	BTFSC STATUS,C
0852  2869  	GOTO	label146

						// In March, at 1AM, apply daylight savings time if appropriate 
						if ((gBcdHour == 1) && (gBcdMonth == 3)) {
0853  0337  	DECF gbl_gBcdHour, W
0854  1D03  	BTFSS STATUS,Z
0855  285D  	GOTO	label145
0856  083A  	MOVF gbl_gBcdMonth, W
0857  3A03  	XORLW 0x03
0858  1D03  	BTFSS STATUS,Z
0859  285D  	GOTO	label145
085D        label145

							gBcdHour++; // one hour forwards
085A  0AB7  	INCF gbl_gBcdHour, F

							ds3231WriteDateTime();
085B  118A  	BCF PCLATH,3
085C  24A5  	CALL ds3231Writ_0001C

						}
						// In October, at 2AM, remove daylight savings time if appropriate (UK/europe) daylight savings time if appropriate (UK/europe) - last sunday of October
						if ((gBcdHour == 2) && (gBcdMonth == 0x10)) {
085D  0837  	MOVF gbl_gBcdHour, W
085E  3A02  	XORLW 0x02
085F  158A  	BSF PCLATH,3
0860  1D03  	BTFSS STATUS,Z
0861  2869  	GOTO	label146
0862  083A  	MOVF gbl_gBcdMonth, W
0863  3A10  	XORLW 0x10
0864  1D03  	BTFSS STATUS,Z
0865  2869  	GOTO	label146
0869        label146

							gBcdHour--; // one hour back
0866  03B7  	DECF gbl_gBcdHour, F

							ds3231WriteDateTime();
0867  118A  	BCF PCLATH,3
0868  24A5  	CALL ds3231Writ_0001C

						}
					}
                }
                if (!gcTriggerMode) {
0869  08D2  	MOVF gbl_gcTriggerMode, F
086A  158A  	BSF PCLATH,3
086B  1D03  	BTFSS STATUS,Z
086C  28BA  	GOTO	label155

					// Don't activate triggers when in trigger set mode
					// Trigger white led
					// Don't activate/deactivate if on and off set hour/min are the same
					if ((gBcdWhiteOnHour != gBcdWhiteOffHour) || (gBcdWhiteOnMinute != gBcdWhiteOffMinute)) {
086D  0856  	MOVF gbl_gBcdWhiteOffHour, W
086E  0654  	XORWF gbl_gBcdWhiteOnHour, W
086F  1D03  	BTFSS STATUS,Z
0870  2875  	GOTO	label147
0871  0855  	MOVF gbl_gBcdWhiteOffMinute, W
0872  0653  	XORWF gbl_gBcdWhiteOnMinute, W
0873  1903  	BTFSC STATUS,Z
0874  2885  	GOTO	label149
0875        label147

						if ((gBcdHour == gBcdWhiteOnHour) && (gBcdMinute == gBcdWhiteOnMinute)) {
0875  0854  	MOVF gbl_gBcdWhiteOnHour, W
0876  0637  	XORWF gbl_gBcdHour, W
0877  1D03  	BTFSS STATUS,Z
0878  287D  	GOTO	label148
0879  0853  	MOVF gbl_gBcdWhiteOnMinute, W
087A  0636  	XORWF gbl_gBcdMinute, W
087B  1903  	BTFSC STATUS,Z

							WHITE_LED = 1;
087C  1487  	BSF gbl_portc,1
087D        label148

						}
						if ((gBcdHour == gBcdWhiteOffHour) && (gBcdMinute == gBcdWhiteOffMinute)) {
087D  0856  	MOVF gbl_gBcdWhiteOffHour, W
087E  0637  	XORWF gbl_gBcdHour, W
087F  1D03  	BTFSS STATUS,Z
0880  2885  	GOTO	label149
0881  0855  	MOVF gbl_gBcdWhiteOffMinute, W
0882  0636  	XORWF gbl_gBcdMinute, W
0883  1903  	BTFSC STATUS,Z

							WHITE_LED = 0;
0884  1087  	BCF gbl_portc,1
0885        label149

						}
					}
					// Trigger blue led
					// Don't activate/deactivate if on and off set hour/min are the same
					if ((gBcdBlueOnHour != gBcdBlueOffHour) || (gBcdBlueOnMinute != gBcdBlueOffMinute)) {
0885  085A  	MOVF gbl_gBcdBlueOffHour, W
0886  0658  	XORWF gbl_gBcdBlueOnHour, W
0887  1D03  	BTFSS STATUS,Z
0888  288D  	GOTO	label150
0889  0859  	MOVF gbl_gBcdBlueOffMinute, W
088A  0657  	XORWF gbl_gBcdBlueOnMinute, W
088B  1903  	BTFSC STATUS,Z
088C  289D  	GOTO	label152
088D        label150

						if ((gBcdHour == gBcdBlueOnHour) && (gBcdMinute == gBcdBlueOnMinute)) {
088D  0858  	MOVF gbl_gBcdBlueOnHour, W
088E  0637  	XORWF gbl_gBcdHour, W
088F  1D03  	BTFSS STATUS,Z
0890  2895  	GOTO	label151
0891  0857  	MOVF gbl_gBcdBlueOnMinute, W
0892  0636  	XORWF gbl_gBcdMinute, W
0893  1903  	BTFSC STATUS,Z

							BLUE_LED = 1;
0894  1507  	BSF gbl_portc,2
0895        label151

						}
						if ((gBcdHour == gBcdBlueOffHour) && (gBcdMinute == gBcdBlueOffMinute)) {
0895  085A  	MOVF gbl_gBcdBlueOffHour, W
0896  0637  	XORWF gbl_gBcdHour, W
0897  1D03  	BTFSS STATUS,Z
0898  289D  	GOTO	label152
0899  0859  	MOVF gbl_gBcdBlueOffMinute, W
089A  0636  	XORWF gbl_gBcdMinute, W
089B  1903  	BTFSC STATUS,Z

							BLUE_LED = 0;
089C  1107  	BCF gbl_portc,2
089D        label152

						}
					}
					// Trigger fan
					// Don't activate/deactivate if on and off temperature are the same
					if (gBcdFanOnTemp != gBcdFanOffTemp) {
089D  085C  	MOVF gbl_gBcdFanOffTemp, W
089E  065B  	XORWF gbl_gBcdFanOnTemp, W
089F  1903  	BTFSC STATUS,Z
08A0  28A9  	GOTO	label153

						if (giDS3231ValueTruncCBCD >= gBcdFanOnTemp) {
08A1  085B  	MOVF gbl_gBcdFanOnTemp, W
08A2  024B  	SUBWF gbl_giDS3231ValueTruncCBCD, W
08A3  1803  	BTFSC STATUS,C

							FAN = 1;
08A4  1485  	BSF gbl_porta,1

						}
						if (giDS3231ValueTruncCBCD <= gBcdFanOffTemp) {
08A5  084B  	MOVF gbl_giDS3231ValueTruncCBCD, W
08A6  025C  	SUBWF gbl_gBcdFanOffTemp, W
08A7  1803  	BTFSC STATUS,C

							FAN = 0;
08A8  1085  	BCF gbl_porta,1
08A9        label153

						}
					}
					// Forced on
					if (gbFanOn)
08A9  194E  	BTFSC gbl_gbFanOn,2

						FAN = 1;
08AA  1485  	BSF gbl_porta,1

					// Trigger heater
					// Don't activate/deactivate if on and off temperature are the same
					if (gBcdHeaterOnTemp != gBcdHeaterOffTemp) {
08AB  085E  	MOVF gbl_gBcdHeaterOffTemp, W
08AC  065D  	XORWF gbl_gBcdHeaterOnTemp, W
08AD  1903  	BTFSC STATUS,Z
08AE  28B7  	GOTO	label154

						if (giDS3231ValueTruncCBCD <= gBcdHeaterOnTemp) {
08AF  084B  	MOVF gbl_giDS3231ValueTruncCBCD, W
08B0  025D  	SUBWF gbl_gBcdHeaterOnTemp, W
08B1  1803  	BTFSC STATUS,C

							HEATER = 1;
08B2  1405  	BSF gbl_porta,0

						}
						if (giDS3231ValueTruncCBCD >= gBcdHeaterOffTemp) {
08B3  085E  	MOVF gbl_gBcdHeaterOffTemp, W
08B4  024B  	SUBWF gbl_giDS3231ValueTruncCBCD, W
08B5  1803  	BTFSC STATUS,C

							HEATER = 0;
08B6  1005  	BCF gbl_porta,0
08B7        label154

						}
					}
					// If temperature is minus, always trigger heater
					if (gbDS3231IsMinus)
08B7  08CC  	MOVF gbl_gbDS3231IsMinus, F
08B8  1D03  	BTFSS STATUS,Z

						HEATER = 1;
08B9  1405  	BSF gbl_porta,0
08BA        label155

				}
				// Display time and temperature or date on TM1638 after clock tick
				if (!gcTriggerMode && !gcSetMode) {
08BA  08D2  	MOVF gbl_gcTriggerMode, F
08BB  1D03  	BTFSS STATUS,Z
08BC  28C2  	GOTO	label156
08BD  08D0  	MOVF gbl_gcSetMode, F
08BE  1D03  	BTFSS STATUS,Z
08BF  28C2  	GOTO	label156
08C2        label156

					tm1638UpdateDisplay();
08C0  118A  	BCF PCLATH,3
08C1  2288  	CALL tm1638Upda_00022

                }
                
                cTask.TASK_TIMER1 = 0;
08C2  114D  	BCF gbl_cTask,2

            }
            if (cTask.TASK_TIMER0) {
08C3  158A  	BSF PCLATH,3
08C4  1CCD  	BTFSS gbl_cTask,1
08C5  2822  	GOTO	label140

				// ~half second count
				if (iTimer0Counts > 9) {
08C6  083E  	MOVF gbl_iTimer0Counts, W
08C7  3C09  	SUBLW 0x09
08C8  1803  	BTFSC STATUS,C
08C9  28D4  	GOTO	label159

					iFlashDigitOff++;
08CA  0ABF  	INCF gbl_iFlashDigitOff, F

					iTimer0Counts = 0;					
08CB  01BE  	CLRF gbl_iTimer0Counts

					// If in set or trigger mode, update the display every ~half second to flash a digit
					if (gcSetMode || gcTriggerMode)
08CC  08D0  	MOVF gbl_gcSetMode, F
08CD  1D03  	BTFSS STATUS,Z
08CE  28D2  	GOTO	label158
08CF  08D2  	MOVF gbl_gcTriggerMode, F
08D0  1903  	BTFSC STATUS,Z
08D1  28D4  	GOTO	label159
08D2        label158

						tm1638UpdateDisplay();
08D2  118A  	BCF PCLATH,3
08D3  2288  	CALL tm1638Upda_00022

				}
				// Poll keys every 50ms
				tm1638ReadKeys();
08D4  118A  	BCF PCLATH,3
08D5  2709  	CALL tm1638Read_00025

				if (tm1638Keys != tm1638KeysOld) {
08D6  0868  	MOVF gbl_tm1638KeysOld, W
08D7  0667  	XORWF gbl_tm1638Keys, W
08D8  158A  	BSF PCLATH,3
08D9  1903  	BTFSC STATUS,Z
08DA  28E0  	GOTO	label160
08E0        label160

					//if (tm1638Keys != 0) {
						processKeys();
08DB  118A  	BCF PCLATH,3
08DC  2742  	CALL processKey_00029

						tm1638UpdateDisplay();
08DD  2288  	CALL tm1638Upda_00022

					//}
					tm1638KeysOld = tm1638Keys;
08DE  0867  	MOVF gbl_tm1638Keys, W
08DF  00E8  	MOVWF gbl_tm1638KeysOld

				}
                cTask.TASK_TIMER0 = 0;
08E0  10CD  	BCF gbl_cTask,1

            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
// I2C Communications Library for I2C MASTER
////////////////////////////////////////////////////////////////////////////
// Author(s): Andrew Smallridge
// Date 15 November 2004
//
// Copyright(C) 2004-2006 Andrew Smallridge
// Copyright(C) 2004-2010 Pavel Baranov
// Copyright(C) 2004-2010 David Hobday
// Existing constants predefined for i2c hardware driver and i2s software
// emulation for the PIC 18F2xx and 18F4xx processors. For hardware support
// on other PICs the constants must be mapped to the corresponding register
// map of the target device
////////////////////////////////////////////////////////////////////////////

/*
////////////////////////////////////////////////////////////////////////////
//	The following three sections should be copied to the user's program:
//		i2c master hardware / software mode definition
//		i2c software implementation template arguments and variables
// 		i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////
// i2c master hardware / software mode definition
//
// For i2c hardware support comment out the #define use_ic2_SW line
////////////////////////////////////////////////////////////////////////////
//#define use_i2c_SW

#if defined use_i2c_SW
////////////////////////////////////////////////////////////////////////////
// i2c software implementation template arguments and variables
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)

// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and software emalated i2c RAM locations. These constants are
// then used by the templated functions. When changing the address of an emulated
// register the corresponding constant mapping must also be changed.
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3					

#else
////////////////////////////////////////////////////////////////////////////
// i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP |i2c_HW)

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and PIC's i2c register locations. These constants are
// then used by the templated functions. 
#define PORTC		0x0f82
#define TRISC		0x0f94
#define e_SSPCON1	0xfc6
#define e_SSPCON2	0xfc5
#define e_SSPSTAT	0xfc7
#define e_SSPADD	0xfc8
#define e_SSPBUF	0xfc9
#define e_SSPIF_PIR	0xf9e
#define e_BCLIF_PIR	0xfa1
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3

#endif

*/


////////////////////////////////////////////////////////////////////////////
// Define the common i2c template structure
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL	template <unsigned char T_SCL_BIT, unsigned short T_SCL_PORT,	\
					unsigned short T_SCL_TRIS, unsigned char T_SDA_BIT, 			\
					unsigned short T_SDA_PORT, unsigned short T_SDA_TRIS,			\
					unsigned short T_i2c_SSPCON1, unsigned short T_i2c_SSPCON2, 	\
					unsigned short T_i2c_SSPSTAT, unsigned short T_i2c_SSPBUF, 		\
					unsigned char T_i2c_SSPIF_BIT, unsigned short T_i2c_SSPIF_PIR,	\
					unsigned char T_i2c_BCLIF_BIT, unsigned short T_i2c_BCLIF_PIR,	\
					unsigned char T_i2c_SMP_BIT, unsigned short T_i2c_SSPADD, 		\
					unsigned char T_MODE>

////////////////////////////////////////////////////////////////////////////
// Define the common i2c template parameters
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL_ARGS	T_SCL_BIT, T_SCL_PORT, T_SCL_TRIS, T_SDA_BIT, 			\
						T_SDA_PORT, T_SDA_TRIS, T_i2c_SSPCON1, T_i2c_SSPCON2, 	\
						T_i2c_SSPSTAT, T_i2c_SSPBUF, T_i2c_SSPIF_BIT, 			\
						T_i2c_SSPIF_PIR, T_i2c_BCLIF_BIT, T_i2c_BCLIF_PIR,		\
						T_i2c_SMP_BIT, T_i2c_SSPADD, T_MODE

////////////////////////////////////////////////////////////////////////////
// Helpers that hide template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_init	i2c_INIT<i2c_ARGS>
#define i2c_start	i2c_START<i2c_ARGS>
#define i2c_restart	i2c_RESTART<i2c_ARGS>
#define i2c_stop	i2c_STOP<i2c_ARGS>
#define i2c_read	i2c_READ<i2c_ARGS>
#define i2c_write	i2c_WRITE<i2c_ARGS>


////////////////////////////////////////////////////////////////////////////
// I2C Control Status Bits - Emulates the PIC18F hardware I2C implementation
////////////////////////////////////////////////////////////////////////////
// define I2C i2C_SSPCON1 control bits
#define	i2c_WCOL	7
#define	i2c_SSPOV	6
#define	i2c_SSPEN	5
#define	i2c_CKP		4
#define	i2c_SSPM3	3
#define	i2c_SSPM2	2
#define	i2c_SSPM1	1
#define	i2c_SSPM0	0

// define I2C SSPCON2 control bits
#define	i2c_GCEN 	7
#define	i2c_ACKSTAT	6
#define	i2c_ACKDT	5
#define	i2c_ACKEN	4
#define	i2c_RCEN	3
#define	i2c_PEN		2
#define	i2c_RSEN	1
#define	i2c_SEN		0

// define I2C SSPSTAT status bits
#define	i2c_DA		5
#define	i2c_P		4
#define	i2c_S		3
#define	i2c_RW		2
#define	i2c_UA		1
#define	i2c_BF		0


////////////////////////////////////////////////////////////////////////////
// I2C Control Flag Bits
////////////////////////////////////////////////////////////////////////////
// define I2C Mode bits
#define	i2c_HW			0x01
#define	i2c_400KHz		0x02	// 100KHz or 400KHz I2C clock (set = 400KHz)
#define	i2c_reset_wdt	0x04
#define i2c_SMP			0x80	


////////////////////////////////////////////////////////////////////////////
// I2C software constants
////////////////////////////////////////////////////////////////////////////
#define	dly 10	// number of 1us delay increments



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Start Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL 
void i2c_START(void)

{
	// Initiate the I2C START condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	delay_us(dly);
0126  300A  	MOVLW 0x0A
0127  1283  	BCF STATUS, RP0
0128  1303  	BCF STATUS, RP1
0129  00F4  	MOVWF delay_us_00000_arg_del
012A  2010  	CALL delay_us_00000

	l_bclif = 0; // initialise the collision flag for this command
012B  11C6  	BCF i2c_START_00000_1_l_bclif,3

	l_sspif = 0;
012C  11C5  	BCF i2c_START_00000_1_l_sspif,3

		
	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
			
		l_sen = 1; // initiate START condition	

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation			
		l_sen = 1; // initiate START condition
012D  1441  	BSF i2c_START_00000_1_l_sen,0

		l_scl_tris = 1; // ensure the SCL line is high
012E  1683  	BSF STATUS, RP0
012F  1587  	BSF i2c_START_00000_1_l_scl_tris,3

		l_sda_tris = 1; // ensure the SDA line is high	
0130  1607  	BSF i2c_START_00000_1_l_sda_tris,4

		l_scl = 0; // prepare to set SCL line low
0131  1283  	BCF STATUS, RP0
0132  1187  	BCF i2c_START_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low
0133  1207  	BCF i2c_START_00000_1_l_sda,4

		
		if (l_scl && l_sda)
0134  1D87  	BTFSS i2c_START_00000_1_l_scl,3
0135  2953  	GOTO	label24
0136  1E07  	BTFSS i2c_START_00000_1_l_sda,4
0137  2953  	GOTO	label24
0153        label24

		{
			// good sign - no collision detected
			delay_us(dly);
0138  300A  	MOVLW 0x0A
0139  00F4  	MOVWF delay_us_00000_arg_del
013A  2010  	CALL delay_us_00000

			
			if (!l_scl) // ensure the clock is still high
013B  1987  	BTFSC i2c_START_00000_1_l_scl,3
013C  2941  	GOTO	label23
0141        label23

			{
				l_bclif = 1;
013D  15C6  	BSF i2c_START_00000_1_l_bclif,3

				l_s = 1;
013E  15C2  	BSF i2c_START_00000_1_l_s,3

				l_sen = 0;
013F  1041  	BCF i2c_START_00000_1_l_sen,0

				return;
			}
					
			l_sda = 0; // prepare to set SDA line low
0141  1207  	BCF i2c_START_00000_1_l_sda,4

			l_sda_tris = 0; // SDA to output (driven low)
0142  1683  	BSF STATUS, RP0
0143  1207  	BCF i2c_START_00000_1_l_sda_tris,4


			delay_us(dly);					
0144  300A  	MOVLW 0x0A
0145  1283  	BCF STATUS, RP0
0146  00F4  	MOVWF delay_us_00000_arg_del
0147  2010  	CALL delay_us_00000

			l_scl = 0; // prepare to set SCL line low
0148  1187  	BCF i2c_START_00000_1_l_scl,3

			l_scl_tris = 0; // SCL to output (driven low)
0149  1683  	BSF STATUS, RP0
014A  1187  	BCF i2c_START_00000_1_l_scl_tris,3


			delay_us(dly);					
014B  300A  	MOVLW 0x0A
014C  1283  	BCF STATUS, RP0
014D  00F4  	MOVWF delay_us_00000_arg_del
014E  2010  	CALL delay_us_00000

			l_s = 1; // set 'S' bit flag (start bit detected)
014F  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0; // clear flag
0150  1041  	BCF i2c_START_00000_1_l_sen,0

			l_sspif = 1; // flag end of start condition interrupt	
0151  15C5  	BSF i2c_START_00000_1_l_sspif,3

		}
		else
		{
			// here is SDA or SCL are low at the start - indicates a bus collision
			l_bclif = 1;
0153  15C6  	BSF i2c_START_00000_1_l_bclif,3

			l_s = 1; // set 'S' bit flag (start bit detected)
0154  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0;
0155  1041  	BCF i2c_START_00000_1_l_sen,0

			l_rsen = 0;
0156  10C1  	BCF i2c_START_00000_1_l_rsen,1

			l_pen = 0;
0157  1141  	BCF i2c_START_00000_1_l_pen,2

			l_rcen = 0;								
0158  11C1  	BCF i2c_START_00000_1_l_rcen,3

			l_acken = 0;			
0159  1241  	BCF i2c_START_00000_1_l_acken,4

		}
	}
}
0140  0008  	RETURN
0152  0008  	RETURN
015A  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Restart Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_RESTART(void)
{
	// Initiate the I2C RESTART condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
			
	delay_us(dly);
	l_bclif = 0; // initialise the collision flag for this command
	l_sspif = 0;

	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_rsen = 1; // initiate RESTART condition
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation	
		l_rsen = 1;
		l_scl = 0;
		l_sda = 0;
		
		if (!l_scl)
		{
			// good sign - no other I2C activity in progress
			l_sda_tris = 1; // float SDA line high	(should already be in this condition)	
			delay_us(dly);
		
			// about to float the clock line
			// ensure the data line is still high
			if (!l_sda)
			{
				// problem - SDA is low, a bus collision has occurred				
				l_bclif = 1; // set the bus collision flag	
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_scl_tris = 1; // float SCL line (high)	
				return;
			}
												
			l_scl_tris = 1; // float SCL line (high)

			// wait until any clock stretching has finished
			while (!l_scl)
				if (T_MODE & i2c_reset_wdt)
					clear_wdt();	
			delay_us(dly);
			
			// here we are about to drive SDA low
			// first ensure SCL is still high
			if (!l_scl)
			{
				// problem - SCL is low, a bus collision has occurred
				l_bclif = 1; // set the bus collision flag
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_sda_tris = 1; // float SDA line (high)
				return;
			}
				
			l_sda_tris = 0; // drive SDA low
			l_s = 1; // set 'S' bit flag (start bit detected)

			delay_us(dly);
			l_scl_tris = 0; // drive SCL low
			l_rsen = 0;
			l_pen = 0;
			l_sen = 0;			
			l_rcen = 0;								
			l_acken = 0;			
			l_sspif = 1; // flag end of start condition interrupt
		}
		else
		{
			// SCL is high at the start
			// some other I2C activity in progress		
			l_rsen = 0; // clear flag
			// exit without further action
		}
	}
}



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Stop Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_STOP(void)

{ 
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_p@T_i2c_SSPSTAT.i2c_P; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;

	l_bclif = 0; // initialise the collision flag for this command
00F6  1283  	BCF STATUS, RP0
00F7  1303  	BCF STATUS, RP1
00F8  11C6  	BCF i2c_STOP_00000_1_l_bclif,3

	l_sspif = 0;
00F9  11C5  	BCF i2c_STOP_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_pen = 1; // initiate STOP condition on the I2C bus	
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
		
	}
	else
	{
		//	Software I2C implementation
		l_pen = 1; // initiate STOP condition on the I2C bus
00FA  1541  	BSF i2c_STOP_00000_1_l_pen,2

		delay_us(dly);
00FB  300A  	MOVLW 0x0A
00FC  00F4  	MOVWF delay_us_00000_arg_del
00FD  2010  	CALL delay_us_00000

		
		l_scl = 0; // prepare to set SCL line low
00FE  1187  	BCF i2c_STOP_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low
00FF  1207  	BCF i2c_STOP_00000_1_l_sda,4

		l_scl_tris = 0; // drive SCL line low (should already be low)
0100  1683  	BSF STATUS, RP0
0101  1187  	BCF i2c_STOP_00000_1_l_scl_tris,3

		l_sda_tris = 0; // drive SDA line low
0102  1207  	BCF i2c_STOP_00000_1_l_sda_tris,4


		delay_us(dly);		
0103  300A  	MOVLW 0x0A
0104  1283  	BCF STATUS, RP0
0105  00F4  	MOVWF delay_us_00000_arg_del
0106  2010  	CALL delay_us_00000

		l_scl_tris = 1; // float SCL line (high)
0107  1683  	BSF STATUS, RP0
0108  1587  	BSF i2c_STOP_00000_1_l_scl_tris,3

		
		// wait until any clock stretching has finished
		while (!l_scl)
0109        label19
0109  1283  	BCF STATUS, RP0
010A  1987  	BTFSC i2c_STOP_00000_1_l_scl,3
010B  290E  	GOTO	label20
010D  2909  	GOTO	label19
010E        label20

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
010C  0064  	CLRWDT

						
		delay_us(dly);
010E  300A  	MOVLW 0x0A
010F  00F4  	MOVWF delay_us_00000_arg_del
0110  2010  	CALL delay_us_00000

		l_sda_tris = 1; // float SDA line
0111  1683  	BSF STATUS, RP0
0112  1607  	BSF i2c_STOP_00000_1_l_sda_tris,4

		delay_us(dly);		
0113  300A  	MOVLW 0x0A
0114  1283  	BCF STATUS, RP0
0115  00F4  	MOVWF delay_us_00000_arg_del
0116  2010  	CALL delay_us_00000

		
		// here the SDA line should be high - if not a collision has occurred				
		if (!l_sda || !l_scl)
0117  1E07  	BTFSS i2c_STOP_00000_1_l_sda,4
0118  291B  	GOTO	label21
0119  1987  	BTFSC i2c_STOP_00000_1_l_scl,3
011A  291F  	GOTO	label22
011B        label21
011F        label22

		{
			// problem - SDA or SCL is low, a bus collision has occurred
			l_bclif = 1; // set the bus collision flag	
011B  15C6  	BSF i2c_STOP_00000_1_l_bclif,3

			l_s = 0; // clear 'S' bit flag
011C  11C2  	BCF i2c_STOP_00000_1_l_s,3

			l_pen = 0; // clear flag
011D  1141  	BCF i2c_STOP_00000_1_l_pen,2

		}
		else
		{		
			l_p = 1;
011F  1642  	BSF i2c_STOP_00000_1_l_p,4

			l_pen = 0;
0120  1141  	BCF i2c_STOP_00000_1_l_pen,2

			l_sen = 0;
0121  1041  	BCF i2c_STOP_00000_1_l_sen,0

			l_rsen = 0;			
0122  10C1  	BCF i2c_STOP_00000_1_l_rsen,1

			l_rcen = 0;								
0123  11C1  	BCF i2c_STOP_00000_1_l_rcen,3

			l_acken = 0;
0124  1241  	BCF i2c_STOP_00000_1_l_acken,4

		}
	}
}
011E  0008  	RETURN
0125  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Write Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_WRITE(unsigned char i2c_data)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;	
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
	
	char BitMask;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
00A5  11C6  	BCF i2c_WRITE_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
00A6  11C5  	BCF i2c_WRITE_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
				
		l_wcol = 0; // clear write collision flag	
		i2c_SSPBUF = i2c_data;

		// test if a write collision occurred
		if (l_wcol)
			return (1); // error exit	

		// wait until MSSP Tx register is empty
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
								
		return (0); // successful exit
	}

	// here for i2c software driver
	l_wcol = 0; // clear write collision flag	
00A7  13C0  	BCF i2c_WRITE_00000_1_l_wcol,7

	i2c_SSPBUF = i2c_data;
00A8  0871  	MOVF i2c_WRITE_00000_arg_i2c_data, W
00A9  00C4  	MOVWF i2c_WRITE_00000_1_i2c_SSPBUF

	
	l_scl = 0; // prepare to set SCL line low
00AA  1187  	BCF i2c_WRITE_00000_1_l_scl,3

	l_sda = 0; // prepare to set SDA line low
00AB  1207  	BCF i2c_WRITE_00000_1_l_sda,4

	l_rw = 0; // signal we are doing a write
00AC  1142  	BCF i2c_WRITE_00000_1_l_rw,2


	for (BitMask = 0x80; BitMask; BitMask>>=1)
00AD  3080  	MOVLW 0x80
00AE  00F2  	MOVWF i2c_WRITE_00000_1_BitMask
00AF        label11
00AF  08F2  	MOVF i2c_WRITE_00000_1_BitMask, F
00B0  1903  	BTFSC STATUS,Z
00B1  28D2  	GOTO	label16
00CF  1003  	BCF STATUS,C
00D0  0CF2  	RRF i2c_WRITE_00000_1_BitMask, F
00D1  28AF  	GOTO	label11
00D2        label16

	{
		if (i2c_data & BitMask)
00B2  0872  	MOVF i2c_WRITE_00000_1_BitMask, W
00B3  0571  	ANDWF i2c_WRITE_00000_arg_i2c_data, W
00B4  1903  	BTFSC STATUS,Z
00B5  28B9  	GOTO	label12
00B9        label12

			l_sda_tris = 1; // float SDA high	
00B6  1683  	BSF STATUS, RP0
00B7  1607  	BSF i2c_WRITE_00000_1_l_sda_tris,4

		else
00B8  28BB  	GOTO	label13
00BB        label13

			l_sda_tris = 0; // drive SDA low
00B9  1683  	BSF STATUS, RP0
00BA  1207  	BCF i2c_WRITE_00000_1_l_sda_tris,4

		delay_us(dly);
00BB  300A  	MOVLW 0x0A
00BC  1283  	BCF STATUS, RP0
00BD  00F4  	MOVWF delay_us_00000_arg_del
00BE  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
00BF  1683  	BSF STATUS, RP0
00C0  1587  	BSF i2c_WRITE_00000_1_l_scl_tris,3


		// wait until any clock stretching has finished
		while (!l_scl)
00C1        label14
00C1  1283  	BCF STATUS, RP0
00C2  1987  	BTFSC i2c_WRITE_00000_1_l_scl,3
00C3  28C6  	GOTO	label15
00C5  28C1  	GOTO	label14
00C6        label15

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
00C4  0064  	CLRWDT

		delay_us(dly);
00C6  300A  	MOVLW 0x0A
00C7  00F4  	MOVWF delay_us_00000_arg_del
00C8  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low	
00C9  1683  	BSF STATUS, RP0
00CA  1187  	BCF i2c_WRITE_00000_1_l_scl_tris,3

		delay_us(dly);
00CB  300A  	MOVLW 0x0A
00CC  1283  	BCF STATUS, RP0
00CD  00F4  	MOVWF delay_us_00000_arg_del
00CE  2010  	CALL delay_us_00000

	}
	// serialized out the data
	// now get the status		
	// set SSPIF
	l_sspif = 1;
00D2  15C5  	BSF i2c_WRITE_00000_1_l_sspif,3

	l_acken = 1;
00D3  1641  	BSF i2c_WRITE_00000_1_l_acken,4

	l_ackdt = 0;
00D4  12C1  	BCF i2c_WRITE_00000_1_l_ackdt,5

	l_sda_tris = 1; // float SDA high
00D5  1683  	BSF STATUS, RP0
00D6  1607  	BSF i2c_WRITE_00000_1_l_sda_tris,4

	
	delay_us(dly);
00D7  300A  	MOVLW 0x0A
00D8  1283  	BCF STATUS, RP0
00D9  00F4  	MOVWF delay_us_00000_arg_del
00DA  2010  	CALL delay_us_00000

	
	l_scl_tris = 1; // float SCL high
00DB  1683  	BSF STATUS, RP0
00DC  1587  	BSF i2c_WRITE_00000_1_l_scl_tris,3

	
	// wait until any clock stretching has finished
	while (!l_scl)
00DD        label17
00DD  1283  	BCF STATUS, RP0
00DE  1987  	BTFSC i2c_WRITE_00000_1_l_scl,3
00DF  28E2  	GOTO	label18
00E1  28DD  	GOTO	label17
00E2        label18

		if (T_MODE & i2c_reset_wdt)
			clear_wdt();	
00E0  0064  	CLRWDT

	delay_us(dly);
00E2  300A  	MOVLW 0x0A
00E3  00F4  	MOVWF delay_us_00000_arg_del
00E4  2010  	CALL delay_us_00000


	// get the status bit
	local_ack = l_sda;
00E5  1073  	BCF i2c_WRITE_00000_1_local_ack,0
00E6  1A07  	BTFSC i2c_WRITE_00000_1_l_sda,4
00E7  1473  	BSF i2c_WRITE_00000_1_local_ack,0

	delay_us(dly);
00E8  300A  	MOVLW 0x0A
00E9  00F4  	MOVWF delay_us_00000_arg_del
00EA  2010  	CALL delay_us_00000


	l_scl_tris = 0; // drive SCL low	
00EB  1683  	BSF STATUS, RP0
00EC  1187  	BCF i2c_WRITE_00000_1_l_scl_tris,3

	l_acken = 0;
00ED  1283  	BCF STATUS, RP0
00EE  1241  	BCF i2c_WRITE_00000_1_l_acken,4

	delay_us(dly);
00EF  300A  	MOVLW 0x0A
00F0  00F4  	MOVWF delay_us_00000_arg_del
00F1  2010  	CALL delay_us_00000

	return(local_ack);
00F2  01F4  	CLRF CompTempVarRet552
00F3  1873  	BTFSC i2c_WRITE_00000_1_local_ack,0
00F4  0AF4  	INCF CompTempVarRet552, F

}
00F5  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Read Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_READ(char ack_status)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	char BitMask;
	char i2c_data;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
01CD  11C6  	BCF i2c_READ_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
01CE  11C5  	BCF i2c_READ_00000_1_l_sspif,3

	l_wcol = 0; // clear write collision flag	
01CF  13C0  	BCF i2c_READ_00000_1_l_wcol,7


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// enable master for 1 byte reception	
		l_rcen = 1;

		// wait until byte received
		while(!l_sspif || !l_bf)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// read the byte from the Rx register
		i2c_data = i2c_SSPBUF;			
			
		// wait until the bus is idle		
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		if (ack_status)
			l_ackdt = 1; // preset ack bit
		else
			l_ackdt = 0; // preset ack bit

		l_sspif = 0;
		l_acken = 1; // acknowledge sequence enable

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();								
	}
	else
	{
		// here for i2c software driver
		l_rcen = 1;
01D0  15C1  	BSF i2c_READ_00000_1_l_rcen,3

		l_ackdt = ack_status;
01D1  1871  	BTFSC i2c_READ_00000_arg_ack_status,0
01D2  16C1  	BSF i2c_READ_00000_1_l_ackdt,5
01D3  1C71  	BTFSS i2c_READ_00000_arg_ack_status,0
01D4  12C1  	BCF i2c_READ_00000_1_l_ackdt,5

		l_rw = 1;
01D5  1542  	BSF i2c_READ_00000_1_l_rw,2

		l_scl = 0; // prepare to set SCL line low
01D6  1187  	BCF i2c_READ_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low	
01D7  1207  	BCF i2c_READ_00000_1_l_sda,4


		// prepare to serialize in the byte
		l_sda_tris = 1; // float SDA
01D8  1683  	BSF STATUS, RP0
01D9  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

		delay_us(dly);
01DA  300A  	MOVLW 0x0A
01DB  1283  	BCF STATUS, RP0
01DC  00F4  	MOVWF delay_us_00000_arg_del
01DD  2010  	CALL delay_us_00000

		i2c_data = 0;
01DE  01F3  	CLRF i2c_READ_00000_1_i2c_data

		for (BitMask = 0x80; BitMask; BitMask>>=1)
01DF  3080  	MOVLW 0x80
01E0  00F2  	MOVWF i2c_READ_00000_1_BitMask
01E1        label35
01E1  08F2  	MOVF i2c_READ_00000_1_BitMask, F
01E2  1903  	BTFSC STATUS,Z
01E3  29FE  	GOTO	label39
01FB  1003  	BCF STATUS,C
01FC  0CF2  	RRF i2c_READ_00000_1_BitMask, F
01FD  29E1  	GOTO	label35
01FE        label39

		{
			l_scl_tris = 1; // float SCL high
01E4  1683  	BSF STATUS, RP0
01E5  1587  	BSF i2c_READ_00000_1_l_scl_tris,3

			// wait until any clock stretching has finished
			while (!l_scl)
01E6        label36
01E6  1283  	BCF STATUS, RP0
01E7  1987  	BTFSC i2c_READ_00000_1_l_scl,3
01E8  29EB  	GOTO	label37
01EA  29E6  	GOTO	label36
01EB        label37

				if (T_MODE & i2c_reset_wdt)
					clear_wdt();		
01E9  0064  	CLRWDT

			delay_us(dly);
01EB  300A  	MOVLW 0x0A
01EC  00F4  	MOVWF delay_us_00000_arg_del
01ED  2010  	CALL delay_us_00000


			// read the current bit
			l_sda_tris = 1; // float SDA
01EE  1683  	BSF STATUS, RP0
01EF  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

			if (l_sda)
01F0  1283  	BCF STATUS, RP0
01F1  1E07  	BTFSS i2c_READ_00000_1_l_sda,4
01F2  29F5  	GOTO	label38
01F5        label38

				i2c_data |= BitMask;
01F3  0872  	MOVF i2c_READ_00000_1_BitMask, W
01F4  04F3  	IORWF i2c_READ_00000_1_i2c_data, F

			l_scl_tris = 0; // drive SCL low
01F5  1683  	BSF STATUS, RP0
01F6  1187  	BCF i2c_READ_00000_1_l_scl_tris,3

			delay_us(dly);
01F7  300A  	MOVLW 0x0A
01F8  1283  	BCF STATUS, RP0
01F9  00F4  	MOVWF delay_us_00000_arg_del
01FA  2010  	CALL delay_us_00000

		}
		// flag receive complete			
		l_sspif = 1;
01FE  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		l_rcen = 0;
01FF  11C1  	BCF i2c_READ_00000_1_l_rcen,3

		
		// set the ACK state
		if (ack_status)	
0200  08F1  	MOVF i2c_READ_00000_arg_ack_status, F
0201  1903  	BTFSC STATUS,Z
0202  2A06  	GOTO	label40
0206        label40

			l_sda_tris = 1; // float SDA high
0203  1683  	BSF STATUS, RP0
0204  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

		else
0205  2A08  	GOTO	label41
0208        label41

			l_sda_tris = 0; // drive SDA low
0206  1683  	BSF STATUS, RP0
0207  1207  	BCF i2c_READ_00000_1_l_sda_tris,4

		delay_us(dly);
0208  300A  	MOVLW 0x0A
0209  1283  	BCF STATUS, RP0
020A  00F4  	MOVWF delay_us_00000_arg_del
020B  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
020C  1683  	BSF STATUS, RP0
020D  1587  	BSF i2c_READ_00000_1_l_scl_tris,3


		// wait until any clock stretching has finished
		while (!l_scl)
020E        label42
020E  1283  	BCF STATUS, RP0
020F  1987  	BTFSC i2c_READ_00000_1_l_scl,3
0210  2A13  	GOTO	label43
0212  2A0E  	GOTO	label42
0213        label43

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
0211  0064  	CLRWDT

	
		l_sspif = 0; // clear SSPIF
0213  11C5  	BCF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
0214  300A  	MOVLW 0x0A
0215  00F4  	MOVWF delay_us_00000_arg_del
0216  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low		
0217  1683  	BSF STATUS, RP0
0218  1187  	BCF i2c_READ_00000_1_l_scl_tris,3

		l_sspif = 1;
0219  1283  	BCF STATUS, RP0
021A  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
021B  300A  	MOVLW 0x0A
021C  00F4  	MOVWF delay_us_00000_arg_del
021D  2010  	CALL delay_us_00000

	}
	return(i2c_data);
021E  0873  	MOVF i2c_READ_00000_1_i2c_data, W
021F  00F4  	MOVWF CompTempVarRet553

}
0220  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Initialization
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_INIT(unsigned char i2c_divisor)

{
	volatile unsigned char i2c_SSPADD@T_i2c_SSPADD, i2c_SSPSTAT@T_i2c_SSPSTAT;
	volatile unsigned char i2c_SSPCON1@T_i2c_SSPCON1,i2c_SSPCON2@T_i2c_SSPCON2;

	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_sspen@T_i2c_SSPCON1.i2c_SSPEN, l_smp@T_i2c_SSPSTAT.T_i2c_SMP_BIT;

	l_sda_tris = 1;
0492  1683  	BSF STATUS, RP0
0493  1607  	BSF i2c_INIT_00000_1_l_sda_tris,4

	l_scl_tris = 1;
0494  1587  	BSF i2c_INIT_00000_1_l_scl_tris,3

	
	i2c_SSPCON1 = 0x00; // initialise the I2C control register (mirrors HW SSPCON1)	
0495  1283  	BCF STATUS, RP0
0496  01C0  	CLRF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPADD = i2c_divisor; // get the I2C baud rate divisor
0497  086F  	MOVF i2c_INIT_00000_arg_i2c_divisor, W
0498  00C3  	MOVWF i2c_INIT_00000_1_i2c_SSPADD

	i2c_SSPCON1 = 0x08; // initialise the I2C control register (mirrors HW SSPCON1)	
0499  3008  	MOVLW 0x08
049A  00C0  	MOVWF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPCON2 = 0x00; // initialise the I2C control register (mirrors HW SSPCON2)	
049B  01C1  	CLRF i2c_INIT_00000_1_i2c_SSPCON2

	
	i2c_SSPSTAT = 0x00; // initialise the I2C status register (mirrors HW SSPSTAT)
049C  01C2  	CLRF i2c_INIT_00000_1_i2c_SSPSTAT

	
	if (T_MODE & i2c_SMP)
		l_smp = 1;
049D  17C2  	BSF i2c_INIT_00000_1_l_smp,7


	l_sspif = 0; // initialise the I2C SSP interrupt status
049E  11C5  	BCF i2c_INIT_00000_1_l_sspif,3

	l_bclif = 0; // initialise the I2C BCL interrupt status
049F  11C6  	BCF i2c_INIT_00000_1_l_bclif,3

	l_sda = 0;
04A0  1207  	BCF i2c_INIT_00000_1_l_sda,4

	l_scl = 0;
04A1  1187  	BCF i2c_INIT_00000_1_l_scl,3

	l_sspen = 1; // enable I2C
04A2  16C0  	BSF i2c_INIT_00000_1_l_sspen,5

	
	i2c_STOP<_I2C_TEMPL_ARGS>();
04A3  20F6  	CALL i2c_STOP_00000

}
04A4  0008  	RETURN







////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  158A  	BSF PCLATH,3
0001  28E3  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B0  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00B1  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00B2  	MOVWF Int1BContext+D'2'
000D  158A  	BSF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2946  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010  3003  	MOVLW 0x03
0011  07F4  	ADDWF delay_us_00000_arg_del, F
0012  0CF4  	RRF delay_us_00000_arg_del, F
0013  0CF4  	RRF delay_us_00000_arg_del, F
0014  307F  	MOVLW 0x7F
0015  05F4  	ANDWF delay_us_00000_arg_del, F
0016        label1
0016  0000  	NOP
0017  0BF4  	DECFSZ delay_us_00000_arg_del, F
0018  2816  	GOTO	label1
0019  0008  	RETURN
001A        ; } delay_us function end

001A        __rom_get_00000
001A        ; { __rom_get ; function begin
001A  0877  	MOVF __rom_get_00000_arg_objNumb, W
001B  00FA  	MOVWF __rom_get_00000_1_romAddr+D'1'
001C  01F9  	CLRF __rom_get_00000_1_romAddr
001D  1003  	BCF STATUS,C
001E  0DFA  	RLF __rom_get_00000_1_romAddr+D'1', F
001F  0DF9  	RLF __rom_get_00000_1_romAddr, F
0020  0DFA  	RLF __rom_get_00000_1_romAddr+D'1', F
0021  0DF9  	RLF __rom_get_00000_1_romAddr, F
0022  07FA  	ADDWF __rom_get_00000_1_romAddr+D'1', F
0023  1803  	BTFSC STATUS,C
0024  0AF9  	INCF __rom_get_00000_1_romAddr, F
0025  07FA  	ADDWF __rom_get_00000_1_romAddr+D'1', F
0026  1803  	BTFSC STATUS,C
0027  0AF9  	INCF __rom_get_00000_1_romAddr, F
0028  3033  	MOVLW	LOW( label2 )
0029  07FA  	ADDWF __rom_get_00000_1_romAddr+D'1', F
002A  1803  	BTFSC STATUS,C
002B  0AF9  	INCF __rom_get_00000_1_romAddr, F
002C  3000  	MOVLW	HIGH( label2 )
002D  0779  	ADDWF __rom_get_00000_1_romAddr, W
002E  008A  	MOVWF PCLATH
002F  0878  	MOVF __rom_get_00000_arg_idx, W
0030  00F9  	MOVWF __rom_get_00000_1_romAddr
0031  087A  	MOVF __rom_get_00000_1_romAddr+D'1', W
0032  0082  	MOVWF PCL
0033        label2
0033  3000  	MOVLW	HIGH( label3 )
0034  008A  	MOVWF PCLATH
0035  3000  	MOVLW	HIGH( label4 )
0036  00FA  	MOVWF __rom_get_00000_1_romAddr+D'1'
0037  3049  	MOVLW	LOW( label4 )
0038  2842  	GOTO	label3
0039  3000  	MOVLW	HIGH( label3 )
003A  008A  	MOVWF PCLATH
003B  3000  	MOVLW	HIGH( label5 )
003C  00FA  	MOVWF __rom_get_00000_1_romAddr+D'1'
003D  3055  	MOVLW	LOW( label5 )
003E  2842  	GOTO	label3
003F  3000  	MOVLW	HIGH( label6 )
0040  00FA  	MOVWF __rom_get_00000_1_romAddr+D'1'
0041  306D  	MOVLW	LOW( label6 )
0042        label3
0042  07F9  	ADDWF __rom_get_00000_1_romAddr, F
0043  1803  	BTFSC STATUS,C
0044  0AFA  	INCF __rom_get_00000_1_romAddr+D'1', F
0045  087A  	MOVF __rom_get_00000_1_romAddr+D'1', W
0046  008A  	MOVWF PCLATH
0047  0879  	MOVF __rom_get_00000_1_romAddr, W
0048  0082  	MOVWF PCL
0049        label4
0049  3431  	RETLW 0x31
004A  3428  	RETLW 0x28
004B  3431  	RETLW 0x31
004C  3430  	RETLW 0x30
004D  3431  	RETLW 0x31
004E  3430  	RETLW 0x30
004F  3431  	RETLW 0x31
0050  3431  	RETLW 0x31
0051  3430  	RETLW 0x30
0052  3431  	RETLW 0x31
0053  3430  	RETLW 0x30
0054  3431  	RETLW 0x31
0055        label5
0055  3404  	RETLW 0x04
0056  3408  	RETLW 0x08
0057  3412  	RETLW 0x12
0058  3416  	RETLW 0x16
0059  3420  	RETLW 0x20
005A  3424  	RETLW 0x24
005B  3428  	RETLW 0x28
005C  3432  	RETLW 0x32
005D  3436  	RETLW 0x36
005E  3440  	RETLW 0x40
005F  3444  	RETLW 0x44
0060  3448  	RETLW 0x48
0061  3452  	RETLW 0x52
0062  3456  	RETLW 0x56
0063  3460  	RETLW 0x60
0064  3464  	RETLW 0x64
0065  3468  	RETLW 0x68
0066  3472  	RETLW 0x72
0067  3476  	RETLW 0x76
0068  3480  	RETLW 0x80
0069  3484  	RETLW 0x84
006A  3488  	RETLW 0x88
006B  3492  	RETLW 0x92
006C  3496  	RETLW 0x96
006D        label6
006D  343F  	RETLW 0x3F
006E  3406  	RETLW 0x06
006F  345B  	RETLW 0x5B
0070  344F  	RETLW 0x4F
0071  3466  	RETLW 0x66
0072  346D  	RETLW 0x6D
0073  347D  	RETLW 0x7D
0074  3407  	RETLW 0x07
0075  347F  	RETLW 0x7F
0076  346F  	RETLW 0x6F
0077        ; } __rom_get function end

0077        delay_10us_00000
0077        ; { delay_10us ; function begin
0077        label7
0077  0000  	NOP
0078  0000  	NOP
0079  0000  	NOP
007A  0000  	NOP
007B  0000  	NOP
007C  0000  	NOP
007D  0000  	NOP
007E  0BF3  	DECFSZ delay_10us_00000_arg_del, F
007F  2877  	GOTO	label7
0080  0008  	RETURN
0081        ; } delay_10us function end

0081        delay_ms_00000
0081        ; { delay_ms ; function begin
0081  08EE  	MOVF delay_ms_00000_arg_del, F
0082  1D03  	BTFSS STATUS,Z
0083  2885  	GOTO	label8
0084  0008  	RETURN
0085        label8
0085  30F9  	MOVLW 0xF9
0086        label9
0086  3EFF  	ADDLW 0xFF
0087  1D03  	BTFSS STATUS,Z
0088  2886  	GOTO	label9
0089  0000  	NOP
008A  0BEE  	DECFSZ delay_ms_00000_arg_del, F
008B  2885  	GOTO	label8
008C  0008  	RETURN
008D        ; } delay_ms function end











025F        __mul_16s__0000F
025F        ; { __mul_16s_16s__16 ; function begin
025F  01FA  	CLRF __mul_16s__0000F_1_i
0260  01FD  	CLRF CompTempVarRet389
0261  01FE  	CLRF CompTempVarRet389+D'1'
0262  0876  	MOVF __mul_16s__0000F_arg_a, W
0263  00FB  	MOVWF __mul_16s__0000F_1_t
0264  0877  	MOVF __mul_16s__0000F_arg_a+D'1', W
0265  00FC  	MOVWF __mul_16s__0000F_1_t+D'1'
0266  1FF9  	BTFSS __mul_16s__0000F_arg_b+D'1',7
0267  2A6E  	GOTO	label50
0268  17FA  	BSF __mul_16s__0000F_1_i,7
0269  09F8  	COMF __mul_16s__0000F_arg_b, F
026A  09F9  	COMF __mul_16s__0000F_arg_b+D'1', F
026B  0AF8  	INCF __mul_16s__0000F_arg_b, F
026C  1903  	BTFSC gbl_status,2
026D  0AF9  	INCF __mul_16s__0000F_arg_b+D'1', F
026E        label50
026E  1A7A  	BTFSC __mul_16s__0000F_1_i,4
026F  2A80  	GOTO	label52
0270  1C78  	BTFSS __mul_16s__0000F_arg_b,0
0271  2A78  	GOTO	label51
0272  087B  	MOVF __mul_16s__0000F_1_t, W
0273  07FD  	ADDWF CompTempVarRet389, F
0274  087C  	MOVF __mul_16s__0000F_1_t+D'1', W
0275  1803  	BTFSC gbl_status,0
0276  0F7C  	INCFSZ __mul_16s__0000F_1_t+D'1', W
0277  07FE  	ADDWF CompTempVarRet389+D'1', F
0278        label51
0278  1003  	BCF gbl_status,0
0279  0CF9  	RRF __mul_16s__0000F_arg_b+D'1', F
027A  0CF8  	RRF __mul_16s__0000F_arg_b, F
027B  1003  	BCF gbl_status,0
027C  0DFB  	RLF __mul_16s__0000F_1_t, F
027D  0DFC  	RLF __mul_16s__0000F_1_t+D'1', F
027E  0AFA  	INCF __mul_16s__0000F_1_i, F
027F  2A6E  	GOTO	label50
0280        label52
0280  1FFA  	BTFSS __mul_16s__0000F_1_i,7
0281  0008  	RETURN
0282  09FD  	COMF CompTempVarRet389, F
0283  09FE  	COMF CompTempVarRet389+D'1', F
0284  0AFD  	INCF CompTempVarRet389, F
0285  1903  	BTFSC gbl_status,2
0286  0AFE  	INCF CompTempVarRet389+D'1', F
0287  0008  	RETURN
0288        ; } __mul_16s_16s__16 function end



































08E3        _startup

0943  158A  	BSF PCLATH,3
0944  120A  	BCF PCLATH,4
0945  2820  	GOTO	main

2007  3FB1  	DW 0x3FB1
