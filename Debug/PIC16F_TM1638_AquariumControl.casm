;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 8.01
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

#ifndef _PIC16F_TM1638_AquariumControl_H_
#define _PIC16F_TM1638_AquariumControl_H_

#define TASK_TIMER0 1
#define TASK_TIMER1 2

#define oneWireBus (portc.5)
#define oneWireTris (trisc.5)
#define tm1638dio (portb.1)
#define tm1638dioTris (trisb.1)
#define tm1638clk (portb.2)
#define tm1638strobe (portb.3)
#define WHITE_LED (portc.1)
#define BLUE_LED (portc.2)
#define FAN (porta.1)
#define HEATER (porta.0)

// Timer 0 preload

#define TMR0PRELOAD 61
// This means timer 1 will overflow when 1 cycle completes, generating the interrupt
#define TMR1HV 0xFF
#define TMR1LV 0xFF

// i2c options
#define use_i2c_SW
// clock SCL on RA3, data SDA on RA4
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)
// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3

#define ds3231_addr 0xD0 // Left shifted 7 bit address 0x68
#define at24c32_addr 0xAE // Left shifted 7 bit address 0x57

// Time and date variables
char gBcdSeconds = 0; // 0 to 59
07E1  1283  	BCF STATUS, RP0
07E2  1303  	BCF STATUS, RP1
07E3  01B5  	CLRF gbl_gBcdSeconds

char gBcdMinute = 0; // 0 to 59
07E4  01B6  	CLRF gbl_gBcdMinute

char gBcdHour = 0; // 0 to 23 or 1 to 12. Also contains 12/24 setting at bit 6. If 12 hour, AM/PM uses bit 5
07E5  01B7  	CLRF gbl_gBcdHour

char gDayOfWeek = 1; // 1 to 7
07E6  3001  	MOVLW 0x01
07E7  00B8  	MOVWF gbl_gDayOfWeek

char gBcdDayOfMonth = 1; // 1 to 31
07E8  3001  	MOVLW 0x01
07E9  00B9  	MOVWF gbl_gBcdDayOfMonth

char gBcdMonth = 1; // 1 to 12 + century at bit 7
07EA  3001  	MOVLW 0x01
07EB  00BA  	MOVWF gbl_gBcdMonth

char gBcdYear = 0x23; // Init to 0x23
07EC  3023  	MOVLW 0x23
07ED  00BB  	MOVWF gbl_gBcdYear

rom char *gDaysInMonth = {0x31, 0x28, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31}; // Days in each month
07EE  3000  	MOVLW 0x00
07EF  00BC  	MOVWF gbl_gDaysInMonth

rom char *gLeapYears = {0x04, 0x08, 0x12, 0x16, 0x20, 0x24, 0x28, 0x32, 0x36, 0x40, 0x44, 0x48, 0x52, 0x56, 0x60, 0x64, 0x68, 0x72, 0x76, 0x80, 0x84, 0x88, 0x92, 0x96}; // List of leap years
07F0  3001  	MOVLW 0x01
07F1  00BD  	MOVWF gbl_gLeapYears


// Timer variables
char iTimer0Counts = 0;
07F2  01BE  	CLRF gbl_iTimer0Counts

char iFlashDigitOff = 0;
07F3  01BF  	CLRF gbl_iFlashDigitOff

char iDigitToFlash = 8; // 8 = no digit to flash
07F4  3008  	MOVLW 0x08
07F5  00C8  	MOVWF gbl_iDigitToFlash


// Hold the upper and lower bytes from the ds18b20
char cTempH = 1;
07F6  3001  	MOVLW 0x01
07F7  00C9  	MOVWF gbl_cTempH

char cTempL = 70;
07F8  3046  	MOVLW 0x46
07F9  00CA  	MOVWF gbl_cTempL

//char iDecimalPosition = 2;

int giDS3231ValueBCD = 0x2000;
07FA  01B3  	CLRF gbl_giDS3231ValueBCD
07FB  3020  	MOVLW 0x20
07FC  00B4  	MOVWF gbl_giDS3231ValueBCD+D'1'

char gbDS3231IsMinus = 0;
07FD  01CB  	CLRF gbl_gbDS3231IsMinus


char cTask = 0; // Used for task scheduler
07FE  01CC  	CLRF gbl_cTask


// States
bool gbWhiteOn = 0;
07FF  104D  	BCF gbl_gbWhiteOn,0

bool gbBlueOn = 0;
0800  10CD  	BCF gbl_gbBlueOn,1

bool gbFanOn = 0;
0801  114D  	BCF gbl_gbFanOn,2

bool gbHeaterOn = 0;
0802  11CD  	BCF gbl_gbHeaterOn,3

bool gbFlashOff = 0;
0803  124D  	BCF gbl_gbFlashOff,4

char gcDisplayMode = 0;
0804  01CE  	CLRF gbl_gcDisplayMode

char gcSetMode = 0;
0805  01CF  	CLRF gbl_gcSetMode

char gcTriggerMode = 0;
0806  01D0  	CLRF gbl_gcTriggerMode


// Triggers
char gBcdWhiteOnMinute = 0; // 0 to 59
0807  01D1  	CLRF gbl_gBcdWhiteOnMinute

char gBcdWhiteOnHour = 0; // 0 to 23
0808  01D2  	CLRF gbl_gBcdWhiteOnHour

char gBcdWhiteOffMinute = 0; // 0 to 59
0809  01D3  	CLRF gbl_gBcdWhiteOffMinute

char gBcdWhiteOffHour = 0; // 0 to 23
080A  01D4  	CLRF gbl_gBcdWhiteOffHour


char gBcdBlueOnMinute = 0; // 0 to 59
080B  01D5  	CLRF gbl_gBcdBlueOnMinute

char gBcdBlueOnHour = 0; // 0 to 23
080C  01D6  	CLRF gbl_gBcdBlueOnHour

char gBcdBlueOffMinute = 0; // 0 to 59
080D  01D7  	CLRF gbl_gBcdBlueOffMinute

char gBcdBlueOffHour = 0; // 0 to 23
080E  01D8  	CLRF gbl_gBcdBlueOffHour


char gBcdFanOnTemp = 0x28; // Degrees C
080F  3028  	MOVLW 0x28
0810  00D9  	MOVWF gbl_gBcdFanOnTemp

char gBcdFanOffTemp = 0x27; // Degrees C
0811  3027  	MOVLW 0x27
0812  00DA  	MOVWF gbl_gBcdFanOffTemp


char gBcdHeaterOnTemp = 0x24; // Degrees C
0813  3024  	MOVLW 0x24
0814  00DB  	MOVWF gbl_gBcdHeaterOnTemp

char gBcdHeaterOffTemp = 0x25; // Degrees C
0815  3025  	MOVLW 0x25
0816  00DC  	MOVWF gbl_gBcdHeaterOffTemp


// Used to output the segments from numbers
char tm1638MaxDigits = 8;
0817  3008  	MOVLW 0x08
0818  00DD  	MOVWF gbl_tm1638MaxDigits

rom char *tm1638DisplayNumtoSeg = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f};
0819  3002  	MOVLW 0x02
081A  00DE  	MOVWF gbl_tm1638DisplayNumtoSeg

char tm1638Dot = 0x80;
081B  3080  	MOVLW 0x80
081C  00DF  	MOVWF gbl_tm1638Dot

char tm1638Brightness = 7; // 0 to 7
081D  3007  	MOVLW 0x07
081E  00E0  	MOVWF gbl_tm1638Brightness

// 0x40 [01000000] = indicate command to display data
char tm1638ByteSetData = 0x40;
081F  3040  	MOVLW 0x40
0820  00E1  	MOVWF gbl_tm1638ByteSetData

// 0x42 [01000010] = indicate command to read data
char tm1638ByteReadData = 0x42;
0821  3042  	MOVLW 0x42
0822  00E2  	MOVWF gbl_tm1638ByteReadData

// 0xC0 [11000000] = write out all bytes
char tm1638ByteSetAddr = 0xC0;
0823  30C0  	MOVLW 0xC0
0824  00E3  	MOVWF gbl_tm1638ByteSetAddr

// 0x88 [10001000] - Display ON, plus brightness
char tm1638ByteSetOn = 0x88;
0825  3088  	MOVLW 0x88
0826  00E4  	MOVWF gbl_tm1638ByteSetOn


// Copy of the data to write / on the display
char tm1638Data[] = {0, 0, 0, 0, 0, 0, 0, 0};
0827  01A0  	CLRF gbl_tm1638Data
0828  01A1  	CLRF gbl_tm1638Data+D'1'
0829  01A2  	CLRF gbl_tm1638Data+D'2'
082A  01A3  	CLRF gbl_tm1638Data+D'3'
082B  01A4  	CLRF gbl_tm1638Data+D'4'
082C  01A5  	CLRF gbl_tm1638Data+D'5'
082D  01A6  	CLRF gbl_tm1638Data+D'6'
082E  01A7  	CLRF gbl_tm1638Data+D'7'

// Copy of the LED status
char tm1638LEDs[] = {0, 0, 0, 0, 0, 0, 0, 0};
082F  01A8  	CLRF gbl_tm1638LEDs
0830  01A9  	CLRF gbl_tm1638LEDs+D'1'
0831  01AA  	CLRF gbl_tm1638LEDs+D'2'
0832  01AB  	CLRF gbl_tm1638LEDs+D'3'
0833  01AC  	CLRF gbl_tm1638LEDs+D'4'
0834  01AD  	CLRF gbl_tm1638LEDs+D'5'
0835  01AE  	CLRF gbl_tm1638LEDs+D'6'
0836  01AF  	CLRF gbl_tm1638LEDs+D'7'

// Copy of the keys
char tm1638Keys = 0;
0837  01E5  	CLRF gbl_tm1638Keys

char tm1638KeysOld = 0;
0838  01E6  	CLRF gbl_tm1638KeysOld

// For printing
char iPrintStartDigit = 0;
0839  01E7  	CLRF gbl_iPrintStartDigit

char iPrintDotDigit = 8;
083A  3008  	MOVLW 0x08
083B  00E8  	MOVWF gbl_iPrintDotDigit

// For adjusting bcd numbers up 1 or down !1
char iBcdAdjustment = 1;
083C  3001  	MOVLW 0x01
083D  00E9  	MOVWF gbl_iBcdAdjustment


// DS18B20 functions
char oneWireIsPresent = 0;
083E  01EA  	CLRF gbl_oneWireIsPresent

char oneWireResetStage = 0;
083F  01EB  	CLRF gbl_oneWireResetStage

void oneWireBusReset();
void oneWireTxByte(char data);
void oneWireTxBytes(char data, char data2);
char oneWireRxByte();

// EEPROM functions
void eepromWriteAll();
char eepromWrite(char address, char data);
void eepromReadAll();
char eepromRead(char address);

// DS3231 functions
void ds3231Write(char ds3231Reg, char bWrite);
void ds3231Init();
void ds3231Start();
void ds3231Stop();
void ds3231WriteDateTime();
void ds3231ReadDateTime();
char ds3231ReadRegister(char cRegAddress);

// TM1638 functions
void tm1638ByteWrite(char bWrite);
void bcdTo7Seg(char iBcdIn);
void tm1638DisplayOn();
void tm1638UpdateDisplay();
void tm1638ReadKeys();

// General functions
int binToBcd(int iBin);
void startTemp();
void readTemp();

char bcdAdjust(char bcd, char bcdMax, char bcdMin);
void adjustDateTime();
void adjustTrigger();
void processKeys();

#endif

#include <system.h>
#include <i2c_driver.h>
#include "PIC16F_TM1638_AquariumControl.h"

//Target PIC16F628A configuration word
#pragma DATA _CONFIG, _BODEN_OFF & _PWRTE_ON & _WDT_OFF & _CP_OFF & _XT_OSC // Brown out reset off, Power-up Timer on, Watchdog timer off, Code Protection off, XT oscillator

//Set clock frequency (for software delays) - 4MHz
#pragma CLOCK_FREQ	4000000

    
/*********************************************************************************************
  void oneWireBusReset()
  First part of the reset routine - drive the bus low for 500us
*********************************************************************************************/
void oneWireBusReset() {

    char isPresent;
    oneWireTris = 1; // start with high
0672  1683  	BSF STATUS, RP0
0673  1303  	BCF STATUS, RP1
0674  1687  	BSF gbl_trisc,5

    isPresent = 0;
0675  1283  	BCF STATUS, RP0
0676  01ED  	CLRF oneWireBus_00017_1_isPresent

    // Send the reset pulse - drive low for 500us
    oneWireBus = 0;      
0677  1287  	BCF gbl_portc,5

    oneWireTris = 0;
0678  1683  	BSF STATUS, RP0
0679  1287  	BCF gbl_trisc,5

    delay_10us(50);
067A  3032  	MOVLW 0x32
067B  1283  	BCF STATUS, RP0
067C  00F2  	MOVWF delay_10us_00000_arg_del
067D  201A  	CALL delay_10us_00000

    // Release line and wait 70us for PD Pulse
    oneWireTris = 1;
067E  1683  	BSF STATUS, RP0
067F  1687  	BSF gbl_trisc,5

    delay_10us(7);
0680  3007  	MOVLW 0x07
0681  1283  	BCF STATUS, RP0
0682  00F2  	MOVWF delay_10us_00000_arg_del
0683  201A  	CALL delay_10us_00000

    // Now sample, if there is a sensor on the bus, the line should be low
    if (oneWireBus) {
0684  1A87  	BTFSC gbl_portc,5

        oneWireIsPresent = 0; // no devices
0685  01EA  	CLRF gbl_oneWireIsPresent

    }
    delay_10us(50);
0686  3032  	MOVLW 0x32
0687  00F2  	MOVWF delay_10us_00000_arg_del
0688  201A  	CALL delay_10us_00000

}
0689  0008  	RETURN


/*********************************************************************************************
  void oneWireTxByte(char data)
  Transmits a single byte from the bus
*********************************************************************************************/
void oneWireTxByte(char cData) {

    char cTemp = 1;
0156  3001  	MOVLW 0x01
0157  00F0  	MOVWF oneWireTxB_00018_1_cTemp

    // Loop through the eight bits in the byte
    for (char i = 0; i < 8; i++) {
0158  01F1  	CLRF oneWireTxB_00018_2_i
0159        label25
0159  3008  	MOVLW 0x08
015A  0271  	SUBWF oneWireTxB_00018_2_i, W
015B  1803  	BTFSC STATUS,C
0170  0AF1  	INCF oneWireTxB_00018_2_i, F
0171  2959  	GOTO	label25

        // Send the LSB first

        // Drive the line low initially for 3us
        oneWireTris = 0;
015D  1683  	BSF STATUS, RP0
015E  1287  	BCF gbl_trisc,5

        oneWireBus = 0;
015F  1283  	BCF STATUS, RP0
0160  1287  	BCF gbl_portc,5


        // Delay not needed for 4MHz PIC
        //delay_us(3); // Delay 3us
        
        if (cData & cTemp) {
0161  0870  	MOVF oneWireTxB_00018_1_cTemp, W
0162  056F  	ANDWF oneWireTxB_00018_arg_cData, W
0163  1903  	BTFSC STATUS,Z
0164  2967  	GOTO	label26

            oneWireTris = 1; // Release the bus
0165  1683  	BSF STATUS, RP0
0166  1687  	BSF gbl_trisc,5

        }
        
        delay_10us(5); // Delay 60us - 50us works fine with code delays
0167  3005  	MOVLW 0x05
0168  1283  	BCF STATUS, RP0
0169  00F2  	MOVWF delay_10us_00000_arg_del
016A  201A  	CALL delay_10us_00000

        oneWireTris = 1; // Release the bus
016B  1683  	BSF STATUS, RP0
016C  1687  	BSF gbl_trisc,5

        
        // move the test bit
        cTemp <<= 1;
016D  1003  	BCF STATUS,C
016E  1283  	BCF STATUS, RP0
016F  0DF0  	RLF oneWireTxB_00018_1_cTemp, F

    }
}
015C  0008  	RETURN


/*********************************************************************************************
  void oneWireTxBytes(char data, char data2)
  Transmits a 2 bytes from the bus
*********************************************************************************************/
void oneWireTxBytes(char cData, char cData2) {

    // Reset first - done in main
    //oneWireBusReset();
    // Send first byte
    oneWireTxByte(cData);
03AA  086D  	MOVF oneWireTxB_00019_arg_cData, W
03AB  00EF  	MOVWF oneWireTxB_00018_arg_cData
03AC  2156  	CALL oneWireTxB_00018

    // Send second byte
    oneWireTxByte(cData2);
03AD  086E  	MOVF oneWireTxB_00019_arg_cData2, W
03AE  00EF  	MOVWF oneWireTxB_00018_arg_cData
03AF  2156  	CALL oneWireTxB_00018

}
03B0  0008  	RETURN


/*********************************************************************************************
  char oneWireRxByte()
  Receives a single byte from the bus
*********************************************************************************************/
char oneWireRxByte() {

    char cDataIn = 0;
03B1  1283  	BCF STATUS, RP0
03B2  1303  	BCF STATUS, RP1
03B3  01ED  	CLRF oneWireRxB_0001A_1_cDataIn

    // Loop through the eight bits in the byte
    for(char i = 0; i < 8; i++) {
03B4  01EE  	CLRF oneWireRxB_0001A_2_i
03B5        label77
03B5  3008  	MOVLW 0x08
03B6  026E  	SUBWF oneWireRxB_0001A_2_i, W
03B7  1803  	BTFSC STATUS,C
03B8  2BCC  	GOTO	label78
03CA  0AEE  	INCF oneWireRxB_0001A_2_i, F
03CB  2BB5  	GOTO	label77
03CC        label78

        // Bring bus low for 15us
        oneWireTris = 0;
03B9  1683  	BSF STATUS, RP0
03BA  1287  	BCF gbl_trisc,5

        oneWireBus = 0;
03BB  1283  	BCF STATUS, RP0
03BC  1287  	BCF gbl_portc,5


        // Delay not needed for 4MHz PIC
        //delay_us(15); // Delay 15us

        // Release bus for 6us, this is enough time for the slave to respond
        oneWireTris = 1;
03BD  1683  	BSF STATUS, RP0
03BE  1687  	BSF gbl_trisc,5

        delay_us(6); // Delay 6us
03BF  3006  	MOVLW 0x06
03C0  1283  	BCF STATUS, RP0
03C1  00F2  	MOVWF delay_us_00000_arg_del
03C2  2010  	CALL delay_us_00000

        
        // Shift data already received left
        cDataIn >>= 1;
03C3  1003  	BCF STATUS,C
03C4  0CED  	RRF oneWireRxB_0001A_1_cDataIn, F

        // Check the value of the onewire bus - set the MSB of cDataIn if so
        if (oneWireBus)
03C5  1A87  	BTFSC gbl_portc,5

            cDataIn.7 = 1;
03C6  17ED  	BSF oneWireRxB_0001A_1_cDataIn,7


        // To finish time slot
        delay_10us(6); // 60us
03C7  3006  	MOVLW 0x06
03C8  00F2  	MOVWF delay_10us_00000_arg_del
03C9  201A  	CALL delay_10us_00000

    } 
    
    return cDataIn;
03CC  086D  	MOVF oneWireRxB_0001A_1_cDataIn, W
03CD  00EE  	MOVWF CompTempVarRet551

}
03CE  0008  	RETURN


/*********************************************************************************************
  void at24c32WriteAll()
  Write multiple bytes
*********************************************************************************************/
void at24c32WriteAll() {

	// https://www.instructables.com/The-Most-Comprehensive-Guide-to-Programming-the-AT/
	i2c_start();
041E  210E  	CALL i2c_START_00000

	i2c_write(at24c32_addr); // address + write
041F  30AE  	MOVLW 0xAE
0420  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0421  208D  	CALL i2c_WRITE_00000

	// start at address 0
	i2c_write(0); // First word address (only 4 bits of the 12 bit byte address)
0422  01EF  	CLRF i2c_WRITE_00000_arg_i2c_data
0423  208D  	CALL i2c_WRITE_00000

	i2c_write(0); // Second word address 
0424  01EF  	CLRF i2c_WRITE_00000_arg_i2c_data
0425  208D  	CALL i2c_WRITE_00000

	// Write data bytes
	// We're only writing 13 bytes here, so no need to worry about row rollover after 32 bytes
	i2c_write(0x44); // To indicate AT24C32 has been written to
0426  3044  	MOVLW 0x44
0427  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0428  208D  	CALL i2c_WRITE_00000

	i2c_write(gBcdWhiteOnMinute);
0429  0851  	MOVF gbl_gBcdWhiteOnMinute, W
042A  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
042B  208D  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOnHour);
042C  0852  	MOVF gbl_gBcdWhiteOnHour, W
042D  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
042E  208D  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOffMinute);
042F  0853  	MOVF gbl_gBcdWhiteOffMinute, W
0430  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0431  208D  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOffHour);
0432  0854  	MOVF gbl_gBcdWhiteOffHour, W
0433  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0434  208D  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOnMinute);
0435  0855  	MOVF gbl_gBcdBlueOnMinute, W
0436  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0437  208D  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOnHour);
0438  0856  	MOVF gbl_gBcdBlueOnHour, W
0439  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
043A  208D  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOffMinute);
043B  0857  	MOVF gbl_gBcdBlueOffMinute, W
043C  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
043D  208D  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOffHour);
043E  0858  	MOVF gbl_gBcdBlueOffHour, W
043F  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0440  208D  	CALL i2c_WRITE_00000

    i2c_write(gBcdFanOnTemp);
0441  0859  	MOVF gbl_gBcdFanOnTemp, W
0442  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0443  208D  	CALL i2c_WRITE_00000

    i2c_write(gBcdFanOffTemp);
0444  085A  	MOVF gbl_gBcdFanOffTemp, W
0445  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0446  208D  	CALL i2c_WRITE_00000

    i2c_write(gBcdHeaterOnTemp);
0447  085B  	MOVF gbl_gBcdHeaterOnTemp, W
0448  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0449  208D  	CALL i2c_WRITE_00000

    i2c_write(gBcdHeaterOffTemp);
044A  085C  	MOVF gbl_gBcdHeaterOffTemp, W
044B  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
044C  208D  	CALL i2c_WRITE_00000

	i2c_stop();
044D  20DE  	CALL i2c_STOP_00000

	delay_ms(10); // Write Cycle Time
044E  300A  	MOVLW 0x0A
044F  00EC  	MOVWF delay_ms_00000_arg_del
0450  2081  	CALL delay_ms_00000

}
0451  0008  	RETURN


/*********************************************************************************************
  void at24c32ReadAll()
  Read all bytes
*********************************************************************************************/
void at24c32ReadAll() {

	i2c_start();
0452  210E  	CALL i2c_START_00000

	i2c_write(at24c32_addr); // address + write
0453  30AE  	MOVLW 0xAE
0454  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0455  208D  	CALL i2c_WRITE_00000

	// start at address 0
	i2c_write(0); // First word address (only 4 bits of the 12 bit byte address)
0456  01EF  	CLRF i2c_WRITE_00000_arg_i2c_data
0457  208D  	CALL i2c_WRITE_00000

	i2c_write(0); // Second word address 
0458  01EF  	CLRF i2c_WRITE_00000_arg_i2c_data
0459  208D  	CALL i2c_WRITE_00000

	i2c_stop(); // Don't actually write a byte, just stop
045A  20DE  	CALL i2c_STOP_00000

	
	i2c_start();
045B  210E  	CALL i2c_START_00000

	i2c_write(at24c32_addr + 1); // address + read
045C  30AF  	MOVLW 0xAF
045D  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
045E  208D  	CALL i2c_WRITE_00000

	char hasWritten = i2c_read(0); // ack
045F  01EF  	CLRF i2c_READ_00000_arg_ack_status
0460  2172  	CALL i2c_READ_00000
0461  0872  	MOVF CompTempVarRet553, W
0462  00ED  	MOVWF at24c32Rea_00029_1_hasWritten

	if (hasWritten != 0x44) {
0463  086D  	MOVF at24c32Rea_00029_1_hasWritten, W
0464  3A44  	XORLW 0x44
0465  1903  	BTFSC STATUS,Z
0466  2C6B  	GOTO	label79
046B        label79

		i2c_read(1); // nack
0467  3001  	MOVLW 0x01
0468  00EF  	MOVWF i2c_READ_00000_arg_ack_status
0469  2172  	CALL i2c_READ_00000

	} else {
046A  2C9C  	GOTO	label80
049C        label80

		gBcdWhiteOnMinute = i2c_read(0); // ack
046B  01EF  	CLRF i2c_READ_00000_arg_ack_status
046C  2172  	CALL i2c_READ_00000
046D  0872  	MOVF CompTempVarRet553, W
046E  00D1  	MOVWF gbl_gBcdWhiteOnMinute

		gBcdWhiteOnHour = i2c_read(0); // ack
046F  01EF  	CLRF i2c_READ_00000_arg_ack_status
0470  2172  	CALL i2c_READ_00000
0471  0872  	MOVF CompTempVarRet553, W
0472  00D2  	MOVWF gbl_gBcdWhiteOnHour

		gBcdWhiteOffMinute = i2c_read(0); // ack
0473  01EF  	CLRF i2c_READ_00000_arg_ack_status
0474  2172  	CALL i2c_READ_00000
0475  0872  	MOVF CompTempVarRet553, W
0476  00D3  	MOVWF gbl_gBcdWhiteOffMinute

		gBcdWhiteOffHour = i2c_read(0); // ack
0477  01EF  	CLRF i2c_READ_00000_arg_ack_status
0478  2172  	CALL i2c_READ_00000
0479  0872  	MOVF CompTempVarRet553, W
047A  00D4  	MOVWF gbl_gBcdWhiteOffHour

		gBcdBlueOnMinute = i2c_read(0); // ack
047B  01EF  	CLRF i2c_READ_00000_arg_ack_status
047C  2172  	CALL i2c_READ_00000
047D  0872  	MOVF CompTempVarRet553, W
047E  00D5  	MOVWF gbl_gBcdBlueOnMinute

		gBcdBlueOnHour = i2c_read(0); // ack
047F  01EF  	CLRF i2c_READ_00000_arg_ack_status
0480  2172  	CALL i2c_READ_00000
0481  0872  	MOVF CompTempVarRet553, W
0482  00D6  	MOVWF gbl_gBcdBlueOnHour

		gBcdBlueOffMinute = i2c_read(0); // ack
0483  01EF  	CLRF i2c_READ_00000_arg_ack_status
0484  2172  	CALL i2c_READ_00000
0485  0872  	MOVF CompTempVarRet553, W
0486  00D7  	MOVWF gbl_gBcdBlueOffMinute

		gBcdBlueOffHour = i2c_read(0); // ack
0487  01EF  	CLRF i2c_READ_00000_arg_ack_status
0488  2172  	CALL i2c_READ_00000
0489  0872  	MOVF CompTempVarRet553, W
048A  00D8  	MOVWF gbl_gBcdBlueOffHour

		gBcdFanOnTemp = i2c_read(0); // ack
048B  01EF  	CLRF i2c_READ_00000_arg_ack_status
048C  2172  	CALL i2c_READ_00000
048D  0872  	MOVF CompTempVarRet553, W
048E  00D9  	MOVWF gbl_gBcdFanOnTemp

		gBcdFanOffTemp = i2c_read(0); // ack
048F  01EF  	CLRF i2c_READ_00000_arg_ack_status
0490  2172  	CALL i2c_READ_00000
0491  0872  	MOVF CompTempVarRet553, W
0492  00DA  	MOVWF gbl_gBcdFanOffTemp

		gBcdHeaterOnTemp = i2c_read(0); // ack
0493  01EF  	CLRF i2c_READ_00000_arg_ack_status
0494  2172  	CALL i2c_READ_00000
0495  0872  	MOVF CompTempVarRet553, W
0496  00DB  	MOVWF gbl_gBcdHeaterOnTemp

		gBcdHeaterOffTemp = i2c_read(1); // nack
0497  3001  	MOVLW 0x01
0498  00EF  	MOVWF i2c_READ_00000_arg_ack_status
0499  2172  	CALL i2c_READ_00000
049A  0872  	MOVF CompTempVarRet553, W
049B  00DC  	MOVWF gbl_gBcdHeaterOffTemp

	}
	i2c_stop();
049C  20DE  	CALL i2c_STOP_00000

}
049D  0008  	RETURN



/*********************************************************************************************
  void ds3231Write(char ds3231Reg, char bWrite)
  Write one byte
*********************************************************************************************/
void ds3231Write(char ds3231Reg, char bWrite) {

	i2c_start();
01C6  210E  	CALL i2c_START_00000

	i2c_write(ds3231_addr); // address + write
01C7  30D0  	MOVLW 0xD0
01C8  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
01C9  208D  	CALL i2c_WRITE_00000

	i2c_write(ds3231Reg); // start at address
01CA  086D  	MOVF ds3231Writ_0001B_arg_ds3231Reg, W
01CB  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
01CC  208D  	CALL i2c_WRITE_00000

	i2c_write(bWrite); // start at address
01CD  086E  	MOVF ds3231Writ_0001B_arg_bWrite, W
01CE  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
01CF  208D  	CALL i2c_WRITE_00000

	i2c_stop();
01D0  20DE  	CALL i2c_STOP_00000

}
01D1  0008  	RETURN


/*********************************************************************************************
  void ds3231Init()
  Initialise the DS3231
*********************************************************************************************/
void ds3231Init() {

	/* control register 0Eh
    bit7 EOSC   Enable Oscillator (1 if oscillator must be stopped when on battery)
    bit6 BBSQW  Battery Backed Square Wave - 0 means square wave disabled when VCC falls below VPF (power fail voltage)
    bit5 CONV   Convert temperature (1 forces a conversion)
    bit4 RS2    Rate select - frequency of square wave output - NA for DS3231M
    bit3 RS1    Rate select - NA for DS3231M
    bit2 INTCN  Interrupt control (1 for use of the alarms and to disable square wave)
    bit1 A2IE   Alarm2 interrupt enable (1 to enable)
    bit0 A1IE   Alarm1 interrupt enable (1 to enable)
    */
	ds3231Write(0x0E, 0x00);
0413  300E  	MOVLW 0x0E
0414  1283  	BCF STATUS, RP0
0415  1303  	BCF STATUS, RP1
0416  00ED  	MOVWF ds3231Writ_0001B_arg_ds3231Reg
0417  01EE  	CLRF ds3231Writ_0001B_arg_bWrite
0418  21C6  	CALL ds3231Writ_0001B

	/* Status Register 0Fh
    bit7 OSF     Oscillator stopped flag - clear oscillator stop flag at init
    bit3 EN32kHz Enable 32kHz Output - 0 for disabled
    bit2 BSY     Busy
    bit1 A2F     Alarm 2 Flag
    bit0 A1F     Alarm 1 Flag
    */
	ds3231Write(0x0F, 0x00);
0419  300F  	MOVLW 0x0F
041A  00ED  	MOVWF ds3231Writ_0001B_arg_ds3231Reg
041B  01EE  	CLRF ds3231Writ_0001B_arg_bWrite
041C  21C6  	CALL ds3231Writ_0001B

}
041D  0008  	RETURN


/*********************************************************************************************
  void ds3231WriteDateTime()
  Write the date to the DS3231
*********************************************************************************************/
void ds3231WriteDateTime() {

	i2c_start();
03E2  210E  	CALL i2c_START_00000

	i2c_write(ds3231_addr); // address + write
03E3  30D0  	MOVLW 0xD0
03E4  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
03E5  208D  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
03E6  01EF  	CLRF i2c_WRITE_00000_arg_i2c_data
03E7  208D  	CALL i2c_WRITE_00000

	i2c_write(0); // seconds
03E8  01EF  	CLRF i2c_WRITE_00000_arg_i2c_data
03E9  208D  	CALL i2c_WRITE_00000

	i2c_write(gBcdMinute); // minutes
03EA  0836  	MOVF gbl_gBcdMinute, W
03EB  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
03EC  208D  	CALL i2c_WRITE_00000

	i2c_write(gBcdHour); // hours
03ED  0837  	MOVF gbl_gBcdHour, W
03EE  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
03EF  208D  	CALL i2c_WRITE_00000

	i2c_write(gDayOfWeek); // day of week
03F0  0838  	MOVF gbl_gDayOfWeek, W
03F1  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
03F2  208D  	CALL i2c_WRITE_00000

	i2c_write(gBcdDayOfMonth); // day of month
03F3  0839  	MOVF gbl_gBcdDayOfMonth, W
03F4  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
03F5  208D  	CALL i2c_WRITE_00000

	i2c_write(gBcdMonth); // month + century
03F6  083A  	MOVF gbl_gBcdMonth, W
03F7  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
03F8  208D  	CALL i2c_WRITE_00000

	i2c_write(gBcdYear); // year
03F9  083B  	MOVF gbl_gBcdYear, W
03FA  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
03FB  208D  	CALL i2c_WRITE_00000

	i2c_stop();
03FC  20DE  	CALL i2c_STOP_00000

}
03FD  0008  	RETURN


/*********************************************************************************************
  void ds3231ReadDateTime()
  Write the date to the DS3231
*********************************************************************************************/
void ds3231ReadDateTime() {

	i2c_start();
06C2  210E  	CALL i2c_START_00000

	i2c_write(ds3231_addr); // address + write
06C3  30D0  	MOVLW 0xD0
06C4  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
06C5  208D  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
06C6  01EF  	CLRF i2c_WRITE_00000_arg_i2c_data
06C7  208D  	CALL i2c_WRITE_00000

	i2c_stop();
06C8  20DE  	CALL i2c_STOP_00000

	
	i2c_start();
06C9  210E  	CALL i2c_START_00000

	i2c_write(ds3231_addr + 1); // address + read
06CA  30D1  	MOVLW 0xD1
06CB  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
06CC  208D  	CALL i2c_WRITE_00000

	gBcdSeconds = i2c_read(0); // ack
06CD  01EF  	CLRF i2c_READ_00000_arg_ack_status
06CE  2172  	CALL i2c_READ_00000
06CF  0872  	MOVF CompTempVarRet553, W
06D0  00B5  	MOVWF gbl_gBcdSeconds

	gBcdMinute = i2c_read(0); // ack
06D1  01EF  	CLRF i2c_READ_00000_arg_ack_status
06D2  2172  	CALL i2c_READ_00000
06D3  0872  	MOVF CompTempVarRet553, W
06D4  00B6  	MOVWF gbl_gBcdMinute

	gBcdHour = i2c_read(0); // ack
06D5  01EF  	CLRF i2c_READ_00000_arg_ack_status
06D6  2172  	CALL i2c_READ_00000
06D7  0872  	MOVF CompTempVarRet553, W
06D8  00B7  	MOVWF gbl_gBcdHour

	gDayOfWeek = i2c_read(0); // ack
06D9  01EF  	CLRF i2c_READ_00000_arg_ack_status
06DA  2172  	CALL i2c_READ_00000
06DB  0872  	MOVF CompTempVarRet553, W
06DC  00B8  	MOVWF gbl_gDayOfWeek

	gBcdDayOfMonth = i2c_read(0); // ack
06DD  01EF  	CLRF i2c_READ_00000_arg_ack_status
06DE  2172  	CALL i2c_READ_00000
06DF  0872  	MOVF CompTempVarRet553, W
06E0  00B9  	MOVWF gbl_gBcdDayOfMonth

	gBcdMonth = i2c_read(0); // ack
06E1  01EF  	CLRF i2c_READ_00000_arg_ack_status
06E2  2172  	CALL i2c_READ_00000
06E3  0872  	MOVF CompTempVarRet553, W
06E4  00BA  	MOVWF gbl_gBcdMonth

	gBcdYear = i2c_read(1); // nack
06E5  3001  	MOVLW 0x01
06E6  00EF  	MOVWF i2c_READ_00000_arg_ack_status
06E7  2172  	CALL i2c_READ_00000
06E8  0872  	MOVF CompTempVarRet553, W
06E9  00BB  	MOVWF gbl_gBcdYear

	i2c_stop();
06EA  20DE  	CALL i2c_STOP_00000

}
06EB  0008  	RETURN


/*********************************************************************************************
  char ds3231ReadRegister(char cRegAddress)
  Read one byte from a given DS3231 register address
*********************************************************************************************/
char ds3231ReadRegister(char cRegAddress) {

	char cStatus;
	i2c_start();
03FE  210E  	CALL i2c_START_00000

	i2c_write(ds3231_addr); // address + write
03FF  30D0  	MOVLW 0xD0
0400  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0401  208D  	CALL i2c_WRITE_00000

	i2c_write(cRegAddress); // start at requested address
0402  086D  	MOVF ds3231Read_0001E_arg_cRegAddress, W
0403  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0404  208D  	CALL i2c_WRITE_00000

	i2c_stop();
0405  20DE  	CALL i2c_STOP_00000

	
	i2c_start();
0406  210E  	CALL i2c_START_00000

	i2c_write(ds3231_addr + 1); // address + read
0407  30D1  	MOVLW 0xD1
0408  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0409  208D  	CALL i2c_WRITE_00000

	cStatus = i2c_read(1); // read the byte, then nack
040A  3001  	MOVLW 0x01
040B  00EF  	MOVWF i2c_READ_00000_arg_ack_status
040C  2172  	CALL i2c_READ_00000
040D  0872  	MOVF CompTempVarRet553, W
040E  00EE  	MOVWF ds3231Read_0001E_1_cStatus

    i2c_stop();
040F  20DE  	CALL i2c_STOP_00000

    return cStatus;
0410  086E  	MOVF ds3231Read_0001E_1_cStatus, W
0411  00EF  	MOVWF CompTempVarRet554

}
0412  0008  	RETURN


/*********************************************************************************************
  void tm1638ByteWrite(char bWrite)
  Write one byte
*********************************************************************************************/
void tm1638ByteWrite(char bWrite) {

    for (char i = 0; i < 8; i++) {
0143  01F1  	CLRF tm1638Byte_0001F_2_i
0144        label24
0144  3008  	MOVLW 0x08
0145  0271  	SUBWF tm1638Byte_0001F_2_i, W
0146  1803  	BTFSC STATUS,C
0154  0AF1  	INCF tm1638Byte_0001F_2_i, F
0155  2944  	GOTO	label24

        tm1638dio = (bWrite & 0x01);
0148  3001  	MOVLW 0x01
0149  0570  	ANDWF tm1638Byte_0001F_arg_bWrite, W
014A  00F2  	MOVWF CompTempVar555
014B  1872  	BTFSC CompTempVar555,0
014C  1486  	BSF gbl_portb,1
014D  1C72  	BTFSS CompTempVar555,0
014E  1086  	BCF gbl_portb,1

        tm1638clk = 0;
014F  1106  	BCF gbl_portb,2

        bWrite = (bWrite >> 1);
0150  08F0  	MOVF tm1638Byte_0001F_arg_bWrite, F
0151  1003  	BCF STATUS,C
0152  0CF0  	RRF tm1638Byte_0001F_arg_bWrite, F

        tm1638clk = 1;
0153  1506  	BSF gbl_portb,2

    }
}
0147  0008  	RETURN


/*********************************************************************************************
  void tm1638DisplayOn()
  Turns the display on, with defined brightness
*********************************************************************************************/
void tm1638DisplayOn() {

    // Write 0x8F [10001000] to set display ON with pulse width 14/16
    tm1638strobe = 0;
03A2  1283  	BCF STATUS, RP0
03A3  1303  	BCF STATUS, RP1
03A4  1186  	BCF gbl_portb,3

    tm1638ByteWrite(0x88);
03A5  3088  	MOVLW 0x88
03A6  00F0  	MOVWF tm1638Byte_0001F_arg_bWrite
03A7  2143  	CALL tm1638Byte_0001F

    tm1638strobe = 1;
03A8  1586  	BSF gbl_portb,3

}
03A9  0008  	RETURN


/*********************************************************************************************
  void bcdTo7Seg(char iBcdIn)
  Convert a single bcd byte into the 7-segment representation (two digits)
  7-segment digit to be written will be iPrintStartDigit, which is auto-incremented after
  If iPrintDotDigit matches, the dot on the display digit will be added
*********************************************************************************************/
void bcdTo7Seg(char iBcdIn) {

    char s7SegDisplay = 0;
01D2  01F2  	CLRF bcdTo7Seg_00000_1_s7SegDisplay

    iPrintStartDigit++; // Increment to last digit
01D3  0AE7  	INCF gbl_iPrintStartDigit, F

    // Work backwards
    for (char sDigit = iPrintStartDigit; sDigit == iPrintStartDigit - 1; sDigit--) {
01D4  0867  	MOVF gbl_iPrintStartDigit, W
01D5  00F3  	MOVWF bcdTo7Seg_00000_2_sDigit
01D6        label36
01D6  0367  	DECF gbl_iPrintStartDigit, W
01D7  0673  	XORWF bcdTo7Seg_00000_2_sDigit, W
01D8  1D03  	BTFSS STATUS,Z
01D9  29F5  	GOTO	label38
01F3  03F3  	DECF bcdTo7Seg_00000_2_sDigit, F
01F4  29D6  	GOTO	label36
01F5        label38

        s7SegDisplay = tm1638DisplayNumtoSeg[iBcdIn & 0x0F];
01DA  085E  	MOVF gbl_tm1638DisplayNumtoSeg, W
01DB  00F4  	MOVWF __rom_get_00000_arg_objNumb
01DC  300F  	MOVLW 0x0F
01DD  0571  	ANDWF bcdTo7Seg_00000_arg_iBcdIn, W
01DE  00F5  	MOVWF __rom_get_00000_arg_idx
01DF  2024  	CALL __rom_get_00000
01E0  00F2  	MOVWF bcdTo7Seg_00000_1_s7SegDisplay

        if (sDigit == iPrintDotDigit)
01E1  0868  	MOVF gbl_iPrintDotDigit, W
01E2  0673  	XORWF bcdTo7Seg_00000_2_sDigit, W
01E3  118A  	BCF PCLATH,3
01E4  120A  	BCF PCLATH,4
01E5  1D03  	BTFSS STATUS,Z
01E6  29E9  	GOTO	label37
01E9        label37

            s7SegDisplay += tm1638Dot;
01E7  085F  	MOVF gbl_tm1638Dot, W
01E8  07F2  	ADDWF bcdTo7Seg_00000_1_s7SegDisplay, F

        tm1638Data[sDigit] = s7SegDisplay;
01E9  1383  	BCF	STATUS,IRP
01EA  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
01EB  0084  	MOVWF FSR
01EC  0873  	MOVF bcdTo7Seg_00000_2_sDigit, W
01ED  0784  	ADDWF FSR, F
01EE  0872  	MOVF bcdTo7Seg_00000_1_s7SegDisplay, W
01EF  0080  	MOVWF INDF

        iBcdIn >>= 4;
01F0  0EF1  	SWAPF bcdTo7Seg_00000_arg_iBcdIn, F
01F1  300F  	MOVLW 0x0F
01F2  05F1  	ANDWF bcdTo7Seg_00000_arg_iBcdIn, F

    }
    iPrintStartDigit++; // Increment to next digit
01F5  0AE7  	INCF gbl_iPrintStartDigit, F

}
01F6  0008  	RETURN


/*********************************************************************************************
  void tm1638UpdateDisplay()
  Publish the tm1638Data and tm1638LEDs arrays to the display
*********************************************************************************************/
void tm1638UpdateDisplay() {

    
    // Display current temperature unless set, trigger or alt display mode is active
    if (gcDisplayMode | gcSetMode | gcTriggerMode) {
0221  1283  	BCF STATUS, RP0
0222  1303  	BCF STATUS, RP1
0223  084F  	MOVF gbl_gcSetMode, W
0224  044E  	IORWF gbl_gcDisplayMode, W
0225  00ED  	MOVWF CompTempVar558
0226  0850  	MOVF gbl_gcTriggerMode, W
0227  046D  	IORWF CompTempVar558, W
0228  1903  	BTFSC STATUS,Z
0229  2B35  	GOTO	label66
0335        label66

        if (gcSetMode == 1) {
022A  034F  	DECF gbl_gcSetMode, W
022B  1D03  	BTFSS STATUS,Z
022C  2A3B  	GOTO	label45
023B        label45

            iDigitToFlash = 3;
022D  3003  	MOVLW 0x03
022E  00C8  	MOVWF gbl_iDigitToFlash

            // Display year
            // Start printing from digit 0
            iPrintStartDigit = 0;
022F  01E7  	CLRF gbl_iPrintStartDigit

            iPrintDotDigit = 1;
0230  3001  	MOVLW 0x01
0231  00E8  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(0x20); // Display 20 in digits 0 and 1 (+dot on 1)
0232  3020  	MOVLW 0x20
0233  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0234  21D2  	CALL bcdTo7Seg_00000

            iPrintDotDigit = 3;
0235  3003  	MOVLW 0x03
0236  00E8  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(gBcdYear); // Display year in digits 2 and 3 (+dot on 3)
0237  083B  	MOVF gbl_gBcdYear, W
0238  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0239  21D2  	CALL bcdTo7Seg_00000

        } else if (gcSetMode == 4) {
023A  2B47  	GOTO	label67
023B  084F  	MOVF gbl_gcSetMode, W
023C  3A04  	XORLW 0x04
023D  1D03  	BTFSS STATUS,Z
023E  2A51  	GOTO	label46
0251        label46

            iDigitToFlash = 3;
023F  3003  	MOVLW 0x03
0240  00C8  	MOVWF gbl_iDigitToFlash

            // Display day of week
            tm1638Data[0] = 0x5E; // d
0241  305E  	MOVLW 0x5E
0242  00A0  	MOVWF gbl_tm1638Data

            tm1638Data[1] = 0x5F; // a
0243  305F  	MOVLW 0x5F
0244  00A1  	MOVWF gbl_tm1638Data+D'1'

            tm1638Data[2] = 0x6E; // y
0245  306E  	MOVLW 0x6E
0246  00A2  	MOVWF gbl_tm1638Data+D'2'

            tm1638Data[3] = tm1638DisplayNumtoSeg[gDayOfWeek] + tm1638Dot;
0247  085E  	MOVF gbl_tm1638DisplayNumtoSeg, W
0248  00F4  	MOVWF __rom_get_00000_arg_objNumb
0249  0838  	MOVF gbl_gDayOfWeek, W
024A  00F5  	MOVWF __rom_get_00000_arg_idx
024B  2024  	CALL __rom_get_00000
024C  075F  	ADDWF gbl_tm1638Dot, W
024D  00A3  	MOVWF gbl_tm1638Data+D'3'

        } else if (gcTriggerMode) {
024E  118A  	BCF PCLATH,3
024F  120A  	BCF PCLATH,4
0250  2B47  	GOTO	label67
0251  08D0  	MOVF gbl_gcTriggerMode, F
0252  1903  	BTFSC STATUS,Z
0253  2B0D  	GOTO	label59
030D        label59

            iPrintDotDigit = 5;
0254  3005  	MOVLW 0x05
0255  00E8  	MOVWF gbl_iPrintDotDigit

            switch (gcTriggerMode) {
027B  2B47  	GOTO	label67

                case 1:
0256  0850  	MOVF gbl_gcTriggerMode, W
0257  3A01  	XORLW 0x01
0258  1903  	BTFSC STATUS,Z
0259  2A7C  	GOTO	label47
027C        label47

                    // White LED on hour
                    tm1638Data[0] = 0x38; // L
027C  3038  	MOVLW 0x38
027D  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x30; // I
027E  3030  	MOVLW 0x30
027F  00A1  	MOVWF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x3f; // O
0280  303F  	MOVLW 0x3F
0281  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x54; // n
0282  3054  	MOVLW 0x54
0283  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
0284  3005  	MOVLW 0x05
0285  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
0286  3004  	MOVLW 0x04
0287  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOnHour); // Display hour in digits 4 and 5 (dot on 5)
0288  0852  	MOVF gbl_gBcdWhiteOnHour, W
0289  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
028A  21D2  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdWhiteOnMinute); // Display minute in digits 6 and 7 (no dot)
028B  0851  	MOVF gbl_gBcdWhiteOnMinute, W
028C  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
028D  21D2  	CALL bcdTo7Seg_00000

                    break;
028E  2B47  	GOTO	label67

                case 2:
025A  3A03  	XORLW 0x03
025B  1903  	BTFSC STATUS,Z
025C  2A8F  	GOTO	label48
028F        label48

                    // White LED on minute
                    iDigitToFlash = 7;
028F  3007  	MOVLW 0x07
0290  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0291  3006  	MOVLW 0x06
0292  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOnMinute); // Display minute in digits 6 and 7 (no dot)
0293  0851  	MOVF gbl_gBcdWhiteOnMinute, W
0294  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0295  21D2  	CALL bcdTo7Seg_00000

                    break;
0296  2B47  	GOTO	label67

                case 3:
025D  3A01  	XORLW 0x01
025E  1903  	BTFSC STATUS,Z
025F  2A97  	GOTO	label49
0297        label49

                    // White LED off hour
                    tm1638Data[3] = 0x71; // F
0297  3071  	MOVLW 0x71
0298  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
0299  3005  	MOVLW 0x05
029A  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
029B  3004  	MOVLW 0x04
029C  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOffHour); 
029D  0854  	MOVF gbl_gBcdWhiteOffHour, W
029E  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
029F  21D2  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdWhiteOffMinute); // Display minute in digits 6 and 7 (no dot)
02A0  0853  	MOVF gbl_gBcdWhiteOffMinute, W
02A1  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02A2  21D2  	CALL bcdTo7Seg_00000

                    break;
02A3  2B47  	GOTO	label67

                case 4:
0260  3A07  	XORLW 0x07
0261  1903  	BTFSC STATUS,Z
0262  2AA4  	GOTO	label50
02A4        label50

                    // White LED off minute
                    iDigitToFlash = 7;
02A4  3007  	MOVLW 0x07
02A5  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
02A6  3006  	MOVLW 0x06
02A7  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOffMinute); // Display minute in digits 6 and 7 (no dot)
02A8  0853  	MOVF gbl_gBcdWhiteOffMinute, W
02A9  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02AA  21D2  	CALL bcdTo7Seg_00000

                    break;
02AB  2B47  	GOTO	label67

                case 5:
0263  3A01  	XORLW 0x01
0264  1903  	BTFSC STATUS,Z
0265  2AAC  	GOTO	label51
02AC        label51

                    // Blue LED on hour
                    tm1638Data[0] = 0x7C; // b
02AC  307C  	MOVLW 0x7C
02AD  00A0  	MOVWF gbl_tm1638Data

                    //tm1638Data[1] = 0x30; // l
                    //tm1638Data[2] = 0x3f; // O
                    tm1638Data[3] = 0x54; // n
02AE  3054  	MOVLW 0x54
02AF  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
02B0  3005  	MOVLW 0x05
02B1  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
02B2  3004  	MOVLW 0x04
02B3  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOnHour); // Display hour in digits 4 and 5 (dot on 5)
02B4  0856  	MOVF gbl_gBcdBlueOnHour, W
02B5  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02B6  21D2  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlueOnMinute); // Display minute in digits 6 and 7 (no dot)
02B7  0855  	MOVF gbl_gBcdBlueOnMinute, W
02B8  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02B9  21D2  	CALL bcdTo7Seg_00000

                    break;
02BA  2B47  	GOTO	label67

                case 6:
0266  3A03  	XORLW 0x03
0267  1903  	BTFSC STATUS,Z
0268  2ABB  	GOTO	label52
02BB        label52

                    // Blue LED on minute
                    iDigitToFlash = 7;
02BB  3007  	MOVLW 0x07
02BC  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
02BD  3006  	MOVLW 0x06
02BE  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOnMinute); // Display minute in digits 6 and 7 (no dot)
02BF  0855  	MOVF gbl_gBcdBlueOnMinute, W
02C0  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02C1  21D2  	CALL bcdTo7Seg_00000

                    break;
02C2  2B47  	GOTO	label67

                case 7:
0269  3A01  	XORLW 0x01
026A  1903  	BTFSC STATUS,Z
026B  2AC3  	GOTO	label53
02C3        label53

                    // Blue LED off hour
                    tm1638Data[3] = 0x71; // F
02C3  3071  	MOVLW 0x71
02C4  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
02C5  3005  	MOVLW 0x05
02C6  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
02C7  3004  	MOVLW 0x04
02C8  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOffHour); // Display hour in digits 4 and 5 (dot on 5)
02C9  0858  	MOVF gbl_gBcdBlueOffHour, W
02CA  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02CB  21D2  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlueOffMinute); // Display minute in digits 6 and 7 (no dot)
02CC  0857  	MOVF gbl_gBcdBlueOffMinute, W
02CD  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02CE  21D2  	CALL bcdTo7Seg_00000

                    break;
02CF  2B47  	GOTO	label67

                case 8:
026C  3A0F  	XORLW 0x0F
026D  1903  	BTFSC STATUS,Z
026E  2AD0  	GOTO	label54
02D0        label54

                    // Blue LED off minute
                    iDigitToFlash = 7;
02D0  3007  	MOVLW 0x07
02D1  00C8  	MOVWF gbl_iDigitToFlash

                    bcdTo7Seg(gBcdBlueOffMinute); // Display minute in digits 6 and 7 (no dot)
02D2  0857  	MOVF gbl_gBcdBlueOffMinute, W
02D3  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02D4  21D2  	CALL bcdTo7Seg_00000

                    break;
02D5  2B47  	GOTO	label67

                case 9:
026F  3A01  	XORLW 0x01
0270  1903  	BTFSC STATUS,Z
0271  2AD6  	GOTO	label55
02D6        label55

                    // Fan on temperature
                    tm1638Data[0] = 0x38; // F
02D6  3038  	MOVLW 0x38
02D7  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x30; // a
02D8  3030  	MOVLW 0x30
02D9  00A1  	MOVWF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x54; // n
02DA  3054  	MOVLW 0x54
02DB  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x00; // 
02DC  01A3  	CLRF gbl_tm1638Data+D'3'

                    tm1638Data[4] = 0x3f; // O
02DD  303F  	MOVLW 0x3F
02DE  00A4  	MOVWF gbl_tm1638Data+D'4'

                    tm1638Data[5] = 0x54; // n
02DF  3054  	MOVLW 0x54
02E0  00A5  	MOVWF gbl_tm1638Data+D'5'

                    iDigitToFlash = 7;
02E1  3007  	MOVLW 0x07
02E2  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
02E3  3006  	MOVLW 0x06
02E4  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdFanOnTemp); // Display celcius in digits 6 and 7 (no dot)
02E5  0859  	MOVF gbl_gBcdFanOnTemp, W
02E6  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02E7  21D2  	CALL bcdTo7Seg_00000

                    break;
02E8  2B47  	GOTO	label67

                case 10:
0272  3A03  	XORLW 0x03
0273  1903  	BTFSC STATUS,Z
0274  2AE9  	GOTO	label56
02E9        label56

                    // Fan off temperature
                    tm1638Data[5] = 0x71; // f
02E9  3071  	MOVLW 0x71
02EA  00A5  	MOVWF gbl_tm1638Data+D'5'

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
02EB  3006  	MOVLW 0x06
02EC  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdFanOffTemp); // Display celcius in digits 6 and 7 (no dot)
02ED  085A  	MOVF gbl_gBcdFanOffTemp, W
02EE  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02EF  21D2  	CALL bcdTo7Seg_00000

                    break;
02F0  2B47  	GOTO	label67

                case 11:
0275  3A01  	XORLW 0x01
0276  1903  	BTFSC STATUS,Z
0277  2AF1  	GOTO	label57
02F1        label57

                    // Heater on temperature
                    tm1638Data[0] = 0x38; // H
02F1  3038  	MOVLW 0x38
02F2  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x7B; // e
02F3  307B  	MOVLW 0x7B
02F4  00A1  	MOVWF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x30; // a
02F5  3030  	MOVLW 0x30
02F6  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x78; // t
02F7  3078  	MOVLW 0x78
02F8  00A3  	MOVWF gbl_tm1638Data+D'3'

                    tm1638Data[4] = 0x3f; // O
02F9  303F  	MOVLW 0x3F
02FA  00A4  	MOVWF gbl_tm1638Data+D'4'

                    tm1638Data[5] = 0x54; // n
02FB  3054  	MOVLW 0x54
02FC  00A5  	MOVWF gbl_tm1638Data+D'5'

                    iDigitToFlash = 7;
02FD  3007  	MOVLW 0x07
02FE  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
02FF  3006  	MOVLW 0x06
0300  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdHeaterOnTemp); // Display celcius in digits 6 and 7 (no dot)
0301  085B  	MOVF gbl_gBcdHeaterOnTemp, W
0302  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0303  21D2  	CALL bcdTo7Seg_00000

                    break;
0304  2B47  	GOTO	label67

                case 12:
0278  3A07  	XORLW 0x07
0279  1903  	BTFSC STATUS,Z
027A  2B05  	GOTO	label58
0305        label58

                    // Heater off temperature
                    tm1638Data[5] = 0x71; // f
0305  3071  	MOVLW 0x71
0306  00A5  	MOVWF gbl_tm1638Data+D'5'

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0307  3006  	MOVLW 0x06
0308  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdHeaterOffTemp); // Display celcius in digits 6 and 7 (no dot)
0309  085C  	MOVF gbl_gBcdHeaterOffTemp, W
030A  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
030B  21D2  	CALL bcdTo7Seg_00000

                    break;
            }
        } else {
030C  2B47  	GOTO	label67

            switch (gcSetMode) {
0329        label65

                case 2:
030D  084F  	MOVF gbl_gcSetMode, W
030E  3A02  	XORLW 0x02
030F  1903  	BTFSC STATUS,Z
0310  2B1B  	GOTO	label60
031B        label60

                    iDigitToFlash = 3;
031B  3003  	MOVLW 0x03
031C  00C8  	MOVWF gbl_iDigitToFlash

                    break;
031D  2B29  	GOTO	label65

                case 3:
0311  3A01  	XORLW 0x01
0312  1903  	BTFSC STATUS,Z
0313  2B1E  	GOTO	label61
031E        label61

                    iDigitToFlash = 1;
031E  3001  	MOVLW 0x01
031F  00C8  	MOVWF gbl_iDigitToFlash

                    break;
0320  2B29  	GOTO	label65

                case 5:
0314  3A06  	XORLW 0x06
0315  1903  	BTFSC STATUS,Z
0316  2B21  	GOTO	label62
0321        label62

                    iDigitToFlash = 5;
0321  3005  	MOVLW 0x05
0322  00C8  	MOVWF gbl_iDigitToFlash

                    break;
0323  2B29  	GOTO	label65

                case 6:
0317  3A03  	XORLW 0x03
0318  1903  	BTFSC STATUS,Z
0319  2B24  	GOTO	label63
0324        label63

                    iDigitToFlash = 7;
0324  3007  	MOVLW 0x07
0325  00C8  	MOVWF gbl_iDigitToFlash

                    break;
0326  2B29  	GOTO	label65

                default:
031A  2B27  	GOTO	label64
0327        label64

                    iDigitToFlash = 8;
0327  3008  	MOVLW 0x08
0328  00C8  	MOVWF gbl_iDigitToFlash

            }
            // Display date DD.MM
            iPrintStartDigit = 0;
0329  01E7  	CLRF gbl_iPrintStartDigit

            iPrintDotDigit = 1;
032A  3001  	MOVLW 0x01
032B  00E8  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(gBcdDayOfMonth); // Display day of month in digits 0 and 1 (+dot on 1)
032C  0839  	MOVF gbl_gBcdDayOfMonth, W
032D  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
032E  21D2  	CALL bcdTo7Seg_00000

            iPrintDotDigit = 3;
032F  3003  	MOVLW 0x03
0330  00E8  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(gBcdMonth); // Display month in digits 2 and 3 (+dot on 3)
0331  083A  	MOVF gbl_gBcdMonth, W
0332  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0333  21D2  	CALL bcdTo7Seg_00000

        }
    } else {
0334  2B47  	GOTO	label67

        // translate DS3231 temperature to digit values
        iPrintDotDigit = 1;
0335  3001  	MOVLW 0x01
0336  00E8  	MOVWF gbl_iPrintDotDigit

        /*
        No support for -10 or below - aquarium should never get that cold!
        if (gbDS3231IsMinus && (giDS3231ValueBCD & 0xF000)) {
            // If minus and value less than or equal -10 (checked as >1000), shift the digits right
            giDS3231ValueBCD >>= 4;
            iPrintDotDigit = 2;
        }*/
        // Display current temperature in digits 0 to 3 (+dot on 1, or 2 if <=-10)
        iPrintStartDigit = 0;
0337  01E7  	CLRF gbl_iPrintStartDigit

        bcdTo7Seg(giDS3231ValueBCD);
0338  0833  	MOVF gbl_giDS3231ValueBCD, W
0339  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
033A  21D2  	CALL bcdTo7Seg_00000

        bcdTo7Seg(giDS3231ValueBCD >> 8);
033B  0834  	MOVF gbl_giDS3231ValueBCD+D'1', W
033C  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
033D  21D2  	CALL bcdTo7Seg_00000


        // left fill zeroes with blanks up to the digit before the decimal place
        if (tm1638Data[0] == 0x3f)
033E  0820  	MOVF gbl_tm1638Data, W
033F  3A3F  	XORLW 0x3F
0340  1903  	BTFSC STATUS,Z

            tm1638Data[0] = 0;
0341  01A0  	CLRF gbl_tm1638Data

        // If minus, overwrite left most digit with minus sign
        if (gbDS3231IsMinus)
0342  08CB  	MOVF gbl_gbDS3231IsMinus, F
0343  1903  	BTFSC STATUS,Z
0344  2B47  	GOTO	label67
0347        label67

            tm1638Data[0] = 0x40;
0345  3040  	MOVLW 0x40
0346  00A0  	MOVWF gbl_tm1638Data

    }

    // HH.MM in last 4 digits of TM1638
    if (!gcTriggerMode) {
0347  08D0  	MOVF gbl_gcTriggerMode, F
0348  1D03  	BTFSS STATUS,Z
0349  2B54  	GOTO	label68
0354        label68

        iPrintStartDigit = 4;
034A  3004  	MOVLW 0x04
034B  00E7  	MOVWF gbl_iPrintStartDigit

        iPrintDotDigit = 5;
034C  3005  	MOVLW 0x05
034D  00E8  	MOVWF gbl_iPrintDotDigit

        bcdTo7Seg(gBcdHour); // Display hour in digits 4 and 5 (dot on 5)
034E  0837  	MOVF gbl_gBcdHour, W
034F  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0350  21D2  	CALL bcdTo7Seg_00000

        bcdTo7Seg(gBcdMinute); // Display minute in digits 6 and 7 (no dot)
0351  0836  	MOVF gbl_gBcdMinute, W
0352  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0353  21D2  	CALL bcdTo7Seg_00000

    }

    // Light LED for set mode
    char cCompareSetMode = gcSetMode + 1;
0354  0A4F  	INCF gbl_gcSetMode, W
0355  00EE  	MOVWF tm1638Upda_00021_1_cCompar_00022

    for (char i = 2; i < 8; i++) {
0356  3002  	MOVLW 0x02
0357  00F0  	MOVWF tm1638Upda_00021_3_i
0358        label69
0358  3008  	MOVLW 0x08
0359  0270  	SUBWF tm1638Upda_00021_3_i, W
035A  1803  	BTFSC STATUS,C
035B  2B71  	GOTO	label72
036F  0AF0  	INCF tm1638Upda_00021_3_i, F
0370  2B58  	GOTO	label69
0371        label72

        if (i == cCompareSetMode)
035C  086E  	MOVF tm1638Upda_00021_1_cCompar_00022, W
035D  0670  	XORWF tm1638Upda_00021_3_i, W
035E  1D03  	BTFSS STATUS,Z
035F  2B68  	GOTO	label70
0368        label70

            tm1638LEDs[i] = 1;
0360  1383  	BCF	STATUS,IRP
0361  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
0362  0084  	MOVWF FSR
0363  0870  	MOVF tm1638Upda_00021_3_i, W
0364  0784  	ADDWF FSR, F
0365  3001  	MOVLW 0x01
0366  0080  	MOVWF INDF

        else
0367  2B6F  	GOTO	label71
036F        label71

            tm1638LEDs[i] = 0;
0368  1383  	BCF	STATUS,IRP
0369  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
036A  0084  	MOVWF FSR
036B  0870  	MOVF tm1638Upda_00021_3_i, W
036C  0784  	ADDWF FSR, F
036D  3000  	MOVLW 0x00
036E  0080  	MOVWF INDF

    }
    tm1638LEDs[0] = HEATER;
0371  01A8  	CLRF gbl_tm1638LEDs
0372  1805  	BTFSC gbl_porta,0
0373  0AA8  	INCF gbl_tm1638LEDs, F

    tm1638LEDs[1] = FAN;
0374  01A9  	CLRF gbl_tm1638LEDs+D'1'
0375  1885  	BTFSC gbl_porta,1
0376  0AA9  	INCF gbl_tm1638LEDs+D'1', F


    // Write 0x40 [01000000] (table 5.1) to indicate command to display data - [Write data to display register]
    tm1638strobe = 0;
0377  1186  	BCF gbl_portb,3

    tm1638ByteWrite(tm1638ByteSetData);
0378  0861  	MOVF gbl_tm1638ByteSetData, W
0379  00F0  	MOVWF tm1638Byte_0001F_arg_bWrite
037A  2143  	CALL tm1638Byte_0001F

    tm1638strobe = 1;
037B  1586  	BSF gbl_portb,3

    
    tm1638strobe = 0;
037C  1186  	BCF gbl_portb,3

    // Specify the display address 0xC0 [11000000] (table 5.2) then write out all 8 bytes [Display address 00H]
    tm1638ByteWrite(tm1638ByteSetAddr);
037D  0863  	MOVF gbl_tm1638ByteSetAddr, W
037E  00F0  	MOVWF tm1638Byte_0001F_arg_bWrite
037F  2143  	CALL tm1638Byte_0001F

    for (char i = 0; i < tm1638MaxDigits; i++) {
0380  01EF  	CLRF tm1638Upda_00021_2_i
0381        label73
0381  085D  	MOVF gbl_tm1638MaxDigits, W
0382  026F  	SUBWF tm1638Upda_00021_2_i, W
0383  1803  	BTFSC STATUS,C
0384  2BA0  	GOTO	label76
039E  0AEF  	INCF tm1638Upda_00021_2_i, F
039F  2B81  	GOTO	label73
03A0        label76

        if (iFlashDigitOff.0 && (i == iDigitToFlash))
0385  1C3F  	BTFSS gbl_iFlashDigitOff,0
0386  2B8E  	GOTO	label74
0387  0848  	MOVF gbl_iDigitToFlash, W
0388  066F  	XORWF tm1638Upda_00021_2_i, W
0389  1D03  	BTFSS STATUS,Z
038A  2B8E  	GOTO	label74
038E        label74

            tm1638ByteWrite(0);
038B  01F0  	CLRF tm1638Byte_0001F_arg_bWrite
038C  2143  	CALL tm1638Byte_0001F

        else
038D  2B96  	GOTO	label75
0396        label75

            tm1638ByteWrite(tm1638Data[i]);
038E  1383  	BCF	STATUS,IRP
038F  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
0390  0084  	MOVWF FSR
0391  086F  	MOVF tm1638Upda_00021_2_i, W
0392  0784  	ADDWF FSR, F
0393  0800  	MOVF INDF, W
0394  00F0  	MOVWF tm1638Byte_0001F_arg_bWrite
0395  2143  	CALL tm1638Byte_0001F

        tm1638ByteWrite(tm1638LEDs[i]);
0396  1383  	BCF	STATUS,IRP
0397  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
0398  0084  	MOVWF FSR
0399  086F  	MOVF tm1638Upda_00021_2_i, W
039A  0784  	ADDWF FSR, F
039B  0800  	MOVF INDF, W
039C  00F0  	MOVWF tm1638Byte_0001F_arg_bWrite
039D  2143  	CALL tm1638Byte_0001F

    }
    tm1638strobe = 1;
03A0  1586  	BSF gbl_portb,3

}
03A1  0008  	RETURN


/*********************************************************************************************
  void tm1638ReadKeys()
  Reads the keys status into tm1638Keys
*********************************************************************************************/
void tm1638ReadKeys() {

    // Write 0x42 [01000010] to indicate command to read data
    tm1638strobe = 0;
05D9  1283  	BCF STATUS, RP0
05DA  1303  	BCF STATUS, RP1
05DB  1186  	BCF gbl_portb,3

    tm1638ByteWrite(tm1638ByteReadData);
05DC  0862  	MOVF gbl_tm1638ByteReadData, W
05DD  00F0  	MOVWF tm1638Byte_0001F_arg_bWrite
05DE  2143  	CALL tm1638Byte_0001F

    
    tm1638dioTris = 1; // Set data pin to input
05DF  1683  	BSF STATUS, RP0
05E0  1486  	BSF gbl_trisb,1

    char tm1638KeysTemp = 32;
05E1  3020  	MOVLW 0x20
05E2  1283  	BCF STATUS, RP0
05E3  00EC  	MOVWF tm1638Read_00023_1_tm1638K_00024

    // Read 4 bytes
    for (char i = 0; i < 32; i++) {
05E4  01ED  	CLRF tm1638Read_00023_2_i
05E5        label106
05E5  3020  	MOVLW 0x20
05E6  026D  	SUBWF tm1638Read_00023_2_i, W
05E7  1803  	BTFSC STATUS,C
05E8  2DF6  	GOTO	label108
05F4  0AED  	INCF tm1638Read_00023_2_i, F
05F5  2DE5  	GOTO	label106
05F6        label108

        tm1638KeysTemp--;
05E9  03EC  	DECF tm1638Read_00023_1_tm1638K_00024, F

        tm1638clk = 0;
05EA  1106  	BCF gbl_portb,2

        delay_us(1);
05EB  3001  	MOVLW 0x01
05EC  00F2  	MOVWF delay_us_00000_arg_del
05ED  2010  	CALL delay_us_00000

        if(tm1638dio)
05EE  1C86  	BTFSS gbl_portb,1
05EF  2DF3  	GOTO	label107
05F3        label107

            tm1638KeysTemp = (tm1638KeysTemp << 1);
05F0  08EC  	MOVF tm1638Read_00023_1_tm1638K_00024, F
05F1  1003  	BCF STATUS,C
05F2  0DEC  	RLF tm1638Read_00023_1_tm1638K_00024, F

        tm1638clk = 1;
05F3  1506  	BSF gbl_portb,2

    }
    tm1638dioTris = 0; // Set data pin to output
05F6  1683  	BSF STATUS, RP0
05F7  1086  	BCF gbl_trisb,1

    tm1638strobe = 1;
05F8  1283  	BCF STATUS, RP0
05F9  1586  	BSF gbl_portb,3


    tm1638Keys = tm1638KeysTemp;
05FA  086C  	MOVF tm1638Read_00023_1_tm1638K_00024, W
05FB  00E5  	MOVWF gbl_tm1638Keys

}
05FC  0008  	RETURN


/*********************************************************************************************
  void convertTemp()
  Used to split the 16 bit integer returned from the ds18b20 into parts for display
*********************************************************************************************/
void convertTemp() {

    // convert both bytes to a 16bit int - e.g. 0000 0001 0100 0110 (1 and 70, gives 326)
    
    signed int iTemp = (cTempH << 8) | cTempL;
06EC  1283  	BCF STATUS, RP0
06ED  1303  	BCF STATUS, RP1
06EE  01ED  	CLRF convertTem_0002A_1_iTemp
06EF  0849  	MOVF gbl_cTempH, W
06F0  00EE  	MOVWF convertTem_0002A_1_iTemp+D'1'
06F1  084A  	MOVF gbl_cTempL, W
06F2  04ED  	IORWF convertTem_0002A_1_iTemp, F

    
    // Celcius
    gbDS3231IsMinus = (iTemp < 0);
06F3  01CB  	CLRF gbl_gbDS3231IsMinus
06F4  1BEE  	BTFSC convertTem_0002A_1_iTemp+D'1',7
06F5  0ACB  	INCF gbl_gbDS3231IsMinus, F

    if (gbDS3231IsMinus) {
06F6  08CB  	MOVF gbl_gbDS3231IsMinus, F
06F7  1903  	BTFSC STATUS,Z
06F8  2EFE  	GOTO	label120

        iTemp = ~iTemp + 1;
06F9  09ED  	COMF convertTem_0002A_1_iTemp, F
06FA  09EE  	COMF convertTem_0002A_1_iTemp+D'1', F
06FB  0AED  	INCF convertTem_0002A_1_iTemp, F
06FC  1903  	BTFSC STATUS,Z
06FD  0AEE  	INCF convertTem_0002A_1_iTemp+D'1', F
06FE        label120

    }
    // this gets celcius * 100 - https://www.phanderson.com/PIC/PICC/sourceboost/ds18b20_1.html
    int iValue = (6 * iTemp) + (iTemp / 4);
06FE  3006  	MOVLW 0x06
06FF  00F6  	MOVWF __mul_16s__0000F_arg_a
0700  01F7  	CLRF __mul_16s__0000F_arg_a+D'1'
0701  086D  	MOVF convertTem_0002A_1_iTemp, W
0702  00F8  	MOVWF __mul_16s__0000F_arg_b
0703  086E  	MOVF convertTem_0002A_1_iTemp+D'1', W
0704  00F9  	MOVWF __mul_16s__0000F_arg_b+D'1'
0705  25B0  	CALL __mul_16s__0000F
0706  087D  	MOVF CompTempVarRet389, W
0707  00EF  	MOVWF convertTem_0002A_1_iValue
0708  087E  	MOVF CompTempVarRet389+D'1', W
0709  00F2  	MOVWF CompTempVar614
070A  086D  	MOVF convertTem_0002A_1_iTemp, W
070B  00F1  	MOVWF CompTempVar611
070C  086E  	MOVF convertTem_0002A_1_iTemp+D'1', W
070D  00F0  	MOVWF convertTem_0002A_1_iValue+D'1'
070E  0D6E  	RLF convertTem_0002A_1_iTemp+D'1', W
070F  0CF0  	RRF convertTem_0002A_1_iValue+D'1', F
0710  0CF1  	RRF CompTempVar611, F
0711  0D6E  	RLF convertTem_0002A_1_iTemp+D'1', W
0712  0CF0  	RRF convertTem_0002A_1_iValue+D'1', F
0713  0CF1  	RRF CompTempVar611, F
0714  0871  	MOVF CompTempVar611, W
0715  07EF  	ADDWF convertTem_0002A_1_iValue, F
0716  0872  	MOVF CompTempVar614, W
0717  1803  	BTFSC STATUS,C
0718  0AF0  	INCF convertTem_0002A_1_iValue+D'1', F
0719  07F0  	ADDWF convertTem_0002A_1_iValue+D'1', F


    // Split the temperature reading into digits
    
    // simple way, but more program memory needed for PIC12 or PIC16 (more than 100 words more)
    //giDS3231ValueBCD = iValue / 1000;
    //giDS3231ValueBCD += (iValue / 100) % 10;
    //giDS3231ValueBCD += (iValue / 10) % 10;
    //giDS3231ValueBCD += iValue % 10;
    
    // Double Dabble
    giDS3231ValueBCD = 0; // 16-bit BCD value - only supporting up to 9999
071A  01B3  	CLRF gbl_giDS3231ValueBCD
071B  01B4  	CLRF gbl_giDS3231ValueBCD+D'1'

    int iTest = 32768; // Start testing from MSB
071C  01F3  	CLRF convertTem_0002A_1_iTest
071D  3080  	MOVLW 0x80
071E  00F4  	MOVWF convertTem_0002A_1_iTest+D'1'

    // Loop through the 16 bits in the two bytes
    for (char i = 0; i < 16; i++) {
071F  01F5  	CLRF convertTem_0002A_2_i
0720        label121
0720  3010  	MOVLW 0x10
0721  0275  	SUBWF convertTem_0002A_2_i, W
0722  1803  	BTFSC STATUS,C
0777  0AF5  	INCF convertTem_0002A_2_i, F
0778  2F20  	GOTO	label121

        // Shift one
        giDS3231ValueBCD <<= 1;
0724  1003  	BCF STATUS,C
0725  0DB3  	RLF gbl_giDS3231ValueBCD, F
0726  0DB4  	RLF gbl_giDS3231ValueBCD+D'1', F

        // If the bit is set, add one
        if (iValue & iTest)
0727  0873  	MOVF convertTem_0002A_1_iTest, W
0728  056F  	ANDWF convertTem_0002A_1_iValue, W
0729  1D03  	BTFSS STATUS,Z
072A  2F2F  	GOTO	label122
072B  0874  	MOVF convertTem_0002A_1_iTest+D'1', W
072C  0570  	ANDWF convertTem_0002A_1_iValue+D'1', W
072D  1903  	BTFSC STATUS,Z
072E  2F32  	GOTO	label123
072F        label122

            giDS3231ValueBCD++;
072F  0AB3  	INCF gbl_giDS3231ValueBCD, F
0730  1903  	BTFSC STATUS,Z
0731  0AB4  	INCF gbl_giDS3231ValueBCD+D'1', F
0732        label123

        
        // Add 3 to any BCD column 5 or greater
        if ((giDS3231ValueBCD & 0x0F) > 0x04)
0732  300F  	MOVLW 0x0F
0733  0533  	ANDWF gbl_giDS3231ValueBCD, W
0734  00F6  	MOVWF CompTempVar622
0735  01F7  	CLRF CompTempVar623
0736  0876  	MOVF CompTempVar622, W
0737  3C04  	SUBLW 0x04
0738  0877  	MOVF CompTempVar623, W
0739  1803  	BTFSC STATUS,C
073A  1D03  	BTFSS STATUS,Z
073B  1BF7  	BTFSC CompTempVar623,7
073C  2F41  	GOTO	label124

            giDS3231ValueBCD += 3;
073D  3003  	MOVLW 0x03
073E  07B3  	ADDWF gbl_giDS3231ValueBCD, F
073F  1803  	BTFSC STATUS,C
0740  0AB4  	INCF gbl_giDS3231ValueBCD+D'1', F
0741        label124

        if ((giDS3231ValueBCD & 0xF0) > 0x49)
0741  30F0  	MOVLW 0xF0
0742  0533  	ANDWF gbl_giDS3231ValueBCD, W
0743  00F8  	MOVWF CompTempVar624
0744  01F9  	CLRF CompTempVar625
0745  0878  	MOVF CompTempVar624, W
0746  3C49  	SUBLW 0x49
0747  0879  	MOVF CompTempVar625, W
0748  1803  	BTFSC STATUS,C
0749  1D03  	BTFSS STATUS,Z
074A  1BF9  	BTFSC CompTempVar625,7
074B  2F50  	GOTO	label125

            giDS3231ValueBCD += 0x30;
074C  3030  	MOVLW 0x30
074D  07B3  	ADDWF gbl_giDS3231ValueBCD, F
074E  1803  	BTFSC STATUS,C
074F  0AB4  	INCF gbl_giDS3231ValueBCD+D'1', F
0750        label125

        if ((giDS3231ValueBCD & 0xF00) > 0x499)
0750  3000  	MOVLW 0x00
0751  0533  	ANDWF gbl_giDS3231ValueBCD, W
0752  00FA  	MOVWF CompTempVar626
0753  0834  	MOVF gbl_giDS3231ValueBCD+D'1', W
0754  390F  	ANDLW 0x0F
0755  00FB  	MOVWF CompTempVar627
0756  087B  	MOVF CompTempVar627, W
0757  3C04  	SUBLW 0x04
0758  1D03  	BTFSS STATUS,Z
0759  2F5C  	GOTO	label126
075A  087A  	MOVF CompTempVar626, W
075B  3C99  	SUBLW 0x99
075C        label126
075C  1803  	BTFSC STATUS,C
075D  2F62  	GOTO	label127
075E  1BFB  	BTFSC CompTempVar627,7
075F  2F62  	GOTO	label127
0762        label127

            giDS3231ValueBCD += 0x300;
0760  3003  	MOVLW 0x03
0761  07B4  	ADDWF gbl_giDS3231ValueBCD+D'1', F

        if ((giDS3231ValueBCD & 0xF000) > 0x4999)
0762  3000  	MOVLW 0x00
0763  0533  	ANDWF gbl_giDS3231ValueBCD, W
0764  00FC  	MOVWF CompTempVar628
0765  0834  	MOVF gbl_giDS3231ValueBCD+D'1', W
0766  39F0  	ANDLW 0xF0
0767  00FD  	MOVWF CompTempVar629
0768  087D  	MOVF CompTempVar629, W
0769  3C49  	SUBLW 0x49
076A  1D03  	BTFSS STATUS,Z
076B  2F6E  	GOTO	label128
076C  087C  	MOVF CompTempVar628, W
076D  3C99  	SUBLW 0x99
076E        label128
076E  1803  	BTFSC STATUS,C
076F  2F74  	GOTO	label129
0770  1BFD  	BTFSC CompTempVar629,7
0771  2F74  	GOTO	label129
0774        label129

            giDS3231ValueBCD += 0x3000;
0772  3030  	MOVLW 0x30
0773  07B4  	ADDWF gbl_giDS3231ValueBCD+D'1', F

        
        // move the test bit
        iTest >>= 1;
0774  0D74  	RLF convertTem_0002A_1_iTest+D'1', W
0775  0CF4  	RRF convertTem_0002A_1_iTest+D'1', F
0776  0CF3  	RRF convertTem_0002A_1_iTest, F

    }
    
    // less program memory needed - may be slower executing
    // https://electronics.stackexchange.com/questions/158563/how-to-split-a-floating-point-number-into-individual-digits
    /*giDS3231ValueBCD = 0;

    // incrementing variables for each digit
    // determine to thousands digit
    while (iValue >= 1000) {
        iValue = iValue - 1000;
        // each time we take off 1000, the digit is incremented
        giDS3231ValueBCD += 0x1000;
    }

    // determine to hundreds digit
    while (iValue >= 100) {
        iValue = iValue - 100;
        // each time we take off 100, the digit is incremented
        giDS3231ValueBCD += 0x100;
    }

    // determine to tens digit
    while (iValue >= 10) {
        iValue = iValue - 10;
        // each time we take off 10, the left most digit is incremented
        giDS3231ValueBCD += 0x10;
    }

    // the last digit is what's left on iValue
    giDS3231ValueBCD += iValue;*/
}
0723  0008  	RETURN


/*********************************************************************************************
  void startTemp()
  Sends the Convert T [44h] function command to the ds18b20
*********************************************************************************************/
void startTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // 44 is the convert function
    oneWireTxBytes(0xCC, 0x44);
05FD  30CC  	MOVLW 0xCC
05FE  1283  	BCF STATUS, RP0
05FF  1303  	BCF STATUS, RP1
0600  00ED  	MOVWF oneWireTxB_00019_arg_cData
0601  3044  	MOVLW 0x44
0602  00EE  	MOVWF oneWireTxB_00019_arg_cData2
0603  23AA  	CALL oneWireTxB_00019

}
0604  0008  	RETURN


/*********************************************************************************************
  void startTemp()
  Sends the Read Scratchpad [BEh] function command to the ds18b20
*********************************************************************************************/
void readTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // BE indicates to read scratchpad
    oneWireTxBytes(0xCC, 0xBE);
0605  30CC  	MOVLW 0xCC
0606  1283  	BCF STATUS, RP0
0607  1303  	BCF STATUS, RP1
0608  00ED  	MOVWF oneWireTxB_00019_arg_cData
0609  30BE  	MOVLW 0xBE
060A  00EE  	MOVWF oneWireTxB_00019_arg_cData2
060B  23AA  	CALL oneWireTxB_00019

    // Now get the temperature from the scratchpad
    // This is in the first two bytes - so get those only and ignore the rest
    cTempL = oneWireRxByte();
060C  23B1  	CALL oneWireRxB_0001A
060D  086E  	MOVF CompTempVarRet551, W
060E  00CA  	MOVWF gbl_cTempL

    cTempH = oneWireRxByte();
060F  23B1  	CALL oneWireRxB_0001A
0610  086E  	MOVF CompTempVarRet551, W
0611  00C9  	MOVWF gbl_cTempH

}
0612  0008  	RETURN


/*********************************************************************************************
  char bcdAdjust(char bcd, char bcdMax, char bcdMin)
  Increment or Decrement a BCD variable for sending to the DS3231, within a given range
  Must set iBcdAdjustment first
*********************************************************************************************/
char bcdAdjust(char bcd, char bcdMax, char bcdMin) {

    if (iBcdAdjustment == 1) {
01F7  0369  	DECF gbl_iBcdAdjustment, W
01F8  1D03  	BTFSS STATUS,Z
01F9  2A0D  	GOTO	label41
020D        label41

        // Increment
        // if at maximum, reset to minimum
        if (bcd == bcdMax)
01FA  086F  	MOVF bcdAdjust_00000_arg_bcdMax, W
01FB  066E  	XORWF bcdAdjust_00000_arg_bcd, W
01FC  1D03  	BTFSS STATUS,Z
01FD  2A01  	GOTO	label39
0201        label39

            bcd = bcdMin;
01FE  0870  	MOVF bcdAdjust_00000_arg_bcdMin, W
01FF  00EE  	MOVWF bcdAdjust_00000_arg_bcd

        else if ((bcd & 0x0F) == 9)
0200  2A1E  	GOTO	label44
0201  300F  	MOVLW 0x0F
0202  056E  	ANDWF bcdAdjust_00000_arg_bcd, W
0203  00F1  	MOVWF CompTempVar600
0204  0871  	MOVF CompTempVar600, W
0205  3A09  	XORLW 0x09
0206  1D03  	BTFSS STATUS,Z
0207  2A0B  	GOTO	label40
020B        label40

            bcd += 0x10;
0208  3010  	MOVLW 0x10
0209  07EE  	ADDWF bcdAdjust_00000_arg_bcd, F

        else
020A  2A1E  	GOTO	label44

            bcd++;
020B  0AEE  	INCF bcdAdjust_00000_arg_bcd, F

    } else {
020C  2A1E  	GOTO	label44

        // Decrement
        // if at minimum, reset to maximum
        if (bcd == bcdMin)
020D  0870  	MOVF bcdAdjust_00000_arg_bcdMin, W
020E  066E  	XORWF bcdAdjust_00000_arg_bcd, W
020F  1D03  	BTFSS STATUS,Z
0210  2A14  	GOTO	label42
0214        label42

            bcd = bcdMax;
0211  086F  	MOVF bcdAdjust_00000_arg_bcdMax, W
0212  00EE  	MOVWF bcdAdjust_00000_arg_bcd

        else if ((bcd & 0x0F) == 0)
0213  2A1E  	GOTO	label44
0214  300F  	MOVLW 0x0F
0215  056E  	ANDWF bcdAdjust_00000_arg_bcd, W
0216  00F1  	MOVWF CompTempVar601
0217  08F1  	MOVF CompTempVar601, F
0218  1D03  	BTFSS STATUS,Z
0219  2A1D  	GOTO	label43
021D        label43

            bcd -= 0x10;
021A  3010  	MOVLW 0x10
021B  02EE  	SUBWF bcdAdjust_00000_arg_bcd, F

        else
021C  2A1E  	GOTO	label44
021E        label44

            bcd--;
021D  03EE  	DECF bcdAdjust_00000_arg_bcd, F

    }
    return bcd;
021E  086E  	MOVF bcdAdjust_00000_arg_bcd, W
021F  00F1  	MOVWF CompTempVarRet599

}
0220  0008  	RETURN


/*********************************************************************************************
  void adjustDateTime()
  Increment or Decrement a BCD variable for sending to the DS3231, within a given range
  Must set iBcdAdjustment first
*********************************************************************************************/
void adjustDateTime() {

    switch (gcSetMode) {

        case 1:
0536  1283  	BCF STATUS, RP0
0537  1303  	BCF STATUS, RP1
0538  084F  	MOVF gbl_gcSetMode, W
0539  3A01  	XORLW 0x01
053A  1903  	BTFSC STATUS,Z
053B  2D4C  	GOTO	label93
054C        label93

            // Setting year
            gBcdYear = bcdAdjust(gBcdYear, 0x99, 0x00);
054C  083B  	MOVF gbl_gBcdYear, W
054D  00EE  	MOVWF bcdAdjust_00000_arg_bcd
054E  3099  	MOVLW 0x99
054F  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
0550  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
0551  21F7  	CALL bcdAdjust_00000
0552  0871  	MOVF CompTempVarRet599, W
0553  00BB  	MOVWF gbl_gBcdYear

            break;
        case 2:
053C  3A03  	XORLW 0x03
053D  1903  	BTFSC STATUS,Z
053E  2D55  	GOTO	label94
0555        label94

            // Setting month
            gBcdMonth = bcdAdjust(gBcdMonth, 0x12, 0x01);
0555  083A  	MOVF gbl_gBcdMonth, W
0556  00EE  	MOVWF bcdAdjust_00000_arg_bcd
0557  3012  	MOVLW 0x12
0558  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
0559  3001  	MOVLW 0x01
055A  00F0  	MOVWF bcdAdjust_00000_arg_bcdMin
055B  21F7  	CALL bcdAdjust_00000
055C  0871  	MOVF CompTempVarRet599, W
055D  00BA  	MOVWF gbl_gBcdMonth

            break;
        case 3:
053F  3A01  	XORLW 0x01
0540  1903  	BTFSC STATUS,Z
0541  2D5F  	GOTO	label95
055F        label95

            // Setting day of month
            char iMonth = gBcdMonth;
055F  083A  	MOVF gbl_gBcdMonth, W
0560  00EC  	MOVWF adjustDate_00025_1_iMonth

            if (iMonth & 0xF0)
0561  30F0  	MOVLW 0xF0
0562  056C  	ANDWF adjustDate_00025_1_iMonth, W
0563  1903  	BTFSC STATUS,Z
0564  2D6A  	GOTO	label96
056A        label96

                iMonth += (gBcdMonth >> 4);
0565  0E3A  	SWAPF gbl_gBcdMonth, W
0566  390F  	ANDLW 0x0F
0567  00EE  	MOVWF CompTempVar602
0568  086E  	MOVF CompTempVar602, W
0569  07EC  	ADDWF adjustDate_00025_1_iMonth, F

            iMonth--; // Make 0 to 11 index based
056A  03EC  	DECF adjustDate_00025_1_iMonth, F

            char bcdMaxDay = gDaysInMonth[iMonth]; 
056B  083C  	MOVF gbl_gDaysInMonth, W
056C  00F4  	MOVWF __rom_get_00000_arg_objNumb
056D  086C  	MOVF adjustDate_00025_1_iMonth, W
056E  00F5  	MOVWF __rom_get_00000_arg_idx
056F  2024  	CALL __rom_get_00000
0570  00ED  	MOVWF adjustDate_00025_1_bcdMaxDay

            // If February, adjust max days for leap years
            if (iMonth == 1) {
0571  036C  	DECF adjustDate_00025_1_iMonth, W
0572  118A  	BCF PCLATH,3
0573  120A  	BCF PCLATH,4
0574  1D03  	BTFSS STATUS,Z
0575  2D8C  	GOTO	label99

                // See if the 24 leap years since 2000 match the current year
                for (char i = 0; i < 24; i++) {
0576  01EE  	CLRF adjustDate_00025_16_i
0577        label97
0577  3018  	MOVLW 0x18
0578  026E  	SUBWF adjustDate_00025_16_i, W
0579  1803  	BTFSC STATUS,C
057A  2D8C  	GOTO	label99
058A  0AEE  	INCF adjustDate_00025_16_i, F
058B  2D77  	GOTO	label97
058C        label99

                    if (gLeapYears[i] == gBcdYear) {
057B  083D  	MOVF gbl_gLeapYears, W
057C  00F4  	MOVWF __rom_get_00000_arg_objNumb
057D  086E  	MOVF adjustDate_00025_16_i, W
057E  00F5  	MOVWF __rom_get_00000_arg_idx
057F  2024  	CALL __rom_get_00000
0580  00EF  	MOVWF CompTempVar603
0581  083B  	MOVF gbl_gBcdYear, W
0582  066F  	XORWF CompTempVar603, W
0583  118A  	BCF PCLATH,3
0584  120A  	BCF PCLATH,4
0585  1D03  	BTFSS STATUS,Z
0586  2D8A  	GOTO	label98
058A        label98

                        bcdMaxDay = 0x29;
0587  3029  	MOVLW 0x29
0588  00ED  	MOVWF adjustDate_00025_1_bcdMaxDay

                        break;
0589  2D8C  	GOTO	label99

                    }
                }
            }
            gBcdDayOfMonth = bcdAdjust(gBcdDayOfMonth, bcdMaxDay, 0x01);
058C  0839  	MOVF gbl_gBcdDayOfMonth, W
058D  00EE  	MOVWF bcdAdjust_00000_arg_bcd
058E  086D  	MOVF adjustDate_00025_1_bcdMaxDay, W
058F  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
0590  3001  	MOVLW 0x01
0591  00F0  	MOVWF bcdAdjust_00000_arg_bcdMin
0592  21F7  	CALL bcdAdjust_00000
0593  0871  	MOVF CompTempVarRet599, W
0594  00B9  	MOVWF gbl_gBcdDayOfMonth

            break;
        case 4:
0542  3A07  	XORLW 0x07
0543  1903  	BTFSC STATUS,Z
0544  2D96  	GOTO	label100
0596        label100

            // Setting day of week
            gDayOfWeek = bcdAdjust(gDayOfWeek, 0x07, 0x01);
0596  0838  	MOVF gbl_gDayOfWeek, W
0597  00EE  	MOVWF bcdAdjust_00000_arg_bcd
0598  3007  	MOVLW 0x07
0599  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
059A  3001  	MOVLW 0x01
059B  00F0  	MOVWF bcdAdjust_00000_arg_bcdMin
059C  21F7  	CALL bcdAdjust_00000
059D  0871  	MOVF CompTempVarRet599, W
059E  00B8  	MOVWF gbl_gDayOfWeek

        case 5:
0545  3A01  	XORLW 0x01
0546  1903  	BTFSC STATUS,Z
0547  2D9F  	GOTO	label101
059F        label101

            // Setting hour
            gBcdHour = bcdAdjust(gBcdHour, 0x23, 0x00);
059F  0837  	MOVF gbl_gBcdHour, W
05A0  00EE  	MOVWF bcdAdjust_00000_arg_bcd
05A1  3023  	MOVLW 0x23
05A2  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
05A3  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
05A4  21F7  	CALL bcdAdjust_00000
05A5  0871  	MOVF CompTempVarRet599, W
05A6  00B7  	MOVWF gbl_gBcdHour

        case 6:
0548  3A03  	XORLW 0x03
0549  1903  	BTFSC STATUS,Z
054A  2DA7  	GOTO	label102
05A7        label102

            // Setting minute
            gBcdMinute = bcdAdjust(gBcdMinute, 0x59, 0x00);
05A7  0836  	MOVF gbl_gBcdMinute, W
05A8  00EE  	MOVWF bcdAdjust_00000_arg_bcd
05A9  3059  	MOVLW 0x59
05AA  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
05AB  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
05AC  21F7  	CALL bcdAdjust_00000
05AD  0871  	MOVF CompTempVarRet599, W
05AE  00B6  	MOVWF gbl_gBcdMinute

    }
}
054B  0008  	RETURN
0554  0008  	RETURN
055E  0008  	RETURN
0595  0008  	RETURN
05AF  0008  	RETURN


/*********************************************************************************************
  void adjustTrigger()
  Increment or Decrement a trigger time or temperate
  Must set iBcdAdjustment first
*********************************************************************************************/
void adjustTrigger() {

    switch (gcTriggerMode) {

        case 1:
049E  1283  	BCF STATUS, RP0
049F  1303  	BCF STATUS, RP1
04A0  0850  	MOVF gbl_gcTriggerMode, W
04A1  3A01  	XORLW 0x01
04A2  1903  	BTFSC STATUS,Z
04A3  2CC6  	GOTO	label81
04C6        label81

            // White LED on hour
            gBcdWhiteOnHour = bcdAdjust(gBcdWhiteOnHour, 0x23, 0x00);
04C6  0852  	MOVF gbl_gBcdWhiteOnHour, W
04C7  00EE  	MOVWF bcdAdjust_00000_arg_bcd
04C8  3023  	MOVLW 0x23
04C9  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
04CA  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
04CB  21F7  	CALL bcdAdjust_00000
04CC  0871  	MOVF CompTempVarRet599, W
04CD  00D2  	MOVWF gbl_gBcdWhiteOnHour

            break;
        case 2:
04A4  3A03  	XORLW 0x03
04A5  1903  	BTFSC STATUS,Z
04A6  2CCF  	GOTO	label82
04CF        label82

            // White LED on minute
            gBcdWhiteOnMinute = bcdAdjust(gBcdWhiteOnMinute, 0x59, 0x00);
04CF  0851  	MOVF gbl_gBcdWhiteOnMinute, W
04D0  00EE  	MOVWF bcdAdjust_00000_arg_bcd
04D1  3059  	MOVLW 0x59
04D2  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
04D3  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
04D4  21F7  	CALL bcdAdjust_00000
04D5  0871  	MOVF CompTempVarRet599, W
04D6  00D1  	MOVWF gbl_gBcdWhiteOnMinute

            break;
        case 3:
04A7  3A01  	XORLW 0x01
04A8  1903  	BTFSC STATUS,Z
04A9  2CD8  	GOTO	label83
04D8        label83

            // White LED off hour
            gBcdWhiteOffHour = bcdAdjust(gBcdWhiteOffHour, 0x23, 0x00);
04D8  0854  	MOVF gbl_gBcdWhiteOffHour, W
04D9  00EE  	MOVWF bcdAdjust_00000_arg_bcd
04DA  3023  	MOVLW 0x23
04DB  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
04DC  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
04DD  21F7  	CALL bcdAdjust_00000
04DE  0871  	MOVF CompTempVarRet599, W
04DF  00D4  	MOVWF gbl_gBcdWhiteOffHour

            break;
        case 4:
04AA  3A07  	XORLW 0x07
04AB  1903  	BTFSC STATUS,Z
04AC  2CE1  	GOTO	label84
04E1        label84

            // White LED off minute
            gBcdWhiteOffMinute = bcdAdjust(gBcdWhiteOffMinute, 0x59, 0x00);
04E1  0853  	MOVF gbl_gBcdWhiteOffMinute, W
04E2  00EE  	MOVWF bcdAdjust_00000_arg_bcd
04E3  3059  	MOVLW 0x59
04E4  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
04E5  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
04E6  21F7  	CALL bcdAdjust_00000
04E7  0871  	MOVF CompTempVarRet599, W
04E8  00D3  	MOVWF gbl_gBcdWhiteOffMinute

            break;
        case 5:
04AD  3A01  	XORLW 0x01
04AE  1903  	BTFSC STATUS,Z
04AF  2CEA  	GOTO	label85
04EA        label85

            // Blue LED on hour
            gBcdBlueOnHour = bcdAdjust(gBcdBlueOnHour, 0x23, 0x00);
04EA  0856  	MOVF gbl_gBcdBlueOnHour, W
04EB  00EE  	MOVWF bcdAdjust_00000_arg_bcd
04EC  3023  	MOVLW 0x23
04ED  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
04EE  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
04EF  21F7  	CALL bcdAdjust_00000
04F0  0871  	MOVF CompTempVarRet599, W
04F1  00D6  	MOVWF gbl_gBcdBlueOnHour

            break;
        case 6:
04B0  3A03  	XORLW 0x03
04B1  1903  	BTFSC STATUS,Z
04B2  2CF3  	GOTO	label86
04F3        label86

            // Blue LED on minute
            gBcdBlueOnMinute = bcdAdjust(gBcdBlueOnMinute, 0x59, 0x00);
04F3  0855  	MOVF gbl_gBcdBlueOnMinute, W
04F4  00EE  	MOVWF bcdAdjust_00000_arg_bcd
04F5  3059  	MOVLW 0x59
04F6  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
04F7  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
04F8  21F7  	CALL bcdAdjust_00000
04F9  0871  	MOVF CompTempVarRet599, W
04FA  00D5  	MOVWF gbl_gBcdBlueOnMinute

            break;
        case 7:
04B3  3A01  	XORLW 0x01
04B4  1903  	BTFSC STATUS,Z
04B5  2CFC  	GOTO	label87
04FC        label87

            // Blue LED off hour
            gBcdBlueOffHour = bcdAdjust(gBcdBlueOffHour, 0x23, 0x00);
04FC  0858  	MOVF gbl_gBcdBlueOffHour, W
04FD  00EE  	MOVWF bcdAdjust_00000_arg_bcd
04FE  3023  	MOVLW 0x23
04FF  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
0500  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
0501  21F7  	CALL bcdAdjust_00000
0502  0871  	MOVF CompTempVarRet599, W
0503  00D8  	MOVWF gbl_gBcdBlueOffHour

            break;
        case 8:
04B6  3A0F  	XORLW 0x0F
04B7  1903  	BTFSC STATUS,Z
04B8  2D05  	GOTO	label88
0505        label88

            // Blue LED off minute
            gBcdBlueOffMinute = bcdAdjust(gBcdBlueOffMinute, 0x59, 0x00);
0505  0857  	MOVF gbl_gBcdBlueOffMinute, W
0506  00EE  	MOVWF bcdAdjust_00000_arg_bcd
0507  3059  	MOVLW 0x59
0508  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
0509  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
050A  21F7  	CALL bcdAdjust_00000
050B  0871  	MOVF CompTempVarRet599, W
050C  00D7  	MOVWF gbl_gBcdBlueOffMinute

            break;
        case 9:
04B9  3A01  	XORLW 0x01
04BA  1903  	BTFSC STATUS,Z
04BB  2D0E  	GOTO	label89
050E        label89

            // Fan on temp - between 20 and 40 degrees C
            gBcdFanOnTemp = bcdAdjust(gBcdFanOnTemp, 0x40, 0x20);
050E  0859  	MOVF gbl_gBcdFanOnTemp, W
050F  00EE  	MOVWF bcdAdjust_00000_arg_bcd
0510  3040  	MOVLW 0x40
0511  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
0512  3020  	MOVLW 0x20
0513  00F0  	MOVWF bcdAdjust_00000_arg_bcdMin
0514  21F7  	CALL bcdAdjust_00000
0515  0871  	MOVF CompTempVarRet599, W
0516  00D9  	MOVWF gbl_gBcdFanOnTemp

            break;
        case 10:
04BC  3A03  	XORLW 0x03
04BD  1903  	BTFSC STATUS,Z
04BE  2D18  	GOTO	label90
0518        label90

            // Fan off temp - off must be lower than on, min 20 degrees C
            gBcdFanOffTemp = bcdAdjust(gBcdFanOffTemp, gBcdFanOffTemp, 0x20);
0518  085A  	MOVF gbl_gBcdFanOffTemp, W
0519  00EE  	MOVWF bcdAdjust_00000_arg_bcd
051A  085A  	MOVF gbl_gBcdFanOffTemp, W
051B  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
051C  3020  	MOVLW 0x20
051D  00F0  	MOVWF bcdAdjust_00000_arg_bcdMin
051E  21F7  	CALL bcdAdjust_00000
051F  0871  	MOVF CompTempVarRet599, W
0520  00DA  	MOVWF gbl_gBcdFanOffTemp

            break;
        case 11:
04BF  3A01  	XORLW 0x01
04C0  1903  	BTFSC STATUS,Z
04C1  2D22  	GOTO	label91
0522        label91

            // Heater on temp - between 20 and 40 degrees C
            gBcdHeaterOnTemp = bcdAdjust(gBcdHeaterOnTemp, 0x40, 0x20);
0522  085B  	MOVF gbl_gBcdHeaterOnTemp, W
0523  00EE  	MOVWF bcdAdjust_00000_arg_bcd
0524  3040  	MOVLW 0x40
0525  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
0526  3020  	MOVLW 0x20
0527  00F0  	MOVWF bcdAdjust_00000_arg_bcdMin
0528  21F7  	CALL bcdAdjust_00000
0529  0871  	MOVF CompTempVarRet599, W
052A  00DB  	MOVWF gbl_gBcdHeaterOnTemp

            break;
        case 12:
04C2  3A07  	XORLW 0x07
04C3  1903  	BTFSC STATUS,Z
04C4  2D2C  	GOTO	label92
052C        label92

            // Heater off temp - off must be higher than on - max 40 degrees C
            gBcdHeaterOffTemp = bcdAdjust(gBcdHeaterOffTemp, 0x40, gBcdHeaterOnTemp);
052C  085C  	MOVF gbl_gBcdHeaterOffTemp, W
052D  00EE  	MOVWF bcdAdjust_00000_arg_bcd
052E  3040  	MOVLW 0x40
052F  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
0530  085B  	MOVF gbl_gBcdHeaterOnTemp, W
0531  00F0  	MOVWF bcdAdjust_00000_arg_bcdMin
0532  21F7  	CALL bcdAdjust_00000
0533  0871  	MOVF CompTempVarRet599, W
0534  00DC  	MOVWF gbl_gBcdHeaterOffTemp

            break;
    }
}
04C5  0008  	RETURN
04CE  0008  	RETURN
04D7  0008  	RETURN
04E0  0008  	RETURN
04E9  0008  	RETURN
04F2  0008  	RETURN
04FB  0008  	RETURN
0504  0008  	RETURN
050D  0008  	RETURN
0517  0008  	RETURN
0521  0008  	RETURN
052B  0008  	RETURN
0535  0008  	RETURN


/*********************************************************************************************
  void processKeys()
  Action a key press
*********************************************************************************************/
void processKeys() {

    switch (tm1638Keys) {

        case 1:
0613  1283  	BCF STATUS, RP0
0614  1303  	BCF STATUS, RP1
0615  0865  	MOVF gbl_tm1638Keys, W
0616  3A01  	XORLW 0x01
0617  1903  	BTFSC STATUS,Z
0618  2E2F  	GOTO	label109
062F        label109

            // Toggle white light on/off
            WHITE_LED = !WHITE_LED;
062F  01EC  	CLRF CompTempVar604
0630  1C87  	BTFSS gbl_portc,1
0631  0AEC  	INCF CompTempVar604, F
0632  186C  	BTFSC CompTempVar604,0
0633  1487  	BSF gbl_portc,1
0634  1C6C  	BTFSS CompTempVar604,0
0635  1087  	BCF gbl_portc,1

            break;
        case 2:
0619  3A03  	XORLW 0x03
061A  1903  	BTFSC STATUS,Z
061B  2E37  	GOTO	label110
0637        label110

            // Toggle blue light on/off
            BLUE_LED = !BLUE_LED;
0637  01EC  	CLRF CompTempVar605
0638  1D07  	BTFSS gbl_portc,2
0639  0AEC  	INCF CompTempVar605, F
063A  186C  	BTFSC CompTempVar605,0
063B  1507  	BSF gbl_portc,2
063C  1C6C  	BTFSS CompTempVar605,0
063D  1107  	BCF gbl_portc,2

            break;
        case 3:
061C  3A01  	XORLW 0x01
061D  1903  	BTFSC STATUS,Z
061E  2E3F  	GOTO	label111
063F        label111

            // Toggle fan on/off
            FAN = !FAN;
063F  01EC  	CLRF CompTempVar606
0640  1C85  	BTFSS gbl_porta,1
0641  0AEC  	INCF CompTempVar606, F
0642  186C  	BTFSC CompTempVar606,0
0643  1485  	BSF gbl_porta,1
0644  1C6C  	BTFSS CompTempVar606,0
0645  1085  	BCF gbl_porta,1

            break;
        case 4:
061F  3A07  	XORLW 0x07
0620  1903  	BTFSC STATUS,Z
0621  2E47  	GOTO	label112
0647        label112

            // Display temp C/temp F/date
            gcDisplayMode++;
0647  0ACE  	INCF gbl_gcDisplayMode, F

            if (gcDisplayMode > 2)
0648  084E  	MOVF gbl_gcDisplayMode, W
0649  3C02  	SUBLW 0x02
064A  1C03  	BTFSS STATUS,C

                gcDisplayMode = 0;
064B  01CE  	CLRF gbl_gcDisplayMode

            break;
        case 5:
0622  3A01  	XORLW 0x01
0623  1903  	BTFSC STATUS,Z
0624  2E4D  	GOTO	label113
064D        label113

            // Set
            gcSetMode++;
064D  0ACF  	INCF gbl_gcSetMode, F

            if (gcSetMode > 6) {
064E  084F  	MOVF gbl_gcSetMode, W
064F  3C06  	SUBLW 0x06
0650  1803  	BTFSC STATUS,C

                ds3231WriteDateTime();
0652  23E2  	CALL ds3231Writ_0001C

                gcSetMode = 0;
0653  01CF  	CLRF gbl_gcSetMode

            }
            break;
        case 6:
0625  3A03  	XORLW 0x03
0626  1903  	BTFSC STATUS,Z
0627  2E55  	GOTO	label114
0655        label114

            // Adjust down
            iBcdAdjustment = 0;
0655  01E9  	CLRF gbl_iBcdAdjustment

            if (gcSetMode) {
0656  08CF  	MOVF gbl_gcSetMode, F
0657  1903  	BTFSC STATUS,Z
0658  2E5B  	GOTO	label115
065B        label115

                adjustDateTime();
0659  2536  	CALL adjustDate_00025

            } else if (gcTriggerMode) {
065B  08D0  	MOVF gbl_gcTriggerMode, F
065C  1D03  	BTFSS STATUS,Z

                adjustTrigger();
065D  249E  	CALL adjustTrig_00026

            }
            break;
        case 7:
0628  3A01  	XORLW 0x01
0629  1903  	BTFSC STATUS,Z
062A  2E5F  	GOTO	label116
065F        label116

            iBcdAdjustment = 1;
065F  3001  	MOVLW 0x01
0660  00E9  	MOVWF gbl_iBcdAdjustment

            // Adjust up
            if (gcSetMode) {
0661  08CF  	MOVF gbl_gcSetMode, F
0662  1903  	BTFSC STATUS,Z
0663  2E66  	GOTO	label117
0666        label117

                adjustDateTime();
0664  2536  	CALL adjustDate_00025

            } else if (gcTriggerMode) {
0666  08D0  	MOVF gbl_gcTriggerMode, F
0667  1D03  	BTFSS STATUS,Z

                adjustTrigger();
0668  249E  	CALL adjustTrig_00026

            }
            break;
        case 8:
062B  3A0F  	XORLW 0x0F
062C  1903  	BTFSC STATUS,Z
062D  2E6A  	GOTO	label118
066A        label118

            // Timer
            gcTriggerMode++;
066A  0AD0  	INCF gbl_gcTriggerMode, F

            if (gcTriggerMode > 12) {
066B  0850  	MOVF gbl_gcTriggerMode, W
066C  3C0C  	SUBLW 0x0C
066D  1803  	BTFSC STATUS,C

                gcTriggerMode = 0;
066F  01D0  	CLRF gbl_gcTriggerMode

                at24c32WriteAll(); // Exiting trigger mode, save the new triggers to EEPROM chip
0670  241E  	CALL at24c32Wri_00028

            }
            break;
    }
}
062E  0008  	RETURN
0636  0008  	RETURN
063E  0008  	RETURN
0646  0008  	RETURN
064C  0008  	RETURN
0651  0008  	RETURN
0654  0008  	RETURN
065A  0008  	RETURN
065E  0008  	RETURN
0665  0008  	RETURN
0669  0008  	RETURN
066E  0008  	RETURN
0671  0008  	RETURN


/*********************************************************************************************
  void interrupt()
  Interrupt handler
*********************************************************************************************/
void interrupt() {

    // Interrupt on timer0 - flash digit delay
    if (intcon.T0IF) {
0843  1D0B  	BTFSS gbl_intcon,2
0844  2852  	GOTO	label144
0852        label144

        iTimer0Counts++;
0845  1283  	BCF STATUS, RP0
0846  1303  	BCF STATUS, RP1
0847  0ABE  	INCF gbl_iTimer0Counts, F

        if (iTimer0Counts > 9) {
0848  083E  	MOVF gbl_iTimer0Counts, W
0849  3C09  	SUBLW 0x09
084A  1803  	BTFSC STATUS,C
084B  284F  	GOTO	label143
084F        label143

            iFlashDigitOff++;
084C  0ABF  	INCF gbl_iFlashDigitOff, F

            iTimer0Counts = 0;
084D  01BE  	CLRF gbl_iTimer0Counts

            cTask.TASK_TIMER0 = 1;
084E  14CC  	BSF gbl_cTask,1

        }
        tmr0 = TMR0PRELOAD;
084F  303D  	MOVLW 0x3D
0850  0081  	MOVWF gbl_tmr0

        // Clear interrupt flag
        intcon.T0IF = 0; 
0851  110B  	BCF gbl_intcon,2

    }
    // Handle timer1 interrupt - delay counter from DS3231
    if (pir1.TMR1IF) {
0852  1283  	BCF STATUS, RP0
0853  1303  	BCF STATUS, RP1
0854  1C0C  	BTFSS gbl_pir1,0
0855  285B  	GOTO	label145
085B        label145

        tmr1h = TMR1HV;      // preset for timer1 MSB register
0856  30FF  	MOVLW 0xFF
0857  008F  	MOVWF gbl_tmr1h

        tmr1l = TMR1LV;      // preset for timer1 LSB register
0858  008E  	MOVWF gbl_tmr1l


        pir1.TMR1IF = 0;     // Clear interrupt flag
0859  100C  	BCF gbl_pir1,0

        cTask.TASK_TIMER1 = 1;
085A  154C  	BSF gbl_cTask,2

    }
}
085B  0E32  	SWAPF Int1BContext+D'2', W
085C  0084  	MOVWF FSR
085D  0E31  	SWAPF Int1BContext+D'1', W
085E  008A  	MOVWF PCLATH
085F  0E30  	SWAPF Int1BContext, W
0860  0083  	MOVWF STATUS
0861  0EFF  	SWAPF Int1Context, F
0862  0E7F  	SWAPF Int1Context, W
0863  0009  	RETFIE


/*********************************************************************************************
  void initialise()
  Function called once only to initialise variables and
  setup the PIC registers
*********************************************************************************************/
void initialise() {

    //PIC16F73 doesn't have an internal oscillator
    //pcon.OSCF = 1; // 4MHz internal osc

    // Configure port A
    /*
    RA7     Doesn't exist
    RA6     Doesn't exist
    RA5     
    RA4     
    RA3     
    RA2     
    RA1     OUT FANS
    RA0     OUT HEATER
    */
    trisa = 0x00; // all outputs
068A  1683  	BSF STATUS, RP0
068B  1303  	BCF STATUS, RP1
068C  0185  	CLRF gbl_trisa

    porta = 0x00; // All off
068D  1283  	BCF STATUS, RP0
068E  0185  	CLRF gbl_porta

    
    // Configure port B
    /*      
    RB7     ICSP PGD
    RB6     ICSP PGC
    RB5     
    RB4     
    RB3     OUT TM1638 STB
    RB2     OUT TM1638 CLK
    RB1     IN/OUT TM1638 DIO
    RB0     
    */
    trisb = 0x00; // all outputs by default
068F  1683  	BSF STATUS, RP0
0690  0186  	CLRF gbl_trisb

    portb = 0x0E; // default TM1638 pins high
0691  300E  	MOVLW 0x0E
0692  1283  	BCF STATUS, RP0
0693  0086  	MOVWF gbl_portb


    // Configure port C
    /*      
    RC7     
    RC6     
    RC5     IN/OUT DS18B20
    RC4     IN/OUT DS3231M I2C SDA
    RC3     IN/OUT DS3231M I2C CLK
    RC2     OUT BLUE LIGHT PWM
    RC1     OUT WHITE LIGHT PWM
    RC0     IN SQW DS3231M
    */
    trisc = 0x21; // RC0 and RC5 inputs
0694  3021  	MOVLW 0x21
0695  1683  	BSF STATUS, RP0
0696  0087  	MOVWF gbl_trisc

    portc = 0x38; // default DS18B20 and DS3231 pins high
0697  3038  	MOVLW 0x38
0698  1283  	BCF STATUS, RP0
0699  0087  	MOVWF gbl_portc


    option_reg = 0;
069A  1683  	BSF STATUS, RP0
069B  0181  	CLRF gbl_option_reg

    option_reg.NOT_RBPU = 1; // disable port b pull ups
069C  1781  	BSF gbl_option_reg,7


    // ADC setup
    // PIC16F73 doesn't have comparators
    //cmcon = 7; // disable all comparators so port a is usable as digital io
    adcon1 = 7; // Set RA0,RA1,RA2,RA5,RA3 all to digital I/O
069D  3007  	MOVLW 0x07
069E  009F  	MOVWF gbl_adcon1



    // Setup timer 0, used for flashing display
    // Timer calculator: http://eng-serve.com/pic/pic_timer.html
    // Timer0 Registers Prescaler= 256 - TMR0 Preset = 61 - Freq = 20.03 Hz - Period = 0.049920 seconds
    //option_reg.T0CS = 0; // bit 5  TMR0 Clock Source Select bit...0 = Internal Clock (CLKO) 1 = Transition on T0CKI pin
    //option_reg.T0SE = 0; // bit 4 TMR0 Source Edge Select bit 0 = low/high 1 = high/low
    //option_reg.PSA = 0; // bit 3  Prescaler Assignment bit...0 = Prescaler is assigned to the Timer0
    option_reg.PS2 = 1; // bits 2-0  PS2:PS0: Prescaler Rate Select bits
069F  1501  	BSF gbl_option_reg,2

    option_reg.PS1 = 1;
06A0  1481  	BSF gbl_option_reg,1

    option_reg.PS0 = 1;
06A1  1401  	BSF gbl_option_reg,0

    tmr0 = TMR0PRELOAD; // preset for timer register (61)
06A2  303D  	MOVLW 0x3D
06A3  1283  	BCF STATUS, RP0
06A4  0081  	MOVWF gbl_tmr0

    intcon.T0IF = 0; // Clear timer 1 interrupt flag bit
06A5  110B  	BCF gbl_intcon,2

    intcon.T0IE = 1; // Timer 1 interrupt enabled
06A6  168B  	BSF gbl_intcon,5


    // Setup timer 1, used to update clock display and periodically ask for a temperature reading
    // Timer 1 setup - interrupt on DS3231 SQW 1Hz
    // Timer1 Registers Prescaler= 1 - TMR1 Preset = 65535 - Freq = 1 Hz
    // Bits 5-4 T1CKPS1:T1CKPS0 = 00: Prescaler Rate Select bits, 00 = 1:1 prescaler
    // Bit 3 T1OSCEN = 0: Timer1 LP Oscillator Enable Control bit, 0 = off
    // Bit 2 NOT_T1SYNC = 1: Timer1 External Clock Input Synchronization Control bit, 1 = Do not synchronize external clock input
    // Bit 1 TMR1CS = 1: Timer1 Clock Source Select bit, 1 = External clock from T1OSO/T1CKI pin (on the rising edge)
    // Bit 0 TMR1ON = 0: Timer1 On Bit, 0 = off
    t1con = 0b00000111;
06A7  3007  	MOVLW 0x07
06A8  0090  	MOVWF gbl_t1con

    tmr1h = TMR1HV;      // preset for timer1 MSB register
06A9  30FF  	MOVLW 0xFF
06AA  008F  	MOVWF gbl_tmr1h

    tmr1l = TMR1LV;      // preset for timer1 LSB register
06AB  008E  	MOVWF gbl_tmr1l

    pie1.TMR1IE = 1;     // Timer 1 interrupt
06AC  1683  	BSF STATUS, RP0
06AD  140C  	BSF gbl_pie1,0

    
    // No task at initialisation
    cTask = 0;
06AE  1283  	BCF STATUS, RP0
06AF  01CC  	CLRF gbl_cTask

    
    // Enable interrupts
    intcon.GIE = 1;
06B0  178B  	BSF gbl_intcon,7

    intcon.PEIE = 1;
06B1  170B  	BSF gbl_intcon,6


	// I2C Bus initialisation - baud rate divisor not applicable for software implementation
	i2c_init(1); 
06B2  3001  	MOVLW 0x01
06B3  00ED  	MOVWF i2c_INIT_00000_arg_i2c_divisor
06B4  23CF  	CALL i2c_INIT_00000


    // Read in variables from EEPROM
    at24c32ReadAll();
06B5  2452  	CALL at24c32Rea_00029


    // Check if the DS3231 needs initilising
    char cStatus = ds3231ReadRegister(0x0F); // Read the status register
06B6  300F  	MOVLW 0x0F
06B7  00ED  	MOVWF ds3231Read_0001E_arg_cRegAddress
06B8  23FE  	CALL ds3231Read_0001E
06B9  086F  	MOVF CompTempVarRet554, W
06BA  00EC  	MOVWF initialise_00000_1_cStatus

    // If the oscillator (OSF bit in status register) has stopped, then init and write a default date/time
    if (cStatus.7) {
06BB  1FEC  	BTFSS initialise_00000_1_cStatus,7
06BC  2EBF  	GOTO	label119
06BF        label119

        ds3231Init();
06BD  2413  	CALL ds3231Init_00000

        ds3231WriteDateTime();
06BE  23E2  	CALL ds3231Writ_0001C

    }
    
	tm1638DisplayOn();
06BF  23A2  	CALL tm1638Disp_00020

    tm1638UpdateDisplay();
06C0  2221  	CALL tm1638Upda_00021

}
06C1  0008  	RETURN


/*********************************************************************************************
  void main()
  Entry method. Loops infinitely with a simple task scheduler.
*********************************************************************************************/
void main() {

    initialise();
0779  268A  	CALL initialise_00000

    
    // Endless loop
    while(1) {
077A        label130
07E0  2F7A  	GOTO	label130

        // Task scheduler
        // If there are tasks to be performed, find out the
        // most recent task from the array and execute it
        while (cTask > 0) {
077A  084C  	MOVF gbl_cTask, W
077B  3C00  	SUBLW 0x00
077C  1803  	BTFSC STATUS,C
077D  2FD5  	GOTO	label140
07D4  2F7A  	GOTO	label130
07D5        label140

            if (cTask.TASK_TIMER1) {
077E  1D4C  	BTFSS gbl_cTask,2
077F  2FCD  	GOTO	label139
07CD        label139

                if (gcSetMode == 0) {
0780  08CF  	MOVF gbl_gcSetMode, F
0781  1D03  	BTFSS STATUS,Z
0782  2F99  	GOTO	label134

                    ds3231ReadDateTime();
0783  26C2  	CALL ds3231Read_0001D

                    if ((gBcdSeconds == 0x29) || (gBcdSeconds == 0x59)) {
0784  0835  	MOVF gbl_gBcdSeconds, W
0785  3A29  	XORLW 0x29
0786  1903  	BTFSC STATUS,Z
0787  2F8C  	GOTO	label131
0788  0835  	MOVF gbl_gBcdSeconds, W
0789  3A59  	XORLW 0x59
078A  1D03  	BTFSS STATUS,Z
078B  2F8F  	GOTO	label132
078C        label131
078F        label132

                        // Ask to convert for temperature reading at 29 seconds or 59 seconds past the minute
                        oneWireBusReset();
078C  2672  	CALL oneWireBus_00017

                        startTemp();
078D  25FD  	CALL startTemp_00000

                    } else if ((gBcdSeconds == 0) || (gBcdSeconds == 0x30)) {
078E  2F99  	GOTO	label134
078F  08B5  	MOVF gbl_gBcdSeconds, F
0790  1903  	BTFSC STATUS,Z
0791  2F96  	GOTO	label133
0792  0835  	MOVF gbl_gBcdSeconds, W
0793  3A30  	XORLW 0x30
0794  1D03  	BTFSS STATUS,Z
0795  2F99  	GOTO	label134
0796        label133
0799        label134

                        // 1 second later, read the converted temperature
                        oneWireBusReset();
0796  2672  	CALL oneWireBus_00017

                        readTemp(); 
0797  2605  	CALL readTemp_00000

                        // store it in the array, next display refresh will pick it up
                        convertTemp();
0798  26EC  	CALL convertTem_0002A

                    }
                }
                // Trigger white led
                if ((gBcdHour == gBcdWhiteOnHour) && (gBcdMinute == gBcdWhiteOnMinute)) {
0799  0852  	MOVF gbl_gBcdWhiteOnHour, W
079A  0637  	XORWF gbl_gBcdHour, W
079B  1D03  	BTFSS STATUS,Z
079C  2FA1  	GOTO	label135
079D  0851  	MOVF gbl_gBcdWhiteOnMinute, W
079E  0636  	XORWF gbl_gBcdMinute, W
079F  1903  	BTFSC STATUS,Z

                    WHITE_LED = 1;
07A0  1487  	BSF gbl_portc,1
07A1        label135

                }
                if ((gBcdHour == gBcdWhiteOffHour) && (gBcdMinute == gBcdWhiteOffMinute)) {
07A1  0854  	MOVF gbl_gBcdWhiteOffHour, W
07A2  0637  	XORWF gbl_gBcdHour, W
07A3  1D03  	BTFSS STATUS,Z
07A4  2FA9  	GOTO	label136
07A5  0853  	MOVF gbl_gBcdWhiteOffMinute, W
07A6  0636  	XORWF gbl_gBcdMinute, W
07A7  1903  	BTFSC STATUS,Z

                    WHITE_LED = 0;
07A8  1087  	BCF gbl_portc,1
07A9        label136

                }
                // Trigger blue led
                if ((gBcdHour == gBcdBlueOnHour) && (gBcdMinute == gBcdBlueOnMinute)) {
07A9  0856  	MOVF gbl_gBcdBlueOnHour, W
07AA  0637  	XORWF gbl_gBcdHour, W
07AB  1D03  	BTFSS STATUS,Z
07AC  2FB1  	GOTO	label137
07AD  0855  	MOVF gbl_gBcdBlueOnMinute, W
07AE  0636  	XORWF gbl_gBcdMinute, W
07AF  1903  	BTFSC STATUS,Z

                    BLUE_LED = 1;
07B0  1507  	BSF gbl_portc,2
07B1        label137

                }
                if ((gBcdHour == gBcdBlueOffHour) && (gBcdMinute == gBcdBlueOffMinute)) {
07B1  0858  	MOVF gbl_gBcdBlueOffHour, W
07B2  0637  	XORWF gbl_gBcdHour, W
07B3  1D03  	BTFSS STATUS,Z
07B4  2FB9  	GOTO	label138
07B5  0857  	MOVF gbl_gBcdBlueOffMinute, W
07B6  0636  	XORWF gbl_gBcdMinute, W
07B7  1903  	BTFSC STATUS,Z

                    BLUE_LED = 0;
07B8  1107  	BCF gbl_portc,2
07B9        label138

                }
                // Trigger fan
                char cTempTruncated = giDS3231ValueBCD >> 8;
07B9  0834  	MOVF gbl_giDS3231ValueBCD+D'1', W
07BA  00EC  	MOVWF main_6_cTempTruncated

                if (cTempTruncated == gBcdFanOnTemp) {
07BB  0859  	MOVF gbl_gBcdFanOnTemp, W
07BC  066C  	XORWF main_6_cTempTruncated, W
07BD  1903  	BTFSC STATUS,Z

                    FAN = 1;
07BE  1485  	BSF gbl_porta,1

                }
                if (cTempTruncated == gBcdFanOffTemp) {
07BF  085A  	MOVF gbl_gBcdFanOffTemp, W
07C0  066C  	XORWF main_6_cTempTruncated, W
07C1  1903  	BTFSC STATUS,Z

                    FAN = 0;
07C2  1085  	BCF gbl_porta,1

                }
                if (cTempTruncated == gBcdHeaterOnTemp) {
07C3  085B  	MOVF gbl_gBcdHeaterOnTemp, W
07C4  066C  	XORWF main_6_cTempTruncated, W
07C5  1903  	BTFSC STATUS,Z

                    HEATER = 1;
07C6  1405  	BSF gbl_porta,0

                }
                if (cTempTruncated == gBcdHeaterOffTemp) {
07C7  085C  	MOVF gbl_gBcdHeaterOffTemp, W
07C8  066C  	XORWF main_6_cTempTruncated, W
07C9  1903  	BTFSC STATUS,Z

                    HEATER = 0;
07CA  1005  	BCF gbl_porta,0

                }
                // Display time and temp or date on TM1638
                tm1638UpdateDisplay();
07CB  2221  	CALL tm1638Upda_00021

                
                cTask.TASK_TIMER1 = 0;
07CC  114C  	BCF gbl_cTask,2

            }
            if (cTask.TASK_TIMER0) {
07CD  1CCC  	BTFSS gbl_cTask,1
07CE  2F7A  	GOTO	label130

                // If in set mode, update the display every ~half second to flash a digit
                if (gcSetMode > 0)
07CF  084F  	MOVF gbl_gcSetMode, W
07D0  3C00  	SUBLW 0x00
07D1  1C03  	BTFSS STATUS,C

                    tm1638UpdateDisplay();
07D2  2221  	CALL tm1638Upda_00021

                cTask.TASK_TIMER0 = 0;
07D3  10CC  	BCF gbl_cTask,1

            }
        }
		// Poll keys
		tm1638ReadKeys();
07D5  25D9  	CALL tm1638Read_00023

		if (tm1638Keys != tm1638KeysOld) {
07D6  0866  	MOVF gbl_tm1638KeysOld, W
07D7  0665  	XORWF gbl_tm1638Keys, W
07D8  1903  	BTFSC STATUS,Z
07D9  2F7A  	GOTO	label130

			if (tm1638Keys != 0)
07DA  08E5  	MOVF gbl_tm1638Keys, F
07DB  1903  	BTFSC STATUS,Z
07DC  2FDE  	GOTO	label141
07DE        label141

				processKeys();
07DD  2613  	CALL processKey_00027

			tm1638KeysOld = tm1638Keys;
07DE  0865  	MOVF gbl_tm1638Keys, W
07DF  00E6  	MOVWF gbl_tm1638KeysOld

		}
    }
}


////////////////////////////////////////////////////////////////////////////
// I2C Communications Library for I2C MASTER
////////////////////////////////////////////////////////////////////////////
// Author(s): Andrew Smallridge
// Date 15 November 2004
//
// Copyright(C) 2004-2006 Andrew Smallridge
// Copyright(C) 2004-2010 Pavel Baranov
// Copyright(C) 2004-2010 David Hobday
// Existing constants predefined for i2c hardware driver and i2s software
// emulation for the PIC 18F2xx and 18F4xx processors. For hardware support
// on other PICs the constants must be mapped to the corresponding register
// map of the target device
////////////////////////////////////////////////////////////////////////////

/*
////////////////////////////////////////////////////////////////////////////
//	The following three sections should be copied to the user's program:
//		i2c master hardware / software mode definition
//		i2c software implementation template arguments and variables
// 		i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////
// i2c master hardware / software mode definition
//
// For i2c hardware support comment out the #define use_ic2_SW line
////////////////////////////////////////////////////////////////////////////
//#define use_i2c_SW

#if defined use_i2c_SW
////////////////////////////////////////////////////////////////////////////
// i2c software implementation template arguments and variables
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)

// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and software emalated i2c RAM locations. These constants are
// then used by the templated functions. When changing the address of an emulated
// register the corresponding constant mapping must also be changed.
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3					

#else
////////////////////////////////////////////////////////////////////////////
// i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP |i2c_HW)

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and PIC's i2c register locations. These constants are
// then used by the templated functions. 
#define PORTC		0x0f82
#define TRISC		0x0f94
#define e_SSPCON1	0xfc6
#define e_SSPCON2	0xfc5
#define e_SSPSTAT	0xfc7
#define e_SSPADD	0xfc8
#define e_SSPBUF	0xfc9
#define e_SSPIF_PIR	0xf9e
#define e_BCLIF_PIR	0xfa1
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3

#endif

*/


////////////////////////////////////////////////////////////////////////////
// Define the common i2c template structure
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL	template <unsigned char T_SCL_BIT, unsigned short T_SCL_PORT,	\
					unsigned short T_SCL_TRIS, unsigned char T_SDA_BIT, 			\
					unsigned short T_SDA_PORT, unsigned short T_SDA_TRIS,			\
					unsigned short T_i2c_SSPCON1, unsigned short T_i2c_SSPCON2, 	\
					unsigned short T_i2c_SSPSTAT, unsigned short T_i2c_SSPBUF, 		\
					unsigned char T_i2c_SSPIF_BIT, unsigned short T_i2c_SSPIF_PIR,	\
					unsigned char T_i2c_BCLIF_BIT, unsigned short T_i2c_BCLIF_PIR,	\
					unsigned char T_i2c_SMP_BIT, unsigned short T_i2c_SSPADD, 		\
					unsigned char T_MODE>

////////////////////////////////////////////////////////////////////////////
// Define the common i2c template parameters
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL_ARGS	T_SCL_BIT, T_SCL_PORT, T_SCL_TRIS, T_SDA_BIT, 			\
						T_SDA_PORT, T_SDA_TRIS, T_i2c_SSPCON1, T_i2c_SSPCON2, 	\
						T_i2c_SSPSTAT, T_i2c_SSPBUF, T_i2c_SSPIF_BIT, 			\
						T_i2c_SSPIF_PIR, T_i2c_BCLIF_BIT, T_i2c_BCLIF_PIR,		\
						T_i2c_SMP_BIT, T_i2c_SSPADD, T_MODE

////////////////////////////////////////////////////////////////////////////
// Helpers that hide template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_init	i2c_INIT<i2c_ARGS>
#define i2c_start	i2c_START<i2c_ARGS>
#define i2c_restart	i2c_RESTART<i2c_ARGS>
#define i2c_stop	i2c_STOP<i2c_ARGS>
#define i2c_read	i2c_READ<i2c_ARGS>
#define i2c_write	i2c_WRITE<i2c_ARGS>


////////////////////////////////////////////////////////////////////////////
// I2C Control Status Bits - Emulates the PIC18F hardware I2C implementation
////////////////////////////////////////////////////////////////////////////
// define I2C i2C_SSPCON1 control bits
#define	i2c_WCOL	7
#define	i2c_SSPOV	6
#define	i2c_SSPEN	5
#define	i2c_CKP		4
#define	i2c_SSPM3	3
#define	i2c_SSPM2	2
#define	i2c_SSPM1	1
#define	i2c_SSPM0	0

// define I2C SSPCON2 control bits
#define	i2c_GCEN 	7
#define	i2c_ACKSTAT	6
#define	i2c_ACKDT	5
#define	i2c_ACKEN	4
#define	i2c_RCEN	3
#define	i2c_PEN		2
#define	i2c_RSEN	1
#define	i2c_SEN		0

// define I2C SSPSTAT status bits
#define	i2c_DA		5
#define	i2c_P		4
#define	i2c_S		3
#define	i2c_RW		2
#define	i2c_UA		1
#define	i2c_BF		0


////////////////////////////////////////////////////////////////////////////
// I2C Control Flag Bits
////////////////////////////////////////////////////////////////////////////
// define I2C Mode bits
#define	i2c_HW			0x01
#define	i2c_400KHz		0x02	// 100KHz or 400KHz I2C clock (set = 400KHz)
#define	i2c_reset_wdt	0x04
#define i2c_SMP			0x80	


////////////////////////////////////////////////////////////////////////////
// I2C software constants
////////////////////////////////////////////////////////////////////////////
#define	dly 10	// number of 1us delay increments



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Start Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL 
void i2c_START(void)

{
	// Initiate the I2C START condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	delay_us(dly);
010E  300A  	MOVLW 0x0A
010F  1283  	BCF STATUS, RP0
0110  1303  	BCF STATUS, RP1
0111  00F2  	MOVWF delay_us_00000_arg_del
0112  2010  	CALL delay_us_00000

	l_bclif = 0; // initialise the collision flag for this command
0113  11C6  	BCF i2c_START_00000_1_l_bclif,3

	l_sspif = 0;
0114  11C5  	BCF i2c_START_00000_1_l_sspif,3

		
	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
			
		l_sen = 1; // initiate START condition	

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation			
		l_sen = 1; // initiate START condition
0115  1441  	BSF i2c_START_00000_1_l_sen,0

		l_scl_tris = 1; // ensure the SCL line is high
0116  1683  	BSF STATUS, RP0
0117  1587  	BSF i2c_START_00000_1_l_scl_tris,3

		l_sda_tris = 1; // ensure the SDA line is high	
0118  1607  	BSF i2c_START_00000_1_l_sda_tris,4

		l_scl = 0; // prepare to set SCL line low
0119  1283  	BCF STATUS, RP0
011A  1187  	BCF i2c_START_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low
011B  1207  	BCF i2c_START_00000_1_l_sda,4

		
		if (l_scl && l_sda)
011C  1D87  	BTFSS i2c_START_00000_1_l_scl,3
011D  293B  	GOTO	label23
011E  1E07  	BTFSS i2c_START_00000_1_l_sda,4
011F  293B  	GOTO	label23
013B        label23

		{
			// good sign - no collision detected
			delay_us(dly);
0120  300A  	MOVLW 0x0A
0121  00F2  	MOVWF delay_us_00000_arg_del
0122  2010  	CALL delay_us_00000

			
			if (!l_scl) // ensure the clock is still high
0123  1987  	BTFSC i2c_START_00000_1_l_scl,3
0124  2929  	GOTO	label22
0129        label22

			{
				l_bclif = 1;
0125  15C6  	BSF i2c_START_00000_1_l_bclif,3

				l_s = 1;
0126  15C2  	BSF i2c_START_00000_1_l_s,3

				l_sen = 0;
0127  1041  	BCF i2c_START_00000_1_l_sen,0

				return;
			}
					
			l_sda = 0; // prepare to set SDA line low
0129  1207  	BCF i2c_START_00000_1_l_sda,4

			l_sda_tris = 0; // SDA to output (driven low)
012A  1683  	BSF STATUS, RP0
012B  1207  	BCF i2c_START_00000_1_l_sda_tris,4


			delay_us(dly);					
012C  300A  	MOVLW 0x0A
012D  1283  	BCF STATUS, RP0
012E  00F2  	MOVWF delay_us_00000_arg_del
012F  2010  	CALL delay_us_00000

			l_scl = 0; // prepare to set SCL line low
0130  1187  	BCF i2c_START_00000_1_l_scl,3

			l_scl_tris = 0; // SCL to output (driven low)
0131  1683  	BSF STATUS, RP0
0132  1187  	BCF i2c_START_00000_1_l_scl_tris,3


			delay_us(dly);					
0133  300A  	MOVLW 0x0A
0134  1283  	BCF STATUS, RP0
0135  00F2  	MOVWF delay_us_00000_arg_del
0136  2010  	CALL delay_us_00000

			l_s = 1; // set 'S' bit flag (start bit detected)
0137  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0; // clear flag
0138  1041  	BCF i2c_START_00000_1_l_sen,0

			l_sspif = 1; // flag end of start condition interrupt	
0139  15C5  	BSF i2c_START_00000_1_l_sspif,3

		}
		else
		{
			// here is SDA or SCL are low at the start - indicates a bus collision
			l_bclif = 1;
013B  15C6  	BSF i2c_START_00000_1_l_bclif,3

			l_s = 1; // set 'S' bit flag (start bit detected)
013C  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0;
013D  1041  	BCF i2c_START_00000_1_l_sen,0

			l_rsen = 0;
013E  10C1  	BCF i2c_START_00000_1_l_rsen,1

			l_pen = 0;
013F  1141  	BCF i2c_START_00000_1_l_pen,2

			l_rcen = 0;								
0140  11C1  	BCF i2c_START_00000_1_l_rcen,3

			l_acken = 0;			
0141  1241  	BCF i2c_START_00000_1_l_acken,4

		}
	}
}
0128  0008  	RETURN
013A  0008  	RETURN
0142  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Restart Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_RESTART(void)
{
	// Initiate the I2C RESTART condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
			
	delay_us(dly);
	l_bclif = 0; // initialise the collision flag for this command
	l_sspif = 0;

	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_rsen = 1; // initiate RESTART condition
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation	
		l_rsen = 1;
		l_scl = 0;
		l_sda = 0;
		
		if (!l_scl)
		{
			// good sign - no other I2C activity in progress
			l_sda_tris = 1; // float SDA line high	(should already be in this condition)	
			delay_us(dly);
		
			// about to float the clock line
			// ensure the data line is still high
			if (!l_sda)
			{
				// problem - SDA is low, a bus collision has occurred				
				l_bclif = 1; // set the bus collision flag	
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_scl_tris = 1; // float SCL line (high)	
				return;
			}
												
			l_scl_tris = 1; // float SCL line (high)

			// wait until any clock stretching has finished
			while (!l_scl)
				if (T_MODE & i2c_reset_wdt)
					clear_wdt();	
			delay_us(dly);
			
			// here we are about to drive SDA low
			// first ensure SCL is still high
			if (!l_scl)
			{
				// problem - SCL is low, a bus collision has occurred
				l_bclif = 1; // set the bus collision flag
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_sda_tris = 1; // float SDA line (high)
				return;
			}
				
			l_sda_tris = 0; // drive SDA low
			l_s = 1; // set 'S' bit flag (start bit detected)

			delay_us(dly);
			l_scl_tris = 0; // drive SCL low
			l_rsen = 0;
			l_pen = 0;
			l_sen = 0;			
			l_rcen = 0;								
			l_acken = 0;			
			l_sspif = 1; // flag end of start condition interrupt
		}
		else
		{
			// SCL is high at the start
			// some other I2C activity in progress		
			l_rsen = 0; // clear flag
			// exit without further action
		}
	}
}



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Stop Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_STOP(void)

{ 
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_p@T_i2c_SSPSTAT.i2c_P; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;

	l_bclif = 0; // initialise the collision flag for this command
00DE  1283  	BCF STATUS, RP0
00DF  1303  	BCF STATUS, RP1
00E0  11C6  	BCF i2c_STOP_00000_1_l_bclif,3

	l_sspif = 0;
00E1  11C5  	BCF i2c_STOP_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_pen = 1; // initiate STOP condition on the I2C bus	
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
		
	}
	else
	{
		//	Software I2C implementation
		l_pen = 1; // initiate STOP condition on the I2C bus
00E2  1541  	BSF i2c_STOP_00000_1_l_pen,2

		delay_us(dly);
00E3  300A  	MOVLW 0x0A
00E4  00F2  	MOVWF delay_us_00000_arg_del
00E5  2010  	CALL delay_us_00000

		
		l_scl = 0; // prepare to set SCL line low
00E6  1187  	BCF i2c_STOP_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low
00E7  1207  	BCF i2c_STOP_00000_1_l_sda,4

		l_scl_tris = 0; // drive SCL line low (should already be low)
00E8  1683  	BSF STATUS, RP0
00E9  1187  	BCF i2c_STOP_00000_1_l_scl_tris,3

		l_sda_tris = 0; // drive SDA line low
00EA  1207  	BCF i2c_STOP_00000_1_l_sda_tris,4


		delay_us(dly);		
00EB  300A  	MOVLW 0x0A
00EC  1283  	BCF STATUS, RP0
00ED  00F2  	MOVWF delay_us_00000_arg_del
00EE  2010  	CALL delay_us_00000

		l_scl_tris = 1; // float SCL line (high)
00EF  1683  	BSF STATUS, RP0
00F0  1587  	BSF i2c_STOP_00000_1_l_scl_tris,3

		
		// wait until any clock stretching has finished
		while (!l_scl)
00F1        label18
00F1  1283  	BCF STATUS, RP0
00F2  1987  	BTFSC i2c_STOP_00000_1_l_scl,3
00F3  28F6  	GOTO	label19
00F5  28F1  	GOTO	label18
00F6        label19

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
00F4  0064  	CLRWDT

						
		delay_us(dly);
00F6  300A  	MOVLW 0x0A
00F7  00F2  	MOVWF delay_us_00000_arg_del
00F8  2010  	CALL delay_us_00000

		l_sda_tris = 1; // float SDA line
00F9  1683  	BSF STATUS, RP0
00FA  1607  	BSF i2c_STOP_00000_1_l_sda_tris,4

		delay_us(dly);		
00FB  300A  	MOVLW 0x0A
00FC  1283  	BCF STATUS, RP0
00FD  00F2  	MOVWF delay_us_00000_arg_del
00FE  2010  	CALL delay_us_00000

		
		// here the SDA line should be high - if not a collision has occurred				
		if (!l_sda || !l_scl)
00FF  1E07  	BTFSS i2c_STOP_00000_1_l_sda,4
0100  2903  	GOTO	label20
0101  1987  	BTFSC i2c_STOP_00000_1_l_scl,3
0102  2907  	GOTO	label21
0103        label20
0107        label21

		{
			// problem - SDA or SCL is low, a bus collision has occurred
			l_bclif = 1; // set the bus collision flag	
0103  15C6  	BSF i2c_STOP_00000_1_l_bclif,3

			l_s = 0; // clear 'S' bit flag
0104  11C2  	BCF i2c_STOP_00000_1_l_s,3

			l_pen = 0; // clear flag
0105  1141  	BCF i2c_STOP_00000_1_l_pen,2

		}
		else
		{		
			l_p = 1;
0107  1642  	BSF i2c_STOP_00000_1_l_p,4

			l_pen = 0;
0108  1141  	BCF i2c_STOP_00000_1_l_pen,2

			l_sen = 0;
0109  1041  	BCF i2c_STOP_00000_1_l_sen,0

			l_rsen = 0;			
010A  10C1  	BCF i2c_STOP_00000_1_l_rsen,1

			l_rcen = 0;								
010B  11C1  	BCF i2c_STOP_00000_1_l_rcen,3

			l_acken = 0;
010C  1241  	BCF i2c_STOP_00000_1_l_acken,4

		}
	}
}
0106  0008  	RETURN
010D  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Write Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_WRITE(unsigned char i2c_data)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;	
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
	
	char BitMask;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
008D  11C6  	BCF i2c_WRITE_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
008E  11C5  	BCF i2c_WRITE_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
				
		l_wcol = 0; // clear write collision flag	
		i2c_SSPBUF = i2c_data;

		// test if a write collision occurred
		if (l_wcol)
			return (1); // error exit	

		// wait until MSSP Tx register is empty
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
								
		return (0); // successful exit
	}

	// here for i2c software driver
	l_wcol = 0; // clear write collision flag	
008F  13C0  	BCF i2c_WRITE_00000_1_l_wcol,7

	i2c_SSPBUF = i2c_data;
0090  086F  	MOVF i2c_WRITE_00000_arg_i2c_data, W
0091  00C4  	MOVWF i2c_WRITE_00000_1_i2c_SSPBUF

	
	l_scl = 0; // prepare to set SCL line low
0092  1187  	BCF i2c_WRITE_00000_1_l_scl,3

	l_sda = 0; // prepare to set SDA line low
0093  1207  	BCF i2c_WRITE_00000_1_l_sda,4

	l_rw = 0; // signal we are doing a write
0094  1142  	BCF i2c_WRITE_00000_1_l_rw,2


	for (BitMask = 0x80; BitMask; BitMask>>=1)
0095  3080  	MOVLW 0x80
0096  00F0  	MOVWF i2c_WRITE_00000_1_BitMask
0097        label10
0097  08F0  	MOVF i2c_WRITE_00000_1_BitMask, F
0098  1903  	BTFSC STATUS,Z
0099  28BA  	GOTO	label15
00B7  1003  	BCF STATUS,C
00B8  0CF0  	RRF i2c_WRITE_00000_1_BitMask, F
00B9  2897  	GOTO	label10
00BA        label15

	{
		if (i2c_data & BitMask)
009A  0870  	MOVF i2c_WRITE_00000_1_BitMask, W
009B  056F  	ANDWF i2c_WRITE_00000_arg_i2c_data, W
009C  1903  	BTFSC STATUS,Z
009D  28A1  	GOTO	label11
00A1        label11

			l_sda_tris = 1; // float SDA high	
009E  1683  	BSF STATUS, RP0
009F  1607  	BSF i2c_WRITE_00000_1_l_sda_tris,4

		else
00A0  28A3  	GOTO	label12
00A3        label12

			l_sda_tris = 0; // drive SDA low
00A1  1683  	BSF STATUS, RP0
00A2  1207  	BCF i2c_WRITE_00000_1_l_sda_tris,4

		delay_us(dly);
00A3  300A  	MOVLW 0x0A
00A4  1283  	BCF STATUS, RP0
00A5  00F2  	MOVWF delay_us_00000_arg_del
00A6  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
00A7  1683  	BSF STATUS, RP0
00A8  1587  	BSF i2c_WRITE_00000_1_l_scl_tris,3


		// wait until any clock stretching has finished
		while (!l_scl)
00A9        label13
00A9  1283  	BCF STATUS, RP0
00AA  1987  	BTFSC i2c_WRITE_00000_1_l_scl,3
00AB  28AE  	GOTO	label14
00AD  28A9  	GOTO	label13
00AE        label14

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
00AC  0064  	CLRWDT

		delay_us(dly);
00AE  300A  	MOVLW 0x0A
00AF  00F2  	MOVWF delay_us_00000_arg_del
00B0  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low	
00B1  1683  	BSF STATUS, RP0
00B2  1187  	BCF i2c_WRITE_00000_1_l_scl_tris,3

		delay_us(dly);
00B3  300A  	MOVLW 0x0A
00B4  1283  	BCF STATUS, RP0
00B5  00F2  	MOVWF delay_us_00000_arg_del
00B6  2010  	CALL delay_us_00000

	}
	// serialized out the data
	// now get the status		
	// set SSPIF
	l_sspif = 1;
00BA  15C5  	BSF i2c_WRITE_00000_1_l_sspif,3

	l_acken = 1;
00BB  1641  	BSF i2c_WRITE_00000_1_l_acken,4

	l_ackdt = 0;
00BC  12C1  	BCF i2c_WRITE_00000_1_l_ackdt,5

	l_sda_tris = 1; // float SDA high
00BD  1683  	BSF STATUS, RP0
00BE  1607  	BSF i2c_WRITE_00000_1_l_sda_tris,4

	
	delay_us(dly);
00BF  300A  	MOVLW 0x0A
00C0  1283  	BCF STATUS, RP0
00C1  00F2  	MOVWF delay_us_00000_arg_del
00C2  2010  	CALL delay_us_00000

	
	l_scl_tris = 1; // float SCL high
00C3  1683  	BSF STATUS, RP0
00C4  1587  	BSF i2c_WRITE_00000_1_l_scl_tris,3

	
	// wait until any clock stretching has finished
	while (!l_scl)
00C5        label16
00C5  1283  	BCF STATUS, RP0
00C6  1987  	BTFSC i2c_WRITE_00000_1_l_scl,3
00C7  28CA  	GOTO	label17
00C9  28C5  	GOTO	label16
00CA        label17

		if (T_MODE & i2c_reset_wdt)
			clear_wdt();	
00C8  0064  	CLRWDT

	delay_us(dly);
00CA  300A  	MOVLW 0x0A
00CB  00F2  	MOVWF delay_us_00000_arg_del
00CC  2010  	CALL delay_us_00000


	// get the status bit
	local_ack = l_sda;
00CD  1071  	BCF i2c_WRITE_00000_1_local_ack,0
00CE  1A07  	BTFSC i2c_WRITE_00000_1_l_sda,4
00CF  1471  	BSF i2c_WRITE_00000_1_local_ack,0

	delay_us(dly);
00D0  300A  	MOVLW 0x0A
00D1  00F2  	MOVWF delay_us_00000_arg_del
00D2  2010  	CALL delay_us_00000


	l_scl_tris = 0; // drive SCL low	
00D3  1683  	BSF STATUS, RP0
00D4  1187  	BCF i2c_WRITE_00000_1_l_scl_tris,3

	l_acken = 0;
00D5  1283  	BCF STATUS, RP0
00D6  1241  	BCF i2c_WRITE_00000_1_l_acken,4

	delay_us(dly);
00D7  300A  	MOVLW 0x0A
00D8  00F2  	MOVWF delay_us_00000_arg_del
00D9  2010  	CALL delay_us_00000

	return(local_ack);
00DA  01F2  	CLRF CompTempVarRet552
00DB  1871  	BTFSC i2c_WRITE_00000_1_local_ack,0
00DC  0AF2  	INCF CompTempVarRet552, F

}
00DD  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Read Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_READ(char ack_status)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	char BitMask;
	char i2c_data;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
0172  11C6  	BCF i2c_READ_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
0173  11C5  	BCF i2c_READ_00000_1_l_sspif,3

	l_wcol = 0; // clear write collision flag	
0174  13C0  	BCF i2c_READ_00000_1_l_wcol,7


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// enable master for 1 byte reception	
		l_rcen = 1;

		// wait until byte received
		while(!l_sspif || !l_bf)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// read the byte from the Rx register
		i2c_data = i2c_SSPBUF;			
			
		// wait until the bus is idle		
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		if (ack_status)
			l_ackdt = 1; // preset ack bit
		else
			l_ackdt = 0; // preset ack bit

		l_sspif = 0;
		l_acken = 1; // acknowledge sequence enable

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();								
	}
	else
	{
		// here for i2c software driver
		l_rcen = 1;
0175  15C1  	BSF i2c_READ_00000_1_l_rcen,3

		l_ackdt = ack_status;
0176  186F  	BTFSC i2c_READ_00000_arg_ack_status,0
0177  16C1  	BSF i2c_READ_00000_1_l_ackdt,5
0178  1C6F  	BTFSS i2c_READ_00000_arg_ack_status,0
0179  12C1  	BCF i2c_READ_00000_1_l_ackdt,5

		l_rw = 1;
017A  1542  	BSF i2c_READ_00000_1_l_rw,2

		l_scl = 0; // prepare to set SCL line low
017B  1187  	BCF i2c_READ_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low	
017C  1207  	BCF i2c_READ_00000_1_l_sda,4


		// prepare to serialize in the byte
		l_sda_tris = 1; // float SDA
017D  1683  	BSF STATUS, RP0
017E  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

		delay_us(dly);
017F  300A  	MOVLW 0x0A
0180  1283  	BCF STATUS, RP0
0181  00F2  	MOVWF delay_us_00000_arg_del
0182  2010  	CALL delay_us_00000

		i2c_data = 0;
0183  01F1  	CLRF i2c_READ_00000_1_i2c_data

		for (BitMask = 0x80; BitMask; BitMask>>=1)
0184  3080  	MOVLW 0x80
0185  00F0  	MOVWF i2c_READ_00000_1_BitMask
0186        label27
0186  08F0  	MOVF i2c_READ_00000_1_BitMask, F
0187  1903  	BTFSC STATUS,Z
0188  29A3  	GOTO	label31
01A0  1003  	BCF STATUS,C
01A1  0CF0  	RRF i2c_READ_00000_1_BitMask, F
01A2  2986  	GOTO	label27
01A3        label31

		{
			l_scl_tris = 1; // float SCL high
0189  1683  	BSF STATUS, RP0
018A  1587  	BSF i2c_READ_00000_1_l_scl_tris,3

			// wait until any clock stretching has finished
			while (!l_scl)
018B        label28
018B  1283  	BCF STATUS, RP0
018C  1987  	BTFSC i2c_READ_00000_1_l_scl,3
018D  2990  	GOTO	label29
018F  298B  	GOTO	label28
0190        label29

				if (T_MODE & i2c_reset_wdt)
					clear_wdt();		
018E  0064  	CLRWDT

			delay_us(dly);
0190  300A  	MOVLW 0x0A
0191  00F2  	MOVWF delay_us_00000_arg_del
0192  2010  	CALL delay_us_00000


			// read the current bit
			l_sda_tris = 1; // float SDA
0193  1683  	BSF STATUS, RP0
0194  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

			if (l_sda)
0195  1283  	BCF STATUS, RP0
0196  1E07  	BTFSS i2c_READ_00000_1_l_sda,4
0197  299A  	GOTO	label30
019A        label30

				i2c_data |= BitMask;
0198  0870  	MOVF i2c_READ_00000_1_BitMask, W
0199  04F1  	IORWF i2c_READ_00000_1_i2c_data, F

			l_scl_tris = 0; // drive SCL low
019A  1683  	BSF STATUS, RP0
019B  1187  	BCF i2c_READ_00000_1_l_scl_tris,3

			delay_us(dly);
019C  300A  	MOVLW 0x0A
019D  1283  	BCF STATUS, RP0
019E  00F2  	MOVWF delay_us_00000_arg_del
019F  2010  	CALL delay_us_00000

		}
		// flag receive complete			
		l_sspif = 1;
01A3  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		l_rcen = 0;
01A4  11C1  	BCF i2c_READ_00000_1_l_rcen,3

		
		// set the ACK state
		if (ack_status)	
01A5  08EF  	MOVF i2c_READ_00000_arg_ack_status, F
01A6  1903  	BTFSC STATUS,Z
01A7  29AB  	GOTO	label32
01AB        label32

			l_sda_tris = 1; // float SDA high
01A8  1683  	BSF STATUS, RP0
01A9  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

		else
01AA  29AD  	GOTO	label33
01AD        label33

			l_sda_tris = 0; // drive SDA low
01AB  1683  	BSF STATUS, RP0
01AC  1207  	BCF i2c_READ_00000_1_l_sda_tris,4

		delay_us(dly);
01AD  300A  	MOVLW 0x0A
01AE  1283  	BCF STATUS, RP0
01AF  00F2  	MOVWF delay_us_00000_arg_del
01B0  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
01B1  1683  	BSF STATUS, RP0
01B2  1587  	BSF i2c_READ_00000_1_l_scl_tris,3


		// wait until any clock stretching has finished
		while (!l_scl)
01B3        label34
01B3  1283  	BCF STATUS, RP0
01B4  1987  	BTFSC i2c_READ_00000_1_l_scl,3
01B5  29B8  	GOTO	label35
01B7  29B3  	GOTO	label34
01B8        label35

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
01B6  0064  	CLRWDT

	
		l_sspif = 0; // clear SSPIF
01B8  11C5  	BCF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
01B9  300A  	MOVLW 0x0A
01BA  00F2  	MOVWF delay_us_00000_arg_del
01BB  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low		
01BC  1683  	BSF STATUS, RP0
01BD  1187  	BCF i2c_READ_00000_1_l_scl_tris,3

		l_sspif = 1;
01BE  1283  	BCF STATUS, RP0
01BF  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
01C0  300A  	MOVLW 0x0A
01C1  00F2  	MOVWF delay_us_00000_arg_del
01C2  2010  	CALL delay_us_00000

	}
	return(i2c_data);
01C3  0871  	MOVF i2c_READ_00000_1_i2c_data, W
01C4  00F2  	MOVWF CompTempVarRet553

}
01C5  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Initialization
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_INIT(unsigned char i2c_divisor)

{
	volatile unsigned char i2c_SSPADD@T_i2c_SSPADD, i2c_SSPSTAT@T_i2c_SSPSTAT;
	volatile unsigned char i2c_SSPCON1@T_i2c_SSPCON1,i2c_SSPCON2@T_i2c_SSPCON2;

	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_sspen@T_i2c_SSPCON1.i2c_SSPEN, l_smp@T_i2c_SSPSTAT.T_i2c_SMP_BIT;

	l_sda_tris = 1;
03CF  1683  	BSF STATUS, RP0
03D0  1607  	BSF i2c_INIT_00000_1_l_sda_tris,4

	l_scl_tris = 1;
03D1  1587  	BSF i2c_INIT_00000_1_l_scl_tris,3

	
	i2c_SSPCON1 = 0x00; // initialise the I2C control register (mirrors HW SSPCON1)	
03D2  1283  	BCF STATUS, RP0
03D3  01C0  	CLRF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPADD = i2c_divisor; // get the I2C baud rate divisor
03D4  086D  	MOVF i2c_INIT_00000_arg_i2c_divisor, W
03D5  00C3  	MOVWF i2c_INIT_00000_1_i2c_SSPADD

	i2c_SSPCON1 = 0x08; // initialise the I2C control register (mirrors HW SSPCON1)	
03D6  3008  	MOVLW 0x08
03D7  00C0  	MOVWF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPCON2 = 0x00; // initialise the I2C control register (mirrors HW SSPCON2)	
03D8  01C1  	CLRF i2c_INIT_00000_1_i2c_SSPCON2

	
	i2c_SSPSTAT = 0x00; // initialise the I2C status register (mirrors HW SSPSTAT)
03D9  01C2  	CLRF i2c_INIT_00000_1_i2c_SSPSTAT

	
	if (T_MODE & i2c_SMP)
		l_smp = 1;
03DA  17C2  	BSF i2c_INIT_00000_1_l_smp,7


	l_sspif = 0; // initialise the I2C SSP interrupt status
03DB  11C5  	BCF i2c_INIT_00000_1_l_sspif,3

	l_bclif = 0; // initialise the I2C BCL interrupt status
03DC  11C6  	BCF i2c_INIT_00000_1_l_bclif,3

	l_sda = 0;
03DD  1207  	BCF i2c_INIT_00000_1_l_sda,4

	l_scl = 0;
03DE  1187  	BCF i2c_INIT_00000_1_l_scl,3

	l_sspen = 1; // enable I2C
03DF  16C0  	BSF i2c_INIT_00000_1_l_sspen,5

	
	i2c_STOP<_I2C_TEMPL_ARGS>();
03E0  20DE  	CALL i2c_STOP_00000

}
03E1  0008  	RETURN







////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  2FE1  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B0  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00B1  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00B2  	MOVWF Int1BContext+D'2'
000D  158A  	BSF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2843  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010  3003  	MOVLW 0x03
0011  07F2  	ADDWF delay_us_00000_arg_del, F
0012  0CF2  	RRF delay_us_00000_arg_del, F
0013  0CF2  	RRF delay_us_00000_arg_del, F
0014  307F  	MOVLW 0x7F
0015  05F2  	ANDWF delay_us_00000_arg_del, F
0016        label1
0016  0000  	NOP
0017  0BF2  	DECFSZ delay_us_00000_arg_del, F
0018  2816  	GOTO	label1
0019  0008  	RETURN
001A        ; } delay_us function end

001A        delay_10us_00000
001A        ; { delay_10us ; function begin
001A        label2
001A  0000  	NOP
001B  0000  	NOP
001C  0000  	NOP
001D  0000  	NOP
001E  0000  	NOP
001F  0000  	NOP
0020  0000  	NOP
0021  0BF2  	DECFSZ delay_10us_00000_arg_del, F
0022  281A  	GOTO	label2
0023  0008  	RETURN
0024        ; } delay_10us function end

0024        __rom_get_00000
0024        ; { __rom_get ; function begin
0024  0874  	MOVF __rom_get_00000_arg_objNumb, W
0025  00F7  	MOVWF __rom_get_00000_1_romAddr+D'1'
0026  01F6  	CLRF __rom_get_00000_1_romAddr
0027  1003  	BCF STATUS,C
0028  0DF7  	RLF __rom_get_00000_1_romAddr+D'1', F
0029  0DF6  	RLF __rom_get_00000_1_romAddr, F
002A  0DF7  	RLF __rom_get_00000_1_romAddr+D'1', F
002B  0DF6  	RLF __rom_get_00000_1_romAddr, F
002C  07F7  	ADDWF __rom_get_00000_1_romAddr+D'1', F
002D  1803  	BTFSC STATUS,C
002E  0AF6  	INCF __rom_get_00000_1_romAddr, F
002F  07F7  	ADDWF __rom_get_00000_1_romAddr+D'1', F
0030  1803  	BTFSC STATUS,C
0031  0AF6  	INCF __rom_get_00000_1_romAddr, F
0032  303D  	MOVLW	LOW( label3 )
0033  07F7  	ADDWF __rom_get_00000_1_romAddr+D'1', F
0034  1803  	BTFSC STATUS,C
0035  0AF6  	INCF __rom_get_00000_1_romAddr, F
0036  3000  	MOVLW	HIGH( label3 )
0037  0776  	ADDWF __rom_get_00000_1_romAddr, W
0038  008A  	MOVWF PCLATH
0039  0875  	MOVF __rom_get_00000_arg_idx, W
003A  00F6  	MOVWF __rom_get_00000_1_romAddr
003B  0877  	MOVF __rom_get_00000_1_romAddr+D'1', W
003C  0082  	MOVWF PCL
003D        label3
003D  3000  	MOVLW	HIGH( label4 )
003E  008A  	MOVWF PCLATH
003F  3000  	MOVLW	HIGH( label5 )
0040  00F7  	MOVWF __rom_get_00000_1_romAddr+D'1'
0041  3053  	MOVLW	LOW( label5 )
0042  284C  	GOTO	label4
0043  3000  	MOVLW	HIGH( label4 )
0044  008A  	MOVWF PCLATH
0045  3000  	MOVLW	HIGH( label6 )
0046  00F7  	MOVWF __rom_get_00000_1_romAddr+D'1'
0047  305F  	MOVLW	LOW( label6 )
0048  284C  	GOTO	label4
0049  3000  	MOVLW	HIGH( label7 )
004A  00F7  	MOVWF __rom_get_00000_1_romAddr+D'1'
004B  3077  	MOVLW	LOW( label7 )
004C        label4
004C  07F6  	ADDWF __rom_get_00000_1_romAddr, F
004D  1803  	BTFSC STATUS,C
004E  0AF7  	INCF __rom_get_00000_1_romAddr+D'1', F
004F  0877  	MOVF __rom_get_00000_1_romAddr+D'1', W
0050  008A  	MOVWF PCLATH
0051  0876  	MOVF __rom_get_00000_1_romAddr, W
0052  0082  	MOVWF PCL
0053        label5
0053  3431  	RETLW 0x31
0054  3428  	RETLW 0x28
0055  3431  	RETLW 0x31
0056  3430  	RETLW 0x30
0057  3431  	RETLW 0x31
0058  3430  	RETLW 0x30
0059  3431  	RETLW 0x31
005A  3431  	RETLW 0x31
005B  3430  	RETLW 0x30
005C  3431  	RETLW 0x31
005D  3430  	RETLW 0x30
005E  3431  	RETLW 0x31
005F        label6
005F  3404  	RETLW 0x04
0060  3408  	RETLW 0x08
0061  3412  	RETLW 0x12
0062  3416  	RETLW 0x16
0063  3420  	RETLW 0x20
0064  3424  	RETLW 0x24
0065  3428  	RETLW 0x28
0066  3432  	RETLW 0x32
0067  3436  	RETLW 0x36
0068  3440  	RETLW 0x40
0069  3444  	RETLW 0x44
006A  3448  	RETLW 0x48
006B  3452  	RETLW 0x52
006C  3456  	RETLW 0x56
006D  3460  	RETLW 0x60
006E  3464  	RETLW 0x64
006F  3468  	RETLW 0x68
0070  3472  	RETLW 0x72
0071  3476  	RETLW 0x76
0072  3480  	RETLW 0x80
0073  3484  	RETLW 0x84
0074  3488  	RETLW 0x88
0075  3492  	RETLW 0x92
0076  3496  	RETLW 0x96
0077        label7
0077  343F  	RETLW 0x3F
0078  3406  	RETLW 0x06
0079  345B  	RETLW 0x5B
007A  344F  	RETLW 0x4F
007B  3466  	RETLW 0x66
007C  346D  	RETLW 0x6D
007D  347D  	RETLW 0x7D
007E  3407  	RETLW 0x07
007F  347F  	RETLW 0x7F
0080  346F  	RETLW 0x6F
0081        ; } __rom_get function end

0081        delay_ms_00000
0081        ; { delay_ms ; function begin
0081  08EC  	MOVF delay_ms_00000_arg_del, F
0082  1D03  	BTFSS STATUS,Z
0083  2885  	GOTO	label8
0084  0008  	RETURN
0085        label8
0085  30F9  	MOVLW 0xF9
0086        label9
0086  3EFF  	ADDLW 0xFF
0087  1D03  	BTFSS STATUS,Z
0088  2886  	GOTO	label9
0089  0000  	NOP
008A  0BEC  	DECFSZ delay_ms_00000_arg_del, F
008B  2885  	GOTO	label8
008C  0008  	RETURN
008D        ; } delay_ms function end





















05B0        __mul_16s__0000F
05B0        ; { __mul_16s_16s__16 ; function begin
05B0  01FA  	CLRF __mul_16s__0000F_1_i
05B1  01FD  	CLRF CompTempVarRet389
05B2  01FE  	CLRF CompTempVarRet389+D'1'
05B3  0876  	MOVF __mul_16s__0000F_arg_a, W
05B4  00FB  	MOVWF __mul_16s__0000F_1_t
05B5  0877  	MOVF __mul_16s__0000F_arg_a+D'1', W
05B6  00FC  	MOVWF __mul_16s__0000F_1_t+D'1'
05B7  1FF9  	BTFSS __mul_16s__0000F_arg_b+D'1',7
05B8  2DBF  	GOTO	label103
05B9  17FA  	BSF __mul_16s__0000F_1_i,7
05BA  09F8  	COMF __mul_16s__0000F_arg_b, F
05BB  09F9  	COMF __mul_16s__0000F_arg_b+D'1', F
05BC  0AF8  	INCF __mul_16s__0000F_arg_b, F
05BD  1903  	BTFSC gbl_status,2
05BE  0AF9  	INCF __mul_16s__0000F_arg_b+D'1', F
05BF        label103
05BF  1A7A  	BTFSC __mul_16s__0000F_1_i,4
05C0  2DD1  	GOTO	label105
05C1  1C78  	BTFSS __mul_16s__0000F_arg_b,0
05C2  2DC9  	GOTO	label104
05C3  087B  	MOVF __mul_16s__0000F_1_t, W
05C4  07FD  	ADDWF CompTempVarRet389, F
05C5  087C  	MOVF __mul_16s__0000F_1_t+D'1', W
05C6  1803  	BTFSC gbl_status,0
05C7  0F7C  	INCFSZ __mul_16s__0000F_1_t+D'1', W
05C8  07FE  	ADDWF CompTempVarRet389+D'1', F
05C9        label104
05C9  1003  	BCF gbl_status,0
05CA  0CF9  	RRF __mul_16s__0000F_arg_b+D'1', F
05CB  0CF8  	RRF __mul_16s__0000F_arg_b, F
05CC  1003  	BCF gbl_status,0
05CD  0DFB  	RLF __mul_16s__0000F_1_t, F
05CE  0DFC  	RLF __mul_16s__0000F_1_t+D'1', F
05CF  0AFA  	INCF __mul_16s__0000F_1_i, F
05D0  2DBF  	GOTO	label103
05D1        label105
05D1  1FFA  	BTFSS __mul_16s__0000F_1_i,7
05D2  0008  	RETURN
05D3  09FD  	COMF CompTempVarRet389, F
05D4  09FE  	COMF CompTempVarRet389+D'1', F
05D5  0AFD  	INCF CompTempVarRet389, F
05D6  1903  	BTFSC gbl_status,2
05D7  0AFE  	INCF CompTempVarRet389+D'1', F
05D8  0008  	RETURN
05D9        ; } __mul_16s_16s__16 function end
























07E1        _startup

0840  118A  	BCF PCLATH,3
0841  120A  	BCF PCLATH,4
0842  2F79  	GOTO	main

2007  3FB1  	DW 0x3FB1
