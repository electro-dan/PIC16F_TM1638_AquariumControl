;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 8.01
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

#ifndef _PIC16F_TM1638_AquariumControl_H_
#define _PIC16F_TM1638_AquariumControl_H_

#define TASK_TIMER0 1
#define TASK_TIMER1 2

#define oneWireBus (portc.5)
#define oneWireTris (trisc.5)
#define tm1638dio (portb.1)
#define tm1638dioTris (trisb.1)
#define tm1638clk (portb.2)
#define tm1638strobe (portb.3)
#define WHITE_LED (portc.1)
#define BLUE_LED (portc.2)
#define FAN (porta.1)
#define HEATER (porta.0)

// Timer 0 preload

#define TMR0PRELOAD 61
// This means timer 1 will overflow when 1 cycle completes, generating the interrupt
#define TMR1HV 0xFF
#define TMR1LV 0xFF

// i2c options
#define use_i2c_SW
// clock SCL on RA3, data SDA on RA4
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)
// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3

#define ds3231Addr 0xD0 // Left shifted 7 bit address 0x68
#define at24c32Addr 0xAE // Left shifted 7 bit address 0x57

// Time and date variables
char gBcdSecond = 0; // 0 to 0x59
09A6  1283  	BCF STATUS, RP0
09A7  1303  	BCF STATUS, RP1
09A8  01B5  	CLRF gbl_gBcdSecond

char gBcdMinute = 0; // 0 to 0x59
09A9  01B6  	CLRF gbl_gBcdMinute

char gBcdHour = 0; // 0 to 0x23 or 1 to 0x12. Also contains 12/24 setting at bit 6. If 12 hour, AM/PM uses bit 5
09AA  01B7  	CLRF gbl_gBcdHour

char gDayOfWeek = 1; // 1 to 7
09AB  3001  	MOVLW 0x01
09AC  00B8  	MOVWF gbl_gDayOfWeek

char gBcdDayOfMonth = 1; // 1 to 0x31
09AD  3001  	MOVLW 0x01
09AE  00B9  	MOVWF gbl_gBcdDayOfMonth

char gBcdMonth = 1; // 1 to 0x12 + century at bit 7
09AF  3001  	MOVLW 0x01
09B0  00BA  	MOVWF gbl_gBcdMonth

char gBcdYear = 0x23; // Init to 0x23
09B1  3023  	MOVLW 0x23
09B2  00BB  	MOVWF gbl_gBcdYear

rom char *gDaysInMonth = {0x31, 0x28, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31}; // Days in each month
09B3  3000  	MOVLW 0x00
09B4  00BC  	MOVWF gbl_gDaysInMonth

rom char *gLeapYears = {0x04, 0x08, 0x12, 0x16, 0x20, 0x24, 0x28, 0x32, 0x36, 0x40, 0x44, 0x48, 0x52, 0x56, 0x60, 0x64, 0x68, 0x72, 0x76, 0x80, 0x84, 0x88, 0x92, 0x96}; // List of leap years
09B5  3001  	MOVLW 0x01
09B6  00BD  	MOVWF gbl_gLeapYears


// Timer variables
char iTimer0Counts = 0;
09B7  01BE  	CLRF gbl_iTimer0Counts

char iFlashDigitOff = 0;
09B8  01BF  	CLRF gbl_iFlashDigitOff

char iDigitToFlash = 8; // 8 = no digit to flash
09B9  3008  	MOVLW 0x08
09BA  00C8  	MOVWF gbl_iDigitToFlash


// Hold the upper and lower bytes from the ds18b20
char cTempH = 1;
09BB  3001  	MOVLW 0x01
09BC  00C9  	MOVWF gbl_cTempH

char cTempL = 70;
09BD  3046  	MOVLW 0x46
09BE  00CA  	MOVWF gbl_cTempL

//char iDecimalPosition = 2;

int giDS3231ValueBCD = 0x0000;
09BF  01B3  	CLRF gbl_giDS3231ValueBCD
09C0  01B4  	CLRF gbl_giDS3231ValueBCD+D'1'

char giDS3231ValueTruncCBCD = 0x00;
09C1  01CB  	CLRF gbl_giDS3231ValueTruncCBCD

char gbDS3231IsMinus = 0;
09C2  01CC  	CLRF gbl_gbDS3231IsMinus


char cTask = 0; // Used for task scheduler
09C3  01CD  	CLRF gbl_cTask


// States
bool gbWhiteOn = 0;
09C4  104E  	BCF gbl_gbWhiteOn,0

bool gbBlueOn = 0;
09C5  10CE  	BCF gbl_gbBlueOn,1

bool gbFanOn = 0;
09C6  114E  	BCF gbl_gbFanOn,2

bool gbHeaterOn = 0;
09C7  11CE  	BCF gbl_gbHeaterOn,3

bool gbFlashOff = 0;
09C8  124E  	BCF gbl_gbFlashOff,4

char gcDisplayMode = 0;
09C9  01CF  	CLRF gbl_gcDisplayMode

char gcSetMode = 0;
09CA  01D0  	CLRF gbl_gcSetMode

char gcHourMode = 0;
09CB  01D1  	CLRF gbl_gcHourMode

char gcTriggerMode = 0;
09CC  01D2  	CLRF gbl_gcTriggerMode


// Triggers
char gBcdWhiteOnMinute = 0; // 0 to 59
09CD  01D3  	CLRF gbl_gBcdWhiteOnMinute

char gBcdWhiteOnHour = 0; // 0 to 23
09CE  01D4  	CLRF gbl_gBcdWhiteOnHour

char gBcdWhiteOffMinute = 0; // 0 to 59
09CF  01D5  	CLRF gbl_gBcdWhiteOffMinute

char gBcdWhiteOffHour = 0; // 0 to 23
09D0  01D6  	CLRF gbl_gBcdWhiteOffHour


char gBcdBlueOnMinute = 0; // 0 to 59
09D1  01D7  	CLRF gbl_gBcdBlueOnMinute

char gBcdBlueOnHour = 0; // 0 to 23
09D2  01D8  	CLRF gbl_gBcdBlueOnHour

char gBcdBlueOffMinute = 0; // 0 to 59
09D3  01D9  	CLRF gbl_gBcdBlueOffMinute

char gBcdBlueOffHour = 0; // 0 to 23
09D4  01DA  	CLRF gbl_gBcdBlueOffHour


char gBcdBlue2OnMinute = 0; // 0 to 59
09D5  01DB  	CLRF gbl_gBcdBlue2OnMinute

char gBcdBlue2OnHour = 0; // 0 to 23
09D6  01DC  	CLRF gbl_gBcdBlue2OnHour

char gBcdBlue2OffMinute = 0; // 0 to 59
09D7  01DD  	CLRF gbl_gBcdBlue2OffMinute

char gBcdBlue2OffHour = 0; // 0 to 23
09D8  01DE  	CLRF gbl_gBcdBlue2OffHour


char gBcdFanOnTemp = 0x28; // Degrees C
09D9  3028  	MOVLW 0x28
09DA  00DF  	MOVWF gbl_gBcdFanOnTemp

char gBcdFanOffTemp = 0x27; // Degrees C
09DB  3027  	MOVLW 0x27
09DC  00E0  	MOVWF gbl_gBcdFanOffTemp


char gBcdHeaterOnTemp = 0x24; // Degrees C
09DD  3024  	MOVLW 0x24
09DE  00E1  	MOVWF gbl_gBcdHeaterOnTemp

char gBcdHeaterOffTemp = 0x25; // Degrees C
09DF  3025  	MOVLW 0x25
09E0  00E2  	MOVWF gbl_gBcdHeaterOffTemp


// Used to output the segments from numbers
char tm1638MaxDigits = 8;
09E1  3008  	MOVLW 0x08
09E2  00E3  	MOVWF gbl_tm1638MaxDigits

rom char *tm1638DisplayNumtoSeg = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F};
09E3  3002  	MOVLW 0x02
09E4  00E4  	MOVWF gbl_tm1638DisplayNumtoSeg

char tm1638Dot = 0x80;
09E5  3080  	MOVLW 0x80
09E6  00E5  	MOVWF gbl_tm1638Dot

char tm1638Brightness = 7; // 0 to 7
09E7  3007  	MOVLW 0x07
09E8  00E6  	MOVWF gbl_tm1638Brightness

// 0x40 [01000000] = indicate command to display data
char tm1638ByteSetData = 0x40;
09E9  3040  	MOVLW 0x40
09EA  00E7  	MOVWF gbl_tm1638ByteSetData

// 0x42 [01000010] = indicate command to read data
char tm1638ByteReadData = 0x42;
09EB  3042  	MOVLW 0x42
09EC  00E8  	MOVWF gbl_tm1638ByteReadData

// 0xC0 [11000000] = write out all bytes
char tm1638ByteSetAddr = 0xC0;
09ED  30C0  	MOVLW 0xC0
09EE  00E9  	MOVWF gbl_tm1638ByteSetAddr

// 0x88 [10001000] - Display ON, plus brightness
char tm1638ByteSetOn = 0x88;
09EF  3088  	MOVLW 0x88
09F0  00EA  	MOVWF gbl_tm1638ByteSetOn


// Copy of the data to write / on the display
char tm1638Data[] = {0, 0, 0, 0, 0, 0, 0, 0};
09F1  01A0  	CLRF gbl_tm1638Data
09F2  01A1  	CLRF gbl_tm1638Data+D'1'
09F3  01A2  	CLRF gbl_tm1638Data+D'2'
09F4  01A3  	CLRF gbl_tm1638Data+D'3'
09F5  01A4  	CLRF gbl_tm1638Data+D'4'
09F6  01A5  	CLRF gbl_tm1638Data+D'5'
09F7  01A6  	CLRF gbl_tm1638Data+D'6'
09F8  01A7  	CLRF gbl_tm1638Data+D'7'

// Copy of the LED status
char tm1638LEDs[] = {0, 0, 0, 0, 0, 0, 0, 0};
09F9  01A8  	CLRF gbl_tm1638LEDs
09FA  01A9  	CLRF gbl_tm1638LEDs+D'1'
09FB  01AA  	CLRF gbl_tm1638LEDs+D'2'
09FC  01AB  	CLRF gbl_tm1638LEDs+D'3'
09FD  01AC  	CLRF gbl_tm1638LEDs+D'4'
09FE  01AD  	CLRF gbl_tm1638LEDs+D'5'
09FF  01AE  	CLRF gbl_tm1638LEDs+D'6'
0A00  01AF  	CLRF gbl_tm1638LEDs+D'7'

// Copy of the keys
char tm1638Keys = 0;
0A01  01EB  	CLRF gbl_tm1638Keys

char tm1638KeysOld = 0;
0A02  01EC  	CLRF gbl_tm1638KeysOld

// For printing
char iPrintStartDigit = 0;
0A03  01ED  	CLRF gbl_iPrintStartDigit

char iPrintDotDigit = 8;
0A04  3008  	MOVLW 0x08
0A05  00EE  	MOVWF gbl_iPrintDotDigit

// For adjusting bcd numbers up 1 or down !1
char iBcdAdjustment = 1;
0A06  3001  	MOVLW 0x01
0A07  00EF  	MOVWF gbl_iBcdAdjustment


// DS18B20 functions
char oneWireIsPresent = 0;
0A08  01F0  	CLRF gbl_oneWireIsPresent

char oneWireResetStage = 0;
0A09  01F1  	CLRF gbl_oneWireResetStage

void oneWireBusReset();
void oneWireTxByte(char data);
void oneWireTxBytes(char data, char data2);
char oneWireRxByte();

// EEPROM functions
void eepromWriteAll();
char eepromWrite(char address, char data);
void eepromReadAll();
char eepromRead(char address);

// DS3231 functions
void ds3231Write(char ds3231Reg, char bWrite);
void ds3231Init();
void ds3231Start();
void ds3231Stop();
void ds3231WriteDateTime();
void ds3231ReadDateTime();
char ds3231ReadRegister(char cRegAddress);

// TM1638 functions
void tm1638ByteWrite(char bWrite);
void bcdTo7Seg(char iBcdIn);
void tm1638DisplayOn();
void tm1638UpdateDisplay();
void tm1638ReadKeys();

// General functions
int binToBcd(int iBin);
void startTemp();
void readTemp();

char bcdAdjust(char bcd, char bcdMax, char bcdMin);
void adjustDateTime();
void adjustTrigger();
void processKeys();

#endif

#include <system.h>
#include <i2c_driver.h>
#include "PIC16F_TM1638_AquariumControl.h"

//Target PIC16F628A configuration word
#pragma DATA _CONFIG, _BODEN_OFF & _PWRTE_ON & _WDT_OFF & _CP_OFF & _XT_OSC // Brown out reset off, Power-up Timer on, Watchdog timer off, Code Protection off, XT oscillator

//Set clock frequency (for software delays) - 4MHz
#pragma CLOCK_FREQ	4000000

    
/*********************************************************************************************
  void oneWireBusReset()
  First part of the reset routine - drive the bus low for 500us
*********************************************************************************************/
void oneWireBusReset() {

    char isPresent;
    oneWireTris = 1; // start with high
084E  1683  	BSF STATUS, RP0
084F  1303  	BCF STATUS, RP1
0850  1687  	BSF gbl_trisc,5

    isPresent = 0;
0851  1283  	BCF STATUS, RP0
0852  01F2  	CLRF oneWireBus_00017_1_isPresent

    // Send the reset pulse - drive low for 500us
    oneWireBus = 0;      
0853  1287  	BCF gbl_portc,5

    oneWireTris = 0;
0854  1683  	BSF STATUS, RP0
0855  1287  	BCF gbl_trisc,5

    delay_10us(50);
0856  3032  	MOVLW 0x32
0857  1283  	BCF STATUS, RP0
0858  00F7  	MOVWF delay_10us_00000_arg_del
0859  118A  	BCF PCLATH,3
085A  2077  	CALL delay_10us_00000

    // Release line and wait 70us for PD Pulse
    oneWireTris = 1;
085B  1683  	BSF STATUS, RP0
085C  1687  	BSF gbl_trisc,5

    delay_10us(7);
085D  3007  	MOVLW 0x07
085E  1283  	BCF STATUS, RP0
085F  00F7  	MOVWF delay_10us_00000_arg_del
0860  2077  	CALL delay_10us_00000

    // Now sample, if there is a sensor on the bus, the line should be low
    if (oneWireBus) {
0861  1A87  	BTFSC gbl_portc,5

        oneWireIsPresent = 0; // no devices
0862  01F0  	CLRF gbl_oneWireIsPresent

    }
    delay_10us(50);
0863  3032  	MOVLW 0x32
0864  00F7  	MOVWF delay_10us_00000_arg_del
0865  2077  	CALL delay_10us_00000

}
0866  0008  	RETURN


/*********************************************************************************************
  void oneWireTxByte(char data)
  Transmits a single byte from the bus
*********************************************************************************************/
void oneWireTxByte(char cData) {

    char cTemp = 1;
016E  3001  	MOVLW 0x01
016F  00F5  	MOVWF oneWireTxB_00018_1_cTemp

    // Loop through the eight bits in the byte
    for (char i = 0; i < 8; i++) {
0170  01F6  	CLRF oneWireTxB_00018_2_i
0171        label26
0171  3008  	MOVLW 0x08
0172  0276  	SUBWF oneWireTxB_00018_2_i, W
0173  1803  	BTFSC STATUS,C
0188  0AF6  	INCF oneWireTxB_00018_2_i, F
0189  2971  	GOTO	label26

        // Send the LSB first

        // Drive the line low initially for 3us
        oneWireTris = 0;
0175  1683  	BSF STATUS, RP0
0176  1287  	BCF gbl_trisc,5

        oneWireBus = 0;
0177  1283  	BCF STATUS, RP0
0178  1287  	BCF gbl_portc,5


        // Delay not needed for 4MHz PIC
        //delay_us(3); // Delay 3us
        
        if (cData & cTemp) {
0179  0875  	MOVF oneWireTxB_00018_1_cTemp, W
017A  0574  	ANDWF oneWireTxB_00018_arg_cData, W
017B  1903  	BTFSC STATUS,Z
017C  297F  	GOTO	label27

            oneWireTris = 1; // Release the bus
017D  1683  	BSF STATUS, RP0
017E  1687  	BSF gbl_trisc,5

        }
        
        delay_10us(5); // Delay 60us - 50us works fine with code delays
017F  3005  	MOVLW 0x05
0180  1283  	BCF STATUS, RP0
0181  00F7  	MOVWF delay_10us_00000_arg_del
0182  2077  	CALL delay_10us_00000

        oneWireTris = 1; // Release the bus
0183  1683  	BSF STATUS, RP0
0184  1687  	BSF gbl_trisc,5

        
        // move the test bit
        cTemp <<= 1;
0185  1003  	BCF STATUS,C
0186  1283  	BCF STATUS, RP0
0187  0DF5  	RLF oneWireTxB_00018_1_cTemp, F

    }
}
0174  0008  	RETURN


/*********************************************************************************************
  void oneWireTxBytes(char data, char data2)
  Transmits a 2 bytes from the bus
*********************************************************************************************/
void oneWireTxBytes(char cData, char cData2) {

    // Reset first - done in main
    //oneWireBusReset();
    // Send first byte
    oneWireTxByte(cData);
04BD  0872  	MOVF oneWireTxB_00019_arg_cData, W
04BE  00F4  	MOVWF oneWireTxB_00018_arg_cData
04BF  216E  	CALL oneWireTxB_00018

    // Send second byte
    oneWireTxByte(cData2);
04C0  0873  	MOVF oneWireTxB_00019_arg_cData2, W
04C1  00F4  	MOVWF oneWireTxB_00018_arg_cData
04C2  216E  	CALL oneWireTxB_00018

}
04C3  0008  	RETURN


/*********************************************************************************************
  char oneWireRxByte()
  Receives a single byte from the bus
*********************************************************************************************/
char oneWireRxByte() {

    char cDataIn = 0;
04C4  1283  	BCF STATUS, RP0
04C5  1303  	BCF STATUS, RP1
04C6  01F2  	CLRF oneWireRxB_0001A_1_cDataIn

    // Loop through the eight bits in the byte
    for(char i = 0; i < 8; i++) {
04C7  01F3  	CLRF oneWireRxB_0001A_2_i
04C8        label99
04C8  3008  	MOVLW 0x08
04C9  0273  	SUBWF oneWireRxB_0001A_2_i, W
04CA  1803  	BTFSC STATUS,C
04CB  2CDF  	GOTO	label100
04DD  0AF3  	INCF oneWireRxB_0001A_2_i, F
04DE  2CC8  	GOTO	label99
04DF        label100

        // Bring bus low for 15us
        oneWireTris = 0;
04CC  1683  	BSF STATUS, RP0
04CD  1287  	BCF gbl_trisc,5

        oneWireBus = 0;
04CE  1283  	BCF STATUS, RP0
04CF  1287  	BCF gbl_portc,5


        // Delay not needed for 4MHz PIC
        //delay_us(15); // Delay 15us

        // Release bus for 6us, this is enough time for the slave to respond
        oneWireTris = 1;
04D0  1683  	BSF STATUS, RP0
04D1  1687  	BSF gbl_trisc,5

        delay_us(3); // Delay 6us
04D2  3003  	MOVLW 0x03
04D3  1283  	BCF STATUS, RP0
04D4  00F8  	MOVWF delay_us_00000_arg_del
04D5  2010  	CALL delay_us_00000

        
        // Shift data already received left
        cDataIn >>= 1;
04D6  1003  	BCF STATUS,C
04D7  0CF2  	RRF oneWireRxB_0001A_1_cDataIn, F

        
        // Check the value of the onewire bus - set the MSB of cDataIn if so
        if (oneWireBus)
04D8  1A87  	BTFSC gbl_portc,5

            cDataIn.7 = 1;
04D9  17F2  	BSF oneWireRxB_0001A_1_cDataIn,7


        // To finish time slot
        delay_10us(6); // 60us
04DA  3006  	MOVLW 0x06
04DB  00F7  	MOVWF delay_10us_00000_arg_del
04DC  2077  	CALL delay_10us_00000

    } 
    
    return cDataIn;
04DF  0872  	MOVF oneWireRxB_0001A_1_cDataIn, W
04E0  00F3  	MOVWF CompTempVarRet551

}
04E1  0008  	RETURN


/*********************************************************************************************
  void at24c32WriteAll()
  Write multiple bytes
*********************************************************************************************/
void at24c32WriteAll() {

	// https://www.instructables.com/The-Most-Comprehensive-Guide-to-Programming-the-AT/
	i2c_start();
05AE  2126  	CALL i2c_START_00000

	i2c_write(at24c32Addr); // address + write
05AF  30AE  	MOVLW 0xAE
05B0  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05B1  20A5  	CALL i2c_WRITE_00000

	// start at address 0
	i2c_write(0); // First word address (only 4 bits of the 12 bit byte address)
05B2  01F5  	CLRF i2c_WRITE_00000_arg_i2c_data
05B3  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // Second word address 
05B4  01F5  	CLRF i2c_WRITE_00000_arg_i2c_data
05B5  20A5  	CALL i2c_WRITE_00000

	// Write data bytes
	// We're only writing 18 bytes here, so no need to worry about row rollover after 32 bytes
	i2c_write(0x44); // To indicate AT24C32 has been written to
05B6  3044  	MOVLW 0x44
05B7  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05B8  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdWhiteOnMinute);
05B9  0853  	MOVF gbl_gBcdWhiteOnMinute, W
05BA  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05BB  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOnHour);
05BC  0854  	MOVF gbl_gBcdWhiteOnHour, W
05BD  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05BE  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOffMinute);
05BF  0855  	MOVF gbl_gBcdWhiteOffMinute, W
05C0  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05C1  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOffHour);
05C2  0856  	MOVF gbl_gBcdWhiteOffHour, W
05C3  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05C4  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOnMinute);
05C5  0857  	MOVF gbl_gBcdBlueOnMinute, W
05C6  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05C7  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOnHour);
05C8  0858  	MOVF gbl_gBcdBlueOnHour, W
05C9  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05CA  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOffMinute);
05CB  0859  	MOVF gbl_gBcdBlueOffMinute, W
05CC  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05CD  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOffHour);
05CE  085A  	MOVF gbl_gBcdBlueOffHour, W
05CF  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05D0  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdFanOnTemp);
05D1  085F  	MOVF gbl_gBcdFanOnTemp, W
05D2  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05D3  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdFanOffTemp);
05D4  0860  	MOVF gbl_gBcdFanOffTemp, W
05D5  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05D6  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdHeaterOnTemp);
05D7  0861  	MOVF gbl_gBcdHeaterOnTemp, W
05D8  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05D9  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdHeaterOffTemp);
05DA  0862  	MOVF gbl_gBcdHeaterOffTemp, W
05DB  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05DC  20A5  	CALL i2c_WRITE_00000

    i2c_write(gcHourMode);
05DD  0851  	MOVF gbl_gcHourMode, W
05DE  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05DF  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlue2OnMinute);
05E0  085B  	MOVF gbl_gBcdBlue2OnMinute, W
05E1  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05E2  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlue2OnHour);
05E3  085C  	MOVF gbl_gBcdBlue2OnHour, W
05E4  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05E5  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlue2OffMinute);
05E6  085D  	MOVF gbl_gBcdBlue2OffMinute, W
05E7  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05E8  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlue2OffHour);
05E9  085E  	MOVF gbl_gBcdBlue2OffHour, W
05EA  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05EB  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
05EC  20F6  	CALL i2c_STOP_00000

	delay_ms(10); // Write Cycle Time
05ED  300A  	MOVLW 0x0A
05EE  00F2  	MOVWF delay_ms_00000_arg_del
05EF  2081  	CALL delay_ms_00000

}
05F0  0008  	RETURN


/*********************************************************************************************
  void at24c32ReadAll()
  Read all bytes
*********************************************************************************************/
void at24c32ReadAll() {

	i2c_start();
05F1  2126  	CALL i2c_START_00000

	i2c_write(at24c32Addr); // address + write
05F2  30AE  	MOVLW 0xAE
05F3  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05F4  20A5  	CALL i2c_WRITE_00000

	// start at address 0
	i2c_write(0); // First word address (only 4 bits of the 12 bit byte address)
05F5  01F5  	CLRF i2c_WRITE_00000_arg_i2c_data
05F6  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // Second word address 
05F7  01F5  	CLRF i2c_WRITE_00000_arg_i2c_data
05F8  20A5  	CALL i2c_WRITE_00000

	i2c_stop(); // Don't actually write a byte, just stop
05F9  20F6  	CALL i2c_STOP_00000

	
	i2c_start();
05FA  2126  	CALL i2c_START_00000

	i2c_write(at24c32Addr + 1); // address + read
05FB  30AF  	MOVLW 0xAF
05FC  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05FD  20A5  	CALL i2c_WRITE_00000

	char hasWritten = i2c_read(0); // ack
05FE  01F5  	CLRF i2c_READ_00000_arg_ack_status
05FF  21CD  	CALL i2c_READ_00000
0600  0878  	MOVF CompTempVarRet553, W
0601  00F3  	MOVWF at24c32Rea_0002C_1_hasWritten

	if (hasWritten != 0x44) {
0602  0873  	MOVF at24c32Rea_0002C_1_hasWritten, W
0603  3A44  	XORLW 0x44
0604  1903  	BTFSC STATUS,Z
0605  2E0A  	GOTO	label103
060A        label103

		i2c_read(1); // nack
0606  3001  	MOVLW 0x01
0607  00F5  	MOVWF i2c_READ_00000_arg_ack_status
0608  21CD  	CALL i2c_READ_00000

	} else {
0609  2E4F  	GOTO	label104
064F        label104

		gBcdWhiteOnMinute = i2c_read(0); // ack
060A  01F5  	CLRF i2c_READ_00000_arg_ack_status
060B  21CD  	CALL i2c_READ_00000
060C  0878  	MOVF CompTempVarRet553, W
060D  00D3  	MOVWF gbl_gBcdWhiteOnMinute

		gBcdWhiteOnHour = i2c_read(0); // ack
060E  01F5  	CLRF i2c_READ_00000_arg_ack_status
060F  21CD  	CALL i2c_READ_00000
0610  0878  	MOVF CompTempVarRet553, W
0611  00D4  	MOVWF gbl_gBcdWhiteOnHour

		gBcdWhiteOffMinute = i2c_read(0); // ack
0612  01F5  	CLRF i2c_READ_00000_arg_ack_status
0613  21CD  	CALL i2c_READ_00000
0614  0878  	MOVF CompTempVarRet553, W
0615  00D5  	MOVWF gbl_gBcdWhiteOffMinute

		gBcdWhiteOffHour = i2c_read(0); // ack
0616  01F5  	CLRF i2c_READ_00000_arg_ack_status
0617  21CD  	CALL i2c_READ_00000
0618  0878  	MOVF CompTempVarRet553, W
0619  00D6  	MOVWF gbl_gBcdWhiteOffHour

		gBcdBlueOnMinute = i2c_read(0); // ack
061A  01F5  	CLRF i2c_READ_00000_arg_ack_status
061B  21CD  	CALL i2c_READ_00000
061C  0878  	MOVF CompTempVarRet553, W
061D  00D7  	MOVWF gbl_gBcdBlueOnMinute

		gBcdBlueOnHour = i2c_read(0); // ack
061E  01F5  	CLRF i2c_READ_00000_arg_ack_status
061F  21CD  	CALL i2c_READ_00000
0620  0878  	MOVF CompTempVarRet553, W
0621  00D8  	MOVWF gbl_gBcdBlueOnHour

		gBcdBlueOffMinute = i2c_read(0); // ack
0622  01F5  	CLRF i2c_READ_00000_arg_ack_status
0623  21CD  	CALL i2c_READ_00000
0624  0878  	MOVF CompTempVarRet553, W
0625  00D9  	MOVWF gbl_gBcdBlueOffMinute

		gBcdBlueOffHour = i2c_read(0); // ack
0626  01F5  	CLRF i2c_READ_00000_arg_ack_status
0627  21CD  	CALL i2c_READ_00000
0628  0878  	MOVF CompTempVarRet553, W
0629  00DA  	MOVWF gbl_gBcdBlueOffHour

		gBcdFanOnTemp = i2c_read(0); // ack
062A  01F5  	CLRF i2c_READ_00000_arg_ack_status
062B  21CD  	CALL i2c_READ_00000
062C  0878  	MOVF CompTempVarRet553, W
062D  00DF  	MOVWF gbl_gBcdFanOnTemp

		gBcdFanOffTemp = i2c_read(0); // ack
062E  01F5  	CLRF i2c_READ_00000_arg_ack_status
062F  21CD  	CALL i2c_READ_00000
0630  0878  	MOVF CompTempVarRet553, W
0631  00E0  	MOVWF gbl_gBcdFanOffTemp

		gBcdHeaterOnTemp = i2c_read(0); // ack
0632  01F5  	CLRF i2c_READ_00000_arg_ack_status
0633  21CD  	CALL i2c_READ_00000
0634  0878  	MOVF CompTempVarRet553, W
0635  00E1  	MOVWF gbl_gBcdHeaterOnTemp

		gBcdHeaterOffTemp = i2c_read(0); // ack
0636  01F5  	CLRF i2c_READ_00000_arg_ack_status
0637  21CD  	CALL i2c_READ_00000
0638  0878  	MOVF CompTempVarRet553, W
0639  00E2  	MOVWF gbl_gBcdHeaterOffTemp

		gcHourMode = i2c_read(0); // ack
063A  01F5  	CLRF i2c_READ_00000_arg_ack_status
063B  21CD  	CALL i2c_READ_00000
063C  0878  	MOVF CompTempVarRet553, W
063D  00D1  	MOVWF gbl_gcHourMode

		gBcdBlue2OnMinute = i2c_read(0); // ack
063E  01F5  	CLRF i2c_READ_00000_arg_ack_status
063F  21CD  	CALL i2c_READ_00000
0640  0878  	MOVF CompTempVarRet553, W
0641  00DB  	MOVWF gbl_gBcdBlue2OnMinute

		gBcdBlue2OnHour = i2c_read(0); // ack
0642  01F5  	CLRF i2c_READ_00000_arg_ack_status
0643  21CD  	CALL i2c_READ_00000
0644  0878  	MOVF CompTempVarRet553, W
0645  00DC  	MOVWF gbl_gBcdBlue2OnHour

		gBcdBlue2OffMinute = i2c_read(0); // ack
0646  01F5  	CLRF i2c_READ_00000_arg_ack_status
0647  21CD  	CALL i2c_READ_00000
0648  0878  	MOVF CompTempVarRet553, W
0649  00DD  	MOVWF gbl_gBcdBlue2OffMinute

		gBcdBlue2OffHour = i2c_read(1); // nack
064A  3001  	MOVLW 0x01
064B  00F5  	MOVWF i2c_READ_00000_arg_ack_status
064C  21CD  	CALL i2c_READ_00000
064D  0878  	MOVF CompTempVarRet553, W
064E  00DE  	MOVWF gbl_gBcdBlue2OffHour

	}
	i2c_stop();
064F  20F6  	CALL i2c_STOP_00000

}
0650  0008  	RETURN



/*********************************************************************************************
  void ds3231Write(char ds3231Reg, char bWrite)
  Write one byte
*********************************************************************************************/
void ds3231Write(char ds3231Reg, char bWrite) {

	i2c_start();
0221  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
0222  30D0  	MOVLW 0xD0
0223  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
0224  20A5  	CALL i2c_WRITE_00000

	i2c_write(ds3231Reg); // start at address
0225  0873  	MOVF ds3231Writ_0001B_arg_ds3231Reg, W
0226  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
0227  20A5  	CALL i2c_WRITE_00000

	i2c_write(bWrite); // start at address
0228  0874  	MOVF ds3231Writ_0001B_arg_bWrite, W
0229  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
022A  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
022B  20F6  	CALL i2c_STOP_00000

}
022C  0008  	RETURN


/*********************************************************************************************
  void ds3231Init()
  Initialise the DS3231
*********************************************************************************************/
void ds3231Init() {

	/* control register 0Eh
    bit7 EOSC   Enable Oscillator (1 if oscillator must be stopped when on battery)
    bit6 BBSQW  Battery Backed Square Wave - 0 means square wave disabled when VCC falls below VPF (power fail voltage)
    bit5 CONV   Convert temperature (1 forces a conversion)
    bit4 RS2    Rate select - frequency of square wave output - NA for DS3231M
    bit3 RS1    Rate select - NA for DS3231M
    bit2 INTCN  Interrupt control (1 for use of the alarms and to disable square wave)
    bit1 A2IE   Alarm2 interrupt enable (1 to enable)
    bit0 A1IE   Alarm1 interrupt enable (1 to enable)
    */
	ds3231Write(0x0E, 0x00);
0526  300E  	MOVLW 0x0E
0527  1283  	BCF STATUS, RP0
0528  1303  	BCF STATUS, RP1
0529  00F3  	MOVWF ds3231Writ_0001B_arg_ds3231Reg
052A  01F4  	CLRF ds3231Writ_0001B_arg_bWrite
052B  2221  	CALL ds3231Writ_0001B

	/* Status Register 0Fh
    bit7 OSF     Oscillator stopped flag - clear oscillator stop flag at init
    bit3 EN32kHz Enable 32kHz Output - 0 for disabled
    bit2 BSY     Busy
    bit1 A2F     Alarm 2 Flag
    bit0 A1F     Alarm 1 Flag
    */
	ds3231Write(0x0F, 0x00);
052C  300F  	MOVLW 0x0F
052D  00F3  	MOVWF ds3231Writ_0001B_arg_ds3231Reg
052E  01F4  	CLRF ds3231Writ_0001B_arg_bWrite
052F  2221  	CALL ds3231Writ_0001B

}
0530  0008  	RETURN


/*********************************************************************************************
  void ds3231WriteDateTime()
  Write the date to the DS3231
*********************************************************************************************/
void ds3231WriteDateTime() {

	i2c_start();
04F5  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
04F6  30D0  	MOVLW 0xD0
04F7  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
04F8  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
04F9  01F5  	CLRF i2c_WRITE_00000_arg_i2c_data
04FA  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // seconds
04FB  01F5  	CLRF i2c_WRITE_00000_arg_i2c_data
04FC  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdMinute); // minutes
04FD  0836  	MOVF gbl_gBcdMinute, W
04FE  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
04FF  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdHour); // hours
0500  0837  	MOVF gbl_gBcdHour, W
0501  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
0502  20A5  	CALL i2c_WRITE_00000

	i2c_write(gDayOfWeek); // day of week
0503  0838  	MOVF gbl_gDayOfWeek, W
0504  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
0505  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdDayOfMonth); // day of month
0506  0839  	MOVF gbl_gBcdDayOfMonth, W
0507  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
0508  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdMonth); // month + century
0509  083A  	MOVF gbl_gBcdMonth, W
050A  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
050B  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdYear); // year
050C  083B  	MOVF gbl_gBcdYear, W
050D  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
050E  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
050F  20F6  	CALL i2c_STOP_00000

}
0510  0008  	RETURN


/*********************************************************************************************
  void ds3231ReadDateTime()
  Write the date to the DS3231
*********************************************************************************************/
void ds3231ReadDateTime() {

	i2c_start();
08A3  118A  	BCF PCLATH,3
08A4  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
08A5  30D0  	MOVLW 0xD0
08A6  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
08A7  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
08A8  01F5  	CLRF i2c_WRITE_00000_arg_i2c_data
08A9  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
08AA  20F6  	CALL i2c_STOP_00000

	
	i2c_start();
08AB  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr + 1); // address + read
08AC  30D1  	MOVLW 0xD1
08AD  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
08AE  20A5  	CALL i2c_WRITE_00000

	gBcdSecond = i2c_read(0); // ack
08AF  01F5  	CLRF i2c_READ_00000_arg_ack_status
08B0  21CD  	CALL i2c_READ_00000
08B1  0878  	MOVF CompTempVarRet553, W
08B2  00B5  	MOVWF gbl_gBcdSecond

	gBcdMinute = i2c_read(0); // ack
08B3  01F5  	CLRF i2c_READ_00000_arg_ack_status
08B4  21CD  	CALL i2c_READ_00000
08B5  0878  	MOVF CompTempVarRet553, W
08B6  00B6  	MOVWF gbl_gBcdMinute

	gBcdHour = i2c_read(0); // ack
08B7  01F5  	CLRF i2c_READ_00000_arg_ack_status
08B8  21CD  	CALL i2c_READ_00000
08B9  0878  	MOVF CompTempVarRet553, W
08BA  00B7  	MOVWF gbl_gBcdHour

	gDayOfWeek = i2c_read(0); // ack
08BB  01F5  	CLRF i2c_READ_00000_arg_ack_status
08BC  21CD  	CALL i2c_READ_00000
08BD  0878  	MOVF CompTempVarRet553, W
08BE  00B8  	MOVWF gbl_gDayOfWeek

	gBcdDayOfMonth = i2c_read(0); // ack
08BF  01F5  	CLRF i2c_READ_00000_arg_ack_status
08C0  21CD  	CALL i2c_READ_00000
08C1  0878  	MOVF CompTempVarRet553, W
08C2  00B9  	MOVWF gbl_gBcdDayOfMonth

	gBcdMonth = i2c_read(0); // ack
08C3  01F5  	CLRF i2c_READ_00000_arg_ack_status
08C4  21CD  	CALL i2c_READ_00000
08C5  0878  	MOVF CompTempVarRet553, W
08C6  00BA  	MOVWF gbl_gBcdMonth

	gBcdYear = i2c_read(1); // nack
08C7  3001  	MOVLW 0x01
08C8  00F5  	MOVWF i2c_READ_00000_arg_ack_status
08C9  21CD  	CALL i2c_READ_00000
08CA  0878  	MOVF CompTempVarRet553, W
08CB  00BB  	MOVWF gbl_gBcdYear

	i2c_stop();
08CC  20F6  	CALL i2c_STOP_00000

}
08CD  0008  	RETURN


/*********************************************************************************************
  char ds3231ReadRegister(char cRegAddress)
  Read one byte from a given DS3231 register address
*********************************************************************************************/
char ds3231ReadRegister(char cRegAddress) {

	char cStatus;
	i2c_start();
0511  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
0512  30D0  	MOVLW 0xD0
0513  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
0514  20A5  	CALL i2c_WRITE_00000

	i2c_write(cRegAddress); // start at requested address
0515  0873  	MOVF ds3231Read_0001E_arg_cRegAddress, W
0516  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
0517  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
0518  20F6  	CALL i2c_STOP_00000

	
	i2c_start();
0519  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr + 1); // address + read
051A  30D1  	MOVLW 0xD1
051B  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
051C  20A5  	CALL i2c_WRITE_00000

	cStatus = i2c_read(1); // read the byte, then nack
051D  3001  	MOVLW 0x01
051E  00F5  	MOVWF i2c_READ_00000_arg_ack_status
051F  21CD  	CALL i2c_READ_00000
0520  0878  	MOVF CompTempVarRet553, W
0521  00F4  	MOVWF ds3231Read_0001E_1_cStatus

    i2c_stop();
0522  20F6  	CALL i2c_STOP_00000

    return cStatus;
0523  0874  	MOVF ds3231Read_0001E_1_cStatus, W
0524  00F5  	MOVWF CompTempVarRet554

}
0525  0008  	RETURN


/*********************************************************************************************
  void tm1638ByteWrite(char bWrite)
  Write one byte
*********************************************************************************************/
void tm1638ByteWrite(char bWrite) {

    for (char i = 0; i < 8; i++) {
015B  01F7  	CLRF tm1638Byte_0001F_2_i
015C        label25
015C  3008  	MOVLW 0x08
015D  0277  	SUBWF tm1638Byte_0001F_2_i, W
015E  1803  	BTFSC STATUS,C
016C  0AF7  	INCF tm1638Byte_0001F_2_i, F
016D  295C  	GOTO	label25

        tm1638dio = (bWrite & 0x01);
0160  3001  	MOVLW 0x01
0161  0576  	ANDWF tm1638Byte_0001F_arg_bWrite, W
0162  00F8  	MOVWF CompTempVar555
0163  1878  	BTFSC CompTempVar555,0
0164  1486  	BSF gbl_portb,1
0165  1C78  	BTFSS CompTempVar555,0
0166  1086  	BCF gbl_portb,1

        tm1638clk = 0;
0167  1106  	BCF gbl_portb,2

        bWrite = (bWrite >> 1);
0168  08F6  	MOVF tm1638Byte_0001F_arg_bWrite, F
0169  1003  	BCF STATUS,C
016A  0CF6  	RRF tm1638Byte_0001F_arg_bWrite, F

        tm1638clk = 1;
016B  1506  	BSF gbl_portb,2

    }
}
015F  0008  	RETURN


/*********************************************************************************************
  void tm1638DisplayOn()
  Turns the display on, with defined brightness
*********************************************************************************************/
void tm1638DisplayOn() {

    // Write 0x8F [10001000] to set display ON with pulse width 14/16
    tm1638strobe = 0;
04B5  1283  	BCF STATUS, RP0
04B6  1303  	BCF STATUS, RP1
04B7  1186  	BCF gbl_portb,3

    tm1638ByteWrite(0x88);
04B8  3088  	MOVLW 0x88
04B9  00F6  	MOVWF tm1638Byte_0001F_arg_bWrite
04BA  215B  	CALL tm1638Byte_0001F

    tm1638strobe = 1;
04BB  1586  	BSF gbl_portb,3

}
04BC  0008  	RETURN


/*********************************************************************************************
  void nibbleTo7Seg(char iNibble)
  Convert a single nibble into the 7-segment representation (two digits)
  7-segment digit to be written will be iPrintStartDigit, which is auto-incremented after
  If iPrintDotDigit matches, the dot on the display digit will be added
*********************************************************************************************/
void nibbleTo7Seg(char bNibble) {

	char s7SegDisplay = tm1638DisplayNumtoSeg[bNibble & 0x0F];
008D  0864  	MOVF gbl_tm1638DisplayNumtoSeg, W
008E  00FB  	MOVWF __rom_get_00000_arg_objNumb
008F  300F  	MOVLW 0x0F
0090  0579  	ANDWF nibbleTo7S_00020_arg_bNibble, W
0091  00FC  	MOVWF __rom_get_00000_arg_idx
0092  201A  	CALL __rom_get_00000
0093  00FA  	MOVWF nibbleTo7S_00020_1_s7SegDisplay

	if (iPrintStartDigit == iPrintDotDigit)
0094  086E  	MOVF gbl_iPrintDotDigit, W
0095  066D  	XORWF gbl_iPrintStartDigit, W
0096  118A  	BCF PCLATH,3
0097  120A  	BCF PCLATH,4
0098  1D03  	BTFSS STATUS,Z
0099  289C  	GOTO	label10
009C        label10

        s7SegDisplay |= tm1638Dot;
009A  0865  	MOVF gbl_tm1638Dot, W
009B  04FA  	IORWF nibbleTo7S_00020_1_s7SegDisplay, F

    tm1638Data[iPrintStartDigit] = s7SegDisplay;
009C  1383  	BCF	STATUS,IRP
009D  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
009E  0084  	MOVWF FSR
009F  086D  	MOVF gbl_iPrintStartDigit, W
00A0  0784  	ADDWF FSR, F
00A1  087A  	MOVF nibbleTo7S_00020_1_s7SegDisplay, W
00A2  0080  	MOVWF INDF

    iPrintStartDigit++;
00A3  0AED  	INCF gbl_iPrintStartDigit, F

}
00A4  0008  	RETURN


/*********************************************************************************************
  void bcdTo7Seg(char iBcdIn)
  Convert a single bcd byte into the 7-segment representation (two digits)
*********************************************************************************************/
void bcdTo7Seg(char iBcdIn) {

    nibbleTo7Seg(iBcdIn >> 4);
022D  0E78  	SWAPF bcdTo7Seg_00000_arg_iBcdIn, W
022E  390F  	ANDLW 0x0F
022F  00F9  	MOVWF nibbleTo7S_00020_arg_bNibble
0230  208D  	CALL nibbleTo7S_00020

    nibbleTo7Seg(iBcdIn);
0231  0878  	MOVF bcdTo7Seg_00000_arg_iBcdIn, W
0232  00F9  	MOVWF nibbleTo7S_00020_arg_bNibble
0233  208D  	CALL nibbleTo7S_00020

}
0234  0008  	RETURN


/*********************************************************************************************
  void tm1638UpdateDisplay()
  Publish the tm1638Data and tm1638LEDs arrays to the display
*********************************************************************************************/
void tm1638UpdateDisplay() {

    
    // Display current temperature unless set, trigger or alt display mode is active
    if ((gcDisplayMode == 2) | gcSetMode | gcTriggerMode) {
0293  1283  	BCF STATUS, RP0
0294  1303  	BCF STATUS, RP1
0295  01F3  	CLRF CompTempVar559
0296  3002  	MOVLW 0x02
0297  024F  	SUBWF gbl_gcDisplayMode, W
0298  1903  	BTFSC STATUS,Z
0299  0AF3  	INCF CompTempVar559, F
029A  0850  	MOVF gbl_gcSetMode, W
029B  04F3  	IORWF CompTempVar559, F
029C  0852  	MOVF gbl_gcTriggerMode, W
029D  0473  	IORWF CompTempVar559, W
029E  1903  	BTFSC STATUS,Z
029F  2BFC  	GOTO	label81
03FC        label81

        if (gcSetMode == 1) {
02A0  0350  	DECF gbl_gcSetMode, W
02A1  1D03  	BTFSS STATUS,Z
02A2  2AAF  	GOTO	label53
02AF        label53

            iDigitToFlash = 3;
02A3  3003  	MOVLW 0x03
02A4  00C8  	MOVWF gbl_iDigitToFlash

            // Display year
            // Start printing from digit 0
            iPrintStartDigit = 0;
02A5  01ED  	CLRF gbl_iPrintStartDigit

            iPrintDotDigit = 3;
02A6  3003  	MOVLW 0x03
02A7  00EE  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(0x20); // Display 20 in digits 0 and 1 (no dot)
02A8  3020  	MOVLW 0x20
02A9  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02AA  222D  	CALL bcdTo7Seg_00000

            bcdTo7Seg(gBcdYear); // Display year in digits 2 and 3 (+dot on 3)
02AB  083B  	MOVF gbl_gBcdYear, W
02AC  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02AD  222D  	CALL bcdTo7Seg_00000

        } else if (gcSetMode == 4) {
02AE  2C2C  	GOTO	label84
02AF  0850  	MOVF gbl_gcSetMode, W
02B0  3A04  	XORLW 0x04
02B1  1D03  	BTFSS STATUS,Z
02B2  2AC5  	GOTO	label54
02C5        label54

            iDigitToFlash = 3;
02B3  3003  	MOVLW 0x03
02B4  00C8  	MOVWF gbl_iDigitToFlash

            // Display day of week
            tm1638Data[0] = 0x5E; // d
02B5  305E  	MOVLW 0x5E
02B6  00A0  	MOVWF gbl_tm1638Data

            tm1638Data[1] = 0x5F; // a
02B7  305F  	MOVLW 0x5F
02B8  00A1  	MOVWF gbl_tm1638Data+D'1'

            tm1638Data[2] = 0x6E; // y
02B9  306E  	MOVLW 0x6E
02BA  00A2  	MOVWF gbl_tm1638Data+D'2'

            tm1638Data[3] = tm1638DisplayNumtoSeg[gDayOfWeek] + tm1638Dot;
02BB  0864  	MOVF gbl_tm1638DisplayNumtoSeg, W
02BC  00FB  	MOVWF __rom_get_00000_arg_objNumb
02BD  0838  	MOVF gbl_gDayOfWeek, W
02BE  00FC  	MOVWF __rom_get_00000_arg_idx
02BF  201A  	CALL __rom_get_00000
02C0  0765  	ADDWF gbl_tm1638Dot, W
02C1  00A3  	MOVWF gbl_tm1638Data+D'3'

        } else if (gcSetMode == 5) {
02C2  118A  	BCF PCLATH,3
02C3  120A  	BCF PCLATH,4
02C4  2C2C  	GOTO	label84
02C5  0850  	MOVF gbl_gcSetMode, W
02C6  3A05  	XORLW 0x05
02C7  1D03  	BTFSS STATUS,Z
02C8  2ADB  	GOTO	label57
02DB        label57

            iDigitToFlash = 1;
02C9  3001  	MOVLW 0x01
02CA  00C8  	MOVWF gbl_iDigitToFlash

            // Display day of week
            if (gcHourMode) {
02CB  08D1  	MOVF gbl_gcHourMode, F
02CC  1903  	BTFSC STATUS,Z
02CD  2AD3  	GOTO	label55
02D3        label55

				tm1638Data[0] = 0x06; // 1
02CE  3006  	MOVLW 0x06
02CF  00A0  	MOVWF gbl_tm1638Data

				tm1638Data[1] = 0x5B; // 2
02D0  305B  	MOVLW 0x5B
02D1  00A1  	MOVWF gbl_tm1638Data+D'1'

			} else {
02D2  2AD7  	GOTO	label56
02D7        label56

				tm1638Data[0] = 0x5B; // 2
02D3  305B  	MOVLW 0x5B
02D4  00A0  	MOVWF gbl_tm1638Data

				tm1638Data[1] = 0x66; // 4
02D5  3066  	MOVLW 0x66
02D6  00A1  	MOVWF gbl_tm1638Data+D'1'

			}
            tm1638Data[2] = 0x74; // h
02D7  3074  	MOVLW 0x74
02D8  00A2  	MOVWF gbl_tm1638Data+D'2'

            tm1638Data[3] = 0x00; // blank
02D9  01A3  	CLRF gbl_tm1638Data+D'3'

        } else if (gcTriggerMode) {
02DA  2C2C  	GOTO	label84
02DB  08D2  	MOVF gbl_gcTriggerMode, F
02DC  1903  	BTFSC STATUS,Z
02DD  2BD4  	GOTO	label74
03D4        label74

            iPrintDotDigit = 5;
02DE  3005  	MOVLW 0x05
02DF  00EE  	MOVWF gbl_iPrintDotDigit

            switch (gcTriggerMode) {
0311  2C2C  	GOTO	label84

                case 1:
02E0  0852  	MOVF gbl_gcTriggerMode, W
02E1  3A01  	XORLW 0x01
02E2  1903  	BTFSC STATUS,Z
02E3  2B12  	GOTO	label58
0312        label58

                    // White LED on hour
                    tm1638Data[0] = 0x38; // L
0312  3038  	MOVLW 0x38
0313  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x00; // space
0314  01A1  	CLRF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x3F; // O
0315  303F  	MOVLW 0x3F
0316  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x54; // n
0317  3054  	MOVLW 0x54
0318  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
0319  3005  	MOVLW 0x05
031A  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
031B  3004  	MOVLW 0x04
031C  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOnHour); // Display hour in digits 4 and 5 (dot on 5)
031D  0854  	MOVF gbl_gBcdWhiteOnHour, W
031E  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
031F  222D  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdWhiteOnMinute); // Display minute in digits 6 and 7 (no dot)
0320  0853  	MOVF gbl_gBcdWhiteOnMinute, W
0321  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0322  222D  	CALL bcdTo7Seg_00000

                    break;
0323  2C2C  	GOTO	label84

                case 2:
02E4  3A03  	XORLW 0x03
02E5  1903  	BTFSC STATUS,Z
02E6  2B24  	GOTO	label59
0324        label59

                    // White LED on minute
                    iDigitToFlash = 7;
0324  3007  	MOVLW 0x07
0325  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0326  3006  	MOVLW 0x06
0327  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOnMinute); // Display minute in digits 6 and 7 (no dot)
0328  0853  	MOVF gbl_gBcdWhiteOnMinute, W
0329  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
032A  222D  	CALL bcdTo7Seg_00000

                    break;
032B  2C2C  	GOTO	label84

                case 3:
02E7  3A01  	XORLW 0x01
02E8  1903  	BTFSC STATUS,Z
02E9  2B2C  	GOTO	label60
032C        label60

                    // White LED off hour
                    tm1638Data[3] = 0x71; // F
032C  3071  	MOVLW 0x71
032D  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
032E  3005  	MOVLW 0x05
032F  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
0330  3004  	MOVLW 0x04
0331  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOffHour); 
0332  0856  	MOVF gbl_gBcdWhiteOffHour, W
0333  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0334  222D  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdWhiteOffMinute); // Display minute in digits 6 and 7 (no dot)
0335  0855  	MOVF gbl_gBcdWhiteOffMinute, W
0336  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0337  222D  	CALL bcdTo7Seg_00000

                    break;
0338  2C2C  	GOTO	label84

                case 4:
02EA  3A07  	XORLW 0x07
02EB  1903  	BTFSC STATUS,Z
02EC  2B39  	GOTO	label61
0339        label61

                    // White LED off minute
                    iDigitToFlash = 7;
0339  3007  	MOVLW 0x07
033A  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
033B  3006  	MOVLW 0x06
033C  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOffMinute); // Display minute in digits 6 and 7 (no dot)
033D  0855  	MOVF gbl_gBcdWhiteOffMinute, W
033E  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
033F  222D  	CALL bcdTo7Seg_00000

                    break;
0340  2C2C  	GOTO	label84

                case 5:
02ED  3A01  	XORLW 0x01
02EE  1903  	BTFSC STATUS,Z
02EF  2B41  	GOTO	label62
0341        label62

                    // 1st Blue LED on hour
                    tm1638Data[0] = 0x7C; // b
0341  307C  	MOVLW 0x7C
0342  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x06; // 1
0343  3006  	MOVLW 0x06
0344  00A1  	MOVWF gbl_tm1638Data+D'1'

                    //tm1638Data[2] = 0x3F; // O
                    tm1638Data[3] = 0x54; // n
0345  3054  	MOVLW 0x54
0346  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
0347  3005  	MOVLW 0x05
0348  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
0349  3004  	MOVLW 0x04
034A  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOnHour); // Display hour in digits 4 and 5 (dot on 5)
034B  0858  	MOVF gbl_gBcdBlueOnHour, W
034C  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
034D  222D  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlueOnMinute); // Display minute in digits 6 and 7 (no dot)
034E  0857  	MOVF gbl_gBcdBlueOnMinute, W
034F  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0350  222D  	CALL bcdTo7Seg_00000

                    break;
0351  2C2C  	GOTO	label84

                case 6:
02F0  3A03  	XORLW 0x03
02F1  1903  	BTFSC STATUS,Z
02F2  2B52  	GOTO	label63
0352        label63

                    // 1st Blue LED on minute
                    iDigitToFlash = 7;
0352  3007  	MOVLW 0x07
0353  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0354  3006  	MOVLW 0x06
0355  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOnMinute); // Display minute in digits 6 and 7 (no dot)
0356  0857  	MOVF gbl_gBcdBlueOnMinute, W
0357  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0358  222D  	CALL bcdTo7Seg_00000

                    break;
0359  2C2C  	GOTO	label84

                case 7:
02F3  3A01  	XORLW 0x01
02F4  1903  	BTFSC STATUS,Z
02F5  2B5A  	GOTO	label64
035A        label64

                    // 1st Blue LED off hour
                    tm1638Data[3] = 0x71; // F
035A  3071  	MOVLW 0x71
035B  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
035C  3005  	MOVLW 0x05
035D  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
035E  3004  	MOVLW 0x04
035F  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOffHour); // Display hour in digits 4 and 5 (dot on 5)
0360  085A  	MOVF gbl_gBcdBlueOffHour, W
0361  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0362  222D  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlueOffMinute); // Display minute in digits 6 and 7 (no dot)
0363  0859  	MOVF gbl_gBcdBlueOffMinute, W
0364  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0365  222D  	CALL bcdTo7Seg_00000

                    break;
0366  2C2C  	GOTO	label84

                case 8:
02F6  3A0F  	XORLW 0x0F
02F7  1903  	BTFSC STATUS,Z
02F8  2B67  	GOTO	label65
0367        label65

                    // 1st Blue LED off minute
                    iDigitToFlash = 7;
0367  3007  	MOVLW 0x07
0368  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0369  3006  	MOVLW 0x06
036A  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOffMinute); // Display minute in digits 6 and 7 (no dot)
036B  0859  	MOVF gbl_gBcdBlueOffMinute, W
036C  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
036D  222D  	CALL bcdTo7Seg_00000

                    break;
036E  2C2C  	GOTO	label84

                case 9:
02F9  3A01  	XORLW 0x01
02FA  1903  	BTFSC STATUS,Z
02FB  2B6F  	GOTO	label66
036F        label66

                    // 2nd Blue LED on hour
                    tm1638Data[0] = 0x7C; // b
036F  307C  	MOVLW 0x7C
0370  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x5B; // 2
0371  305B  	MOVLW 0x5B
0372  00A1  	MOVWF gbl_tm1638Data+D'1'

                    //tm1638Data[2] = 0x3F; // O
                    tm1638Data[3] = 0x54; // n
0373  3054  	MOVLW 0x54
0374  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
0375  3005  	MOVLW 0x05
0376  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
0377  3004  	MOVLW 0x04
0378  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlue2OnHour); // Display hour in digits 4 and 5 (dot on 5)
0379  085C  	MOVF gbl_gBcdBlue2OnHour, W
037A  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
037B  222D  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlue2OnMinute); // Display minute in digits 6 and 7 (no dot)
037C  085B  	MOVF gbl_gBcdBlue2OnMinute, W
037D  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
037E  222D  	CALL bcdTo7Seg_00000

                    break;
037F  2C2C  	GOTO	label84

                case 10:
02FC  3A03  	XORLW 0x03
02FD  1903  	BTFSC STATUS,Z
02FE  2B80  	GOTO	label67
0380        label67

                    // 2nd Blue LED on minute
                    iDigitToFlash = 7;
0380  3007  	MOVLW 0x07
0381  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0382  3006  	MOVLW 0x06
0383  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOnMinute); // Display minute in digits 6 and 7 (no dot)
0384  0857  	MOVF gbl_gBcdBlueOnMinute, W
0385  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0386  222D  	CALL bcdTo7Seg_00000

                    break;
0387  2C2C  	GOTO	label84

                case 11:
02FF  3A01  	XORLW 0x01
0300  1903  	BTFSC STATUS,Z
0301  2B88  	GOTO	label68
0388        label68

                    // 2nd Blue LED off hour
                    tm1638Data[3] = 0x71; // F
0388  3071  	MOVLW 0x71
0389  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
038A  3005  	MOVLW 0x05
038B  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
038C  3004  	MOVLW 0x04
038D  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlue2OffHour); // Display hour in digits 4 and 5 (dot on 5)
038E  085E  	MOVF gbl_gBcdBlue2OffHour, W
038F  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0390  222D  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlue2OffMinute); // Display minute in digits 6 and 7 (no dot)
0391  085D  	MOVF gbl_gBcdBlue2OffMinute, W
0392  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0393  222D  	CALL bcdTo7Seg_00000

                    break;
0394  2C2C  	GOTO	label84

                case 12:
0302  3A07  	XORLW 0x07
0303  1903  	BTFSC STATUS,Z
0304  2B95  	GOTO	label69
0395        label69

                    // 2nd Blue LED off minute
                    iDigitToFlash = 7;
0395  3007  	MOVLW 0x07
0396  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0397  3006  	MOVLW 0x06
0398  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlue2OffMinute); // Display minute in digits 6 and 7 (no dot)
0399  085D  	MOVF gbl_gBcdBlue2OffMinute, W
039A  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
039B  222D  	CALL bcdTo7Seg_00000

                    break;
039C  2C2C  	GOTO	label84

                case 13:
0305  3A01  	XORLW 0x01
0306  1903  	BTFSC STATUS,Z
0307  2B9D  	GOTO	label70
039D        label70

                    // Fan on temperature
                    tm1638Data[0] = 0x71; // F
039D  3071  	MOVLW 0x71
039E  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x5F; // a
039F  305F  	MOVLW 0x5F
03A0  00A1  	MOVWF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x54; // n
03A1  3054  	MOVLW 0x54
03A2  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x00; // space
03A3  01A3  	CLRF gbl_tm1638Data+D'3'

                    tm1638Data[4] = 0x3F; // O
03A4  303F  	MOVLW 0x3F
03A5  00A4  	MOVWF gbl_tm1638Data+D'4'

                    tm1638Data[5] = 0x54; // n
03A6  3054  	MOVLW 0x54
03A7  00A5  	MOVWF gbl_tm1638Data+D'5'

                    iDigitToFlash = 7;
03A8  3007  	MOVLW 0x07
03A9  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
03AA  3006  	MOVLW 0x06
03AB  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdFanOnTemp); // Display celcius in digits 6 and 7 (no dot)
03AC  085F  	MOVF gbl_gBcdFanOnTemp, W
03AD  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03AE  222D  	CALL bcdTo7Seg_00000

                    break;
03AF  2C2C  	GOTO	label84

                case 14:
0308  3A03  	XORLW 0x03
0309  1903  	BTFSC STATUS,Z
030A  2BB0  	GOTO	label71
03B0        label71

                    // Fan off temperature
                    tm1638Data[5] = 0x71; // f
03B0  3071  	MOVLW 0x71
03B1  00A5  	MOVWF gbl_tm1638Data+D'5'

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
03B2  3006  	MOVLW 0x06
03B3  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdFanOffTemp); // Display celcius in digits 6 and 7 (no dot)
03B4  0860  	MOVF gbl_gBcdFanOffTemp, W
03B5  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03B6  222D  	CALL bcdTo7Seg_00000

                    break;
03B7  2C2C  	GOTO	label84

                case 15:
030B  3A01  	XORLW 0x01
030C  1903  	BTFSC STATUS,Z
030D  2BB8  	GOTO	label72
03B8        label72

                    // Heater on temperature
                    tm1638Data[0] = 0x76; // H
03B8  3076  	MOVLW 0x76
03B9  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x7B; // e
03BA  307B  	MOVLW 0x7B
03BB  00A1  	MOVWF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x5F; // a
03BC  305F  	MOVLW 0x5F
03BD  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x78; // t
03BE  3078  	MOVLW 0x78
03BF  00A3  	MOVWF gbl_tm1638Data+D'3'

                    tm1638Data[4] = 0x3F; // O
03C0  303F  	MOVLW 0x3F
03C1  00A4  	MOVWF gbl_tm1638Data+D'4'

                    tm1638Data[5] = 0x54; // n
03C2  3054  	MOVLW 0x54
03C3  00A5  	MOVWF gbl_tm1638Data+D'5'

                    iDigitToFlash = 7;
03C4  3007  	MOVLW 0x07
03C5  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
03C6  3006  	MOVLW 0x06
03C7  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdHeaterOnTemp); // Display celcius in digits 6 and 7 (no dot)
03C8  0861  	MOVF gbl_gBcdHeaterOnTemp, W
03C9  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03CA  222D  	CALL bcdTo7Seg_00000

                    break;
03CB  2C2C  	GOTO	label84

                case 16:
030E  3A1F  	XORLW 0x1F
030F  1903  	BTFSC STATUS,Z
0310  2BCC  	GOTO	label73
03CC        label73

                    // Heater off temperature
                    tm1638Data[5] = 0x71; // f
03CC  3071  	MOVLW 0x71
03CD  00A5  	MOVWF gbl_tm1638Data+D'5'

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
03CE  3006  	MOVLW 0x06
03CF  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdHeaterOffTemp); // Display celcius in digits 6 and 7 (no dot)
03D0  0862  	MOVF gbl_gBcdHeaterOffTemp, W
03D1  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03D2  222D  	CALL bcdTo7Seg_00000

                    break;
            }
        } else {
03D3  2C2C  	GOTO	label84

            switch (gcSetMode) {
03F0        label80

                case 2:
03D4  0850  	MOVF gbl_gcSetMode, W
03D5  3A02  	XORLW 0x02
03D6  1903  	BTFSC STATUS,Z
03D7  2BE2  	GOTO	label75
03E2        label75

                    iDigitToFlash = 3;
03E2  3003  	MOVLW 0x03
03E3  00C8  	MOVWF gbl_iDigitToFlash

                    break;
03E4  2BF0  	GOTO	label80

                case 3:
03D8  3A01  	XORLW 0x01
03D9  1903  	BTFSC STATUS,Z
03DA  2BE5  	GOTO	label76
03E5        label76

                    iDigitToFlash = 1;
03E5  3001  	MOVLW 0x01
03E6  00C8  	MOVWF gbl_iDigitToFlash

                    break;
03E7  2BF0  	GOTO	label80

                case 6:
03DB  3A05  	XORLW 0x05
03DC  1903  	BTFSC STATUS,Z
03DD  2BE8  	GOTO	label77
03E8        label77

                    iDigitToFlash = 5;
03E8  3005  	MOVLW 0x05
03E9  00C8  	MOVWF gbl_iDigitToFlash

                    break;
03EA  2BF0  	GOTO	label80

                case 7:
03DE  3A01  	XORLW 0x01
03DF  1903  	BTFSC STATUS,Z
03E0  2BEB  	GOTO	label78
03EB        label78

                    iDigitToFlash = 7;
03EB  3007  	MOVLW 0x07
03EC  00C8  	MOVWF gbl_iDigitToFlash

                    break;
03ED  2BF0  	GOTO	label80

                default:
03E1  2BEE  	GOTO	label79
03EE        label79

                    iDigitToFlash = 8;
03EE  3008  	MOVLW 0x08
03EF  00C8  	MOVWF gbl_iDigitToFlash

            }
            // Display date DD.MM
            iPrintStartDigit = 0;
03F0  01ED  	CLRF gbl_iPrintStartDigit

            iPrintDotDigit = 1;
03F1  3001  	MOVLW 0x01
03F2  00EE  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(gBcdDayOfMonth); // Display day of month in digits 0 and 1 (+dot on 1)
03F3  0839  	MOVF gbl_gBcdDayOfMonth, W
03F4  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03F5  222D  	CALL bcdTo7Seg_00000

            iPrintDotDigit = 3;
03F6  3003  	MOVLW 0x03
03F7  00EE  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(gBcdMonth); // Display month in digits 2 and 3 (+dot on 3)
03F8  083A  	MOVF gbl_gBcdMonth, W
03F9  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03FA  222D  	CALL bcdTo7Seg_00000

        }
    } else {
03FB  2C2C  	GOTO	label84

        iDigitToFlash = 8; // No flashing digit in this mode
03FC  3008  	MOVLW 0x08
03FD  00C8  	MOVWF gbl_iDigitToFlash

        // translate DS3231 temperature to digit values
        iPrintDotDigit = 1;
03FE  3001  	MOVLW 0x01
03FF  00EE  	MOVWF gbl_iPrintDotDigit

        if (gcDisplayMode == 1) // no dot on the first two digits for fahrenheit
0400  034F  	DECF gbl_gcDisplayMode, W
0401  1D03  	BTFSS STATUS,Z
0402  2C05  	GOTO	label82
0405        label82

			iPrintDotDigit = 2;
0403  3002  	MOVLW 0x02
0404  00EE  	MOVWF gbl_iPrintDotDigit

        // For -10 or below, shift digits right
        if (gbDS3231IsMinus && (giDS3231ValueBCD & 0xF000)) {
0405  08CC  	MOVF gbl_gbDS3231IsMinus, F
0406  1903  	BTFSC STATUS,Z
0407  2C1A  	GOTO	label83
0408  30F0  	MOVLW 0xF0
0409  0534  	ANDWF gbl_giDS3231ValueBCD+D'1', W
040A  1903  	BTFSC STATUS,Z
040B  2C1A  	GOTO	label83
041A        label83

            giDS3231ValueBCD >>= 4;
040C  0D34  	RLF gbl_giDS3231ValueBCD+D'1', W
040D  0CB4  	RRF gbl_giDS3231ValueBCD+D'1', F
040E  0CB3  	RRF gbl_giDS3231ValueBCD, F
040F  0D34  	RLF gbl_giDS3231ValueBCD+D'1', W
0410  0CB4  	RRF gbl_giDS3231ValueBCD+D'1', F
0411  0CB3  	RRF gbl_giDS3231ValueBCD, F
0412  0D34  	RLF gbl_giDS3231ValueBCD+D'1', W
0413  0CB4  	RRF gbl_giDS3231ValueBCD+D'1', F
0414  0CB3  	RRF gbl_giDS3231ValueBCD, F
0415  0D34  	RLF gbl_giDS3231ValueBCD+D'1', W
0416  0CB4  	RRF gbl_giDS3231ValueBCD+D'1', F
0417  0CB3  	RRF gbl_giDS3231ValueBCD, F

            iPrintDotDigit = 2;
0418  3002  	MOVLW 0x02
0419  00EE  	MOVWF gbl_iPrintDotDigit

        }
        // Display current temperature in digits 0 to 3 (+dot on digit 1 and 3)
        iPrintStartDigit = 0;
041A  01ED  	CLRF gbl_iPrintStartDigit

        bcdTo7Seg(giDS3231ValueBCD >> 8);
041B  0834  	MOVF gbl_giDS3231ValueBCD+D'1', W
041C  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
041D  222D  	CALL bcdTo7Seg_00000

        bcdTo7Seg(giDS3231ValueBCD);
041E  0833  	MOVF gbl_giDS3231ValueBCD, W
041F  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0420  222D  	CALL bcdTo7Seg_00000

        // Also display dot on 4th digit (always)
		//tm1638Data[3] = tm1638Data[3] + tm1638Dot;
		tm1638Data[3] |= tm1638Dot;
0421  0865  	MOVF gbl_tm1638Dot, W
0422  04A3  	IORWF gbl_tm1638Data+D'3', F


        // left fill zero with blank
        if (tm1638Data[0] == 0x3F)
0423  0820  	MOVF gbl_tm1638Data, W
0424  3A3F  	XORLW 0x3F
0425  1903  	BTFSC STATUS,Z

            tm1638Data[0] = 0;
0426  01A0  	CLRF gbl_tm1638Data

        // If minus, overwrite left most digit with minus sign
        if (gbDS3231IsMinus)
0427  08CC  	MOVF gbl_gbDS3231IsMinus, F
0428  1903  	BTFSC STATUS,Z
0429  2C2C  	GOTO	label84
042C        label84

            tm1638Data[0] = 0x40;
042A  3040  	MOVLW 0x40
042B  00A0  	MOVWF gbl_tm1638Data

    }

    // HH.MM in last 4 digits of TM1638
    if (!gcTriggerMode) {
042C  08D2  	MOVF gbl_gcTriggerMode, F
042D  1D03  	BTFSS STATUS,Z
042E  2C67  	GOTO	label90
0467        label90

        iPrintStartDigit = 4;
042F  3004  	MOVLW 0x04
0430  00ED  	MOVWF gbl_iPrintStartDigit

        // Flash dot every second
        if (gBcdSecond.0)
0431  1C35  	BTFSS gbl_gBcdSecond,0
0432  2C36  	GOTO	label85
0436        label85

			iPrintDotDigit = 5;
0433  3005  	MOVLW 0x05
0434  00EE  	MOVWF gbl_iPrintDotDigit

		else
0435  2C38  	GOTO	label86
0438        label86

			iPrintDotDigit = 8;
0436  3008  	MOVLW 0x08
0437  00EE  	MOVWF gbl_iPrintDotDigit

        char cBcdHourDisp = gBcdHour;
0438  0837  	MOVF gbl_gBcdHour, W
0439  00F7  	MOVWF tm1638Upda_00022_190_cBcdH_00024

        if (gcHourMode && (gBcdHour > 0x12)) {
043A  08D1  	MOVF gbl_gcHourMode, F
043B  1903  	BTFSC STATUS,Z
043C  2C4C  	GOTO	label87
043D  0837  	MOVF gbl_gBcdHour, W
043E  3C12  	SUBLW 0x12
043F  1803  	BTFSC STATUS,C
0440  2C4C  	GOTO	label87

			// convert to 12h
			cBcdHourDisp -= 0x12;
0441  3012  	MOVLW 0x12
0442  02F7  	SUBWF tm1638Upda_00022_190_cBcdH_00024, F

			// For 8 and 9pm, take off another 6
			if ((cBcdHourDisp & 0x0F) > 7)
0443  300F  	MOVLW 0x0F
0444  0577  	ANDWF tm1638Upda_00022_190_cBcdH_00024, W
0445  00F8  	MOVWF CompTempVar602
0446  0878  	MOVF CompTempVar602, W
0447  3C07  	SUBLW 0x07
0448  1803  	BTFSC STATUS,C
0449  2C4C  	GOTO	label87
044C        label87

                cBcdHourDisp -= 6;
044A  3006  	MOVLW 0x06
044B  02F7  	SUBWF tm1638Upda_00022_190_cBcdH_00024, F

        }
        if (gcHourMode && gBcdHour == 0) {
044C  08D1  	MOVF gbl_gcHourMode, F
044D  1903  	BTFSC STATUS,Z
044E  2C54  	GOTO	label88
044F  08B7  	MOVF gbl_gBcdHour, F
0450  1D03  	BTFSS STATUS,Z
0451  2C54  	GOTO	label88
0454        label88

			cBcdHourDisp = 0x12; // 12am
0452  3012  	MOVLW 0x12
0453  00F7  	MOVWF tm1638Upda_00022_190_cBcdH_00024

        }
        bcdTo7Seg(cBcdHourDisp); // Display hour in digits 4 and 5 (dot on 5)
0454  0877  	MOVF tm1638Upda_00022_190_cBcdH_00024, W
0455  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0456  222D  	CALL bcdTo7Seg_00000

        // left fill zero with blank
        if (tm1638Data[4] == 0x3F)
0457  0824  	MOVF gbl_tm1638Data+D'4', W
0458  3A3F  	XORLW 0x3F
0459  1903  	BTFSC STATUS,Z

            tm1638Data[4] = 0;
045A  01A4  	CLRF gbl_tm1638Data+D'4'

        if (gcHourMode && (gBcdHour > 0x11)) {
045B  08D1  	MOVF gbl_gcHourMode, F
045C  1903  	BTFSC STATUS,Z
045D  2C64  	GOTO	label89
045E  0837  	MOVF gbl_gBcdHour, W
045F  3C11  	SUBLW 0x11
0460  1803  	BTFSC STATUS,C
0461  2C64  	GOTO	label89
0464        label89

			// PM dot
			iPrintDotDigit = 7;
0462  3007  	MOVLW 0x07
0463  00EE  	MOVWF gbl_iPrintDotDigit

        }
        bcdTo7Seg(gBcdMinute); // Display minute in digits 6 and 7 (no dot)
0464  0836  	MOVF gbl_gBcdMinute, W
0465  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0466  222D  	CALL bcdTo7Seg_00000

    }

    // Light LED for set mode
    char cCompareSetMode = gcSetMode;
0467  0850  	MOVF gbl_gcSetMode, W
0468  00F4  	MOVWF tm1638Upda_00022_1_cCompar_00023

    for (char i = 2; i < 8; i++) {
0469  3002  	MOVLW 0x02
046A  00F6  	MOVWF tm1638Upda_00022_3_i
046B        label91
046B  3008  	MOVLW 0x08
046C  0276  	SUBWF tm1638Upda_00022_3_i, W
046D  1803  	BTFSC STATUS,C
046E  2C84  	GOTO	label94
0482  0AF6  	INCF tm1638Upda_00022_3_i, F
0483  2C6B  	GOTO	label91
0484        label94

        if (i == cCompareSetMode)
046F  0874  	MOVF tm1638Upda_00022_1_cCompar_00023, W
0470  0676  	XORWF tm1638Upda_00022_3_i, W
0471  1D03  	BTFSS STATUS,Z
0472  2C7B  	GOTO	label92
047B        label92

            tm1638LEDs[i] = 1;
0473  1383  	BCF	STATUS,IRP
0474  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
0475  0084  	MOVWF FSR
0476  0876  	MOVF tm1638Upda_00022_3_i, W
0477  0784  	ADDWF FSR, F
0478  3001  	MOVLW 0x01
0479  0080  	MOVWF INDF

        else
047A  2C82  	GOTO	label93
0482        label93

            tm1638LEDs[i] = 0;
047B  1383  	BCF	STATUS,IRP
047C  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
047D  0084  	MOVWF FSR
047E  0876  	MOVF tm1638Upda_00022_3_i, W
047F  0784  	ADDWF FSR, F
0480  3000  	MOVLW 0x00
0481  0080  	MOVWF INDF

    }
    tm1638LEDs[0] = HEATER;
0484  01A8  	CLRF gbl_tm1638LEDs
0485  1805  	BTFSC gbl_porta,0
0486  0AA8  	INCF gbl_tm1638LEDs, F

    tm1638LEDs[1] = FAN;
0487  01A9  	CLRF gbl_tm1638LEDs+D'1'
0488  1885  	BTFSC gbl_porta,1
0489  0AA9  	INCF gbl_tm1638LEDs+D'1', F


    // Write 0x40 [01000000] (table 5.1) to indicate command to display data - [Write data to display register]
    tm1638strobe = 0;
048A  1186  	BCF gbl_portb,3

    tm1638ByteWrite(tm1638ByteSetData);
048B  0867  	MOVF gbl_tm1638ByteSetData, W
048C  00F6  	MOVWF tm1638Byte_0001F_arg_bWrite
048D  215B  	CALL tm1638Byte_0001F

    tm1638strobe = 1;
048E  1586  	BSF gbl_portb,3

    
    tm1638strobe = 0;
048F  1186  	BCF gbl_portb,3

    // Specify the display address 0xC0 [11000000] (table 5.2) [Display address 00H] then write out all 16 bytes
    tm1638ByteWrite(tm1638ByteSetAddr);
0490  0869  	MOVF gbl_tm1638ByteSetAddr, W
0491  00F6  	MOVWF tm1638Byte_0001F_arg_bWrite
0492  215B  	CALL tm1638Byte_0001F

    for (char i = 0; i < tm1638MaxDigits; i++) {
0493  01F5  	CLRF tm1638Upda_00022_2_i
0494        label95
0494  0863  	MOVF gbl_tm1638MaxDigits, W
0495  0275  	SUBWF tm1638Upda_00022_2_i, W
0496  1803  	BTFSC STATUS,C
0497  2CB3  	GOTO	label98
04B1  0AF5  	INCF tm1638Upda_00022_2_i, F
04B2  2C94  	GOTO	label95
04B3        label98

        // display digit first
        if (iFlashDigitOff.0 && (i == iDigitToFlash))
0498  1C3F  	BTFSS gbl_iFlashDigitOff,0
0499  2CA1  	GOTO	label96
049A  0848  	MOVF gbl_iDigitToFlash, W
049B  0675  	XORWF tm1638Upda_00022_2_i, W
049C  1D03  	BTFSS STATUS,Z
049D  2CA1  	GOTO	label96
04A1        label96

            tm1638ByteWrite(0);
049E  01F6  	CLRF tm1638Byte_0001F_arg_bWrite
049F  215B  	CALL tm1638Byte_0001F

        else
04A0  2CA9  	GOTO	label97
04A9        label97

            tm1638ByteWrite(tm1638Data[i]);
04A1  1383  	BCF	STATUS,IRP
04A2  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
04A3  0084  	MOVWF FSR
04A4  0875  	MOVF tm1638Upda_00022_2_i, W
04A5  0784  	ADDWF FSR, F
04A6  0800  	MOVF INDF, W
04A7  00F6  	MOVWF tm1638Byte_0001F_arg_bWrite
04A8  215B  	CALL tm1638Byte_0001F

        // then LED
        tm1638ByteWrite(tm1638LEDs[i]);
04A9  1383  	BCF	STATUS,IRP
04AA  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
04AB  0084  	MOVWF FSR
04AC  0875  	MOVF tm1638Upda_00022_2_i, W
04AD  0784  	ADDWF FSR, F
04AE  0800  	MOVF INDF, W
04AF  00F6  	MOVWF tm1638Byte_0001F_arg_bWrite
04B0  215B  	CALL tm1638Byte_0001F

    }
    tm1638strobe = 1;
04B3  1586  	BSF gbl_portb,3

}
04B4  0008  	RETURN


/*********************************************************************************************
  void tm1638ReadKeys()
  Reads the keys status into tm1638Keys
*********************************************************************************************/
void tm1638ReadKeys() {

    // Write 0x42 [01000010] to indicate command to read data
    tm1638strobe = 0;
07A9  1283  	BCF STATUS, RP0
07AA  1303  	BCF STATUS, RP1
07AB  1186  	BCF gbl_portb,3

    tm1638ByteWrite(tm1638ByteReadData);
07AC  0868  	MOVF gbl_tm1638ByteReadData, W
07AD  00F6  	MOVWF tm1638Byte_0001F_arg_bWrite
07AE  215B  	CALL tm1638Byte_0001F

    
    tm1638dioTris = 1; // Set data pin to input
07AF  1683  	BSF STATUS, RP0
07B0  1486  	BSF gbl_trisb,1

    char tm1638KeysTemp = 32;
07B1  3020  	MOVLW 0x20
07B2  1283  	BCF STATUS, RP0
07B3  00F2  	MOVWF tm1638Read_00025_1_tm1638K_00026

    // Read 4 bytes
    for (char i = 0; i < 32; i++) {
07B4  01F3  	CLRF tm1638Read_00025_2_i
07B5        label134
07B5  3020  	MOVLW 0x20
07B6  0273  	SUBWF tm1638Read_00025_2_i, W
07B7  1803  	BTFSC STATUS,C
07B8  2FC5  	GOTO	label136
07C3  0AF3  	INCF tm1638Read_00025_2_i, F
07C4  2FB5  	GOTO	label134
07C5        label136

        tm1638KeysTemp--;
07B9  03F2  	DECF tm1638Read_00025_1_tm1638K_00026, F

        tm1638clk = 0;
07BA  1106  	BCF gbl_portb,2

        delay_us(1);
07BB  3001  	MOVLW 0x01
07BC  00F8  	MOVWF delay_us_00000_arg_del
07BD  2010  	CALL delay_us_00000

        if(tm1638dio)
07BE  1C86  	BTFSS gbl_portb,1
07BF  2FC2  	GOTO	label135
07C2        label135

            tm1638KeysTemp <<= 1;
07C0  1003  	BCF STATUS,C
07C1  0DF2  	RLF tm1638Read_00025_1_tm1638K_00026, F

        tm1638clk = 1;
07C2  1506  	BSF gbl_portb,2

    }
    tm1638dioTris = 0; // Set data pin to output
07C5  1683  	BSF STATUS, RP0
07C6  1086  	BCF gbl_trisb,1

    tm1638strobe = 1;
07C7  1283  	BCF STATUS, RP0
07C8  1586  	BSF gbl_portb,3


    tm1638Keys = tm1638KeysTemp;
07C9  0872  	MOVF tm1638Read_00025_1_tm1638K_00026, W
07CA  00EB  	MOVWF gbl_tm1638Keys

    /*
    1F = 0001 1111
	17 = 0001 0111
	0F = 0000 1111
	07 = 0000 0111
	1B = 0001 1011
	13 = 0001 0011
	0B = 0000 1011
	03 = 0000 0111
	*/
}
07CB  0008  	RETURN


/*********************************************************************************************
  int intToBcd(int iValue)
  Used to split the 16 bit integer into bcd parts (max 9999)
*********************************************************************************************/
int intToBcd(int iValue) {

    int iBcdOut = 0;
018A  01FC  	CLRF intToBcd_00000_1_iBcdOut
018B  01FD  	CLRF intToBcd_00000_1_iBcdOut+D'1'

    // Split via loops = less program memory needed, may be slower executing
    // https://electronics.stackexchange.com/questions/158563/how-to-split-a-floating-point-number-into-individual-digits
    iBcdOut = 0;
018C  01FC  	CLRF intToBcd_00000_1_iBcdOut
018D  01FD  	CLRF intToBcd_00000_1_iBcdOut+D'1'


    // incrementing variables for each digit
    // determine to thousands digit
    while (iValue >= 1000) {
018E        label28
018E  3003  	MOVLW 0x03
018F  027B  	SUBWF intToBcd_00000_arg_iValue+D'1', W
0190  1D03  	BTFSS STATUS,Z
0191  2994  	GOTO	label29
0192  30E8  	MOVLW 0xE8
0193  027A  	SUBWF intToBcd_00000_arg_iValue, W
0194        label29
0194  1C03  	BTFSS STATUS,C
0195  29A1  	GOTO	label30
0196  1BFB  	BTFSC intToBcd_00000_arg_iValue+D'1',7
0197  29A1  	GOTO	label30
01A0  298E  	GOTO	label28
01A1        label30

        iValue -= 1000;
0198  30E8  	MOVLW 0xE8
0199  02FA  	SUBWF intToBcd_00000_arg_iValue, F
019A  3003  	MOVLW 0x03
019B  1C03  	BTFSS STATUS,C
019C  03FB  	DECF intToBcd_00000_arg_iValue+D'1', F
019D  02FB  	SUBWF intToBcd_00000_arg_iValue+D'1', F

        // each time we take off 1000, the digit is incremented
        iBcdOut += 0x1000;
019E  3010  	MOVLW 0x10
019F  07FD  	ADDWF intToBcd_00000_1_iBcdOut+D'1', F

    }

    // determine to hundreds digit
    while (iValue >= 100) {
01A1  087B  	MOVF intToBcd_00000_arg_iValue+D'1', W
01A2  3A80  	XORLW 0x80
01A3  00FE  	MOVWF CompTempVar651
01A4  3080  	MOVLW 0x80
01A5  027E  	SUBWF CompTempVar651, W
01A6  1D03  	BTFSS STATUS,Z
01A7  29AA  	GOTO	label31
01A8  3064  	MOVLW 0x64
01A9  027A  	SUBWF intToBcd_00000_arg_iValue, W
01AA        label31
01AA  1C03  	BTFSS STATUS,C
01AB  29B2  	GOTO	label32
01B1  29A1  	GOTO	label30
01B2        label32

        iValue -= 100;
01AC  3064  	MOVLW 0x64
01AD  02FA  	SUBWF intToBcd_00000_arg_iValue, F
01AE  1C03  	BTFSS STATUS,C
01AF  03FB  	DECF intToBcd_00000_arg_iValue+D'1', F

        // each time we take off 100, the digit is incremented
        iBcdOut += 0x100;
01B0  0AFD  	INCF intToBcd_00000_1_iBcdOut+D'1', F

    }

    // determine to tens digit
    while (iValue >= 10) {
01B2  087B  	MOVF intToBcd_00000_arg_iValue+D'1', W
01B3  3A80  	XORLW 0x80
01B4  00FE  	MOVWF CompTempVar652
01B5  3080  	MOVLW 0x80
01B6  027E  	SUBWF CompTempVar652, W
01B7  1D03  	BTFSS STATUS,Z
01B8  29BB  	GOTO	label33
01B9  300A  	MOVLW 0x0A
01BA  027A  	SUBWF intToBcd_00000_arg_iValue, W
01BB        label33
01BB  1C03  	BTFSS STATUS,C
01BC  29C6  	GOTO	label34
01C5  29B2  	GOTO	label32
01C6        label34

        iValue -= 10;
01BD  300A  	MOVLW 0x0A
01BE  02FA  	SUBWF intToBcd_00000_arg_iValue, F
01BF  1C03  	BTFSS STATUS,C
01C0  03FB  	DECF intToBcd_00000_arg_iValue+D'1', F

        // each time we take off 10, the left most digit is incremented
        iBcdOut += 0x10;
01C1  3010  	MOVLW 0x10
01C2  07FC  	ADDWF intToBcd_00000_1_iBcdOut, F
01C3  1803  	BTFSC STATUS,C
01C4  0AFD  	INCF intToBcd_00000_1_iBcdOut+D'1', F

    }

    // the last digit is what's left on iValue
    iBcdOut += iValue;
01C6  087A  	MOVF intToBcd_00000_arg_iValue, W
01C7  07FC  	ADDWF intToBcd_00000_1_iBcdOut, F
01C8  087B  	MOVF intToBcd_00000_arg_iValue+D'1', W
01C9  1803  	BTFSC STATUS,C
01CA  0AFD  	INCF intToBcd_00000_1_iBcdOut+D'1', F
01CB  07FD  	ADDWF intToBcd_00000_1_iBcdOut+D'1', F

}
01CC  0008  	RETURN


/*********************************************************************************************
  void convertTemp()
  Used to convert the ds18b20 temperature to display values
*********************************************************************************************/
void convertTemp() {

    // convert both bytes to a 16bit int - e.g. 0000 0001 0100 0110 (1 and 70, gives 326)
    signed int iTemp = (cTempH << 8) | cTempL;
0531  1283  	BCF STATUS, RP0
0532  1303  	BCF STATUS, RP1
0533  01F2  	CLRF convertTem_0002A_1_iTemp
0534  0849  	MOVF gbl_cTempH, W
0535  00F3  	MOVWF convertTem_0002A_1_iTemp+D'1'
0536  084A  	MOVF gbl_cTempL, W
0537  04F2  	IORWF convertTem_0002A_1_iTemp, F

    signed int iTemp2 = iTemp;
0538  0872  	MOVF convertTem_0002A_1_iTemp, W
0539  00F4  	MOVWF convertTem_0002A_1_iTemp2
053A  0873  	MOVF convertTem_0002A_1_iTemp+D'1', W
053B  00F5  	MOVWF convertTem_0002A_1_iTemp2+D'1'

    
    // this gets celcius * 100 - https://www.phanderson.com/PIC/PICC/sourceboost/ds18b20_1.html
    // Celcius value is always required for triggering
	gbDS3231IsMinus = (iTemp2 < 0);
053C  01CC  	CLRF gbl_gbDS3231IsMinus
053D  1BF5  	BTFSC convertTem_0002A_1_iTemp2+D'1',7
053E  0ACC  	INCF gbl_gbDS3231IsMinus, F

	if (gbDS3231IsMinus) {
053F  08CC  	MOVF gbl_gbDS3231IsMinus, F
0540  1903  	BTFSC STATUS,Z
0541  2D47  	GOTO	label101

		iTemp2 = ~iTemp2 + 1;
0542  09F4  	COMF convertTem_0002A_1_iTemp2, F
0543  09F5  	COMF convertTem_0002A_1_iTemp2+D'1', F
0544  0AF4  	INCF convertTem_0002A_1_iTemp2, F
0545  1903  	BTFSC STATUS,Z
0546  0AF5  	INCF convertTem_0002A_1_iTemp2+D'1', F
0547        label101

	}
    int iValueC = (6 * iTemp2) + (iTemp2 / 4);
0547  3006  	MOVLW 0x06
0548  00FA  	MOVWF __mul_16s__0000F_arg_a
0549  01FB  	CLRF __mul_16s__0000F_arg_a+D'1'
054A  0874  	MOVF convertTem_0002A_1_iTemp2, W
054B  00FC  	MOVWF __mul_16s__0000F_arg_b
054C  0875  	MOVF convertTem_0002A_1_iTemp2+D'1', W
054D  00FD  	MOVWF __mul_16s__0000F_arg_b+D'1'
054E  225F  	CALL __mul_16s__0000F
054F  1683  	BSF STATUS, RP0
0550  0822  	MOVF CompTempVarRet389, W
0551  1283  	BCF STATUS, RP0
0552  00F6  	MOVWF convertTem_0002A_1_iValueC
0553  1683  	BSF STATUS, RP0
0554  0823  	MOVF CompTempVarRet389+D'1', W
0555  1283  	BCF STATUS, RP0
0556  00F9  	MOVWF CompTempVar629
0557  0874  	MOVF convertTem_0002A_1_iTemp2, W
0558  00F8  	MOVWF CompTempVar626
0559  0875  	MOVF convertTem_0002A_1_iTemp2+D'1', W
055A  00F7  	MOVWF convertTem_0002A_1_iValueC+D'1'
055B  0D75  	RLF convertTem_0002A_1_iTemp2+D'1', W
055C  0CF7  	RRF convertTem_0002A_1_iValueC+D'1', F
055D  0CF8  	RRF CompTempVar626, F
055E  0D75  	RLF convertTem_0002A_1_iTemp2+D'1', W
055F  0CF7  	RRF convertTem_0002A_1_iValueC+D'1', F
0560  0CF8  	RRF CompTempVar626, F
0561  0878  	MOVF CompTempVar626, W
0562  07F6  	ADDWF convertTem_0002A_1_iValueC, F
0563  0879  	MOVF CompTempVar629, W
0564  1803  	BTFSC STATUS,C
0565  0AF7  	INCF convertTem_0002A_1_iValueC+D'1', F
0566  07F7  	ADDWF convertTem_0002A_1_iValueC+D'1', F

    // Split the temperature reading into digits
    giDS3231ValueBCD = intToBcd(iValueC);
0567  0876  	MOVF convertTem_0002A_1_iValueC, W
0568  00FA  	MOVWF intToBcd_00000_arg_iValue
0569  0877  	MOVF convertTem_0002A_1_iValueC+D'1', W
056A  00FB  	MOVWF intToBcd_00000_arg_iValue+D'1'
056B  218A  	CALL intToBcd_00000
056C  087C  	MOVF CompTempVarRet650, W
056D  00B3  	MOVWF gbl_giDS3231ValueBCD
056E  087D  	MOVF CompTempVarRet650+D'1', W
056F  00B4  	MOVWF gbl_giDS3231ValueBCD+D'1'

    // Truncated value for triggering heater/fans
    giDS3231ValueTruncCBCD = giDS3231ValueBCD >> 8;
0570  0834  	MOVF gbl_giDS3231ValueBCD+D'1', W
0571  00CB  	MOVWF gbl_giDS3231ValueTruncCBCD

    
    if (gcDisplayMode == 1) {
0572  034F  	DECF gbl_gcDisplayMode, W
0573  1D03  	BTFSS STATUS,Z

		// -17.8125 (-285/65251) results in minus fahrenheit (-0.125), -17.75 (-284/65250) results in positive fahrenheit (1)
        // this gets Fahrenheit * 10 - https://www.electro-tech-online.com/threads/temperature-sensor-ds18b20-display-fahrenhiet.117377/
        iTemp2 = ((iTemp + 4) / 8) + iTemp + 320;
0575  3004  	MOVLW 0x04
0576  0772  	ADDWF convertTem_0002A_1_iTemp, W
0577  00FB  	MOVWF CompTempVar641
0578  0873  	MOVF convertTem_0002A_1_iTemp+D'1', W
0579  00FD  	MOVWF CompTempVar644
057A  1803  	BTFSC STATUS,C
057B  0AFD  	INCF CompTempVar644, F
057C  087D  	MOVF CompTempVar644, W
057D  00FA  	MOVWF CompTempVar638
057E  0D7D  	RLF CompTempVar644, W
057F  0CFA  	RRF CompTempVar638, F
0580  0CFB  	RRF CompTempVar641, F
0581  0D7D  	RLF CompTempVar644, W
0582  0CFA  	RRF CompTempVar638, F
0583  0CFB  	RRF CompTempVar641, F
0584  0D7D  	RLF CompTempVar644, W
0585  0CFA  	RRF CompTempVar638, F
0586  0CFB  	RRF CompTempVar641, F
0587  0872  	MOVF convertTem_0002A_1_iTemp, W
0588  07FB  	ADDWF CompTempVar641, F
0589  0873  	MOVF convertTem_0002A_1_iTemp+D'1', W
058A  00FC  	MOVWF CompTempVar642
058B  087A  	MOVF CompTempVar638, W
058C  1803  	BTFSC STATUS,C
058D  0AFC  	INCF CompTempVar642, F
058E  07FC  	ADDWF CompTempVar642, F
058F  3040  	MOVLW 0x40
0590  07FB  	ADDWF CompTempVar641, F
0591  3001  	MOVLW 0x01
0592  1803  	BTFSC STATUS,C
0593  0AFC  	INCF CompTempVar642, F
0594  07FC  	ADDWF CompTempVar642, F
0595  087B  	MOVF CompTempVar641, W
0596  00F4  	MOVWF convertTem_0002A_1_iTemp2
0597  087C  	MOVF CompTempVar642, W
0598  00F5  	MOVWF convertTem_0002A_1_iTemp2+D'1'

        // convert to absolute value
        gbDS3231IsMinus = (iTemp2 < 0);
0599  01CC  	CLRF gbl_gbDS3231IsMinus
059A  1BF5  	BTFSC convertTem_0002A_1_iTemp2+D'1',7
059B  0ACC  	INCF gbl_gbDS3231IsMinus, F

        if (gbDS3231IsMinus) {
059C  08CC  	MOVF gbl_gbDS3231IsMinus, F
059D  1903  	BTFSC STATUS,Z
059E  2DA4  	GOTO	label102

            iTemp2 = ~iTemp2 + 1;
059F  09F4  	COMF convertTem_0002A_1_iTemp2, F
05A0  09F5  	COMF convertTem_0002A_1_iTemp2+D'1', F
05A1  0AF4  	INCF convertTem_0002A_1_iTemp2, F
05A2  1903  	BTFSC STATUS,Z
05A3  0AF5  	INCF convertTem_0002A_1_iTemp2+D'1', F
05A4        label102

        }
        // Split the temperature reading into digits
        giDS3231ValueBCD = intToBcd(iTemp2);
05A4  0874  	MOVF convertTem_0002A_1_iTemp2, W
05A5  00FA  	MOVWF intToBcd_00000_arg_iValue
05A6  0875  	MOVF convertTem_0002A_1_iTemp2+D'1', W
05A7  00FB  	MOVWF intToBcd_00000_arg_iValue+D'1'
05A8  218A  	CALL intToBcd_00000
05A9  087C  	MOVF CompTempVarRet650, W
05AA  00B3  	MOVWF gbl_giDS3231ValueBCD
05AB  087D  	MOVF CompTempVarRet650+D'1', W
05AC  00B4  	MOVWF gbl_giDS3231ValueBCD+D'1'

	}
}
0574  0008  	RETURN
05AD  0008  	RETURN


/*********************************************************************************************
  void startTemp()
  Sends the Convert T [44h] function command to the ds18b20
*********************************************************************************************/
void startTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // 44 is the convert function
    oneWireTxBytes(0xCC, 0x44);
07CC  30CC  	MOVLW 0xCC
07CD  1283  	BCF STATUS, RP0
07CE  1303  	BCF STATUS, RP1
07CF  00F2  	MOVWF oneWireTxB_00019_arg_cData
07D0  3044  	MOVLW 0x44
07D1  00F3  	MOVWF oneWireTxB_00019_arg_cData2
07D2  24BD  	CALL oneWireTxB_00019

}
07D3  0008  	RETURN


/*********************************************************************************************
  void startTemp()
  Sends the Read Scratchpad [BEh] function command to the ds18b20
*********************************************************************************************/
void readTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // BE indicates to read scratchpad
    oneWireTxBytes(0xCC, 0xBE);
07D4  30CC  	MOVLW 0xCC
07D5  1283  	BCF STATUS, RP0
07D6  1303  	BCF STATUS, RP1
07D7  00F2  	MOVWF oneWireTxB_00019_arg_cData
07D8  30BE  	MOVLW 0xBE
07D9  00F3  	MOVWF oneWireTxB_00019_arg_cData2
07DA  24BD  	CALL oneWireTxB_00019

    // Now get the temperature from the scratchpad
    // This is in the first two bytes - so get those only and ignore the rest
    cTempL = oneWireRxByte();
07DB  24C4  	CALL oneWireRxB_0001A
07DC  0873  	MOVF CompTempVarRet551, W
07DD  00CA  	MOVWF gbl_cTempL

    cTempH = oneWireRxByte();
07DE  24C4  	CALL oneWireRxB_0001A
07DF  0873  	MOVF CompTempVarRet551, W
07E0  00C9  	MOVWF gbl_cTempH

}
07E1  0008  	RETURN


/*********************************************************************************************
  char bcdAdjust(char bcd, char bcdMax, char bcdMin)
  Increment or Decrement a BCD variable for sending to the DS3231, within a given range
  Must set iBcdAdjustment first
*********************************************************************************************/
char bcdAdjust(char bcd, char bcdMax, char bcdMin) {

    if (iBcdAdjustment == 1) {
0235  036F  	DECF gbl_iBcdAdjustment, W
0236  1D03  	BTFSS STATUS,Z
0237  2A4B  	GOTO	label46
024B        label46

        // Increment
        // if at maximum, reset to minimum
        if (bcd == bcdMax)
0238  0875  	MOVF bcdAdjust_00000_arg_bcdMax, W
0239  0674  	XORWF bcdAdjust_00000_arg_bcd, W
023A  1D03  	BTFSS STATUS,Z
023B  2A3F  	GOTO	label44
023F        label44

            bcd = bcdMin;
023C  0876  	MOVF bcdAdjust_00000_arg_bcdMin, W
023D  00F4  	MOVWF bcdAdjust_00000_arg_bcd

        else if ((bcd & 0x0F) == 9)
023E  2A5C  	GOTO	label49
023F  300F  	MOVLW 0x0F
0240  0574  	ANDWF bcdAdjust_00000_arg_bcd, W
0241  00F7  	MOVWF CompTempVar615
0242  0877  	MOVF CompTempVar615, W
0243  3A09  	XORLW 0x09
0244  1D03  	BTFSS STATUS,Z
0245  2A49  	GOTO	label45
0249        label45

            bcd += 0x07; // add 0x10 (16), minus 9
0246  3007  	MOVLW 0x07
0247  07F4  	ADDWF bcdAdjust_00000_arg_bcd, F

        else
0248  2A5C  	GOTO	label49

            bcd++;
0249  0AF4  	INCF bcdAdjust_00000_arg_bcd, F

    } else {
024A  2A5C  	GOTO	label49

        // Decrement
        // if at minimum, reset to maximum
        if (bcd == bcdMin)
024B  0876  	MOVF bcdAdjust_00000_arg_bcdMin, W
024C  0674  	XORWF bcdAdjust_00000_arg_bcd, W
024D  1D03  	BTFSS STATUS,Z
024E  2A52  	GOTO	label47
0252        label47

            bcd = bcdMax;
024F  0875  	MOVF bcdAdjust_00000_arg_bcdMax, W
0250  00F4  	MOVWF bcdAdjust_00000_arg_bcd

        else if ((bcd & 0x0F) == 0)
0251  2A5C  	GOTO	label49
0252  300F  	MOVLW 0x0F
0253  0574  	ANDWF bcdAdjust_00000_arg_bcd, W
0254  00F7  	MOVWF CompTempVar616
0255  08F7  	MOVF CompTempVar616, F
0256  1D03  	BTFSS STATUS,Z
0257  2A5B  	GOTO	label48
025B        label48

            bcd -= 0x07; // minus 0x10 (16), add 9
0258  3007  	MOVLW 0x07
0259  02F4  	SUBWF bcdAdjust_00000_arg_bcd, F

        else
025A  2A5C  	GOTO	label49
025C        label49

            bcd--;
025B  03F4  	DECF bcdAdjust_00000_arg_bcd, F

    }
    return bcd;
025C  0874  	MOVF bcdAdjust_00000_arg_bcd, W
025D  00F7  	MOVWF CompTempVarRet614

}
025E  0008  	RETURN


/*********************************************************************************************
  void adjustDateTime()
  Increment or Decrement a BCD variable for sending to the DS3231, within a given range
  Must set iBcdAdjustment first
*********************************************************************************************/
void adjustDateTime() {

    switch (gcSetMode) {

        case 1:
0724  1283  	BCF STATUS, RP0
0725  1303  	BCF STATUS, RP1
0726  0850  	MOVF gbl_gcSetMode, W
0727  3A01  	XORLW 0x01
0728  1903  	BTFSC STATUS,Z
0729  2F3D  	GOTO	label123
073D        label123

            // Setting year
            gBcdYear = bcdAdjust(gBcdYear, 0x99, 0x00);
073D  083B  	MOVF gbl_gBcdYear, W
073E  00F4  	MOVWF bcdAdjust_00000_arg_bcd
073F  3099  	MOVLW 0x99
0740  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
0741  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
0742  2235  	CALL bcdAdjust_00000
0743  0877  	MOVF CompTempVarRet614, W
0744  00BB  	MOVWF gbl_gBcdYear

            break;
        case 2:
072A  3A03  	XORLW 0x03
072B  1903  	BTFSC STATUS,Z
072C  2F46  	GOTO	label124
0746        label124

            // Setting month
            gBcdMonth = bcdAdjust(gBcdMonth, 0x12, 0x01);
0746  083A  	MOVF gbl_gBcdMonth, W
0747  00F4  	MOVWF bcdAdjust_00000_arg_bcd
0748  3012  	MOVLW 0x12
0749  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
074A  3001  	MOVLW 0x01
074B  00F6  	MOVWF bcdAdjust_00000_arg_bcdMin
074C  2235  	CALL bcdAdjust_00000
074D  0877  	MOVF CompTempVarRet614, W
074E  00BA  	MOVWF gbl_gBcdMonth

            break;
        case 3:
072D  3A01  	XORLW 0x01
072E  1903  	BTFSC STATUS,Z
072F  2F50  	GOTO	label125
0750        label125

            // Setting day of month
            char iMonth = gBcdMonth;
0750  083A  	MOVF gbl_gBcdMonth, W
0751  00F2  	MOVWF adjustDate_00027_1_iMonth

            if (iMonth & 0xF0)
0752  30F0  	MOVLW 0xF0
0753  0572  	ANDWF adjustDate_00027_1_iMonth, W
0754  1903  	BTFSC STATUS,Z
0755  2F5B  	GOTO	label126
075B        label126

                iMonth += (gBcdMonth >> 4);
0756  0E3A  	SWAPF gbl_gBcdMonth, W
0757  390F  	ANDLW 0x0F
0758  00F4  	MOVWF CompTempVar617
0759  0874  	MOVF CompTempVar617, W
075A  07F2  	ADDWF adjustDate_00027_1_iMonth, F

            iMonth--; // Make 0 to 11 index based
075B  03F2  	DECF adjustDate_00027_1_iMonth, F

            char bcdMaxDay = gDaysInMonth[iMonth]; 
075C  083C  	MOVF gbl_gDaysInMonth, W
075D  00FB  	MOVWF __rom_get_00000_arg_objNumb
075E  0872  	MOVF adjustDate_00027_1_iMonth, W
075F  00FC  	MOVWF __rom_get_00000_arg_idx
0760  201A  	CALL __rom_get_00000
0761  00F3  	MOVWF adjustDate_00027_1_bcdMaxDay

            // If February, adjust max days for leap years
            if (iMonth == 1) {
0762  0372  	DECF adjustDate_00027_1_iMonth, W
0763  118A  	BCF PCLATH,3
0764  120A  	BCF PCLATH,4
0765  1D03  	BTFSS STATUS,Z
0766  2F7D  	GOTO	label129

                // See if the 24 leap years since 2000 match the current year
                for (char i = 0; i < 24; i++) {
0767  01F4  	CLRF adjustDate_00027_16_i
0768        label127
0768  3018  	MOVLW 0x18
0769  0274  	SUBWF adjustDate_00027_16_i, W
076A  1803  	BTFSC STATUS,C
076B  2F7D  	GOTO	label129
077B  0AF4  	INCF adjustDate_00027_16_i, F
077C  2F68  	GOTO	label127
077D        label129

                    if (gLeapYears[i] == gBcdYear) {
076C  083D  	MOVF gbl_gLeapYears, W
076D  00FB  	MOVWF __rom_get_00000_arg_objNumb
076E  0874  	MOVF adjustDate_00027_16_i, W
076F  00FC  	MOVWF __rom_get_00000_arg_idx
0770  201A  	CALL __rom_get_00000
0771  00F5  	MOVWF CompTempVar618
0772  083B  	MOVF gbl_gBcdYear, W
0773  0675  	XORWF CompTempVar618, W
0774  118A  	BCF PCLATH,3
0775  120A  	BCF PCLATH,4
0776  1D03  	BTFSS STATUS,Z
0777  2F7B  	GOTO	label128
077B        label128

                        bcdMaxDay = 0x29;
0778  3029  	MOVLW 0x29
0779  00F3  	MOVWF adjustDate_00027_1_bcdMaxDay

                        break;
077A  2F7D  	GOTO	label129

                    }
                }
            }
            gBcdDayOfMonth = bcdAdjust(gBcdDayOfMonth, bcdMaxDay, 0x01);
077D  0839  	MOVF gbl_gBcdDayOfMonth, W
077E  00F4  	MOVWF bcdAdjust_00000_arg_bcd
077F  0873  	MOVF adjustDate_00027_1_bcdMaxDay, W
0780  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
0781  3001  	MOVLW 0x01
0782  00F6  	MOVWF bcdAdjust_00000_arg_bcdMin
0783  2235  	CALL bcdAdjust_00000
0784  0877  	MOVF CompTempVarRet614, W
0785  00B9  	MOVWF gbl_gBcdDayOfMonth

            break;
        case 4:
0730  3A07  	XORLW 0x07
0731  1903  	BTFSC STATUS,Z
0732  2F87  	GOTO	label130
0787        label130

            // Setting day of week
            gDayOfWeek = bcdAdjust(gDayOfWeek, 0x07, 0x01);
0787  0838  	MOVF gbl_gDayOfWeek, W
0788  00F4  	MOVWF bcdAdjust_00000_arg_bcd
0789  3007  	MOVLW 0x07
078A  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
078B  3001  	MOVLW 0x01
078C  00F6  	MOVWF bcdAdjust_00000_arg_bcdMin
078D  2235  	CALL bcdAdjust_00000
078E  0877  	MOVF CompTempVarRet614, W
078F  00B8  	MOVWF gbl_gDayOfWeek

            break;
        case 5:
0733  3A01  	XORLW 0x01
0734  1903  	BTFSC STATUS,Z
0735  2F91  	GOTO	label131
0791        label131

            // Setting 12h/24h
            gcHourMode++;
0791  0AD1  	INCF gbl_gcHourMode, F

            if (gcHourMode > 2)
0792  0851  	MOVF gbl_gcHourMode, W
0793  3C02  	SUBLW 0x02
0794  1C03  	BTFSS STATUS,C

				gcHourMode = 0;
0795  01D1  	CLRF gbl_gcHourMode

            break;
        case 6:
0736  3A03  	XORLW 0x03
0737  1903  	BTFSC STATUS,Z
0738  2F97  	GOTO	label132
0797        label132

            // Setting hour
            gBcdHour = bcdAdjust(gBcdHour, 0x23, 0x00);
0797  0837  	MOVF gbl_gBcdHour, W
0798  00F4  	MOVWF bcdAdjust_00000_arg_bcd
0799  3023  	MOVLW 0x23
079A  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
079B  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
079C  2235  	CALL bcdAdjust_00000
079D  0877  	MOVF CompTempVarRet614, W
079E  00B7  	MOVWF gbl_gBcdHour

            break;
        case 7:
0739  3A01  	XORLW 0x01
073A  1903  	BTFSC STATUS,Z
073B  2FA0  	GOTO	label133
07A0        label133

            // Setting minute
            gBcdMinute = bcdAdjust(gBcdMinute, 0x59, 0x00);
07A0  0836  	MOVF gbl_gBcdMinute, W
07A1  00F4  	MOVWF bcdAdjust_00000_arg_bcd
07A2  3059  	MOVLW 0x59
07A3  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
07A4  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
07A5  2235  	CALL bcdAdjust_00000
07A6  0877  	MOVF CompTempVarRet614, W
07A7  00B6  	MOVWF gbl_gBcdMinute

            break;
    }
}
073C  0008  	RETURN
0745  0008  	RETURN
074F  0008  	RETURN
0786  0008  	RETURN
0790  0008  	RETURN
0796  0008  	RETURN
079F  0008  	RETURN
07A8  0008  	RETURN


/*********************************************************************************************
  void adjustTrigger()
  Increment or Decrement a trigger time or temperate
  Must set iBcdAdjustment first
*********************************************************************************************/
void adjustTrigger() {

    switch (gcTriggerMode) {

        case 1:
0651  1283  	BCF STATUS, RP0
0652  1303  	BCF STATUS, RP1
0653  0852  	MOVF gbl_gcTriggerMode, W
0654  3A01  	XORLW 0x01
0655  1903  	BTFSC STATUS,Z
0656  2E85  	GOTO	label105
0685        label105

            // White LED on hour
            gBcdWhiteOnHour = bcdAdjust(gBcdWhiteOnHour, 0x23, 0x00);
0685  0854  	MOVF gbl_gBcdWhiteOnHour, W
0686  00F4  	MOVWF bcdAdjust_00000_arg_bcd
0687  3023  	MOVLW 0x23
0688  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
0689  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
068A  2235  	CALL bcdAdjust_00000
068B  0877  	MOVF CompTempVarRet614, W
068C  00D4  	MOVWF gbl_gBcdWhiteOnHour

            break;
        case 2:
0657  3A03  	XORLW 0x03
0658  1903  	BTFSC STATUS,Z
0659  2E8E  	GOTO	label106
068E        label106

            // White LED on minute
            gBcdWhiteOnMinute = bcdAdjust(gBcdWhiteOnMinute, 0x59, 0x00);
068E  0853  	MOVF gbl_gBcdWhiteOnMinute, W
068F  00F4  	MOVWF bcdAdjust_00000_arg_bcd
0690  3059  	MOVLW 0x59
0691  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
0692  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
0693  2235  	CALL bcdAdjust_00000
0694  0877  	MOVF CompTempVarRet614, W
0695  00D3  	MOVWF gbl_gBcdWhiteOnMinute

            break;
        case 3:
065A  3A01  	XORLW 0x01
065B  1903  	BTFSC STATUS,Z
065C  2E97  	GOTO	label107
0697        label107

            // White LED off hour
            gBcdWhiteOffHour = bcdAdjust(gBcdWhiteOffHour, 0x23, 0x00);
0697  0856  	MOVF gbl_gBcdWhiteOffHour, W
0698  00F4  	MOVWF bcdAdjust_00000_arg_bcd
0699  3023  	MOVLW 0x23
069A  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
069B  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
069C  2235  	CALL bcdAdjust_00000
069D  0877  	MOVF CompTempVarRet614, W
069E  00D6  	MOVWF gbl_gBcdWhiteOffHour

            break;
        case 4:
065D  3A07  	XORLW 0x07
065E  1903  	BTFSC STATUS,Z
065F  2EA0  	GOTO	label108
06A0        label108

            // White LED off minute
            gBcdWhiteOffMinute = bcdAdjust(gBcdWhiteOffMinute, 0x59, 0x00);
06A0  0855  	MOVF gbl_gBcdWhiteOffMinute, W
06A1  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06A2  3059  	MOVLW 0x59
06A3  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06A4  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06A5  2235  	CALL bcdAdjust_00000
06A6  0877  	MOVF CompTempVarRet614, W
06A7  00D5  	MOVWF gbl_gBcdWhiteOffMinute

            break;
        case 5:
0660  3A01  	XORLW 0x01
0661  1903  	BTFSC STATUS,Z
0662  2EA9  	GOTO	label109
06A9        label109

            // Blue LED on hour
            gBcdBlueOnHour = bcdAdjust(gBcdBlueOnHour, 0x23, 0x00);
06A9  0858  	MOVF gbl_gBcdBlueOnHour, W
06AA  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06AB  3023  	MOVLW 0x23
06AC  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06AD  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06AE  2235  	CALL bcdAdjust_00000
06AF  0877  	MOVF CompTempVarRet614, W
06B0  00D8  	MOVWF gbl_gBcdBlueOnHour

            break;
        case 6:
0663  3A03  	XORLW 0x03
0664  1903  	BTFSC STATUS,Z
0665  2EB2  	GOTO	label110
06B2        label110

            // Blue LED on minute
            gBcdBlueOnMinute = bcdAdjust(gBcdBlueOnMinute, 0x59, 0x00);
06B2  0857  	MOVF gbl_gBcdBlueOnMinute, W
06B3  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06B4  3059  	MOVLW 0x59
06B5  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06B6  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06B7  2235  	CALL bcdAdjust_00000
06B8  0877  	MOVF CompTempVarRet614, W
06B9  00D7  	MOVWF gbl_gBcdBlueOnMinute

            break;
        case 7:
0666  3A01  	XORLW 0x01
0667  1903  	BTFSC STATUS,Z
0668  2EBB  	GOTO	label111
06BB        label111

            // Blue LED off hour
            gBcdBlueOffHour = bcdAdjust(gBcdBlueOffHour, 0x23, 0x00);
06BB  085A  	MOVF gbl_gBcdBlueOffHour, W
06BC  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06BD  3023  	MOVLW 0x23
06BE  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06BF  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06C0  2235  	CALL bcdAdjust_00000
06C1  0877  	MOVF CompTempVarRet614, W
06C2  00DA  	MOVWF gbl_gBcdBlueOffHour

            break;
        case 8:
0669  3A0F  	XORLW 0x0F
066A  1903  	BTFSC STATUS,Z
066B  2EC4  	GOTO	label112
06C4        label112

            // Blue LED off minute
            gBcdBlueOffMinute = bcdAdjust(gBcdBlueOffMinute, 0x59, 0x00);
06C4  0859  	MOVF gbl_gBcdBlueOffMinute, W
06C5  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06C6  3059  	MOVLW 0x59
06C7  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06C8  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06C9  2235  	CALL bcdAdjust_00000
06CA  0877  	MOVF CompTempVarRet614, W
06CB  00D9  	MOVWF gbl_gBcdBlueOffMinute

            break;
        case 9:
066C  3A01  	XORLW 0x01
066D  1903  	BTFSC STATUS,Z
066E  2ECD  	GOTO	label113
06CD        label113

            // Blue LED on hour
            gBcdBlue2OnHour = bcdAdjust(gBcdBlue2OnHour, 0x23, 0x00);
06CD  085C  	MOVF gbl_gBcdBlue2OnHour, W
06CE  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06CF  3023  	MOVLW 0x23
06D0  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06D1  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06D2  2235  	CALL bcdAdjust_00000
06D3  0877  	MOVF CompTempVarRet614, W
06D4  00DC  	MOVWF gbl_gBcdBlue2OnHour

            break;
        case 10:
066F  3A03  	XORLW 0x03
0670  1903  	BTFSC STATUS,Z
0671  2ED6  	GOTO	label114
06D6        label114

            // Blue LED on minute
            gBcdBlue2OnMinute = bcdAdjust(gBcdBlue2OnMinute, 0x59, 0x00);
06D6  085B  	MOVF gbl_gBcdBlue2OnMinute, W
06D7  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06D8  3059  	MOVLW 0x59
06D9  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06DA  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06DB  2235  	CALL bcdAdjust_00000
06DC  0877  	MOVF CompTempVarRet614, W
06DD  00DB  	MOVWF gbl_gBcdBlue2OnMinute

            break;
        case 11:
0672  3A01  	XORLW 0x01
0673  1903  	BTFSC STATUS,Z
0674  2EDF  	GOTO	label115
06DF        label115

            // Blue LED off hour
            gBcdBlue2OffHour = bcdAdjust(gBcdBlue2OffHour, 0x23, 0x00);
06DF  085E  	MOVF gbl_gBcdBlue2OffHour, W
06E0  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06E1  3023  	MOVLW 0x23
06E2  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06E3  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06E4  2235  	CALL bcdAdjust_00000
06E5  0877  	MOVF CompTempVarRet614, W
06E6  00DE  	MOVWF gbl_gBcdBlue2OffHour

            break;
        case 12:
0675  3A07  	XORLW 0x07
0676  1903  	BTFSC STATUS,Z
0677  2EE8  	GOTO	label116
06E8        label116

            // Blue LED off minute
            gBcdBlue2OffMinute = bcdAdjust(gBcdBlue2OffMinute, 0x59, 0x00);
06E8  085D  	MOVF gbl_gBcdBlue2OffMinute, W
06E9  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06EA  3059  	MOVLW 0x59
06EB  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06EC  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06ED  2235  	CALL bcdAdjust_00000
06EE  0877  	MOVF CompTempVarRet614, W
06EF  00DD  	MOVWF gbl_gBcdBlue2OffMinute

            break;
        case 13:
0678  3A01  	XORLW 0x01
0679  1903  	BTFSC STATUS,Z
067A  2EF1  	GOTO	label117
06F1        label117

            // Fan on temp - between 20 and 40 degrees C
            gBcdFanOnTemp = bcdAdjust(gBcdFanOnTemp, 0x40, 0x20);
06F1  085F  	MOVF gbl_gBcdFanOnTemp, W
06F2  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06F3  3040  	MOVLW 0x40
06F4  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06F5  3020  	MOVLW 0x20
06F6  00F6  	MOVWF bcdAdjust_00000_arg_bcdMin
06F7  2235  	CALL bcdAdjust_00000
06F8  0877  	MOVF CompTempVarRet614, W
06F9  00DF  	MOVWF gbl_gBcdFanOnTemp

            break;
        case 14:
067B  3A03  	XORLW 0x03
067C  1903  	BTFSC STATUS,Z
067D  2EFB  	GOTO	label118
06FB        label118

            // Fan off temp - off must be lower than on, min 20 degrees C
            if (gBcdFanOffTemp > gBcdFanOnTemp)
06FB  0860  	MOVF gbl_gBcdFanOffTemp, W
06FC  025F  	SUBWF gbl_gBcdFanOnTemp, W
06FD  1803  	BTFSC STATUS,C
06FE  2F01  	GOTO	label119
0701        label119

				gBcdFanOffTemp = gBcdFanOnTemp;
06FF  085F  	MOVF gbl_gBcdFanOnTemp, W
0700  00E0  	MOVWF gbl_gBcdFanOffTemp

            gBcdFanOffTemp = bcdAdjust(gBcdFanOffTemp, gBcdFanOnTemp, 0x20);
0701  0860  	MOVF gbl_gBcdFanOffTemp, W
0702  00F4  	MOVWF bcdAdjust_00000_arg_bcd
0703  085F  	MOVF gbl_gBcdFanOnTemp, W
0704  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
0705  3020  	MOVLW 0x20
0706  00F6  	MOVWF bcdAdjust_00000_arg_bcdMin
0707  2235  	CALL bcdAdjust_00000
0708  0877  	MOVF CompTempVarRet614, W
0709  00E0  	MOVWF gbl_gBcdFanOffTemp

            break;
        case 15:
067E  3A01  	XORLW 0x01
067F  1903  	BTFSC STATUS,Z
0680  2F0B  	GOTO	label120
070B        label120

            // Heater on temp - between 0 and 40 degrees C
            gBcdHeaterOnTemp = bcdAdjust(gBcdHeaterOnTemp, 0x40, 0);
070B  0861  	MOVF gbl_gBcdHeaterOnTemp, W
070C  00F4  	MOVWF bcdAdjust_00000_arg_bcd
070D  3040  	MOVLW 0x40
070E  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
070F  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
0710  2235  	CALL bcdAdjust_00000
0711  0877  	MOVF CompTempVarRet614, W
0712  00E1  	MOVWF gbl_gBcdHeaterOnTemp

            break;
        case 16:
0681  3A1F  	XORLW 0x1F
0682  1903  	BTFSC STATUS,Z
0683  2F14  	GOTO	label121
0714        label121

            // Heater off temp - off must be equal or higher than on - max 40 degrees C
            if (gBcdHeaterOffTemp < gBcdHeaterOnTemp)
0714  0861  	MOVF gbl_gBcdHeaterOnTemp, W
0715  0262  	SUBWF gbl_gBcdHeaterOffTemp, W
0716  1803  	BTFSC STATUS,C
0717  2F1A  	GOTO	label122
071A        label122

				gBcdHeaterOffTemp = gBcdHeaterOnTemp;
0718  0861  	MOVF gbl_gBcdHeaterOnTemp, W
0719  00E2  	MOVWF gbl_gBcdHeaterOffTemp

            gBcdHeaterOffTemp = bcdAdjust(gBcdHeaterOffTemp, 0x40, gBcdHeaterOnTemp);
071A  0862  	MOVF gbl_gBcdHeaterOffTemp, W
071B  00F4  	MOVWF bcdAdjust_00000_arg_bcd
071C  3040  	MOVLW 0x40
071D  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
071E  0861  	MOVF gbl_gBcdHeaterOnTemp, W
071F  00F6  	MOVWF bcdAdjust_00000_arg_bcdMin
0720  2235  	CALL bcdAdjust_00000
0721  0877  	MOVF CompTempVarRet614, W
0722  00E2  	MOVWF gbl_gBcdHeaterOffTemp

            break;
    }
}
0684  0008  	RETURN
068D  0008  	RETURN
0696  0008  	RETURN
069F  0008  	RETURN
06A8  0008  	RETURN
06B1  0008  	RETURN
06BA  0008  	RETURN
06C3  0008  	RETURN
06CC  0008  	RETURN
06D5  0008  	RETURN
06DE  0008  	RETURN
06E7  0008  	RETURN
06F0  0008  	RETURN
06FA  0008  	RETURN
070A  0008  	RETURN
0713  0008  	RETURN
0723  0008  	RETURN


/*********************************************************************************************
  void processKeys()
  Action a key press
*********************************************************************************************/
void processKeys() {

    switch (tm1638Keys) {

        case 0x1F:
07E2  1283  	BCF STATUS, RP0
07E3  1303  	BCF STATUS, RP1
07E4  086B  	MOVF gbl_tm1638Keys, W
07E5  3A1F  	XORLW 0x1F
07E6  1903  	BTFSC STATUS,Z
07E7  2FFF  	GOTO	label137
07FF        label137

            // Toggle white light on/off
            WHITE_LED = !WHITE_LED;
07FF  01F2  	CLRF CompTempVar619
0800  1C87  	BTFSS gbl_portc,1
0801  0AF2  	INCF CompTempVar619, F
0802  1872  	BTFSC CompTempVar619,0
0803  1487  	BSF gbl_portc,1
0804  1C72  	BTFSS CompTempVar619,0
0805  1087  	BCF gbl_portc,1

            break;
        case 0x17:
07E8  3A08  	XORLW 0x08
07E9  158A  	BSF PCLATH,3
07EA  1903  	BTFSC STATUS,Z
07EB  2807  	GOTO	label138
0807        label138

            // Toggle blue light on/off
            BLUE_LED = !BLUE_LED;
0807  01F2  	CLRF CompTempVar620
0808  1D07  	BTFSS gbl_portc,2
0809  0AF2  	INCF CompTempVar620, F
080A  1872  	BTFSC CompTempVar620,0
080B  1507  	BSF gbl_portc,2
080C  1C72  	BTFSS CompTempVar620,0
080D  1107  	BCF gbl_portc,2

            break;
        case 0x0F:
07EC  3A18  	XORLW 0x18
07ED  1903  	BTFSC STATUS,Z
07EE  280F  	GOTO	label139
080F        label139

            // Toggle fan on/off
            gbFanOn = !gbFanOn;
080F  01F2  	CLRF CompTempVar621
0810  1D4E  	BTFSS gbl_gbFanOn,2
0811  0AF2  	INCF CompTempVar621, F
0812  114E  	BCF gbl_gbFanOn,2
0813  0872  	MOVF CompTempVar621, W
0814  1D03  	BTFSS STATUS,Z
0815  154E  	BSF gbl_gbFanOn,2

            break;
        case 0x07:
07EF  3A08  	XORLW 0x08
07F0  1903  	BTFSC STATUS,Z
07F1  2817  	GOTO	label140
0817        label140

            // Exit other modes
            gcSetMode = 0;
0817  01D0  	CLRF gbl_gcSetMode

            gcTriggerMode = 0;
0818  01D2  	CLRF gbl_gcTriggerMode

            // Display temp C/temp F/date
            gcDisplayMode++;
0819  0ACF  	INCF gbl_gcDisplayMode, F

            if (gcDisplayMode > 3)
081A  084F  	MOVF gbl_gcDisplayMode, W
081B  3C03  	SUBLW 0x03
081C  1C03  	BTFSS STATUS,C

                gcDisplayMode = 0;
081D  01CF  	CLRF gbl_gcDisplayMode

            convertTemp(); // force conversion (no read)
081E  118A  	BCF PCLATH,3
081F  2531  	CALL convertTem_0002A

            break;
        case 0x1B:
07F2  3A1C  	XORLW 0x1C
07F3  1903  	BTFSC STATUS,Z
07F4  2821  	GOTO	label141
0821        label141

            // Exit other modes
            gcTriggerMode = 0;
0821  01D2  	CLRF gbl_gcTriggerMode

            // Adjust set mode
            gcSetMode++;
0822  0AD0  	INCF gbl_gcSetMode, F

            if (gcSetMode > 7) {
0823  0850  	MOVF gbl_gcSetMode, W
0824  3C07  	SUBLW 0x07
0825  1803  	BTFSC STATUS,C

                ds3231WriteDateTime();
0827  118A  	BCF PCLATH,3
0828  24F5  	CALL ds3231Writ_0001C

                gcSetMode = 0;
0829  01D0  	CLRF gbl_gcSetMode

            }
            break;
        case 0x13:
07F5  3A08  	XORLW 0x08
07F6  1903  	BTFSC STATUS,Z
07F7  282B  	GOTO	label142
082B        label142

            // Adjust down
            iBcdAdjustment = 0;
082B  01EF  	CLRF gbl_iBcdAdjustment

            if (gcSetMode) {
082C  08D0  	MOVF gbl_gcSetMode, F
082D  1903  	BTFSC STATUS,Z
082E  2832  	GOTO	label143
0832        label143

                adjustDateTime();
082F  118A  	BCF PCLATH,3
0830  2724  	CALL adjustDate_00027

            } else if (gcTriggerMode) {
0832  08D2  	MOVF gbl_gcTriggerMode, F
0834  1D03  	BTFSS STATUS,Z

                adjustTrigger();
0833  118A  	BCF PCLATH,3
0835  2651  	CALL adjustTrig_00028

            }
            break;
        case 0x0B:
07F8  3A18  	XORLW 0x18
07F9  1903  	BTFSC STATUS,Z
07FA  2837  	GOTO	label144
0837        label144

            iBcdAdjustment = 1;
0837  3001  	MOVLW 0x01
0838  00EF  	MOVWF gbl_iBcdAdjustment

            // Adjust up
            if (gcSetMode) {
0839  08D0  	MOVF gbl_gcSetMode, F
083A  1903  	BTFSC STATUS,Z
083B  283F  	GOTO	label145
083F        label145

                adjustDateTime();
083C  118A  	BCF PCLATH,3
083D  2724  	CALL adjustDate_00027

            } else if (gcTriggerMode) {
083F  08D2  	MOVF gbl_gcTriggerMode, F
0841  1D03  	BTFSS STATUS,Z

                adjustTrigger();
0840  118A  	BCF PCLATH,3
0842  2651  	CALL adjustTrig_00028

            }
            break;
        case 0x03:
07FB  3A08  	XORLW 0x08
07FC  1903  	BTFSC STATUS,Z
07FD  2844  	GOTO	label146
0844        label146

            // Exit set mode
            gcSetMode = 0;
0844  01D0  	CLRF gbl_gcSetMode

            // Adjust timer mode
            gcTriggerMode++;
0845  0AD2  	INCF gbl_gcTriggerMode, F

            if (gcTriggerMode > 12) {
0846  0852  	MOVF gbl_gcTriggerMode, W
0847  3C0C  	SUBLW 0x0C
0848  1803  	BTFSC STATUS,C

                gcTriggerMode = 0;
084A  01D2  	CLRF gbl_gcTriggerMode

                at24c32WriteAll(); // Exiting trigger mode, save the new triggers to EEPROM chip
084B  118A  	BCF PCLATH,3
084C  25AE  	CALL at24c32Wri_0002B

            }
            break;
    }
}
07FE  0008  	RETURN
0806  0008  	RETURN
080E  0008  	RETURN
0816  0008  	RETURN
0820  0008  	RETURN
0826  0008  	RETURN
082A  0008  	RETURN
0831  0008  	RETURN
0836  0008  	RETURN
083E  0008  	RETURN
0843  0008  	RETURN
0849  0008  	RETURN
084D  0008  	RETURN


/*********************************************************************************************
  void interrupt()
  Interrupt handler
*********************************************************************************************/
void interrupt() {

    // Interrupt on timer0 - flash digit delay
    if (intcon.T0IF) {
0A0D  1D0B  	BTFSS gbl_intcon,2
0A0E  2A16  	GOTO	label173
0A16        label173

        iTimer0Counts++;
0A0F  1283  	BCF STATUS, RP0
0A10  1303  	BCF STATUS, RP1
0A11  0ABE  	INCF gbl_iTimer0Counts, F

        tmr0 = TMR0PRELOAD;
0A12  303D  	MOVLW 0x3D
0A13  0081  	MOVWF gbl_tmr0

        cTask.TASK_TIMER0 = 1;
0A14  14CD  	BSF gbl_cTask,1

        // Clear interrupt flag
        intcon.T0IF = 0; 
0A15  110B  	BCF gbl_intcon,2

    }
    // Handle timer1 interrupt - delay counter from DS3231
    if (pir1.TMR1IF) {
0A16  1283  	BCF STATUS, RP0
0A17  1303  	BCF STATUS, RP1
0A18  1C0C  	BTFSS gbl_pir1,0
0A19  2A1F  	GOTO	label174
0A1F        label174

        tmr1h = TMR1HV;      // preset for timer1 MSB register
0A1A  30FF  	MOVLW 0xFF
0A1B  008F  	MOVWF gbl_tmr1h

        tmr1l = TMR1LV;      // preset for timer1 LSB register
0A1C  008E  	MOVWF gbl_tmr1l


        pir1.TMR1IF = 0;     // Clear interrupt flag
0A1D  100C  	BCF gbl_pir1,0

        cTask.TASK_TIMER1 = 1;
0A1E  154D  	BSF gbl_cTask,2

    }
}
0A1F  0E32  	SWAPF Int1BContext+D'2', W
0A20  0084  	MOVWF FSR
0A21  0E31  	SWAPF Int1BContext+D'1', W
0A22  008A  	MOVWF PCLATH
0A23  0E30  	SWAPF Int1BContext, W
0A24  0083  	MOVWF STATUS
0A25  0EFF  	SWAPF Int1Context, F
0A26  0E7F  	SWAPF Int1Context, W
0A27  0009  	RETFIE


/*********************************************************************************************
  void initialise()
  Function called once only to initialise variables and
  setup the PIC registers
*********************************************************************************************/
void initialise() {

    //PIC16F73 doesn't have an internal oscillator
    //pcon.OSCF = 1; // 4MHz internal osc

    // Configure port A
    /*
    RA7     Doesn't exist
    RA6     Doesn't exist
    RA5     
    RA4     
    RA3     
    RA2     
    RA1     OUT FANS
    RA0     OUT HEATER
    */
    trisa = 0x00; // all outputs
0867  1683  	BSF STATUS, RP0
0868  1303  	BCF STATUS, RP1
0869  0185  	CLRF gbl_trisa

    porta = 0x00; // All off
086A  1283  	BCF STATUS, RP0
086B  0185  	CLRF gbl_porta

    
    // Configure port B
    /*      
    RB7     ICSP PGD
    RB6     ICSP PGC
    RB5     
    RB4     
    RB3     OUT TM1638 STB
    RB2     OUT TM1638 CLK
    RB1     IN/OUT TM1638 DIO
    RB0     
    */
    trisb = 0x00; // all outputs by default
086C  1683  	BSF STATUS, RP0
086D  0186  	CLRF gbl_trisb

    portb = 0x0E; // default TM1638 pins high
086E  300E  	MOVLW 0x0E
086F  1283  	BCF STATUS, RP0
0870  0086  	MOVWF gbl_portb


    // Configure port C
    /*      
    RC7     
    RC6     
    RC5     IN/OUT DS18B20
    RC4     IN/OUT DS3231M I2C SDA
    RC3     IN/OUT DS3231M I2C CLK
    RC2     OUT BLUE LIGHT PWM
    RC1     OUT WHITE LIGHT PWM
    RC0     IN SQW DS3231M
    */
    trisc = 0x21; // RC0 and RC5 inputs
0871  3021  	MOVLW 0x21
0872  1683  	BSF STATUS, RP0
0873  0087  	MOVWF gbl_trisc

    portc = 0x38; // default DS18B20 and DS3231 pins high
0874  3038  	MOVLW 0x38
0875  1283  	BCF STATUS, RP0
0876  0087  	MOVWF gbl_portc


    option_reg = 0;
0877  1683  	BSF STATUS, RP0
0878  0181  	CLRF gbl_option_reg

    option_reg.NOT_RBPU = 1; // disable port b pull ups
0879  1781  	BSF gbl_option_reg,7


    // ADC setup
    // PIC16F73 doesn't have comparators
    //cmcon = 7; // disable all comparators so port a is usable as digital io
    adcon1 = 7; // Set RA0,RA1,RA2,RA5,RA3 all to digital I/O
087A  3007  	MOVLW 0x07
087B  009F  	MOVWF gbl_adcon1



    // Setup timer 0, used for flashing display
    // Timer calculator: http://eng-serve.com/pic/pic_timer.html
    // Timer0 Registers Prescaler= 256 - TMR0 Preset = 61 - Freq = 20.03 Hz - Period = 0.049920 seconds
    //option_reg.T0CS = 0; // bit 5  TMR0 Clock Source Select bit...0 = Internal Clock (CLKO) 1 = Transition on T0CKI pin
    //option_reg.T0SE = 0; // bit 4 TMR0 Source Edge Select bit 0 = low/high 1 = high/low
    //option_reg.PSA = 0; // bit 3  Prescaler Assignment bit...0 = Prescaler is assigned to the Timer0
    option_reg.PS2 = 1; // bits 2-0  PS2:PS0: Prescaler Rate Select bits
087C  1501  	BSF gbl_option_reg,2

    option_reg.PS1 = 1;
087D  1481  	BSF gbl_option_reg,1

    option_reg.PS0 = 1;
087E  1401  	BSF gbl_option_reg,0

    tmr0 = TMR0PRELOAD; // preset for timer register (61)
087F  303D  	MOVLW 0x3D
0880  1283  	BCF STATUS, RP0
0881  0081  	MOVWF gbl_tmr0

    intcon.T0IF = 0; // Clear timer 1 interrupt flag bit
0882  110B  	BCF gbl_intcon,2

    intcon.T0IE = 1; // Timer 1 interrupt enabled
0883  168B  	BSF gbl_intcon,5


    // Setup timer 1, used to update clock display and periodically ask for a temperature reading
    // Timer 1 setup - interrupt on DS3231 SQW 1Hz
    // Timer1 Registers Prescaler= 1 - TMR1 Preset = 65535 - Freq = 1 Hz
    // Bits 5-4 T1CKPS1:T1CKPS0 = 00: Prescaler Rate Select bits, 00 = 1:1 prescaler
    // Bit 3 T1OSCEN = 0: Timer1 LP Oscillator Enable Control bit, 0 = off
    // Bit 2 NOT_T1SYNC = 1: Timer1 External Clock Input Synchronization Control bit, 1 = Do not synchronize external clock input
    // Bit 1 TMR1CS = 1: Timer1 Clock Source Select bit, 1 = External clock from T1OSO/T1CKI pin (on the rising edge)
    // Bit 0 TMR1ON = 0: Timer1 On Bit, 0 = off
    t1con = 0b00000111;
0884  3007  	MOVLW 0x07
0885  0090  	MOVWF gbl_t1con

    tmr1h = TMR1HV;      // preset for timer1 MSB register
0886  30FF  	MOVLW 0xFF
0887  008F  	MOVWF gbl_tmr1h

    tmr1l = TMR1LV;      // preset for timer1 LSB register
0888  008E  	MOVWF gbl_tmr1l

    pie1.TMR1IE = 1;     // Timer 1 interrupt
0889  1683  	BSF STATUS, RP0
088A  140C  	BSF gbl_pie1,0

    
    // No task at initialisation
    cTask = 0;
088B  1283  	BCF STATUS, RP0
088C  01CD  	CLRF gbl_cTask

    
    // Enable interrupts
    intcon.GIE = 1;
088D  178B  	BSF gbl_intcon,7

    intcon.PEIE = 1;
088E  170B  	BSF gbl_intcon,6


	// I2C Bus initialisation - baud rate divisor not applicable for software implementation
	i2c_init(1); 
088F  3001  	MOVLW 0x01
0890  00F3  	MOVWF i2c_INIT_00000_arg_i2c_divisor
0891  118A  	BCF PCLATH,3
0892  24E2  	CALL i2c_INIT_00000


    // Read in variables from EEPROM
    at24c32ReadAll();
0893  25F1  	CALL at24c32Rea_0002C


    // Check if the DS3231 needs initilising
    char cStatus = ds3231ReadRegister(0x0F); // Read the status register
0894  300F  	MOVLW 0x0F
0895  00F3  	MOVWF ds3231Read_0001E_arg_cRegAddress
0896  2511  	CALL ds3231Read_0001E
0897  0875  	MOVF CompTempVarRet554, W
0898  00F2  	MOVWF initialise_00000_1_cStatus

    // If the oscillator (OSF bit in status register) has stopped, then init and write a default date/time
    if (cStatus.7) {
0899  158A  	BSF PCLATH,3
089A  1FF2  	BTFSS initialise_00000_1_cStatus,7
089B  289F  	GOTO	label147
089F        label147

        ds3231Init();
089C  118A  	BCF PCLATH,3
089D  2526  	CALL ds3231Init_00000

        ds3231WriteDateTime();
089E  24F5  	CALL ds3231Writ_0001C

    }
    
	tm1638DisplayOn();
089F  118A  	BCF PCLATH,3
08A0  24B5  	CALL tm1638Disp_00021

    tm1638UpdateDisplay();
08A1  2293  	CALL tm1638Upda_00022

}
08A2  0008  	RETURN


/*********************************************************************************************
  void main()
  Entry method. Loops infinitely with a simple task scheduler.
*********************************************************************************************/
void main() {

    initialise();
08CE  2067  	CALL initialise_00000

    
    // Endless loop
    while(1) {
08CF        label148

        // Task scheduler
        // If there are tasks to be performed, find out the
        // most recent task from the array and execute it
        while (cTask > 0) {
08CF  084D  	MOVF gbl_cTask, W
08D0  3C00  	SUBLW 0x00
08D1  158A  	BSF PCLATH,3
08D2  1803  	BTFSC STATUS,C
08D3  28CF  	GOTO	label148

            if (cTask.TASK_TIMER1) {
08D4  1D4D  	BTFSS gbl_cTask,2
08D5  2985  	GOTO	label168
0985        label168

                if (!gcSetMode) {
08D6  08D0  	MOVF gbl_gcSetMode, F
08D7  1D03  	BTFSS STATUS,Z
08D8  2913  	GOTO	label154

                    // Don't read date/time when in set mode
                    ds3231ReadDateTime();
08D9  20A3  	CALL ds3231Read_0001D

                    if ((gBcdSecond == 0x29) || (gBcdSecond == 0x59)) {
08DA  0835  	MOVF gbl_gBcdSecond, W
08DB  3A29  	XORLW 0x29
08DC  158A  	BSF PCLATH,3
08DD  1903  	BTFSC STATUS,Z
08DE  28E3  	GOTO	label149
08DF  0835  	MOVF gbl_gBcdSecond, W
08E0  3A59  	XORLW 0x59
08E1  1D03  	BTFSS STATUS,Z
08E2  28E7  	GOTO	label150
08E3        label149
08E7        label150

                        // Ask to convert for temperature reading at 29 seconds or 59 seconds past the minute
                        oneWireBusReset();
08E3  204E  	CALL oneWireBus_00017

                        startTemp();
08E4  27CC  	CALL startTemp_00000

                    } else if ((gBcdSecond == 0) || (gBcdSecond == 0x30)) {
08E5  158A  	BSF PCLATH,3
08E6  28F1  	GOTO	label152
08E7  08B5  	MOVF gbl_gBcdSecond, F
08E8  1903  	BTFSC STATUS,Z
08E9  28EE  	GOTO	label151
08EA  0835  	MOVF gbl_gBcdSecond, W
08EB  3A30  	XORLW 0x30
08EC  1D03  	BTFSS STATUS,Z
08ED  28F1  	GOTO	label152
08EE        label151
08F1        label152
09A4  158A  	BSF PCLATH,3
09A5  28CF  	GOTO	label148

                        // 1 second later, read the converted temperature
                        oneWireBusReset();
08EE  204E  	CALL oneWireBus_00017

                        readTemp(); 
08EF  27D4  	CALL readTemp_00000

                        // store it in the array, next display refresh will pick it up
                        convertTemp();
08F0  2531  	CALL convertTem_0002A

                    }
                    // daylight savings time handling (UK/europe) - last sunday of March or October (this can fall between the 25th and the 31st)
                    if ((gBcdSecond == 0) && (gDayOfWeek == 7) && (gBcdDayOfMonth > 0x24)) {
08F1  08B5  	MOVF gbl_gBcdSecond, F
08F2  158A  	BSF PCLATH,3
08F3  1D03  	BTFSS STATUS,Z
08F4  2913  	GOTO	label154
08F5  0838  	MOVF gbl_gDayOfWeek, W
08F6  3A07  	XORLW 0x07
08F7  1D03  	BTFSS STATUS,Z
08F8  2913  	GOTO	label154
08F9  0839  	MOVF gbl_gBcdDayOfMonth, W
08FA  3C24  	SUBLW 0x24
08FB  1803  	BTFSC STATUS,C
08FC  2913  	GOTO	label154

						// In March, at 1AM, apply daylight savings time if appropriate 
						if ((gBcdHour == 1) && (gBcdMonth == 3)) {
08FD  0337  	DECF gbl_gBcdHour, W
08FE  1D03  	BTFSS STATUS,Z
08FF  2907  	GOTO	label153
0900  083A  	MOVF gbl_gBcdMonth, W
0901  3A03  	XORLW 0x03
0902  1D03  	BTFSS STATUS,Z
0903  2907  	GOTO	label153
0907        label153

							gBcdHour++; // one hour forwards
0904  0AB7  	INCF gbl_gBcdHour, F

							ds3231WriteDateTime();
0905  118A  	BCF PCLATH,3
0906  24F5  	CALL ds3231Writ_0001C

						}
						// In October, at 2AM, remove daylight savings time if appropriate (UK/europe) daylight savings time if appropriate (UK/europe) - last sunday of October
						if ((gBcdHour == 2) && (gBcdMonth == 0x10)) {
0907  0837  	MOVF gbl_gBcdHour, W
0908  3A02  	XORLW 0x02
0909  158A  	BSF PCLATH,3
090A  1D03  	BTFSS STATUS,Z
090B  2913  	GOTO	label154
090C  083A  	MOVF gbl_gBcdMonth, W
090D  3A10  	XORLW 0x10
090E  1D03  	BTFSS STATUS,Z
090F  2913  	GOTO	label154
0913        label154

							gBcdHour--; // one hour back
0910  03B7  	DECF gbl_gBcdHour, F

							ds3231WriteDateTime();
0911  118A  	BCF PCLATH,3
0912  24F5  	CALL ds3231Writ_0001C

						}
					}
                }
                if (!gcTriggerMode) {
0913  08D2  	MOVF gbl_gcTriggerMode, F
0914  158A  	BSF PCLATH,3
0915  1D03  	BTFSS STATUS,Z
0916  297C  	GOTO	label166

					// Don't activate triggers when in trigger set mode
					// Trigger white led
					// Don't activate/deactivate if on and off set hour/min are the same
					if ((gBcdWhiteOnHour != gBcdWhiteOffHour) || (gBcdWhiteOnMinute != gBcdWhiteOffMinute)) {
0917  0856  	MOVF gbl_gBcdWhiteOffHour, W
0918  0654  	XORWF gbl_gBcdWhiteOnHour, W
0919  1D03  	BTFSS STATUS,Z
091A  291F  	GOTO	label155
091B  0855  	MOVF gbl_gBcdWhiteOffMinute, W
091C  0653  	XORWF gbl_gBcdWhiteOnMinute, W
091D  1903  	BTFSC STATUS,Z
091E  292F  	GOTO	label157
091F        label155

						if ((gBcdHour == gBcdWhiteOnHour) && (gBcdMinute == gBcdWhiteOnMinute)) {
091F  0854  	MOVF gbl_gBcdWhiteOnHour, W
0920  0637  	XORWF gbl_gBcdHour, W
0921  1D03  	BTFSS STATUS,Z
0922  2927  	GOTO	label156
0923  0853  	MOVF gbl_gBcdWhiteOnMinute, W
0924  0636  	XORWF gbl_gBcdMinute, W
0925  1903  	BTFSC STATUS,Z

							WHITE_LED = 1;
0926  1487  	BSF gbl_portc,1
0927        label156

						}
						if ((gBcdHour == gBcdWhiteOffHour) && (gBcdMinute == gBcdWhiteOffMinute)) {
0927  0856  	MOVF gbl_gBcdWhiteOffHour, W
0928  0637  	XORWF gbl_gBcdHour, W
0929  1D03  	BTFSS STATUS,Z
092A  292F  	GOTO	label157
092B  0855  	MOVF gbl_gBcdWhiteOffMinute, W
092C  0636  	XORWF gbl_gBcdMinute, W
092D  1903  	BTFSC STATUS,Z

							WHITE_LED = 0;
092E  1087  	BCF gbl_portc,1
092F        label157

						}
					}
					// Trigger blue led
					// Don't activate/deactivate if on and off set hour/min are the same
					if ((gBcdBlueOnHour != gBcdBlueOffHour) || (gBcdBlueOnMinute != gBcdBlueOffMinute)) {
092F  085A  	MOVF gbl_gBcdBlueOffHour, W
0930  0658  	XORWF gbl_gBcdBlueOnHour, W
0931  1D03  	BTFSS STATUS,Z
0932  2937  	GOTO	label158
0933  0859  	MOVF gbl_gBcdBlueOffMinute, W
0934  0657  	XORWF gbl_gBcdBlueOnMinute, W
0935  1903  	BTFSC STATUS,Z
0936  2947  	GOTO	label160
0937        label158

						if ((gBcdHour == gBcdBlueOnHour) && (gBcdMinute == gBcdBlueOnMinute)) {
0937  0858  	MOVF gbl_gBcdBlueOnHour, W
0938  0637  	XORWF gbl_gBcdHour, W
0939  1D03  	BTFSS STATUS,Z
093A  293F  	GOTO	label159
093B  0857  	MOVF gbl_gBcdBlueOnMinute, W
093C  0636  	XORWF gbl_gBcdMinute, W
093D  1903  	BTFSC STATUS,Z

							BLUE_LED = 1;
093E  1507  	BSF gbl_portc,2
093F        label159

						}
						if ((gBcdHour == gBcdBlueOffHour) && (gBcdMinute == gBcdBlueOffMinute)) {
093F  085A  	MOVF gbl_gBcdBlueOffHour, W
0940  0637  	XORWF gbl_gBcdHour, W
0941  1D03  	BTFSS STATUS,Z
0942  2947  	GOTO	label160
0943  0859  	MOVF gbl_gBcdBlueOffMinute, W
0944  0636  	XORWF gbl_gBcdMinute, W
0945  1903  	BTFSC STATUS,Z

							BLUE_LED = 0;
0946  1107  	BCF gbl_portc,2
0947        label160

						}
					}
					// 2nd Trigger blue led
					// Don't activate/deactivate if on and off set hour/min are the same
					if ((gBcdBlue2OnHour != gBcdBlue2OffHour) || (gBcdBlue2OnMinute != gBcdBlue2OffMinute)) {
0947  085E  	MOVF gbl_gBcdBlue2OffHour, W
0948  065C  	XORWF gbl_gBcdBlue2OnHour, W
0949  1D03  	BTFSS STATUS,Z
094A  294F  	GOTO	label161
094B  085D  	MOVF gbl_gBcdBlue2OffMinute, W
094C  065B  	XORWF gbl_gBcdBlue2OnMinute, W
094D  1903  	BTFSC STATUS,Z
094E  295F  	GOTO	label163
094F        label161

						if ((gBcdHour == gBcdBlue2OnHour) && (gBcdMinute == gBcdBlue2OnMinute)) {
094F  085C  	MOVF gbl_gBcdBlue2OnHour, W
0950  0637  	XORWF gbl_gBcdHour, W
0951  1D03  	BTFSS STATUS,Z
0952  2957  	GOTO	label162
0953  085B  	MOVF gbl_gBcdBlue2OnMinute, W
0954  0636  	XORWF gbl_gBcdMinute, W
0955  1903  	BTFSC STATUS,Z

							BLUE_LED = 1;
0956  1507  	BSF gbl_portc,2
0957        label162

						}
						if ((gBcdHour == gBcdBlue2OffHour) && (gBcdMinute == gBcdBlue2OffMinute)) {
0957  085E  	MOVF gbl_gBcdBlue2OffHour, W
0958  0637  	XORWF gbl_gBcdHour, W
0959  1D03  	BTFSS STATUS,Z
095A  295F  	GOTO	label163
095B  085D  	MOVF gbl_gBcdBlue2OffMinute, W
095C  0636  	XORWF gbl_gBcdMinute, W
095D  1903  	BTFSC STATUS,Z

							BLUE_LED = 0;
095E  1107  	BCF gbl_portc,2
095F        label163

						}
					}
					// Trigger fan
					// Don't activate/deactivate if on and off temperature are the same
					if (gBcdFanOnTemp != gBcdFanOffTemp) {
095F  0860  	MOVF gbl_gBcdFanOffTemp, W
0960  065F  	XORWF gbl_gBcdFanOnTemp, W
0961  1903  	BTFSC STATUS,Z
0962  296B  	GOTO	label164

						if (giDS3231ValueTruncCBCD >= gBcdFanOnTemp) {
0963  085F  	MOVF gbl_gBcdFanOnTemp, W
0964  024B  	SUBWF gbl_giDS3231ValueTruncCBCD, W
0965  1803  	BTFSC STATUS,C

							FAN = 1;
0966  1485  	BSF gbl_porta,1

						}
						if (giDS3231ValueTruncCBCD <= gBcdFanOffTemp) {
0967  084B  	MOVF gbl_giDS3231ValueTruncCBCD, W
0968  0260  	SUBWF gbl_gBcdFanOffTemp, W
0969  1803  	BTFSC STATUS,C

							FAN = 0;
096A  1085  	BCF gbl_porta,1
096B        label164

						}
					}
					// Forced on
					if (gbFanOn)
096B  194E  	BTFSC gbl_gbFanOn,2

						FAN = 1;
096C  1485  	BSF gbl_porta,1

					// Trigger heater
					// Don't activate/deactivate if on and off temperature are the same
					if (gBcdHeaterOnTemp != gBcdHeaterOffTemp) {
096D  0862  	MOVF gbl_gBcdHeaterOffTemp, W
096E  0661  	XORWF gbl_gBcdHeaterOnTemp, W
096F  1903  	BTFSC STATUS,Z
0970  2979  	GOTO	label165

						if (giDS3231ValueTruncCBCD <= gBcdHeaterOnTemp) {
0971  084B  	MOVF gbl_giDS3231ValueTruncCBCD, W
0972  0261  	SUBWF gbl_gBcdHeaterOnTemp, W
0973  1803  	BTFSC STATUS,C

							HEATER = 1;
0974  1405  	BSF gbl_porta,0

						}
						if (giDS3231ValueTruncCBCD >= gBcdHeaterOffTemp) {
0975  0862  	MOVF gbl_gBcdHeaterOffTemp, W
0976  024B  	SUBWF gbl_giDS3231ValueTruncCBCD, W
0977  1803  	BTFSC STATUS,C

							HEATER = 0;
0978  1005  	BCF gbl_porta,0
0979        label165

						}
					}
					// If temperature is minus, always trigger heater
					if (gbDS3231IsMinus)
0979  08CC  	MOVF gbl_gbDS3231IsMinus, F
097A  1D03  	BTFSS STATUS,Z

						HEATER = 1;
097B  1405  	BSF gbl_porta,0
097C        label166

				}
				// Display time and temperature or date on TM1638 after clock tick
				if (!gcTriggerMode && !gcSetMode) {
097C  08D2  	MOVF gbl_gcTriggerMode, F
097D  1D03  	BTFSS STATUS,Z
097E  2984  	GOTO	label167
097F  08D0  	MOVF gbl_gcSetMode, F
0980  1D03  	BTFSS STATUS,Z
0981  2984  	GOTO	label167
0984        label167

					tm1638UpdateDisplay();
0982  118A  	BCF PCLATH,3
0983  2293  	CALL tm1638Upda_00022

                }
                
                cTask.TASK_TIMER1 = 0;
0984  114D  	BCF gbl_cTask,2

            }
            if (cTask.TASK_TIMER0) {
0985  158A  	BSF PCLATH,3
0986  1CCD  	BTFSS gbl_cTask,1
0987  28CF  	GOTO	label148

				// ~half second count
				if (iTimer0Counts > 9) {
0988  083E  	MOVF gbl_iTimer0Counts, W
0989  3C09  	SUBLW 0x09
098A  1803  	BTFSC STATUS,C
098B  2996  	GOTO	label170

					iFlashDigitOff++;
098C  0ABF  	INCF gbl_iFlashDigitOff, F

					iTimer0Counts = 0;					
098D  01BE  	CLRF gbl_iTimer0Counts

					// If in set or trigger mode, update the display every ~half second to flash a digit
					if (gcSetMode || gcTriggerMode)
098E  08D0  	MOVF gbl_gcSetMode, F
098F  1D03  	BTFSS STATUS,Z
0990  2994  	GOTO	label169
0991  08D2  	MOVF gbl_gcTriggerMode, F
0992  1903  	BTFSC STATUS,Z
0993  2996  	GOTO	label170
0994        label169

						tm1638UpdateDisplay();
0994  118A  	BCF PCLATH,3
0995  2293  	CALL tm1638Upda_00022

				}
				// Poll keys every 50ms
				tm1638ReadKeys();
0996  118A  	BCF PCLATH,3
0997  27A9  	CALL tm1638Read_00025

				if (tm1638Keys != tm1638KeysOld) {
0998  086C  	MOVF gbl_tm1638KeysOld, W
0999  066B  	XORWF gbl_tm1638Keys, W
099A  158A  	BSF PCLATH,3
099B  1903  	BTFSC STATUS,Z
099C  29A3  	GOTO	label171
09A3        label171

					//if (tm1638Keys != 0) {
						processKeys();
099D  118A  	BCF PCLATH,3
099E  27E2  	CALL processKey_00029

						tm1638UpdateDisplay();
099F  118A  	BCF PCLATH,3
09A0  2293  	CALL tm1638Upda_00022

					//}
					tm1638KeysOld = tm1638Keys;
09A1  086B  	MOVF gbl_tm1638Keys, W
09A2  00EC  	MOVWF gbl_tm1638KeysOld

				}
                cTask.TASK_TIMER0 = 0;
09A3  10CD  	BCF gbl_cTask,1

            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
// I2C Communications Library for I2C MASTER
////////////////////////////////////////////////////////////////////////////
// Author(s): Andrew Smallridge
// Date 15 November 2004
//
// Copyright(C) 2004-2006 Andrew Smallridge
// Copyright(C) 2004-2010 Pavel Baranov
// Copyright(C) 2004-2010 David Hobday
// Existing constants predefined for i2c hardware driver and i2s software
// emulation for the PIC 18F2xx and 18F4xx processors. For hardware support
// on other PICs the constants must be mapped to the corresponding register
// map of the target device
////////////////////////////////////////////////////////////////////////////

/*
////////////////////////////////////////////////////////////////////////////
//	The following three sections should be copied to the user's program:
//		i2c master hardware / software mode definition
//		i2c software implementation template arguments and variables
// 		i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////
// i2c master hardware / software mode definition
//
// For i2c hardware support comment out the #define use_ic2_SW line
////////////////////////////////////////////////////////////////////////////
//#define use_i2c_SW

#if defined use_i2c_SW
////////////////////////////////////////////////////////////////////////////
// i2c software implementation template arguments and variables
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)

// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and software emalated i2c RAM locations. These constants are
// then used by the templated functions. When changing the address of an emulated
// register the corresponding constant mapping must also be changed.
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3					

#else
////////////////////////////////////////////////////////////////////////////
// i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP |i2c_HW)

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and PIC's i2c register locations. These constants are
// then used by the templated functions. 
#define PORTC		0x0f82
#define TRISC		0x0f94
#define e_SSPCON1	0xfc6
#define e_SSPCON2	0xfc5
#define e_SSPSTAT	0xfc7
#define e_SSPADD	0xfc8
#define e_SSPBUF	0xfc9
#define e_SSPIF_PIR	0xf9e
#define e_BCLIF_PIR	0xfa1
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3

#endif

*/


////////////////////////////////////////////////////////////////////////////
// Define the common i2c template structure
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL	template <unsigned char T_SCL_BIT, unsigned short T_SCL_PORT,	\
					unsigned short T_SCL_TRIS, unsigned char T_SDA_BIT, 			\
					unsigned short T_SDA_PORT, unsigned short T_SDA_TRIS,			\
					unsigned short T_i2c_SSPCON1, unsigned short T_i2c_SSPCON2, 	\
					unsigned short T_i2c_SSPSTAT, unsigned short T_i2c_SSPBUF, 		\
					unsigned char T_i2c_SSPIF_BIT, unsigned short T_i2c_SSPIF_PIR,	\
					unsigned char T_i2c_BCLIF_BIT, unsigned short T_i2c_BCLIF_PIR,	\
					unsigned char T_i2c_SMP_BIT, unsigned short T_i2c_SSPADD, 		\
					unsigned char T_MODE>

////////////////////////////////////////////////////////////////////////////
// Define the common i2c template parameters
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL_ARGS	T_SCL_BIT, T_SCL_PORT, T_SCL_TRIS, T_SDA_BIT, 			\
						T_SDA_PORT, T_SDA_TRIS, T_i2c_SSPCON1, T_i2c_SSPCON2, 	\
						T_i2c_SSPSTAT, T_i2c_SSPBUF, T_i2c_SSPIF_BIT, 			\
						T_i2c_SSPIF_PIR, T_i2c_BCLIF_BIT, T_i2c_BCLIF_PIR,		\
						T_i2c_SMP_BIT, T_i2c_SSPADD, T_MODE

////////////////////////////////////////////////////////////////////////////
// Helpers that hide template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_init	i2c_INIT<i2c_ARGS>
#define i2c_start	i2c_START<i2c_ARGS>
#define i2c_restart	i2c_RESTART<i2c_ARGS>
#define i2c_stop	i2c_STOP<i2c_ARGS>
#define i2c_read	i2c_READ<i2c_ARGS>
#define i2c_write	i2c_WRITE<i2c_ARGS>


////////////////////////////////////////////////////////////////////////////
// I2C Control Status Bits - Emulates the PIC18F hardware I2C implementation
////////////////////////////////////////////////////////////////////////////
// define I2C i2C_SSPCON1 control bits
#define	i2c_WCOL	7
#define	i2c_SSPOV	6
#define	i2c_SSPEN	5
#define	i2c_CKP		4
#define	i2c_SSPM3	3
#define	i2c_SSPM2	2
#define	i2c_SSPM1	1
#define	i2c_SSPM0	0

// define I2C SSPCON2 control bits
#define	i2c_GCEN 	7
#define	i2c_ACKSTAT	6
#define	i2c_ACKDT	5
#define	i2c_ACKEN	4
#define	i2c_RCEN	3
#define	i2c_PEN		2
#define	i2c_RSEN	1
#define	i2c_SEN		0

// define I2C SSPSTAT status bits
#define	i2c_DA		5
#define	i2c_P		4
#define	i2c_S		3
#define	i2c_RW		2
#define	i2c_UA		1
#define	i2c_BF		0


////////////////////////////////////////////////////////////////////////////
// I2C Control Flag Bits
////////////////////////////////////////////////////////////////////////////
// define I2C Mode bits
#define	i2c_HW			0x01
#define	i2c_400KHz		0x02	// 100KHz or 400KHz I2C clock (set = 400KHz)
#define	i2c_reset_wdt	0x04
#define i2c_SMP			0x80	


////////////////////////////////////////////////////////////////////////////
// I2C software constants
////////////////////////////////////////////////////////////////////////////
#define	dly 10	// number of 1us delay increments



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Start Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL 
void i2c_START(void)

{
	// Initiate the I2C START condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	delay_us(dly);
0126  300A  	MOVLW 0x0A
0127  1283  	BCF STATUS, RP0
0128  1303  	BCF STATUS, RP1
0129  00F8  	MOVWF delay_us_00000_arg_del
012A  2010  	CALL delay_us_00000

	l_bclif = 0; // initialise the collision flag for this command
012B  11C6  	BCF i2c_START_00000_1_l_bclif,3

	l_sspif = 0;
012C  11C5  	BCF i2c_START_00000_1_l_sspif,3

		
	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
			
		l_sen = 1; // initiate START condition	

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation			
		l_sen = 1; // initiate START condition
012D  1441  	BSF i2c_START_00000_1_l_sen,0

		l_scl_tris = 1; // ensure the SCL line is high
012E  1683  	BSF STATUS, RP0
012F  1587  	BSF i2c_START_00000_1_l_scl_tris,3

		l_sda_tris = 1; // ensure the SDA line is high	
0130  1607  	BSF i2c_START_00000_1_l_sda_tris,4

		l_scl = 0; // prepare to set SCL line low
0131  1283  	BCF STATUS, RP0
0132  1187  	BCF i2c_START_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low
0133  1207  	BCF i2c_START_00000_1_l_sda,4

		
		if (l_scl && l_sda)
0134  1D87  	BTFSS i2c_START_00000_1_l_scl,3
0135  2953  	GOTO	label24
0136  1E07  	BTFSS i2c_START_00000_1_l_sda,4
0137  2953  	GOTO	label24
0153        label24

		{
			// good sign - no collision detected
			delay_us(dly);
0138  300A  	MOVLW 0x0A
0139  00F8  	MOVWF delay_us_00000_arg_del
013A  2010  	CALL delay_us_00000

			
			if (!l_scl) // ensure the clock is still high
013B  1987  	BTFSC i2c_START_00000_1_l_scl,3
013C  2941  	GOTO	label23
0141        label23

			{
				l_bclif = 1;
013D  15C6  	BSF i2c_START_00000_1_l_bclif,3

				l_s = 1;
013E  15C2  	BSF i2c_START_00000_1_l_s,3

				l_sen = 0;
013F  1041  	BCF i2c_START_00000_1_l_sen,0

				return;
			}
					
			l_sda = 0; // prepare to set SDA line low
0141  1207  	BCF i2c_START_00000_1_l_sda,4

			l_sda_tris = 0; // SDA to output (driven low)
0142  1683  	BSF STATUS, RP0
0143  1207  	BCF i2c_START_00000_1_l_sda_tris,4


			delay_us(dly);					
0144  300A  	MOVLW 0x0A
0145  1283  	BCF STATUS, RP0
0146  00F8  	MOVWF delay_us_00000_arg_del
0147  2010  	CALL delay_us_00000

			l_scl = 0; // prepare to set SCL line low
0148  1187  	BCF i2c_START_00000_1_l_scl,3

			l_scl_tris = 0; // SCL to output (driven low)
0149  1683  	BSF STATUS, RP0
014A  1187  	BCF i2c_START_00000_1_l_scl_tris,3


			delay_us(dly);					
014B  300A  	MOVLW 0x0A
014C  1283  	BCF STATUS, RP0
014D  00F8  	MOVWF delay_us_00000_arg_del
014E  2010  	CALL delay_us_00000

			l_s = 1; // set 'S' bit flag (start bit detected)
014F  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0; // clear flag
0150  1041  	BCF i2c_START_00000_1_l_sen,0

			l_sspif = 1; // flag end of start condition interrupt	
0151  15C5  	BSF i2c_START_00000_1_l_sspif,3

		}
		else
		{
			// here is SDA or SCL are low at the start - indicates a bus collision
			l_bclif = 1;
0153  15C6  	BSF i2c_START_00000_1_l_bclif,3

			l_s = 1; // set 'S' bit flag (start bit detected)
0154  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0;
0155  1041  	BCF i2c_START_00000_1_l_sen,0

			l_rsen = 0;
0156  10C1  	BCF i2c_START_00000_1_l_rsen,1

			l_pen = 0;
0157  1141  	BCF i2c_START_00000_1_l_pen,2

			l_rcen = 0;								
0158  11C1  	BCF i2c_START_00000_1_l_rcen,3

			l_acken = 0;			
0159  1241  	BCF i2c_START_00000_1_l_acken,4

		}
	}
}
0140  0008  	RETURN
0152  0008  	RETURN
015A  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Restart Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_RESTART(void)
{
	// Initiate the I2C RESTART condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
			
	delay_us(dly);
	l_bclif = 0; // initialise the collision flag for this command
	l_sspif = 0;

	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_rsen = 1; // initiate RESTART condition
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation	
		l_rsen = 1;
		l_scl = 0;
		l_sda = 0;
		
		if (!l_scl)
		{
			// good sign - no other I2C activity in progress
			l_sda_tris = 1; // float SDA line high	(should already be in this condition)	
			delay_us(dly);
		
			// about to float the clock line
			// ensure the data line is still high
			if (!l_sda)
			{
				// problem - SDA is low, a bus collision has occurred				
				l_bclif = 1; // set the bus collision flag	
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_scl_tris = 1; // float SCL line (high)	
				return;
			}
												
			l_scl_tris = 1; // float SCL line (high)

			// wait until any clock stretching has finished
			while (!l_scl)
				if (T_MODE & i2c_reset_wdt)
					clear_wdt();	
			delay_us(dly);
			
			// here we are about to drive SDA low
			// first ensure SCL is still high
			if (!l_scl)
			{
				// problem - SCL is low, a bus collision has occurred
				l_bclif = 1; // set the bus collision flag
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_sda_tris = 1; // float SDA line (high)
				return;
			}
				
			l_sda_tris = 0; // drive SDA low
			l_s = 1; // set 'S' bit flag (start bit detected)

			delay_us(dly);
			l_scl_tris = 0; // drive SCL low
			l_rsen = 0;
			l_pen = 0;
			l_sen = 0;			
			l_rcen = 0;								
			l_acken = 0;			
			l_sspif = 1; // flag end of start condition interrupt
		}
		else
		{
			// SCL is high at the start
			// some other I2C activity in progress		
			l_rsen = 0; // clear flag
			// exit without further action
		}
	}
}



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Stop Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_STOP(void)

{ 
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_p@T_i2c_SSPSTAT.i2c_P; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;

	l_bclif = 0; // initialise the collision flag for this command
00F6  1283  	BCF STATUS, RP0
00F7  1303  	BCF STATUS, RP1
00F8  11C6  	BCF i2c_STOP_00000_1_l_bclif,3

	l_sspif = 0;
00F9  11C5  	BCF i2c_STOP_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_pen = 1; // initiate STOP condition on the I2C bus	
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
		
	}
	else
	{
		//	Software I2C implementation
		l_pen = 1; // initiate STOP condition on the I2C bus
00FA  1541  	BSF i2c_STOP_00000_1_l_pen,2

		delay_us(dly);
00FB  300A  	MOVLW 0x0A
00FC  00F8  	MOVWF delay_us_00000_arg_del
00FD  2010  	CALL delay_us_00000

		
		l_scl = 0; // prepare to set SCL line low
00FE  1187  	BCF i2c_STOP_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low
00FF  1207  	BCF i2c_STOP_00000_1_l_sda,4

		l_scl_tris = 0; // drive SCL line low (should already be low)
0100  1683  	BSF STATUS, RP0
0101  1187  	BCF i2c_STOP_00000_1_l_scl_tris,3

		l_sda_tris = 0; // drive SDA line low
0102  1207  	BCF i2c_STOP_00000_1_l_sda_tris,4


		delay_us(dly);		
0103  300A  	MOVLW 0x0A
0104  1283  	BCF STATUS, RP0
0105  00F8  	MOVWF delay_us_00000_arg_del
0106  2010  	CALL delay_us_00000

		l_scl_tris = 1; // float SCL line (high)
0107  1683  	BSF STATUS, RP0
0108  1587  	BSF i2c_STOP_00000_1_l_scl_tris,3

		
		// wait until any clock stretching has finished
		while (!l_scl)
0109        label19
0109  1283  	BCF STATUS, RP0
010A  1987  	BTFSC i2c_STOP_00000_1_l_scl,3
010B  290E  	GOTO	label20
010D  2909  	GOTO	label19
010E        label20

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
010C  0064  	CLRWDT

						
		delay_us(dly);
010E  300A  	MOVLW 0x0A
010F  00F8  	MOVWF delay_us_00000_arg_del
0110  2010  	CALL delay_us_00000

		l_sda_tris = 1; // float SDA line
0111  1683  	BSF STATUS, RP0
0112  1607  	BSF i2c_STOP_00000_1_l_sda_tris,4

		delay_us(dly);		
0113  300A  	MOVLW 0x0A
0114  1283  	BCF STATUS, RP0
0115  00F8  	MOVWF delay_us_00000_arg_del
0116  2010  	CALL delay_us_00000

		
		// here the SDA line should be high - if not a collision has occurred				
		if (!l_sda || !l_scl)
0117  1E07  	BTFSS i2c_STOP_00000_1_l_sda,4
0118  291B  	GOTO	label21
0119  1987  	BTFSC i2c_STOP_00000_1_l_scl,3
011A  291F  	GOTO	label22
011B        label21
011F        label22

		{
			// problem - SDA or SCL is low, a bus collision has occurred
			l_bclif = 1; // set the bus collision flag	
011B  15C6  	BSF i2c_STOP_00000_1_l_bclif,3

			l_s = 0; // clear 'S' bit flag
011C  11C2  	BCF i2c_STOP_00000_1_l_s,3

			l_pen = 0; // clear flag
011D  1141  	BCF i2c_STOP_00000_1_l_pen,2

		}
		else
		{		
			l_p = 1;
011F  1642  	BSF i2c_STOP_00000_1_l_p,4

			l_pen = 0;
0120  1141  	BCF i2c_STOP_00000_1_l_pen,2

			l_sen = 0;
0121  1041  	BCF i2c_STOP_00000_1_l_sen,0

			l_rsen = 0;			
0122  10C1  	BCF i2c_STOP_00000_1_l_rsen,1

			l_rcen = 0;								
0123  11C1  	BCF i2c_STOP_00000_1_l_rcen,3

			l_acken = 0;
0124  1241  	BCF i2c_STOP_00000_1_l_acken,4

		}
	}
}
011E  0008  	RETURN
0125  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Write Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_WRITE(unsigned char i2c_data)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;	
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
	
	char BitMask;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
00A5  11C6  	BCF i2c_WRITE_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
00A6  11C5  	BCF i2c_WRITE_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
				
		l_wcol = 0; // clear write collision flag	
		i2c_SSPBUF = i2c_data;

		// test if a write collision occurred
		if (l_wcol)
			return (1); // error exit	

		// wait until MSSP Tx register is empty
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
								
		return (0); // successful exit
	}

	// here for i2c software driver
	l_wcol = 0; // clear write collision flag	
00A7  13C0  	BCF i2c_WRITE_00000_1_l_wcol,7

	i2c_SSPBUF = i2c_data;
00A8  0875  	MOVF i2c_WRITE_00000_arg_i2c_data, W
00A9  00C4  	MOVWF i2c_WRITE_00000_1_i2c_SSPBUF

	
	l_scl = 0; // prepare to set SCL line low
00AA  1187  	BCF i2c_WRITE_00000_1_l_scl,3

	l_sda = 0; // prepare to set SDA line low
00AB  1207  	BCF i2c_WRITE_00000_1_l_sda,4

	l_rw = 0; // signal we are doing a write
00AC  1142  	BCF i2c_WRITE_00000_1_l_rw,2


	for (BitMask = 0x80; BitMask; BitMask>>=1)
00AD  3080  	MOVLW 0x80
00AE  00F6  	MOVWF i2c_WRITE_00000_1_BitMask
00AF        label11
00AF  08F6  	MOVF i2c_WRITE_00000_1_BitMask, F
00B0  1903  	BTFSC STATUS,Z
00B1  28D2  	GOTO	label16
00CF  1003  	BCF STATUS,C
00D0  0CF6  	RRF i2c_WRITE_00000_1_BitMask, F
00D1  28AF  	GOTO	label11
00D2        label16

	{
		if (i2c_data & BitMask)
00B2  0876  	MOVF i2c_WRITE_00000_1_BitMask, W
00B3  0575  	ANDWF i2c_WRITE_00000_arg_i2c_data, W
00B4  1903  	BTFSC STATUS,Z
00B5  28B9  	GOTO	label12
00B9        label12

			l_sda_tris = 1; // float SDA high	
00B6  1683  	BSF STATUS, RP0
00B7  1607  	BSF i2c_WRITE_00000_1_l_sda_tris,4

		else
00B8  28BB  	GOTO	label13
00BB        label13

			l_sda_tris = 0; // drive SDA low
00B9  1683  	BSF STATUS, RP0
00BA  1207  	BCF i2c_WRITE_00000_1_l_sda_tris,4

		delay_us(dly);
00BB  300A  	MOVLW 0x0A
00BC  1283  	BCF STATUS, RP0
00BD  00F8  	MOVWF delay_us_00000_arg_del
00BE  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
00BF  1683  	BSF STATUS, RP0
00C0  1587  	BSF i2c_WRITE_00000_1_l_scl_tris,3


		// wait until any clock stretching has finished
		while (!l_scl)
00C1        label14
00C1  1283  	BCF STATUS, RP0
00C2  1987  	BTFSC i2c_WRITE_00000_1_l_scl,3
00C3  28C6  	GOTO	label15
00C5  28C1  	GOTO	label14
00C6        label15

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
00C4  0064  	CLRWDT

		delay_us(dly);
00C6  300A  	MOVLW 0x0A
00C7  00F8  	MOVWF delay_us_00000_arg_del
00C8  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low	
00C9  1683  	BSF STATUS, RP0
00CA  1187  	BCF i2c_WRITE_00000_1_l_scl_tris,3

		delay_us(dly);
00CB  300A  	MOVLW 0x0A
00CC  1283  	BCF STATUS, RP0
00CD  00F8  	MOVWF delay_us_00000_arg_del
00CE  2010  	CALL delay_us_00000

	}
	// serialized out the data
	// now get the status		
	// set SSPIF
	l_sspif = 1;
00D2  15C5  	BSF i2c_WRITE_00000_1_l_sspif,3

	l_acken = 1;
00D3  1641  	BSF i2c_WRITE_00000_1_l_acken,4

	l_ackdt = 0;
00D4  12C1  	BCF i2c_WRITE_00000_1_l_ackdt,5

	l_sda_tris = 1; // float SDA high
00D5  1683  	BSF STATUS, RP0
00D6  1607  	BSF i2c_WRITE_00000_1_l_sda_tris,4

	
	delay_us(dly);
00D7  300A  	MOVLW 0x0A
00D8  1283  	BCF STATUS, RP0
00D9  00F8  	MOVWF delay_us_00000_arg_del
00DA  2010  	CALL delay_us_00000

	
	l_scl_tris = 1; // float SCL high
00DB  1683  	BSF STATUS, RP0
00DC  1587  	BSF i2c_WRITE_00000_1_l_scl_tris,3

	
	// wait until any clock stretching has finished
	while (!l_scl)
00DD        label17
00DD  1283  	BCF STATUS, RP0
00DE  1987  	BTFSC i2c_WRITE_00000_1_l_scl,3
00DF  28E2  	GOTO	label18
00E1  28DD  	GOTO	label17
00E2        label18

		if (T_MODE & i2c_reset_wdt)
			clear_wdt();	
00E0  0064  	CLRWDT

	delay_us(dly);
00E2  300A  	MOVLW 0x0A
00E3  00F8  	MOVWF delay_us_00000_arg_del
00E4  2010  	CALL delay_us_00000


	// get the status bit
	local_ack = l_sda;
00E5  1077  	BCF i2c_WRITE_00000_1_local_ack,0
00E6  1A07  	BTFSC i2c_WRITE_00000_1_l_sda,4
00E7  1477  	BSF i2c_WRITE_00000_1_local_ack,0

	delay_us(dly);
00E8  300A  	MOVLW 0x0A
00E9  00F8  	MOVWF delay_us_00000_arg_del
00EA  2010  	CALL delay_us_00000


	l_scl_tris = 0; // drive SCL low	
00EB  1683  	BSF STATUS, RP0
00EC  1187  	BCF i2c_WRITE_00000_1_l_scl_tris,3

	l_acken = 0;
00ED  1283  	BCF STATUS, RP0
00EE  1241  	BCF i2c_WRITE_00000_1_l_acken,4

	delay_us(dly);
00EF  300A  	MOVLW 0x0A
00F0  00F8  	MOVWF delay_us_00000_arg_del
00F1  2010  	CALL delay_us_00000

	return(local_ack);
00F2  01F8  	CLRF CompTempVarRet552
00F3  1877  	BTFSC i2c_WRITE_00000_1_local_ack,0
00F4  0AF8  	INCF CompTempVarRet552, F

}
00F5  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Read Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_READ(char ack_status)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	char BitMask;
	char i2c_data;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
01CD  11C6  	BCF i2c_READ_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
01CE  11C5  	BCF i2c_READ_00000_1_l_sspif,3

	l_wcol = 0; // clear write collision flag	
01CF  13C0  	BCF i2c_READ_00000_1_l_wcol,7


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// enable master for 1 byte reception	
		l_rcen = 1;

		// wait until byte received
		while(!l_sspif || !l_bf)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// read the byte from the Rx register
		i2c_data = i2c_SSPBUF;			
			
		// wait until the bus is idle		
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		if (ack_status)
			l_ackdt = 1; // preset ack bit
		else
			l_ackdt = 0; // preset ack bit

		l_sspif = 0;
		l_acken = 1; // acknowledge sequence enable

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();								
	}
	else
	{
		// here for i2c software driver
		l_rcen = 1;
01D0  15C1  	BSF i2c_READ_00000_1_l_rcen,3

		l_ackdt = ack_status;
01D1  1875  	BTFSC i2c_READ_00000_arg_ack_status,0
01D2  16C1  	BSF i2c_READ_00000_1_l_ackdt,5
01D3  1C75  	BTFSS i2c_READ_00000_arg_ack_status,0
01D4  12C1  	BCF i2c_READ_00000_1_l_ackdt,5

		l_rw = 1;
01D5  1542  	BSF i2c_READ_00000_1_l_rw,2

		l_scl = 0; // prepare to set SCL line low
01D6  1187  	BCF i2c_READ_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low	
01D7  1207  	BCF i2c_READ_00000_1_l_sda,4


		// prepare to serialize in the byte
		l_sda_tris = 1; // float SDA
01D8  1683  	BSF STATUS, RP0
01D9  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

		delay_us(dly);
01DA  300A  	MOVLW 0x0A
01DB  1283  	BCF STATUS, RP0
01DC  00F8  	MOVWF delay_us_00000_arg_del
01DD  2010  	CALL delay_us_00000

		i2c_data = 0;
01DE  01F7  	CLRF i2c_READ_00000_1_i2c_data

		for (BitMask = 0x80; BitMask; BitMask>>=1)
01DF  3080  	MOVLW 0x80
01E0  00F6  	MOVWF i2c_READ_00000_1_BitMask
01E1        label35
01E1  08F6  	MOVF i2c_READ_00000_1_BitMask, F
01E2  1903  	BTFSC STATUS,Z
01E3  29FE  	GOTO	label39
01FB  1003  	BCF STATUS,C
01FC  0CF6  	RRF i2c_READ_00000_1_BitMask, F
01FD  29E1  	GOTO	label35
01FE        label39

		{
			l_scl_tris = 1; // float SCL high
01E4  1683  	BSF STATUS, RP0
01E5  1587  	BSF i2c_READ_00000_1_l_scl_tris,3

			// wait until any clock stretching has finished
			while (!l_scl)
01E6        label36
01E6  1283  	BCF STATUS, RP0
01E7  1987  	BTFSC i2c_READ_00000_1_l_scl,3
01E8  29EB  	GOTO	label37
01EA  29E6  	GOTO	label36
01EB        label37

				if (T_MODE & i2c_reset_wdt)
					clear_wdt();		
01E9  0064  	CLRWDT

			delay_us(dly);
01EB  300A  	MOVLW 0x0A
01EC  00F8  	MOVWF delay_us_00000_arg_del
01ED  2010  	CALL delay_us_00000


			// read the current bit
			l_sda_tris = 1; // float SDA
01EE  1683  	BSF STATUS, RP0
01EF  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

			if (l_sda)
01F0  1283  	BCF STATUS, RP0
01F1  1E07  	BTFSS i2c_READ_00000_1_l_sda,4
01F2  29F5  	GOTO	label38
01F5        label38

				i2c_data |= BitMask;
01F3  0876  	MOVF i2c_READ_00000_1_BitMask, W
01F4  04F7  	IORWF i2c_READ_00000_1_i2c_data, F

			l_scl_tris = 0; // drive SCL low
01F5  1683  	BSF STATUS, RP0
01F6  1187  	BCF i2c_READ_00000_1_l_scl_tris,3

			delay_us(dly);
01F7  300A  	MOVLW 0x0A
01F8  1283  	BCF STATUS, RP0
01F9  00F8  	MOVWF delay_us_00000_arg_del
01FA  2010  	CALL delay_us_00000

		}
		// flag receive complete			
		l_sspif = 1;
01FE  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		l_rcen = 0;
01FF  11C1  	BCF i2c_READ_00000_1_l_rcen,3

		
		// set the ACK state
		if (ack_status)	
0200  08F5  	MOVF i2c_READ_00000_arg_ack_status, F
0201  1903  	BTFSC STATUS,Z
0202  2A06  	GOTO	label40
0206        label40

			l_sda_tris = 1; // float SDA high
0203  1683  	BSF STATUS, RP0
0204  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

		else
0205  2A08  	GOTO	label41
0208        label41

			l_sda_tris = 0; // drive SDA low
0206  1683  	BSF STATUS, RP0
0207  1207  	BCF i2c_READ_00000_1_l_sda_tris,4

		delay_us(dly);
0208  300A  	MOVLW 0x0A
0209  1283  	BCF STATUS, RP0
020A  00F8  	MOVWF delay_us_00000_arg_del
020B  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
020C  1683  	BSF STATUS, RP0
020D  1587  	BSF i2c_READ_00000_1_l_scl_tris,3


		// wait until any clock stretching has finished
		while (!l_scl)
020E        label42
020E  1283  	BCF STATUS, RP0
020F  1987  	BTFSC i2c_READ_00000_1_l_scl,3
0210  2A13  	GOTO	label43
0212  2A0E  	GOTO	label42
0213        label43

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
0211  0064  	CLRWDT

	
		l_sspif = 0; // clear SSPIF
0213  11C5  	BCF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
0214  300A  	MOVLW 0x0A
0215  00F8  	MOVWF delay_us_00000_arg_del
0216  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low		
0217  1683  	BSF STATUS, RP0
0218  1187  	BCF i2c_READ_00000_1_l_scl_tris,3

		l_sspif = 1;
0219  1283  	BCF STATUS, RP0
021A  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
021B  300A  	MOVLW 0x0A
021C  00F8  	MOVWF delay_us_00000_arg_del
021D  2010  	CALL delay_us_00000

	}
	return(i2c_data);
021E  0877  	MOVF i2c_READ_00000_1_i2c_data, W
021F  00F8  	MOVWF CompTempVarRet553

}
0220  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Initialization
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_INIT(unsigned char i2c_divisor)

{
	volatile unsigned char i2c_SSPADD@T_i2c_SSPADD, i2c_SSPSTAT@T_i2c_SSPSTAT;
	volatile unsigned char i2c_SSPCON1@T_i2c_SSPCON1,i2c_SSPCON2@T_i2c_SSPCON2;

	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_sspen@T_i2c_SSPCON1.i2c_SSPEN, l_smp@T_i2c_SSPSTAT.T_i2c_SMP_BIT;

	l_sda_tris = 1;
04E2  1683  	BSF STATUS, RP0
04E3  1607  	BSF i2c_INIT_00000_1_l_sda_tris,4

	l_scl_tris = 1;
04E4  1587  	BSF i2c_INIT_00000_1_l_scl_tris,3

	
	i2c_SSPCON1 = 0x00; // initialise the I2C control register (mirrors HW SSPCON1)	
04E5  1283  	BCF STATUS, RP0
04E6  01C0  	CLRF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPADD = i2c_divisor; // get the I2C baud rate divisor
04E7  0873  	MOVF i2c_INIT_00000_arg_i2c_divisor, W
04E8  00C3  	MOVWF i2c_INIT_00000_1_i2c_SSPADD

	i2c_SSPCON1 = 0x08; // initialise the I2C control register (mirrors HW SSPCON1)	
04E9  3008  	MOVLW 0x08
04EA  00C0  	MOVWF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPCON2 = 0x00; // initialise the I2C control register (mirrors HW SSPCON2)	
04EB  01C1  	CLRF i2c_INIT_00000_1_i2c_SSPCON2

	
	i2c_SSPSTAT = 0x00; // initialise the I2C status register (mirrors HW SSPSTAT)
04EC  01C2  	CLRF i2c_INIT_00000_1_i2c_SSPSTAT

	
	if (T_MODE & i2c_SMP)
		l_smp = 1;
04ED  17C2  	BSF i2c_INIT_00000_1_l_smp,7


	l_sspif = 0; // initialise the I2C SSP interrupt status
04EE  11C5  	BCF i2c_INIT_00000_1_l_sspif,3

	l_bclif = 0; // initialise the I2C BCL interrupt status
04EF  11C6  	BCF i2c_INIT_00000_1_l_bclif,3

	l_sda = 0;
04F0  1207  	BCF i2c_INIT_00000_1_l_sda,4

	l_scl = 0;
04F1  1187  	BCF i2c_INIT_00000_1_l_scl,3

	l_sspen = 1; // enable I2C
04F2  16C0  	BSF i2c_INIT_00000_1_l_sspen,5

	
	i2c_STOP<_I2C_TEMPL_ARGS>();
04F3  20F6  	CALL i2c_STOP_00000

}
04F4  0008  	RETURN







////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  158A  	BSF PCLATH,3
0001  29A6  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B0  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00B1  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00B2  	MOVWF Int1BContext+D'2'
000D  158A  	BSF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2A0D  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010  3003  	MOVLW 0x03
0011  07F8  	ADDWF delay_us_00000_arg_del, F
0012  0CF8  	RRF delay_us_00000_arg_del, F
0013  0CF8  	RRF delay_us_00000_arg_del, F
0014  307F  	MOVLW 0x7F
0015  05F8  	ANDWF delay_us_00000_arg_del, F
0016        label1
0016  0000  	NOP
0017  0BF8  	DECFSZ delay_us_00000_arg_del, F
0018  2816  	GOTO	label1
0019  0008  	RETURN
001A        ; } delay_us function end

001A        __rom_get_00000
001A        ; { __rom_get ; function begin
001A  087B  	MOVF __rom_get_00000_arg_objNumb, W
001B  00FE  	MOVWF __rom_get_00000_1_romAddr+D'1'
001C  01FD  	CLRF __rom_get_00000_1_romAddr
001D  1003  	BCF STATUS,C
001E  0DFE  	RLF __rom_get_00000_1_romAddr+D'1', F
001F  0DFD  	RLF __rom_get_00000_1_romAddr, F
0020  0DFE  	RLF __rom_get_00000_1_romAddr+D'1', F
0021  0DFD  	RLF __rom_get_00000_1_romAddr, F
0022  07FE  	ADDWF __rom_get_00000_1_romAddr+D'1', F
0023  1803  	BTFSC STATUS,C
0024  0AFD  	INCF __rom_get_00000_1_romAddr, F
0025  07FE  	ADDWF __rom_get_00000_1_romAddr+D'1', F
0026  1803  	BTFSC STATUS,C
0027  0AFD  	INCF __rom_get_00000_1_romAddr, F
0028  3033  	MOVLW	LOW( label2 )
0029  07FE  	ADDWF __rom_get_00000_1_romAddr+D'1', F
002A  1803  	BTFSC STATUS,C
002B  0AFD  	INCF __rom_get_00000_1_romAddr, F
002C  3000  	MOVLW	HIGH( label2 )
002D  077D  	ADDWF __rom_get_00000_1_romAddr, W
002E  008A  	MOVWF PCLATH
002F  087C  	MOVF __rom_get_00000_arg_idx, W
0030  00FD  	MOVWF __rom_get_00000_1_romAddr
0031  087E  	MOVF __rom_get_00000_1_romAddr+D'1', W
0032  0082  	MOVWF PCL
0033        label2
0033  3000  	MOVLW	HIGH( label3 )
0034  008A  	MOVWF PCLATH
0035  3000  	MOVLW	HIGH( label4 )
0036  00FE  	MOVWF __rom_get_00000_1_romAddr+D'1'
0037  3049  	MOVLW	LOW( label4 )
0038  2842  	GOTO	label3
0039  3000  	MOVLW	HIGH( label3 )
003A  008A  	MOVWF PCLATH
003B  3000  	MOVLW	HIGH( label5 )
003C  00FE  	MOVWF __rom_get_00000_1_romAddr+D'1'
003D  3055  	MOVLW	LOW( label5 )
003E  2842  	GOTO	label3
003F  3000  	MOVLW	HIGH( label6 )
0040  00FE  	MOVWF __rom_get_00000_1_romAddr+D'1'
0041  306D  	MOVLW	LOW( label6 )
0042        label3
0042  07FD  	ADDWF __rom_get_00000_1_romAddr, F
0043  1803  	BTFSC STATUS,C
0044  0AFE  	INCF __rom_get_00000_1_romAddr+D'1', F
0045  087E  	MOVF __rom_get_00000_1_romAddr+D'1', W
0046  008A  	MOVWF PCLATH
0047  087D  	MOVF __rom_get_00000_1_romAddr, W
0048  0082  	MOVWF PCL
0049        label4
0049  3431  	RETLW 0x31
004A  3428  	RETLW 0x28
004B  3431  	RETLW 0x31
004C  3430  	RETLW 0x30
004D  3431  	RETLW 0x31
004E  3430  	RETLW 0x30
004F  3431  	RETLW 0x31
0050  3431  	RETLW 0x31
0051  3430  	RETLW 0x30
0052  3431  	RETLW 0x31
0053  3430  	RETLW 0x30
0054  3431  	RETLW 0x31
0055        label5
0055  3404  	RETLW 0x04
0056  3408  	RETLW 0x08
0057  3412  	RETLW 0x12
0058  3416  	RETLW 0x16
0059  3420  	RETLW 0x20
005A  3424  	RETLW 0x24
005B  3428  	RETLW 0x28
005C  3432  	RETLW 0x32
005D  3436  	RETLW 0x36
005E  3440  	RETLW 0x40
005F  3444  	RETLW 0x44
0060  3448  	RETLW 0x48
0061  3452  	RETLW 0x52
0062  3456  	RETLW 0x56
0063  3460  	RETLW 0x60
0064  3464  	RETLW 0x64
0065  3468  	RETLW 0x68
0066  3472  	RETLW 0x72
0067  3476  	RETLW 0x76
0068  3480  	RETLW 0x80
0069  3484  	RETLW 0x84
006A  3488  	RETLW 0x88
006B  3492  	RETLW 0x92
006C  3496  	RETLW 0x96
006D        label6
006D  343F  	RETLW 0x3F
006E  3406  	RETLW 0x06
006F  345B  	RETLW 0x5B
0070  344F  	RETLW 0x4F
0071  3466  	RETLW 0x66
0072  346D  	RETLW 0x6D
0073  347D  	RETLW 0x7D
0074  3407  	RETLW 0x07
0075  347F  	RETLW 0x7F
0076  346F  	RETLW 0x6F
0077        ; } __rom_get function end

0077        delay_10us_00000
0077        ; { delay_10us ; function begin
0077        label7
0077  0000  	NOP
0078  0000  	NOP
0079  0000  	NOP
007A  0000  	NOP
007B  0000  	NOP
007C  0000  	NOP
007D  0000  	NOP
007E  0BF7  	DECFSZ delay_10us_00000_arg_del, F
007F  2877  	GOTO	label7
0080  0008  	RETURN
0081        ; } delay_10us function end

0081        delay_ms_00000
0081        ; { delay_ms ; function begin
0081  08F2  	MOVF delay_ms_00000_arg_del, F
0082  1D03  	BTFSS STATUS,Z
0083  2885  	GOTO	label8
0084  0008  	RETURN
0085        label8
0085  30F9  	MOVLW 0xF9
0086        label9
0086  3EFF  	ADDLW 0xFF
0087  1D03  	BTFSS STATUS,Z
0088  2886  	GOTO	label9
0089  0000  	NOP
008A  0BF2  	DECFSZ delay_ms_00000_arg_del, F
008B  2885  	GOTO	label8
008C  0008  	RETURN
008D        ; } delay_ms function end











025F        __mul_16s__0000F
025F        ; { __mul_16s_16s__16 ; function begin
025F  01FE  	CLRF __mul_16s__0000F_1_i
0260  1683  	BSF STATUS, RP0
0261  01A2  	CLRF CompTempVarRet389
0262  01A3  	CLRF CompTempVarRet389+D'1'
0263  1283  	BCF STATUS, RP0
0264  087A  	MOVF __mul_16s__0000F_arg_a, W
0265  1683  	BSF STATUS, RP0
0266  00A0  	MOVWF __mul_16s__0000F_1_t
0267  1283  	BCF STATUS, RP0
0268  087B  	MOVF __mul_16s__0000F_arg_a+D'1', W
0269  1683  	BSF STATUS, RP0
026A  00A1  	MOVWF __mul_16s__0000F_1_t+D'1'
026B  1283  	BCF STATUS, RP0
026C  1FFD  	BTFSS __mul_16s__0000F_arg_b+D'1',7
026D  2A74  	GOTO	label50
026E  17FE  	BSF __mul_16s__0000F_1_i,7
026F  09FC  	COMF __mul_16s__0000F_arg_b, F
0270  09FD  	COMF __mul_16s__0000F_arg_b+D'1', F
0271  0AFC  	INCF __mul_16s__0000F_arg_b, F
0272  1903  	BTFSC gbl_status,2
0273  0AFD  	INCF __mul_16s__0000F_arg_b+D'1', F
0274        label50
0274  1A7E  	BTFSC __mul_16s__0000F_1_i,4
0275  2A8A  	GOTO	label52
0276  1C7C  	BTFSS __mul_16s__0000F_arg_b,0
0277  2A7F  	GOTO	label51
0278  1683  	BSF STATUS, RP0
0279  0820  	MOVF __mul_16s__0000F_1_t, W
027A  07A2  	ADDWF CompTempVarRet389, F
027B  0821  	MOVF __mul_16s__0000F_1_t+D'1', W
027C  1803  	BTFSC gbl_status,0
027D  0F21  	INCFSZ __mul_16s__0000F_1_t+D'1', W
027E  07A3  	ADDWF CompTempVarRet389+D'1', F
027F        label51
027F  1003  	BCF gbl_status,0
0280  1283  	BCF STATUS, RP0
0281  0CFD  	RRF __mul_16s__0000F_arg_b+D'1', F
0282  0CFC  	RRF __mul_16s__0000F_arg_b, F
0283  1003  	BCF gbl_status,0
0284  1683  	BSF STATUS, RP0
0285  0DA0  	RLF __mul_16s__0000F_1_t, F
0286  0DA1  	RLF __mul_16s__0000F_1_t+D'1', F
0287  1283  	BCF STATUS, RP0
0288  0AFE  	INCF __mul_16s__0000F_1_i, F
0289  2A74  	GOTO	label50
028A        label52
028A  1FFE  	BTFSS __mul_16s__0000F_1_i,7
028B  0008  	RETURN
028C  1683  	BSF STATUS, RP0
028D  09A2  	COMF CompTempVarRet389, F
028E  09A3  	COMF CompTempVarRet389+D'1', F
028F  0AA2  	INCF CompTempVarRet389, F
0290  1903  	BTFSC gbl_status,2
0291  0AA3  	INCF CompTempVarRet389+D'1', F
0292  0008  	RETURN
0293        ; } __mul_16s_16s__16 function end





































09A6        _startup

0A0A  158A  	BSF PCLATH,3
0A0B  120A  	BCF PCLATH,4
0A0C  28CE  	GOTO	main

2007  3FB1  	DW 0x3FB1
