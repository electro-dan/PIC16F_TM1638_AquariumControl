;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 8.01
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

#ifndef _PIC16F_TM1638_AquariumControl_H_
#define _PIC16F_TM1638_AquariumControl_H_

#define TASK_TIMER1 2
#define TASK_TIMER1_START 3
#define TASK_TIMER1_READ 4
#define TASK_TIMER2 5

#define oneWireBus (portc.5)
#define oneWireTris (trisc.5)
#define tm1638dio (portb.1)
#define tm1638dioTris (trisb.1)
#define tm1638clk (portb.2)
#define tm1638strobe (portb.3)
#define WHITE_LED (portc.1)
#define BLUE_LED (portc.2)
#define FAN (porta.1)
#define HEATER (porta.0)

// This means timer 1 will overflow when 1 cycle completes, generating the interrupt
#define TMR1HV 0xFF
#define TMR1LV 0xFF

// i2c options
#define use_i2c_SW
// clock SCL on RA3, data SDA on RA4
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)
// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3

#define ds3231_addr 0xD0 // Left shifted 7 bit address 0x68
#define at24c32_addr 0xAE // Left shifted 7 bit address 0x57

// Time and date variables
char gBcdSeconds = 0; // 0 to 59
07D7  1283  	BCF STATUS, RP0
07D8  1303  	BCF STATUS, RP1
07D9  01B5  	CLRF gbl_gBcdSeconds

char gBcdMinute = 0; // 0 to 59
07DA  01B6  	CLRF gbl_gBcdMinute

char gBcdHour = 0; // 0 to 23 or 1 to 12. Also contains 12/24 setting at bit 6. If 12 hour, AM/PM uses bit 5
07DB  01B7  	CLRF gbl_gBcdHour

char gDayOfWeek = 1; // 1 to 7
07DC  3001  	MOVLW 0x01
07DD  00B8  	MOVWF gbl_gDayOfWeek

char gBcdDayOfMonth = 1; // 1 to 31
07DE  3001  	MOVLW 0x01
07DF  00B9  	MOVWF gbl_gBcdDayOfMonth

char gBcdMonth = 1; // 1 to 12 + century at bit 7
07E0  3001  	MOVLW 0x01
07E1  00BA  	MOVWF gbl_gBcdMonth

char gBcdYear = 0x23; // Init to 0x23
07E2  3023  	MOVLW 0x23
07E3  00BB  	MOVWF gbl_gBcdYear

rom char *gDaysInMonth = {0x31, 0x28, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31}; // Days in each month
07E4  3000  	MOVLW 0x00
07E5  00BC  	MOVWF gbl_gDaysInMonth

rom char *gLeapYears = {0x04, 0x08, 0x12, 0x16, 0x20, 0x24, 0x28, 0x32, 0x36, 0x40, 0x44, 0x48, 0x52, 0x56, 0x60, 0x64, 0x68, 0x72, 0x76, 0x80, 0x84, 0x88, 0x92, 0x96}; // List of leap years
07E6  3001  	MOVLW 0x01
07E7  00BD  	MOVWF gbl_gLeapYears


// Timer variables
char iTimer2Counts = 0;
07E8  01BE  	CLRF gbl_iTimer2Counts

char iFlashDigitOff = 0;
07E9  01BF  	CLRF gbl_iFlashDigitOff

char iDigitToFlash = 8; // 8 = no digit to flash
07EA  3008  	MOVLW 0x08
07EB  00C8  	MOVWF gbl_iDigitToFlash


// Hold the upper and lower bytes from the ds18b0x
char cTempH = 0;
07EC  01C9  	CLRF gbl_cTempH

char cTempL = 0;
07ED  01CA  	CLRF gbl_cTempL

//char iDecimalPosition = 2;

int giDS3231ValueBCD = 0;
07EE  01B3  	CLRF gbl_giDS3231ValueBCD
07EF  01B4  	CLRF gbl_giDS3231ValueBCD+D'1'

char gbDS3231IsMinus = 0;
07F0  01CB  	CLRF gbl_gbDS3231IsMinus


char cTask = 0; // Used for task scheduler
07F1  01CC  	CLRF gbl_cTask


// States
bool gbWhiteOn = 0;
07F2  104D  	BCF gbl_gbWhiteOn,0

bool gbBlueOn = 0;
07F3  10CD  	BCF gbl_gbBlueOn,1

bool gbFanOn = 0;
07F4  114D  	BCF gbl_gbFanOn,2

bool gbHeaterOn = 0;
07F5  11CD  	BCF gbl_gbHeaterOn,3

bool gbFlashOff = 0;
07F6  124D  	BCF gbl_gbFlashOff,4

char gcDisplayMode = 0;
07F7  01CE  	CLRF gbl_gcDisplayMode

char gcSetMode = 0;
07F8  01CF  	CLRF gbl_gcSetMode

char gcTriggerMode = 0;
07F9  01D0  	CLRF gbl_gcTriggerMode


// Triggers
char gBcdWhiteOnMinute = 0; // 0 to 59
07FA  01D1  	CLRF gbl_gBcdWhiteOnMinute

char gBcdWhiteOnHour = 0; // 0 to 23
07FB  01D2  	CLRF gbl_gBcdWhiteOnHour

char gBcdWhiteOffMinute = 0; // 0 to 59
07FC  01D3  	CLRF gbl_gBcdWhiteOffMinute

char gBcdWhiteOffHour = 0; // 0 to 23
07FD  01D4  	CLRF gbl_gBcdWhiteOffHour


char gBcdBlueOnMinute = 0; // 0 to 59
07FE  01D5  	CLRF gbl_gBcdBlueOnMinute

char gBcdBlueOnHour = 0; // 0 to 23
07FF  01D6  	CLRF gbl_gBcdBlueOnHour

char gBcdBlueOffMinute = 0; // 0 to 59
0800  01D7  	CLRF gbl_gBcdBlueOffMinute

char gBcdBlueOffHour = 0; // 0 to 23
0801  01D8  	CLRF gbl_gBcdBlueOffHour


char gBcdFanOnTemp = 0x28; // Degrees C
0802  3028  	MOVLW 0x28
0803  00D9  	MOVWF gbl_gBcdFanOnTemp

char gBcdFanOffTemp = 0x27; // Degrees C
0804  3027  	MOVLW 0x27
0805  00DA  	MOVWF gbl_gBcdFanOffTemp


char gBcdHeaterOnTemp = 0x24; // Degrees C
0806  3024  	MOVLW 0x24
0807  00DB  	MOVWF gbl_gBcdHeaterOnTemp

char gBcdHeaterOffTemp = 0x25; // Degrees C
0808  3025  	MOVLW 0x25
0809  00DC  	MOVWF gbl_gBcdHeaterOffTemp


// Used to output the segments from numbers
char tm1638MaxDigits = 8;
080A  3008  	MOVLW 0x08
080B  00DD  	MOVWF gbl_tm1638MaxDigits

rom char *tm1638DisplayNumtoSeg = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f};
080C  3002  	MOVLW 0x02
080D  00DE  	MOVWF gbl_tm1638DisplayNumtoSeg

char tm1638Dot = 0x80;
080E  3080  	MOVLW 0x80
080F  00DF  	MOVWF gbl_tm1638Dot

char tm1638Brightness = 7; // 0 to 7
0810  3007  	MOVLW 0x07
0811  00E0  	MOVWF gbl_tm1638Brightness

// 0x40 [01000000] = indicate command to display data
char tm1638ByteSetData = 0x40;
0812  3040  	MOVLW 0x40
0813  00E1  	MOVWF gbl_tm1638ByteSetData

// 0x42 [01000010] = indicate command to read data
char tm1638ByteReadData = 0x42;
0814  3042  	MOVLW 0x42
0815  00E2  	MOVWF gbl_tm1638ByteReadData

// 0xC0 [11000000] = write out all bytes
char tm1638ByteSetAddr = 0xC0;
0816  30C0  	MOVLW 0xC0
0817  00E3  	MOVWF gbl_tm1638ByteSetAddr

// 0x88 [10001000] - Display ON, plus brightness
char tm1638ByteSetOn = 0x88;
0818  3088  	MOVLW 0x88
0819  00E4  	MOVWF gbl_tm1638ByteSetOn


// Copy of the data to write / on the display
char tm1638Data[] = {0, 0, 0, 0, 0, 0, 0, 0};
081A  01A0  	CLRF gbl_tm1638Data
081B  01A1  	CLRF gbl_tm1638Data+D'1'
081C  01A2  	CLRF gbl_tm1638Data+D'2'
081D  01A3  	CLRF gbl_tm1638Data+D'3'
081E  01A4  	CLRF gbl_tm1638Data+D'4'
081F  01A5  	CLRF gbl_tm1638Data+D'5'
0820  01A6  	CLRF gbl_tm1638Data+D'6'
0821  01A7  	CLRF gbl_tm1638Data+D'7'

// Copy of the LED status
char tm1638LEDs[] = {0, 0, 0, 0, 0, 0, 0, 0};
0822  01A8  	CLRF gbl_tm1638LEDs
0823  01A9  	CLRF gbl_tm1638LEDs+D'1'
0824  01AA  	CLRF gbl_tm1638LEDs+D'2'
0825  01AB  	CLRF gbl_tm1638LEDs+D'3'
0826  01AC  	CLRF gbl_tm1638LEDs+D'4'
0827  01AD  	CLRF gbl_tm1638LEDs+D'5'
0828  01AE  	CLRF gbl_tm1638LEDs+D'6'
0829  01AF  	CLRF gbl_tm1638LEDs+D'7'

// Copy of the keys
char tm1638Keys = 0;
082A  01E5  	CLRF gbl_tm1638Keys

// For printing
char iPrintStartDigit = 0;
082B  01E6  	CLRF gbl_iPrintStartDigit

char iPrintDotDigit = 8;
082C  3008  	MOVLW 0x08
082D  00E7  	MOVWF gbl_iPrintDotDigit

// For adjusting bcd numbers up 1 or down !1
char iBcdAdjustment = 1;
082E  3001  	MOVLW 0x01
082F  00E8  	MOVWF gbl_iBcdAdjustment


// DS18B20 functions
char oneWireIsPresent = 0;
0830  01E9  	CLRF gbl_oneWireIsPresent

char oneWireResetStage = 0;
0831  01EA  	CLRF gbl_oneWireResetStage

void oneWireBusReset();
void oneWireTxByte(char data);
void oneWireTxBytes(char data, char data2);
char oneWireRxByte();

// EEPROM functions
void eepromWriteAll();
char eepromWrite(char address, char data);
void eepromReadAll();
char eepromRead(char address);

// DS3231 functions
void ds3231Write(char ds3231Reg, char bWrite);
void ds3231Init();
void ds3231Start();
void ds3231Stop();
void ds3231WriteDateTime();
void ds3231ReadDateTime();
char ds3231ReadRegister(char cRegAddress);

// TM1638 functions
void tm1638ByteWrite(char bWrite);
void bcdTo7Seg(char iBcdIn);
void tm1638UpdateDisplay();
void tm1638ReadKeys();

// General functions
int binToBcd(int iBin);
void startTemp();
void readTemp();

char bcdAdjust(char bcd, char bcdMax, char bcdMin);
void adjustDateTime();
void adjustTrigger();
void processKeys();

#endif

#include <system.h>
#include <i2c_driver.h>
#include "PIC16F_TM1638_AquariumControl.h"

//Target PIC16F628A configuration word
#pragma DATA _CONFIG, _BODEN_OFF & _PWRTE_ON & _WDT_OFF & _CP_OFF & _XT_OSC // Brown out reset off, Power-up Timer on, Watchdog timer off, Code Protection off, XT oscillator

//Set clock frequency (for software delays) - 4MHz
#pragma CLOCK_FREQ	4000000

    
/*********************************************************************************************
  oneWireBusReset()
  First part of the reset routine - drive the bus low for 500us
*********************************************************************************************/
void oneWireBusReset() {

    char isPresent;
    oneWireTris = 1; // start with high
06C5  1683  	BSF STATUS, RP0
06C6  1303  	BCF STATUS, RP1
06C7  1687  	BSF gbl_trisc,5

    isPresent = 0;
06C8  1283  	BCF STATUS, RP0
06C9  01EC  	CLRF oneWireBus_00017_1_isPresent

    // Send the reset pulse - drive low for 500us
    oneWireBus = 0;      
06CA  1287  	BCF gbl_portc,5

    oneWireTris = 0;
06CB  1683  	BSF STATUS, RP0
06CC  1287  	BCF gbl_trisc,5

    delay_10us(50);
06CD  3032  	MOVLW 0x32
06CE  1283  	BCF STATUS, RP0
06CF  00F1  	MOVWF delay_10us_00000_arg_del
06D0  201A  	CALL delay_10us_00000

    // Release line and wait 70us for PD Pulse
    oneWireTris = 1;
06D1  1683  	BSF STATUS, RP0
06D2  1687  	BSF gbl_trisc,5

    delay_10us(7);
06D3  3007  	MOVLW 0x07
06D4  1283  	BCF STATUS, RP0
06D5  00F1  	MOVWF delay_10us_00000_arg_del
06D6  201A  	CALL delay_10us_00000

    // Now sample, if there is a sensor on the bus, the line should be low
    if (oneWireBus) {
06D7  1A87  	BTFSC gbl_portc,5

        oneWireIsPresent = 0; // no devices
06D8  01E9  	CLRF gbl_oneWireIsPresent

    }
    delay_10us(50);
06D9  3032  	MOVLW 0x32
06DA  00F1  	MOVWF delay_10us_00000_arg_del
06DB  201A  	CALL delay_10us_00000

}
06DC  0008  	RETURN


/*********************************************************************************************
  oneWireTxByte(char data)
  Transmits a single byte from the bus
*********************************************************************************************/
void oneWireTxByte(char cData) {

    char cTemp = 1;
0143  3001  	MOVLW 0x01
0144  00EF  	MOVWF oneWireTxB_00018_1_cTemp

    // Loop through the eight bits in the byte
    for (char i = 0; i < 8; i++) {
0145  01F0  	CLRF oneWireTxB_00018_2_i
0146        label24
0146  3008  	MOVLW 0x08
0147  0270  	SUBWF oneWireTxB_00018_2_i, W
0148  1803  	BTFSC STATUS,C
015D  0AF0  	INCF oneWireTxB_00018_2_i, F
015E  2946  	GOTO	label24

        // Send the LSB first

        // Drive the line low initially for 3us
        oneWireTris = 0;
014A  1683  	BSF STATUS, RP0
014B  1287  	BCF gbl_trisc,5

        oneWireBus = 0;
014C  1283  	BCF STATUS, RP0
014D  1287  	BCF gbl_portc,5


        // Delay not needed for 4MHz PIC
        //delay_us(3); // Delay 3us
        
        if (cData & cTemp) {
014E  086F  	MOVF oneWireTxB_00018_1_cTemp, W
014F  056E  	ANDWF oneWireTxB_00018_arg_cData, W
0150  1903  	BTFSC STATUS,Z
0151  2954  	GOTO	label25

            oneWireTris = 1; // Release the bus
0152  1683  	BSF STATUS, RP0
0153  1687  	BSF gbl_trisc,5

        }
        
        delay_10us(5); // Delay 60us - 50us works fine with code delays
0154  3005  	MOVLW 0x05
0155  1283  	BCF STATUS, RP0
0156  00F1  	MOVWF delay_10us_00000_arg_del
0157  201A  	CALL delay_10us_00000

        oneWireTris = 1; // Release the bus
0158  1683  	BSF STATUS, RP0
0159  1687  	BSF gbl_trisc,5

        
        // move the test bit
        cTemp <<= 1;
015A  1003  	BCF STATUS,C
015B  1283  	BCF STATUS, RP0
015C  0DEF  	RLF oneWireTxB_00018_1_cTemp, F

    }
}
0149  0008  	RETURN


/*********************************************************************************************
  oneWireTxBytes(char data, char data2)
  Transmits a 2 bytes from the bus
*********************************************************************************************/
void oneWireTxBytes(char cData, char cData2) {

    // Reset first - done in main
    //oneWireBusReset();
    // Send first byte
    oneWireTxByte(cData);
01FC  086C  	MOVF oneWireTxB_00019_arg_cData, W
01FD  00EE  	MOVWF oneWireTxB_00018_arg_cData
01FE  2143  	CALL oneWireTxB_00018

    // Send second byte
    oneWireTxByte(cData2);
01FF  086D  	MOVF oneWireTxB_00019_arg_cData2, W
0200  00EE  	MOVWF oneWireTxB_00018_arg_cData
0201  2143  	CALL oneWireTxB_00018

}
0202  0008  	RETURN


/*********************************************************************************************
  oneWireRxByte()
  Receives a single byte from the bus
*********************************************************************************************/
char oneWireRxByte() {

    char cDataIn = 0;
0203  1283  	BCF STATUS, RP0
0204  1303  	BCF STATUS, RP1
0205  01EC  	CLRF oneWireRxB_0001A_1_cDataIn

    // Loop through the eight bits in the byte
    for(char i = 0; i < 8; i++) {
0206  01ED  	CLRF oneWireRxB_0001A_2_i
0207        label42
0207  3008  	MOVLW 0x08
0208  026D  	SUBWF oneWireRxB_0001A_2_i, W
0209  1803  	BTFSC STATUS,C
020A  2A1E  	GOTO	label43
021C  0AED  	INCF oneWireRxB_0001A_2_i, F
021D  2A07  	GOTO	label42
021E        label43

        // Bring bus low for 15us
        oneWireTris = 0;
020B  1683  	BSF STATUS, RP0
020C  1287  	BCF gbl_trisc,5

        oneWireBus = 0;
020D  1283  	BCF STATUS, RP0
020E  1287  	BCF gbl_portc,5


        // Delay not needed for 4MHz PIC
        //delay_us(15); // Delay 15us

        // Release bus for 6us, this is enough time for the slave to respond
        oneWireTris = 1;
020F  1683  	BSF STATUS, RP0
0210  1687  	BSF gbl_trisc,5

        delay_us(6); // Delay 6us
0211  3006  	MOVLW 0x06
0212  1283  	BCF STATUS, RP0
0213  00F1  	MOVWF delay_us_00000_arg_del
0214  2010  	CALL delay_us_00000

        
        // Shift data already received left
        cDataIn >>= 1;
0215  1003  	BCF STATUS,C
0216  0CEC  	RRF oneWireRxB_0001A_1_cDataIn, F

        // Check the value of the onewire bus - set the MSB of cDataIn if so
        if (oneWireBus)
0217  1A87  	BTFSC gbl_portc,5

            cDataIn.7 = 1;
0218  17EC  	BSF oneWireRxB_0001A_1_cDataIn,7


        // To finish time slot
        delay_10us(6); // 60us
0219  3006  	MOVLW 0x06
021A  00F1  	MOVWF delay_10us_00000_arg_del
021B  201A  	CALL delay_10us_00000

    } 
    
    return cDataIn;
021E  086C  	MOVF oneWireRxB_0001A_1_cDataIn, W
021F  00ED  	MOVWF CompTempVarRet550

}
0220  0008  	RETURN


// https://www.instructables.com/The-Most-Comprehensive-Guide-to-Programming-the-AT/
/*********************************************************************************************
 at24c32WriteAll()
 Write multiple bytes
*********************************************************************************************/
void at24c32WriteAll() {

	i2c_start();
02FE  210E  	CALL i2c_START_00000

	i2c_write(at24c32_addr); // address + write
02FF  30AE  	MOVLW 0xAE
0300  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
0301  208D  	CALL i2c_WRITE_00000

	// start at address 0
	i2c_write(0); // First word address (only 4 bits of the 12 bit byte address)
0302  01EE  	CLRF i2c_WRITE_00000_arg_i2c_data
0303  208D  	CALL i2c_WRITE_00000

	i2c_write(0); // Second word address 
0304  01EE  	CLRF i2c_WRITE_00000_arg_i2c_data
0305  208D  	CALL i2c_WRITE_00000

	// Write data bytes
	// We're only writing 12 bytes here, so no need to worry about row rollover after 32 bytes
	i2c_write(gBcdWhiteOnMinute);
0306  0851  	MOVF gbl_gBcdWhiteOnMinute, W
0307  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
0308  208D  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOnHour);
0309  0852  	MOVF gbl_gBcdWhiteOnHour, W
030A  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
030B  208D  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOffMinute);
030C  0853  	MOVF gbl_gBcdWhiteOffMinute, W
030D  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
030E  208D  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOffHour);
030F  0854  	MOVF gbl_gBcdWhiteOffHour, W
0310  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
0311  208D  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOnMinute);
0312  0855  	MOVF gbl_gBcdBlueOnMinute, W
0313  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
0314  208D  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOnHour);
0315  0856  	MOVF gbl_gBcdBlueOnHour, W
0316  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
0317  208D  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOffMinute);
0318  0857  	MOVF gbl_gBcdBlueOffMinute, W
0319  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
031A  208D  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOffHour);
031B  0858  	MOVF gbl_gBcdBlueOffHour, W
031C  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
031D  208D  	CALL i2c_WRITE_00000

    i2c_write(gBcdFanOnTemp);
031E  0859  	MOVF gbl_gBcdFanOnTemp, W
031F  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
0320  208D  	CALL i2c_WRITE_00000

    i2c_write(gBcdFanOffTemp);
0321  085A  	MOVF gbl_gBcdFanOffTemp, W
0322  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
0323  208D  	CALL i2c_WRITE_00000

    i2c_write(gBcdHeaterOnTemp);
0324  085B  	MOVF gbl_gBcdHeaterOnTemp, W
0325  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
0326  208D  	CALL i2c_WRITE_00000

    i2c_write(gBcdHeaterOffTemp);
0327  085C  	MOVF gbl_gBcdHeaterOffTemp, W
0328  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
0329  208D  	CALL i2c_WRITE_00000

	i2c_stop();
032A  20DE  	CALL i2c_STOP_00000

	delay_ms(10); // Write Cycle Time
032B  300A  	MOVLW 0x0A
032C  00EB  	MOVWF delay_ms_00000_arg_del
032D  2024  	CALL delay_ms_00000

}
032E  0008  	RETURN


/*********************************************************************************************
 at24c32ReadAll()
 Read all bytes
*********************************************************************************************/
void at24c32ReadAll() {

	i2c_start();
032F  210E  	CALL i2c_START_00000

	i2c_write(at24c32_addr); // address + write
0330  30AE  	MOVLW 0xAE
0331  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
0332  208D  	CALL i2c_WRITE_00000

	// start at address 0
	i2c_write(0); // First word address (only 4 bits of the 12 bit byte address)
0333  01EE  	CLRF i2c_WRITE_00000_arg_i2c_data
0334  208D  	CALL i2c_WRITE_00000

	i2c_write(0); // Second word address 
0335  01EE  	CLRF i2c_WRITE_00000_arg_i2c_data
0336  208D  	CALL i2c_WRITE_00000

	i2c_stop(); // Don't actually write a byte, just stop
0337  20DE  	CALL i2c_STOP_00000

	
	i2c_start();
0338  210E  	CALL i2c_START_00000

	i2c_write(ds3231_addr + 1); // address + read
0339  30D1  	MOVLW 0xD1
033A  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
033B  208D  	CALL i2c_WRITE_00000

	gBcdWhiteOnMinute = i2c_read(0); // ack
033C  01EE  	CLRF i2c_READ_00000_arg_ack_status
033D  215F  	CALL i2c_READ_00000
033E  0871  	MOVF CompTempVarRet552, W
033F  00D1  	MOVWF gbl_gBcdWhiteOnMinute

	gBcdWhiteOnHour = i2c_read(0); // ack
0340  01EE  	CLRF i2c_READ_00000_arg_ack_status
0341  215F  	CALL i2c_READ_00000
0342  0871  	MOVF CompTempVarRet552, W
0343  00D2  	MOVWF gbl_gBcdWhiteOnHour

	gBcdWhiteOffMinute = i2c_read(0); // ack
0344  01EE  	CLRF i2c_READ_00000_arg_ack_status
0345  215F  	CALL i2c_READ_00000
0346  0871  	MOVF CompTempVarRet552, W
0347  00D3  	MOVWF gbl_gBcdWhiteOffMinute

	gBcdWhiteOffHour = i2c_read(0); // ack
0348  01EE  	CLRF i2c_READ_00000_arg_ack_status
0349  215F  	CALL i2c_READ_00000
034A  0871  	MOVF CompTempVarRet552, W
034B  00D4  	MOVWF gbl_gBcdWhiteOffHour

	gBcdBlueOnMinute = i2c_read(0); // ack
034C  01EE  	CLRF i2c_READ_00000_arg_ack_status
034D  215F  	CALL i2c_READ_00000
034E  0871  	MOVF CompTempVarRet552, W
034F  00D5  	MOVWF gbl_gBcdBlueOnMinute

	gBcdBlueOnHour = i2c_read(0); // ack
0350  01EE  	CLRF i2c_READ_00000_arg_ack_status
0351  215F  	CALL i2c_READ_00000
0352  0871  	MOVF CompTempVarRet552, W
0353  00D6  	MOVWF gbl_gBcdBlueOnHour

	gBcdBlueOffMinute = i2c_read(0); // ack
0354  01EE  	CLRF i2c_READ_00000_arg_ack_status
0355  215F  	CALL i2c_READ_00000
0356  0871  	MOVF CompTempVarRet552, W
0357  00D7  	MOVWF gbl_gBcdBlueOffMinute

	gBcdBlueOffHour = i2c_read(0); // ack
0358  01EE  	CLRF i2c_READ_00000_arg_ack_status
0359  215F  	CALL i2c_READ_00000
035A  0871  	MOVF CompTempVarRet552, W
035B  00D8  	MOVWF gbl_gBcdBlueOffHour

	gBcdFanOnTemp = i2c_read(0); // ack
035C  01EE  	CLRF i2c_READ_00000_arg_ack_status
035D  215F  	CALL i2c_READ_00000
035E  0871  	MOVF CompTempVarRet552, W
035F  00D9  	MOVWF gbl_gBcdFanOnTemp

	gBcdFanOffTemp = i2c_read(0); // ack
0360  01EE  	CLRF i2c_READ_00000_arg_ack_status
0361  215F  	CALL i2c_READ_00000
0362  0871  	MOVF CompTempVarRet552, W
0363  00DA  	MOVWF gbl_gBcdFanOffTemp

	gBcdHeaterOnTemp = i2c_read(0); // ack
0364  01EE  	CLRF i2c_READ_00000_arg_ack_status
0365  215F  	CALL i2c_READ_00000
0366  0871  	MOVF CompTempVarRet552, W
0367  00DB  	MOVWF gbl_gBcdHeaterOnTemp

	gBcdHeaterOffTemp = i2c_read(1); // nack
0368  3001  	MOVLW 0x01
0369  00EE  	MOVWF i2c_READ_00000_arg_ack_status
036A  215F  	CALL i2c_READ_00000
036B  0871  	MOVF CompTempVarRet552, W
036C  00DC  	MOVWF gbl_gBcdHeaterOffTemp

	i2c_stop();
036D  20DE  	CALL i2c_STOP_00000

}
036E  0008  	RETURN



/*********************************************************************************************
 ds3231Write(char ds3231Reg, char bWrite)
 Write one byte
*********************************************************************************************/
void ds3231Write(char ds3231Reg, char bWrite) {

	i2c_start();
01B3  210E  	CALL i2c_START_00000

	i2c_write(ds3231_addr); // address + write
01B4  30D0  	MOVLW 0xD0
01B5  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
01B6  208D  	CALL i2c_WRITE_00000

	i2c_write(ds3231Reg); // start at address
01B7  086C  	MOVF ds3231Writ_0001B_arg_ds3231Reg, W
01B8  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
01B9  208D  	CALL i2c_WRITE_00000

	i2c_write(bWrite); // start at address
01BA  086D  	MOVF ds3231Writ_0001B_arg_bWrite, W
01BB  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
01BC  208D  	CALL i2c_WRITE_00000

	i2c_stop();
01BD  20DE  	CALL i2c_STOP_00000

}
01BE  0008  	RETURN


/*********************************************************************************************
 ds3231Init()
 Initialise the DS3231
*********************************************************************************************/
void ds3231Init() {

	/* control register 0Eh
    bit7 EOSC   Enable Oscillator (1 if oscillator must be stopped when on battery)
    bit6 BBSQW  Battery Backed Square Wave - 0 means square wave disabled when VCC falls below VPF (power fail voltage)
    bit5 CONV   Convert temperature (1 forces a conversion)
    bit4 RS2    Rate select - frequency of square wave output - NA for DS3231M
    bit3 RS1    Rate select - NA for DS3231M
    bit2 INTCN  Interrupt control (1 for use of the alarms and to disable square wave)
    bit1 A2IE   Alarm2 interrupt enable (1 to enable)
    bit0 A1IE   Alarm1 interrupt enable (1 to enable)
    */
	ds3231Write(0x0E, 0x00);
0265  300E  	MOVLW 0x0E
0266  1283  	BCF STATUS, RP0
0267  1303  	BCF STATUS, RP1
0268  00EC  	MOVWF ds3231Writ_0001B_arg_ds3231Reg
0269  01ED  	CLRF ds3231Writ_0001B_arg_bWrite
026A  21B3  	CALL ds3231Writ_0001B

	/* Status Register 0Fh
    bit7 OSF     Oscillator stopped flag - clear oscillator stop flag at init
    bit3 EN32kHz Enable 32kHz Output - 0 for disabled
    bit2 BSY     Busy
    bit1 A2F     Alarm 2 Flag
    bit0 A1F     Alarm 1 Flag
    */
	ds3231Write(0x0F, 0x00);
026B  300F  	MOVLW 0x0F
026C  00EC  	MOVWF ds3231Writ_0001B_arg_ds3231Reg
026D  01ED  	CLRF ds3231Writ_0001B_arg_bWrite
026E  21B3  	CALL ds3231Writ_0001B

}
026F  0008  	RETURN


/*********************************************************************************************
 ds3231WriteDateTime()
 Write the date to the DS3231
*********************************************************************************************/
void ds3231WriteDateTime() {

	i2c_start();
0234  210E  	CALL i2c_START_00000

	i2c_write(ds3231_addr); // address + write
0235  30D0  	MOVLW 0xD0
0236  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
0237  208D  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
0238  01EE  	CLRF i2c_WRITE_00000_arg_i2c_data
0239  208D  	CALL i2c_WRITE_00000

	i2c_write(0); // seconds
023A  01EE  	CLRF i2c_WRITE_00000_arg_i2c_data
023B  208D  	CALL i2c_WRITE_00000

	i2c_write(gBcdMinute); // minutes
023C  0836  	MOVF gbl_gBcdMinute, W
023D  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
023E  208D  	CALL i2c_WRITE_00000

	i2c_write(gBcdHour); // hours
023F  0837  	MOVF gbl_gBcdHour, W
0240  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
0241  208D  	CALL i2c_WRITE_00000

	i2c_write(gDayOfWeek); // day of week
0242  0838  	MOVF gbl_gDayOfWeek, W
0243  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
0244  208D  	CALL i2c_WRITE_00000

	i2c_write(gBcdDayOfMonth); // day of month
0245  0839  	MOVF gbl_gBcdDayOfMonth, W
0246  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
0247  208D  	CALL i2c_WRITE_00000

	i2c_write(gBcdMonth); // month + century
0248  083A  	MOVF gbl_gBcdMonth, W
0249  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
024A  208D  	CALL i2c_WRITE_00000

	i2c_write(gBcdYear); // year
024B  083B  	MOVF gbl_gBcdYear, W
024C  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
024D  208D  	CALL i2c_WRITE_00000

	i2c_stop();
024E  20DE  	CALL i2c_STOP_00000

}
024F  0008  	RETURN


/*********************************************************************************************
 ds3231ReadDateTime()
 Write the date to the DS3231
*********************************************************************************************/
void ds3231ReadDateTime() {

	i2c_start();
0714  210E  	CALL i2c_START_00000

	i2c_write(ds3231_addr); // address + write
0715  30D0  	MOVLW 0xD0
0716  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
0717  208D  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
0718  01EE  	CLRF i2c_WRITE_00000_arg_i2c_data
0719  208D  	CALL i2c_WRITE_00000

	i2c_stop();
071A  20DE  	CALL i2c_STOP_00000

	
	i2c_start();
071B  210E  	CALL i2c_START_00000

	i2c_write(ds3231_addr + 1); // address + read
071C  30D1  	MOVLW 0xD1
071D  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
071E  208D  	CALL i2c_WRITE_00000

	gBcdSeconds = i2c_read(0); // ack
071F  01EE  	CLRF i2c_READ_00000_arg_ack_status
0720  215F  	CALL i2c_READ_00000
0721  0871  	MOVF CompTempVarRet552, W
0722  00B5  	MOVWF gbl_gBcdSeconds

	gBcdMinute = i2c_read(0); // ack
0723  01EE  	CLRF i2c_READ_00000_arg_ack_status
0724  215F  	CALL i2c_READ_00000
0725  0871  	MOVF CompTempVarRet552, W
0726  00B6  	MOVWF gbl_gBcdMinute

	gBcdHour = i2c_read(0); // ack
0727  01EE  	CLRF i2c_READ_00000_arg_ack_status
0728  215F  	CALL i2c_READ_00000
0729  0871  	MOVF CompTempVarRet552, W
072A  00B7  	MOVWF gbl_gBcdHour

	gDayOfWeek = i2c_read(0); // ack
072B  01EE  	CLRF i2c_READ_00000_arg_ack_status
072C  215F  	CALL i2c_READ_00000
072D  0871  	MOVF CompTempVarRet552, W
072E  00B8  	MOVWF gbl_gDayOfWeek

	gBcdDayOfMonth = i2c_read(0); // ack
072F  01EE  	CLRF i2c_READ_00000_arg_ack_status
0730  215F  	CALL i2c_READ_00000
0731  0871  	MOVF CompTempVarRet552, W
0732  00B9  	MOVWF gbl_gBcdDayOfMonth

	gBcdMonth = i2c_read(0); // ack
0733  01EE  	CLRF i2c_READ_00000_arg_ack_status
0734  215F  	CALL i2c_READ_00000
0735  0871  	MOVF CompTempVarRet552, W
0736  00BA  	MOVWF gbl_gBcdMonth

	gBcdYear = i2c_read(1); // nack
0737  3001  	MOVLW 0x01
0738  00EE  	MOVWF i2c_READ_00000_arg_ack_status
0739  215F  	CALL i2c_READ_00000
073A  0871  	MOVF CompTempVarRet552, W
073B  00BB  	MOVWF gbl_gBcdYear

	i2c_stop();
073C  20DE  	CALL i2c_STOP_00000

}
073D  0008  	RETURN


/*********************************************************************************************
 ds3231ReadRegister(char cRegAddress)
 Read one byte from a given DS3231 register address
*********************************************************************************************/
char ds3231ReadRegister(char cRegAddress) {

	char cStatus;
	i2c_start();
0250  210E  	CALL i2c_START_00000

	i2c_write(ds3231_addr); // address + write
0251  30D0  	MOVLW 0xD0
0252  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
0253  208D  	CALL i2c_WRITE_00000

	i2c_write(cRegAddress); // start at requested address
0254  086C  	MOVF ds3231Read_0001E_arg_cRegAddress, W
0255  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
0256  208D  	CALL i2c_WRITE_00000

	i2c_stop();
0257  20DE  	CALL i2c_STOP_00000

	
	i2c_start();
0258  210E  	CALL i2c_START_00000

	i2c_write(ds3231_addr + 1); // address + read
0259  30D1  	MOVLW 0xD1
025A  00EE  	MOVWF i2c_WRITE_00000_arg_i2c_data
025B  208D  	CALL i2c_WRITE_00000

	cStatus = i2c_read(1); // read the byte, then nack
025C  3001  	MOVLW 0x01
025D  00EE  	MOVWF i2c_READ_00000_arg_ack_status
025E  215F  	CALL i2c_READ_00000
025F  0871  	MOVF CompTempVarRet552, W
0260  00ED  	MOVWF ds3231Read_0001E_1_cStatus

    i2c_stop();
0261  20DE  	CALL i2c_STOP_00000

    return cStatus;
0262  086D  	MOVF ds3231Read_0001E_1_cStatus, W
0263  00EE  	MOVWF CompTempVarRet553

}
0264  0008  	RETURN


/*********************************************************************************************
 tm1638ByteWrite(char bWrite)
 Write one byte
*********************************************************************************************/
void tm1638ByteWrite(char bWrite) {

    for (char i = 0; i < 8; i++) {
01E9  01F0  	CLRF tm1638Byte_0001F_2_i
01EA        label41
01EA  3008  	MOVLW 0x08
01EB  0270  	SUBWF tm1638Byte_0001F_2_i, W
01EC  1803  	BTFSC STATUS,C
01FA  0AF0  	INCF tm1638Byte_0001F_2_i, F
01FB  29EA  	GOTO	label41

        tm1638dio = (bWrite & 0x01);
01EE  3001  	MOVLW 0x01
01EF  056F  	ANDWF tm1638Byte_0001F_arg_bWrite, W
01F0  00F1  	MOVWF CompTempVar554
01F1  1871  	BTFSC CompTempVar554,0
01F2  1486  	BSF gbl_portb,1
01F3  1C71  	BTFSS CompTempVar554,0
01F4  1086  	BCF gbl_portb,1

        tm1638clk = 0;
01F5  1106  	BCF gbl_portb,2

        bWrite = (bWrite >> 1);
01F6  08EF  	MOVF tm1638Byte_0001F_arg_bWrite, F
01F7  1003  	BCF STATUS,C
01F8  0CEF  	RRF tm1638Byte_0001F_arg_bWrite, F

        tm1638clk = 1;
01F9  1506  	BSF gbl_portb,2

    }
}
01ED  0008  	RETURN


void bcdTo7Seg(char iBcdIn) {

    char s7SegDisplay = 0;
02D9  01F1  	CLRF bcdTo7Seg_00000_1_s7SegDisplay

    iPrintStartDigit++; // Increment to last digit
02DA  0AE6  	INCF gbl_iPrintStartDigit, F

    char sDigit = iPrintStartDigit;
02DB  0866  	MOVF gbl_iPrintStartDigit, W
02DC  00F2  	MOVWF bcdTo7Seg_00000_1_sDigit

    // Work backwards
    for (sDigit; sDigit == iPrintStartDigit - 1; sDigit--) {
02DD        label54
02DD  0366  	DECF gbl_iPrintStartDigit, W
02DE  0672  	XORWF bcdTo7Seg_00000_1_sDigit, W
02DF  1D03  	BTFSS STATUS,Z
02E0  2AFC  	GOTO	label56
02FA  03F2  	DECF bcdTo7Seg_00000_1_sDigit, F
02FB  2ADD  	GOTO	label54
02FC        label56

        s7SegDisplay = tm1638DisplayNumtoSeg[iBcdIn & 0x0F];
02E1  085E  	MOVF gbl_tm1638DisplayNumtoSeg, W
02E2  00F3  	MOVWF __rom_get_00000_arg_objNumb
02E3  300F  	MOVLW 0x0F
02E4  0570  	ANDWF bcdTo7Seg_00000_arg_iBcdIn, W
02E5  00F4  	MOVWF __rom_get_00000_arg_idx
02E6  2030  	CALL __rom_get_00000
02E7  00F1  	MOVWF bcdTo7Seg_00000_1_s7SegDisplay

        if (sDigit == iPrintDotDigit)
02E8  0867  	MOVF gbl_iPrintDotDigit, W
02E9  0672  	XORWF bcdTo7Seg_00000_1_sDigit, W
02EA  118A  	BCF PCLATH,3
02EB  120A  	BCF PCLATH,4
02EC  1D03  	BTFSS STATUS,Z
02ED  2AF0  	GOTO	label55
02F0        label55

            s7SegDisplay += tm1638Dot;
02EE  085F  	MOVF gbl_tm1638Dot, W
02EF  07F1  	ADDWF bcdTo7Seg_00000_1_s7SegDisplay, F

        tm1638Data[sDigit] = s7SegDisplay;
02F0  1383  	BCF	STATUS,IRP
02F1  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
02F2  0084  	MOVWF FSR
02F3  0872  	MOVF bcdTo7Seg_00000_1_sDigit, W
02F4  0784  	ADDWF FSR, F
02F5  0871  	MOVF bcdTo7Seg_00000_1_s7SegDisplay, W
02F6  0080  	MOVWF INDF

        iBcdIn >>= 4;
02F7  0EF0  	SWAPF bcdTo7Seg_00000_arg_iBcdIn, F
02F8  300F  	MOVLW 0x0F
02F9  05F0  	ANDWF bcdTo7Seg_00000_arg_iBcdIn, F

    }
    iPrintStartDigit++; // Increment to next digit
02FC  0AE6  	INCF gbl_iPrintStartDigit, F

}
02FD  0008  	RETURN



/*********************************************************************************************
 tm1638UpdateDisplay()
 Publish the tm1638Data and tm1638LEDs arrays to the display
*********************************************************************************************/
void tm1638UpdateDisplay() {

    
    // Display current temperature unless set, trigger or alt display mode is active
    if (gcDisplayMode | gcSetMode | gcTriggerMode) {
04AA  1283  	BCF STATUS, RP0
04AB  1303  	BCF STATUS, RP1
04AC  084F  	MOVF gbl_gcSetMode, W
04AD  044E  	IORWF gbl_gcDisplayMode, W
04AE  00EC  	MOVWF CompTempVar557
04AF  0850  	MOVF gbl_gcTriggerMode, W
04B0  046C  	IORWF CompTempVar557, W
04B1  1903  	BTFSC STATUS,Z
04B2  2DBE  	GOTO	label103
05BE        label103

        if (gcSetMode == 1) {
04B3  034F  	DECF gbl_gcSetMode, W
04B4  1D03  	BTFSS STATUS,Z
04B5  2CC4  	GOTO	label82
04C4        label82

            iDigitToFlash = 3;
04B6  3003  	MOVLW 0x03
04B7  00C8  	MOVWF gbl_iDigitToFlash

            // Display year
            // Start printing from digit 0
            iPrintStartDigit = 0;
04B8  01E6  	CLRF gbl_iPrintStartDigit

            iPrintDotDigit = 1;
04B9  3001  	MOVLW 0x01
04BA  00E7  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(0x20); // Display 20 in digits 0 and 1 (+dot on 1)
04BB  3020  	MOVLW 0x20
04BC  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
04BD  22D9  	CALL bcdTo7Seg_00000

            iPrintDotDigit = 3;
04BE  3003  	MOVLW 0x03
04BF  00E7  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(gBcdYear); // Display year in digits 2 and 3 (+dot on 3)
04C0  083B  	MOVF gbl_gBcdYear, W
04C1  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
04C2  22D9  	CALL bcdTo7Seg_00000

        } else if (gcSetMode == 4) {
04C3  2DD0  	GOTO	label104
04C4  084F  	MOVF gbl_gcSetMode, W
04C5  3A04  	XORLW 0x04
04C6  1D03  	BTFSS STATUS,Z
04C7  2CDA  	GOTO	label83
04DA        label83

            iDigitToFlash = 3;
04C8  3003  	MOVLW 0x03
04C9  00C8  	MOVWF gbl_iDigitToFlash

            // Display day of week
            tm1638Data[0] = 0x5E; // d
04CA  305E  	MOVLW 0x5E
04CB  00A0  	MOVWF gbl_tm1638Data

            tm1638Data[1] = 0x5F; // a
04CC  305F  	MOVLW 0x5F
04CD  00A1  	MOVWF gbl_tm1638Data+D'1'

            tm1638Data[2] = 0x6E; // y
04CE  306E  	MOVLW 0x6E
04CF  00A2  	MOVWF gbl_tm1638Data+D'2'

            tm1638Data[3] = tm1638DisplayNumtoSeg[gDayOfWeek] + tm1638Dot;
04D0  085E  	MOVF gbl_tm1638DisplayNumtoSeg, W
04D1  00F3  	MOVWF __rom_get_00000_arg_objNumb
04D2  0838  	MOVF gbl_gDayOfWeek, W
04D3  00F4  	MOVWF __rom_get_00000_arg_idx
04D4  2030  	CALL __rom_get_00000
04D5  075F  	ADDWF gbl_tm1638Dot, W
04D6  00A3  	MOVWF gbl_tm1638Data+D'3'

        } else if (gcTriggerMode) {
04D7  118A  	BCF PCLATH,3
04D8  120A  	BCF PCLATH,4
04D9  2DD0  	GOTO	label104
04DA  08D0  	MOVF gbl_gcTriggerMode, F
04DB  1903  	BTFSC STATUS,Z
04DC  2D96  	GOTO	label96
0596        label96

            iPrintDotDigit = 5;
04DD  3005  	MOVLW 0x05
04DE  00E7  	MOVWF gbl_iPrintDotDigit

            switch (gcTriggerMode) {
0504  2DD0  	GOTO	label104

                case 1:
04DF  0850  	MOVF gbl_gcTriggerMode, W
04E0  3A01  	XORLW 0x01
04E1  1903  	BTFSC STATUS,Z
04E2  2D05  	GOTO	label84
0505        label84

                    // White LED on hour
                    tm1638Data[0] = 0x38; // L
0505  3038  	MOVLW 0x38
0506  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x30; // I
0507  3030  	MOVLW 0x30
0508  00A1  	MOVWF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x3f; // O
0509  303F  	MOVLW 0x3F
050A  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x54; // n
050B  3054  	MOVLW 0x54
050C  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
050D  3005  	MOVLW 0x05
050E  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
050F  3004  	MOVLW 0x04
0510  00E6  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOnHour); // Display hour in digits 4 and 5 (dot on 5)
0511  0852  	MOVF gbl_gBcdWhiteOnHour, W
0512  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0513  22D9  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdWhiteOnMinute); // Display minute in digits 6 and 7 (no dot)
0514  0851  	MOVF gbl_gBcdWhiteOnMinute, W
0515  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0516  22D9  	CALL bcdTo7Seg_00000

                    break;
0517  2DD0  	GOTO	label104

                case 2:
04E3  3A03  	XORLW 0x03
04E4  1903  	BTFSC STATUS,Z
04E5  2D18  	GOTO	label85
0518        label85

                    // White LED on minute
                    iDigitToFlash = 7;
0518  3007  	MOVLW 0x07
0519  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
051A  3006  	MOVLW 0x06
051B  00E6  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOnMinute); // Display minute in digits 6 and 7 (no dot)
051C  0851  	MOVF gbl_gBcdWhiteOnMinute, W
051D  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
051E  22D9  	CALL bcdTo7Seg_00000

                    break;
051F  2DD0  	GOTO	label104

                case 3:
04E6  3A01  	XORLW 0x01
04E7  1903  	BTFSC STATUS,Z
04E8  2D20  	GOTO	label86
0520        label86

                    // White LED off hour
                    tm1638Data[3] = 0x71; // F
0520  3071  	MOVLW 0x71
0521  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
0522  3005  	MOVLW 0x05
0523  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
0524  3004  	MOVLW 0x04
0525  00E6  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOffHour); 
0526  0854  	MOVF gbl_gBcdWhiteOffHour, W
0527  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0528  22D9  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdWhiteOffMinute); // Display minute in digits 6 and 7 (no dot)
0529  0853  	MOVF gbl_gBcdWhiteOffMinute, W
052A  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
052B  22D9  	CALL bcdTo7Seg_00000

                    break;
052C  2DD0  	GOTO	label104

                case 4:
04E9  3A07  	XORLW 0x07
04EA  1903  	BTFSC STATUS,Z
04EB  2D2D  	GOTO	label87
052D        label87

                    // White LED off minute
                    iDigitToFlash = 7;
052D  3007  	MOVLW 0x07
052E  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
052F  3006  	MOVLW 0x06
0530  00E6  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOffMinute); // Display minute in digits 6 and 7 (no dot)
0531  0853  	MOVF gbl_gBcdWhiteOffMinute, W
0532  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0533  22D9  	CALL bcdTo7Seg_00000

                    break;
0534  2DD0  	GOTO	label104

                case 5:
04EC  3A01  	XORLW 0x01
04ED  1903  	BTFSC STATUS,Z
04EE  2D35  	GOTO	label88
0535        label88

                    // Blue LED on hour
                    tm1638Data[0] = 0x7C; // b
0535  307C  	MOVLW 0x7C
0536  00A0  	MOVWF gbl_tm1638Data

                    //tm1638Data[1] = 0x30; // l
                    //tm1638Data[2] = 0x3f; // O
                    tm1638Data[3] = 0x54; // n
0537  3054  	MOVLW 0x54
0538  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
0539  3005  	MOVLW 0x05
053A  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
053B  3004  	MOVLW 0x04
053C  00E6  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOnHour); // Display hour in digits 4 and 5 (dot on 5)
053D  0856  	MOVF gbl_gBcdBlueOnHour, W
053E  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
053F  22D9  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlueOnMinute); // Display minute in digits 6 and 7 (no dot)
0540  0855  	MOVF gbl_gBcdBlueOnMinute, W
0541  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0542  22D9  	CALL bcdTo7Seg_00000

                    break;
0543  2DD0  	GOTO	label104

                case 6:
04EF  3A03  	XORLW 0x03
04F0  1903  	BTFSC STATUS,Z
04F1  2D44  	GOTO	label89
0544        label89

                    // Blue LED on minute
                    iDigitToFlash = 7;
0544  3007  	MOVLW 0x07
0545  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0546  3006  	MOVLW 0x06
0547  00E6  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOnMinute); // Display minute in digits 6 and 7 (no dot)
0548  0855  	MOVF gbl_gBcdBlueOnMinute, W
0549  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
054A  22D9  	CALL bcdTo7Seg_00000

                    break;
054B  2DD0  	GOTO	label104

                case 7:
04F2  3A01  	XORLW 0x01
04F3  1903  	BTFSC STATUS,Z
04F4  2D4C  	GOTO	label90
054C        label90

                    // Blue LED off hour
                    tm1638Data[3] = 0x71; // F
054C  3071  	MOVLW 0x71
054D  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
054E  3005  	MOVLW 0x05
054F  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
0550  3004  	MOVLW 0x04
0551  00E6  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOffHour); // Display hour in digits 4 and 5 (dot on 5)
0552  0858  	MOVF gbl_gBcdBlueOffHour, W
0553  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0554  22D9  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlueOffMinute); // Display minute in digits 6 and 7 (no dot)
0555  0857  	MOVF gbl_gBcdBlueOffMinute, W
0556  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0557  22D9  	CALL bcdTo7Seg_00000

                    break;
0558  2DD0  	GOTO	label104

                case 8:
04F5  3A0F  	XORLW 0x0F
04F6  1903  	BTFSC STATUS,Z
04F7  2D59  	GOTO	label91
0559        label91

                    // Blue LED off minute
                    iDigitToFlash = 7;
0559  3007  	MOVLW 0x07
055A  00C8  	MOVWF gbl_iDigitToFlash

                    bcdTo7Seg(gBcdBlueOffMinute); // Display minute in digits 6 and 7 (no dot)
055B  0857  	MOVF gbl_gBcdBlueOffMinute, W
055C  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
055D  22D9  	CALL bcdTo7Seg_00000

                    break;
055E  2DD0  	GOTO	label104

                case 9:
04F8  3A01  	XORLW 0x01
04F9  1903  	BTFSC STATUS,Z
04FA  2D5F  	GOTO	label92
055F        label92

                    // Fan on temperature
                    tm1638Data[0] = 0x38; // F
055F  3038  	MOVLW 0x38
0560  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x30; // a
0561  3030  	MOVLW 0x30
0562  00A1  	MOVWF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x54; // n
0563  3054  	MOVLW 0x54
0564  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x00; // 
0565  01A3  	CLRF gbl_tm1638Data+D'3'

                    tm1638Data[4] = 0x3f; // O
0566  303F  	MOVLW 0x3F
0567  00A4  	MOVWF gbl_tm1638Data+D'4'

                    tm1638Data[5] = 0x54; // n
0568  3054  	MOVLW 0x54
0569  00A5  	MOVWF gbl_tm1638Data+D'5'

                    iDigitToFlash = 7;
056A  3007  	MOVLW 0x07
056B  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
056C  3006  	MOVLW 0x06
056D  00E6  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdFanOnTemp); // Display celcius in digits 6 and 7 (no dot)
056E  0859  	MOVF gbl_gBcdFanOnTemp, W
056F  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0570  22D9  	CALL bcdTo7Seg_00000

                    break;
0571  2DD0  	GOTO	label104

                case 10:
04FB  3A03  	XORLW 0x03
04FC  1903  	BTFSC STATUS,Z
04FD  2D72  	GOTO	label93
0572        label93

                    // Fan off temperature
                    tm1638Data[5] = 0x71; // f
0572  3071  	MOVLW 0x71
0573  00A5  	MOVWF gbl_tm1638Data+D'5'

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0574  3006  	MOVLW 0x06
0575  00E6  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdFanOffTemp); // Display celcius in digits 6 and 7 (no dot)
0576  085A  	MOVF gbl_gBcdFanOffTemp, W
0577  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0578  22D9  	CALL bcdTo7Seg_00000

                    break;
0579  2DD0  	GOTO	label104

                case 11:
04FE  3A01  	XORLW 0x01
04FF  1903  	BTFSC STATUS,Z
0500  2D7A  	GOTO	label94
057A        label94

                    // Heater on temperature
                    tm1638Data[0] = 0x38; // H
057A  3038  	MOVLW 0x38
057B  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x7B; // e
057C  307B  	MOVLW 0x7B
057D  00A1  	MOVWF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x30; // a
057E  3030  	MOVLW 0x30
057F  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x78; // t
0580  3078  	MOVLW 0x78
0581  00A3  	MOVWF gbl_tm1638Data+D'3'

                    tm1638Data[4] = 0x3f; // O
0582  303F  	MOVLW 0x3F
0583  00A4  	MOVWF gbl_tm1638Data+D'4'

                    tm1638Data[5] = 0x54; // n
0584  3054  	MOVLW 0x54
0585  00A5  	MOVWF gbl_tm1638Data+D'5'

                    iDigitToFlash = 7;
0586  3007  	MOVLW 0x07
0587  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0588  3006  	MOVLW 0x06
0589  00E6  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdHeaterOnTemp); // Display celcius in digits 6 and 7 (no dot)
058A  085B  	MOVF gbl_gBcdHeaterOnTemp, W
058B  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
058C  22D9  	CALL bcdTo7Seg_00000

                    break;
058D  2DD0  	GOTO	label104

                case 12:
0501  3A07  	XORLW 0x07
0502  1903  	BTFSC STATUS,Z
0503  2D8E  	GOTO	label95
058E        label95

                    // Heater off temperature
                    tm1638Data[5] = 0x71; // f
058E  3071  	MOVLW 0x71
058F  00A5  	MOVWF gbl_tm1638Data+D'5'

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0590  3006  	MOVLW 0x06
0591  00E6  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdHeaterOffTemp); // Display celcius in digits 6 and 7 (no dot)
0592  085C  	MOVF gbl_gBcdHeaterOffTemp, W
0593  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0594  22D9  	CALL bcdTo7Seg_00000

                    break;
            }
        } else {
0595  2DD0  	GOTO	label104

            switch (gcSetMode) {
05B2        label102

                case 2:
0596  084F  	MOVF gbl_gcSetMode, W
0597  3A02  	XORLW 0x02
0598  1903  	BTFSC STATUS,Z
0599  2DA4  	GOTO	label97
05A4        label97

                    iDigitToFlash = 3;
05A4  3003  	MOVLW 0x03
05A5  00C8  	MOVWF gbl_iDigitToFlash

                    break;
05A6  2DB2  	GOTO	label102

                case 3:
059A  3A01  	XORLW 0x01
059B  1903  	BTFSC STATUS,Z
059C  2DA7  	GOTO	label98
05A7        label98

                    iDigitToFlash = 1;
05A7  3001  	MOVLW 0x01
05A8  00C8  	MOVWF gbl_iDigitToFlash

                    break;
05A9  2DB2  	GOTO	label102

                case 5:
059D  3A06  	XORLW 0x06
059E  1903  	BTFSC STATUS,Z
059F  2DAA  	GOTO	label99
05AA        label99

                    iDigitToFlash = 5;
05AA  3005  	MOVLW 0x05
05AB  00C8  	MOVWF gbl_iDigitToFlash

                    break;
05AC  2DB2  	GOTO	label102

                case 6:
05A0  3A03  	XORLW 0x03
05A1  1903  	BTFSC STATUS,Z
05A2  2DAD  	GOTO	label100
05AD        label100

                    iDigitToFlash = 7;
05AD  3007  	MOVLW 0x07
05AE  00C8  	MOVWF gbl_iDigitToFlash

                    break;
05AF  2DB2  	GOTO	label102

                default:
05A3  2DB0  	GOTO	label101
05B0        label101

                    iDigitToFlash = 8;
05B0  3008  	MOVLW 0x08
05B1  00C8  	MOVWF gbl_iDigitToFlash

            }
            // Display date DD.MM
            iPrintStartDigit = 0;
05B2  01E6  	CLRF gbl_iPrintStartDigit

            iPrintDotDigit = 1;
05B3  3001  	MOVLW 0x01
05B4  00E7  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(gBcdDayOfMonth); // Display day of month in digits 0 and 1 (+dot on 1)
05B5  0839  	MOVF gbl_gBcdDayOfMonth, W
05B6  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
05B7  22D9  	CALL bcdTo7Seg_00000

            iPrintDotDigit = 3;
05B8  3003  	MOVLW 0x03
05B9  00E7  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(gBcdMonth); // Display month in digits 2 and 3 (+dot on 3)
05BA  083A  	MOVF gbl_gBcdMonth, W
05BB  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
05BC  22D9  	CALL bcdTo7Seg_00000

        }
    } else {
05BD  2DD0  	GOTO	label104

        // translate DS3231 temperature to digit values
        iPrintDotDigit = 1;
05BE  3001  	MOVLW 0x01
05BF  00E7  	MOVWF gbl_iPrintDotDigit

        /*
        No support for -10 or below - aquarium should never get that cold!
        if (gbDS3231IsMinus && (giDS3231ValueBCD & 0xF000)) {
            // If minus and value less than or equal -10 (checked as >1000), shift the digits right
            giDS3231ValueBCD >>= 4;
            iPrintDotDigit = 2;
        }*/
        // Display current temperature in digits 0 to 3 (+dot on 1, or 2 if <=-10)
        iPrintStartDigit = 0;
05C0  01E6  	CLRF gbl_iPrintStartDigit

        bcdTo7Seg(giDS3231ValueBCD);
05C1  0833  	MOVF gbl_giDS3231ValueBCD, W
05C2  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
05C3  22D9  	CALL bcdTo7Seg_00000

        bcdTo7Seg(giDS3231ValueBCD >> 8);
05C4  0834  	MOVF gbl_giDS3231ValueBCD+D'1', W
05C5  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
05C6  22D9  	CALL bcdTo7Seg_00000


        // left fill zeroes with blanks up to the digit before the decimal place
        if (tm1638Data[0] == 0x3f)
05C7  0820  	MOVF gbl_tm1638Data, W
05C8  3A3F  	XORLW 0x3F
05C9  1903  	BTFSC STATUS,Z

            tm1638Data[0] = 0;
05CA  01A0  	CLRF gbl_tm1638Data

        // If minus, overwrite left most digit with minus sign
        if (gbDS3231IsMinus)
05CB  08CB  	MOVF gbl_gbDS3231IsMinus, F
05CC  1903  	BTFSC STATUS,Z
05CD  2DD0  	GOTO	label104
05D0        label104

            tm1638Data[0] = 0x40;
05CE  3040  	MOVLW 0x40
05CF  00A0  	MOVWF gbl_tm1638Data

    }

    // HH.MM in last 4 digits of TM1638
    if (!gcTriggerMode) {
05D0  08D0  	MOVF gbl_gcTriggerMode, F
05D1  1D03  	BTFSS STATUS,Z
05D2  2DDD  	GOTO	label105
05DD        label105

        iPrintStartDigit = 4;
05D3  3004  	MOVLW 0x04
05D4  00E6  	MOVWF gbl_iPrintStartDigit

        iPrintDotDigit = 5;
05D5  3005  	MOVLW 0x05
05D6  00E7  	MOVWF gbl_iPrintDotDigit

        bcdTo7Seg(gBcdHour); // Display hour in digits 4 and 5 (dot on 5)
05D7  0837  	MOVF gbl_gBcdHour, W
05D8  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
05D9  22D9  	CALL bcdTo7Seg_00000

        bcdTo7Seg(gBcdMinute); // Display minute in digits 6 and 7 (no dot)
05DA  0836  	MOVF gbl_gBcdMinute, W
05DB  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
05DC  22D9  	CALL bcdTo7Seg_00000

    }

    // Light LED for set mode
    char cCompareSetMode = gcSetMode + 2;
05DD  3002  	MOVLW 0x02
05DE  074F  	ADDWF gbl_gcSetMode, W
05DF  00ED  	MOVWF tm1638Upda_00020_1_cCompar_00021

    for (char i = 2; i < 8; i++) {
05E0  3002  	MOVLW 0x02
05E1  00EF  	MOVWF tm1638Upda_00020_3_i
05E2        label106
05E2  3008  	MOVLW 0x08
05E3  026F  	SUBWF tm1638Upda_00020_3_i, W
05E4  1803  	BTFSC STATUS,C
05E5  2DFB  	GOTO	label109
05F9  0AEF  	INCF tm1638Upda_00020_3_i, F
05FA  2DE2  	GOTO	label106
05FB        label109

        if (i == cCompareSetMode)
05E6  086D  	MOVF tm1638Upda_00020_1_cCompar_00021, W
05E7  066F  	XORWF tm1638Upda_00020_3_i, W
05E8  1D03  	BTFSS STATUS,Z
05E9  2DF2  	GOTO	label107
05F2        label107

            tm1638LEDs[i] = 1;
05EA  1383  	BCF	STATUS,IRP
05EB  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
05EC  0084  	MOVWF FSR
05ED  086F  	MOVF tm1638Upda_00020_3_i, W
05EE  0784  	ADDWF FSR, F
05EF  3001  	MOVLW 0x01
05F0  0080  	MOVWF INDF

        else
05F1  2DF9  	GOTO	label108
05F9        label108

            tm1638LEDs[i] = 0;
05F2  1383  	BCF	STATUS,IRP
05F3  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
05F4  0084  	MOVWF FSR
05F5  086F  	MOVF tm1638Upda_00020_3_i, W
05F6  0784  	ADDWF FSR, F
05F7  3000  	MOVLW 0x00
05F8  0080  	MOVWF INDF

    }
    tm1638LEDs[0] = HEATER;
05FB  01A8  	CLRF gbl_tm1638LEDs
05FC  1805  	BTFSC gbl_porta,0
05FD  0AA8  	INCF gbl_tm1638LEDs, F

    tm1638LEDs[1] = FAN;
05FE  01A9  	CLRF gbl_tm1638LEDs+D'1'
05FF  1885  	BTFSC gbl_porta,1
0600  0AA9  	INCF gbl_tm1638LEDs+D'1', F


    // Write 0x40 [01000000] to indicate command to display data - [Write data to display register]
    tm1638strobe = 0;
0601  1186  	BCF gbl_portb,3

    tm1638ByteWrite(tm1638ByteSetData);
0602  0861  	MOVF gbl_tm1638ByteSetData, W
0603  00EF  	MOVWF tm1638Byte_0001F_arg_bWrite
0604  21E9  	CALL tm1638Byte_0001F

    tm1638strobe = 1;
0605  1586  	BSF gbl_portb,3

    
    tm1638strobe = 0;
0606  1186  	BCF gbl_portb,3

    // Specify the display address 0xC0 [11000000] then write out all 8 bytes
    tm1638ByteWrite(tm1638ByteSetAddr);
0607  0863  	MOVF gbl_tm1638ByteSetAddr, W
0608  00EF  	MOVWF tm1638Byte_0001F_arg_bWrite
0609  21E9  	CALL tm1638Byte_0001F

    for (char i = 0; i < tm1638MaxDigits; i++) {
060A  01EE  	CLRF tm1638Upda_00020_2_i
060B        label110
060B  085D  	MOVF gbl_tm1638MaxDigits, W
060C  026E  	SUBWF tm1638Upda_00020_2_i, W
060D  1803  	BTFSC STATUS,C
060E  2E2A  	GOTO	label113
0628  0AEE  	INCF tm1638Upda_00020_2_i, F
0629  2E0B  	GOTO	label110
062A        label113

        if (iFlashDigitOff.0 && (i == iDigitToFlash))
060F  1C3F  	BTFSS gbl_iFlashDigitOff,0
0610  2E18  	GOTO	label111
0611  0848  	MOVF gbl_iDigitToFlash, W
0612  066E  	XORWF tm1638Upda_00020_2_i, W
0613  1D03  	BTFSS STATUS,Z
0614  2E18  	GOTO	label111
0618        label111

            tm1638ByteWrite(0);
0615  01EF  	CLRF tm1638Byte_0001F_arg_bWrite
0616  21E9  	CALL tm1638Byte_0001F

        else
0617  2E20  	GOTO	label112
0620        label112

            tm1638ByteWrite(tm1638Data[i]);
0618  1383  	BCF	STATUS,IRP
0619  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
061A  0084  	MOVWF FSR
061B  086E  	MOVF tm1638Upda_00020_2_i, W
061C  0784  	ADDWF FSR, F
061D  0800  	MOVF INDF, W
061E  00EF  	MOVWF tm1638Byte_0001F_arg_bWrite
061F  21E9  	CALL tm1638Byte_0001F

        tm1638ByteWrite(tm1638LEDs[i]);
0620  1383  	BCF	STATUS,IRP
0621  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
0622  0084  	MOVWF FSR
0623  086E  	MOVF tm1638Upda_00020_2_i, W
0624  0784  	ADDWF FSR, F
0625  0800  	MOVF INDF, W
0626  00EF  	MOVWF tm1638Byte_0001F_arg_bWrite
0627  21E9  	CALL tm1638Byte_0001F

    }
    tm1638strobe = 1;
062A  1586  	BSF gbl_portb,3

}
062B  0008  	RETURN


/*********************************************************************************************
 tm1638ReadKeys()
 Reads the keys status into tm1638Keys
*********************************************************************************************/
void tm1638ReadKeys() {

    // Write 0x42 [01000010] to indicate command to read data
    tm1638strobe = 0;
062C  1283  	BCF STATUS, RP0
062D  1303  	BCF STATUS, RP1
062E  1186  	BCF gbl_portb,3

    tm1638ByteWrite(tm1638ByteReadData);
062F  0862  	MOVF gbl_tm1638ByteReadData, W
0630  00EF  	MOVWF tm1638Byte_0001F_arg_bWrite
0631  21E9  	CALL tm1638Byte_0001F

    
    tm1638dioTris = 1; // Set data pin to input
0632  1683  	BSF STATUS, RP0
0633  1486  	BSF gbl_trisb,1

    char tm1638KeysTemp = 32;
0634  3020  	MOVLW 0x20
0635  1283  	BCF STATUS, RP0
0636  00EB  	MOVWF tm1638Read_00022_1_tm1638K_00023

    // Read 4 bytes
    for (char i = 0; i < 32; i++) {
0637  01EC  	CLRF tm1638Read_00022_2_i
0638        label114
0638  3020  	MOVLW 0x20
0639  026C  	SUBWF tm1638Read_00022_2_i, W
063A  1803  	BTFSC STATUS,C
063B  2E49  	GOTO	label116
0647  0AEC  	INCF tm1638Read_00022_2_i, F
0648  2E38  	GOTO	label114
0649        label116

        tm1638KeysTemp--;
063C  03EB  	DECF tm1638Read_00022_1_tm1638K_00023, F

        tm1638clk = 0;
063D  1106  	BCF gbl_portb,2

        delay_us(1);
063E  3001  	MOVLW 0x01
063F  00F1  	MOVWF delay_us_00000_arg_del
0640  2010  	CALL delay_us_00000

        if(tm1638dio)
0641  1C86  	BTFSS gbl_portb,1
0642  2E46  	GOTO	label115
0646        label115

            tm1638KeysTemp = (tm1638KeysTemp << 1);
0643  08EB  	MOVF tm1638Read_00022_1_tm1638K_00023, F
0644  1003  	BCF STATUS,C
0645  0DEB  	RLF tm1638Read_00022_1_tm1638K_00023, F

        tm1638clk = 1;
0646  1506  	BSF gbl_portb,2

    }
    tm1638dioTris = 0; // Set data pin to output
0649  1683  	BSF STATUS, RP0
064A  1086  	BCF gbl_trisb,1

    tm1638strobe = 1;
064B  1283  	BCF STATUS, RP0
064C  1586  	BSF gbl_portb,3


    tm1638Keys = tm1638KeysTemp;
064D  086B  	MOVF tm1638Read_00022_1_tm1638K_00023, W
064E  00E5  	MOVWF gbl_tm1638Keys

}
064F  0008  	RETURN


/*********************************************************************************************
  Function called once only to initialise variables and
  setup the PIC registers
*********************************************************************************************/
void initialise() {

    //PIC16F73 doesn't have an internal oscillator
    //pcon.OSCF = 1; // 4MHz internal osc

    // Configure port A
    /*
    RA7     Doesn't exist
    RA6     Doesn't exist
    RA5     
    RA4     
    RA3     
    RA2     
    RA1     OUT FANS
    RA0     OUT HEATER
    */
    trisa = 0x00; // all outputs
06DD  1683  	BSF STATUS, RP0
06DE  1303  	BCF STATUS, RP1
06DF  0185  	CLRF gbl_trisa

    porta = 0x00; // All off
06E0  1283  	BCF STATUS, RP0
06E1  0185  	CLRF gbl_porta

    
    // Configure port B
    /*      
    RB7     ICSP PGD
    RB6     ICSP PGC
    RB5     
    RB4     
    RB3     OUT TM1638 STB
    RB2     OUT TM1638 CLK
    RB1     IN/OUT TM1638 DIO
    RB0     
    */
    trisb = 0x00; // all outputs by default
06E2  1683  	BSF STATUS, RP0
06E3  0186  	CLRF gbl_trisb

    portb = 0x0E; // default TM1638 pins high
06E4  300E  	MOVLW 0x0E
06E5  1283  	BCF STATUS, RP0
06E6  0086  	MOVWF gbl_portb


    // Configure port C
    /*      
    RC7     
    RC6     
    RC5     IN/OUT DS18B20
    RC4     IN/OUT DS3231M I2C SDA
    RC3     IN/OUT DS3231M I2C CLK
    RC2     OUT BLUE LIGHT PWM
    RC1     OUT WHITE LIGHT PWM
    RC0     IN SQW DS3231M
    */
    trisb = 0x01; // all outputs except RC0
06E7  3001  	MOVLW 0x01
06E8  1683  	BSF STATUS, RP0
06E9  0086  	MOVWF gbl_trisb

    portb = 0x38; // default DS18B20 and DS3231 pins high
06EA  3038  	MOVLW 0x38
06EB  1283  	BCF STATUS, RP0
06EC  0086  	MOVWF gbl_portb


    option_reg = 0;
06ED  1683  	BSF STATUS, RP0
06EE  0181  	CLRF gbl_option_reg

    option_reg.NOT_RBPU = 1; // disable port b pull ups
06EF  1781  	BSF gbl_option_reg,7


    // ADC setup
    // PIC16F73 doesn't have comparators
    //cmcon = 7; // disable all comparators so port a is usable as digital io
    adcon1 = 7; // Set RA0,RA1,RA2,RA5,RA3 all to digital I/O
06F0  3007  	MOVLW 0x07
06F1  009F  	MOVWF gbl_adcon1



    // Setup timer 0, used for PWM
    // https://labprojectsbd.com/2021/03/31/pwm-pulse-generation-using-pic12f675-micro-controller/
    // Timer calculator: http://eng-serve.com/pic/pic_timer.html
    // Timer0 Registers Prescaler= 16 - TMR0 Preset = 0 - Freq = 244.14 Hz - Period = 0.004096 seconds
    //option_reg.T0CS = 0; // bit 5  TMR0 Clock Source Select bit...0 = Internal Clock (CLKO) 1 = Transition on T0CKI pin
    //option_reg.T0SE = 0; // bit 4 TMR0 Source Edge Select bit 0 = low/high 1 = high/low
    //option_reg.PSA = 0; // bit 3  Prescaler Assignment bit...0 = Prescaler is assigned to the Timer0
    //option_reg.PS2 = 0; // bits 2-0  PS2:PS0: Prescaler Rate Select bits
    /*option_reg.PS1 = 1;
    option_reg.PS0 = 1;
    tmr0 = 0; // preset for timer register
    intcon.T0IF = 0; // Clear timer 1 interrupt flag bit
    intcon.T0IE = 1; // Timer 1 interrupt enabled*/

    // Setup timer 1, used to update clock display and periodically ask for a temperature reading
    // Timer 1 setup - interrupt on DS3231 SQW 1Hz
    // Timer1 Registers Prescaler= 1 - TMR1 Preset = 65535 - Freq = 1 Hz
    // Bits 5-4 T1CKPS1:T1CKPS0 = 00: Prescaler Rate Select bits, 00 = 1:1 prescaler
    // Bit 3 T1OSCEN = 0: Timer1 LP Oscillator Enable Control bit, 0 = off
    // Bit 2 NOT_T1SYNC = 1: Timer1 External Clock Input Synchronization Control bit, 1 = Do not synchronize external clock input
    // Bit 1 TMR1CS = 1: Timer1 Clock Source Select bit, 1 = External clock from T1OSO/T1CKI pin (on the rising edge)
    // Bit 0 TMR1ON = 0: Timer1 On Bit, 0 = off
    t1con = 0b00000110;
06F2  3006  	MOVLW 0x06
06F3  1283  	BCF STATUS, RP0
06F4  0090  	MOVWF gbl_t1con

    tmr1h = TMR1HV;      // preset for timer1 MSB register
06F5  30FF  	MOVLW 0xFF
06F6  008F  	MOVWF gbl_tmr1h

    tmr1l = TMR1LV;      // preset for timer1 LSB register
06F7  008E  	MOVWF gbl_tmr1l

    pie1.TMR1IE = 1;     // Timer 1 interrupt
06F8  1683  	BSF STATUS, RP0
06F9  140C  	BSF gbl_pie1,0

    
    // Setup timer 2, used for flashing display
    // Timer calculator: http://eng-serve.com/pic/pic_timer.html
    //Timer2 Registers Prescaler= 16 - TMR2 PostScaler = 16 - PR2 = 195 - Freq = 20.03 Hz - Period = 0.049920 seconds
    t2con |= 120; // bits 6-3 Post scaler 1:1 thru 1:16
06FA  3078  	MOVLW 0x78
06FB  1283  	BCF STATUS, RP0
06FC  0492  	IORWF gbl_t2con, F

    t2con.TMR2ON = 1; // bit 2 turn timer2 on;
06FD  1512  	BSF gbl_t2con,2

    t2con.T2CKPS1 = 1; // bits 1-0  Prescaler Rate Select bits
06FE  1492  	BSF gbl_t2con,1

    //t2con.T2CKPS0 = 0;
    pr2 = 195; // PR2 (Timer2 Match value)
06FF  30C3  	MOVLW 0xC3
0700  1683  	BSF STATUS, RP0
0701  0092  	MOVWF gbl_pr2


    // No task at initialisation
    cTask = 0;
0702  1283  	BCF STATUS, RP0
0703  01CC  	CLRF gbl_cTask

    
    // Enable interrupts
    intcon.GIE = 1;
0704  178B  	BSF gbl_intcon,7

    intcon.PEIE = 1;
0705  170B  	BSF gbl_intcon,6


	// I2C Bus initialisation - baud rate divisor not applicable for software implementation
	i2c_init(1); 
0706  3001  	MOVLW 0x01
0707  00EC  	MOVWF i2c_INIT_00000_arg_i2c_divisor
0708  2221  	CALL i2c_INIT_00000


    // Read in variables from EEPROM
    at24c32ReadAll();
0709  232F  	CALL at24c32Rea_00028


    // Check if the DS3231 needs initilising
    char cStatus = ds3231ReadRegister(0x0F); // Read the status register
070A  300F  	MOVLW 0x0F
070B  00EC  	MOVWF ds3231Read_0001E_arg_cRegAddress
070C  2250  	CALL ds3231Read_0001E
070D  086E  	MOVF CompTempVarRet553, W
070E  00EB  	MOVWF initialise_00000_1_cStatus

    // If the oscillator (OSF bit in status register) has stopped, then init and write a default date/time
    if (cStatus.7) {
070F  1FEB  	BTFSS initialise_00000_1_cStatus,7

        ds3231Init();
0711  2265  	CALL ds3231Init_00000

        ds3231WriteDateTime();
0712  2234  	CALL ds3231Writ_0001C

    }
}
0710  0008  	RETURN
0713  0008  	RETURN



/*********************************************************************************************
  interrupt()
  Interrupt handler
*********************************************************************************************/
void interrupt() {

    // Handle timer1 interrupt - delay counter from DS3231
    if (pir1.TMR1IF) {
0835  1283  	BCF STATUS, RP0
0836  1303  	BCF STATUS, RP1
0837  1C0C  	BTFSS gbl_pir1,0
0838  283E  	GOTO	label140
083E        label140

        tmr1h = TMR1HV;      // preset for timer1 MSB register
0839  30FF  	MOVLW 0xFF
083A  008F  	MOVWF gbl_tmr1h

        tmr1l = TMR1LV;      // preset for timer1 LSB register
083B  008E  	MOVWF gbl_tmr1l


        pir1.TMR1IF = 0;     // Clear interrupt flag
083C  100C  	BCF gbl_pir1,0

        cTask.TASK_TIMER1 = 1;
083D  154C  	BSF gbl_cTask,2

    }
    
    // Interrupt on timer2 - flash digit delay
    if (pir1.TMR2IF) {
083E  1C8C  	BTFSS gbl_pir1,1
083F  2849  	GOTO	label142
0849        label142

        iTimer2Counts++;
0840  0ABE  	INCF gbl_iTimer2Counts, F

        if (iTimer2Counts > 9) {
0841  083E  	MOVF gbl_iTimer2Counts, W
0842  3C09  	SUBLW 0x09
0843  1803  	BTFSC STATUS,C
0844  2848  	GOTO	label141
0848        label141

            iFlashDigitOff++;
0845  0ABF  	INCF gbl_iFlashDigitOff, F

            iTimer2Counts = 0;
0846  01BE  	CLRF gbl_iTimer2Counts

            cTask.TASK_TIMER2 = 1;
0847  16CC  	BSF gbl_cTask,5

        }
        // Clear interrupt flag
        pir1.TMR2IF = 0; 
0848  108C  	BCF gbl_pir1,1

    }
}
0849  0E32  	SWAPF Int1BContext+D'2', W
084A  0084  	MOVWF FSR
084B  0E31  	SWAPF Int1BContext+D'1', W
084C  008A  	MOVWF PCLATH
084D  0E30  	SWAPF Int1BContext, W
084E  0083  	MOVWF STATUS
084F  0EFF  	SWAPF Int1Context, F
0850  0E7F  	SWAPF Int1Context, W
0851  0009  	RETFIE


int binToBcd(int iBin) {

    int iBcd = 0; // 16-bit BCD value - only supporting up to 9999
0270  01F4  	CLRF binToBcd_00000_1_iBcd
0271  01F5  	CLRF binToBcd_00000_1_iBcd+D'1'

    int iTest = 32768; // Start testing from MSB
0272  01F6  	CLRF binToBcd_00000_1_iTest
0273  3080  	MOVLW 0x80
0274  00F7  	MOVWF binToBcd_00000_1_iTest+D'1'

    // Loop through the 16 bits in the two bytes
    for (char i = 0; i < 16; i++) {
0275  01F8  	CLRF binToBcd_00000_2_i
0276        label44
0276  3010  	MOVLW 0x10
0277  0278  	SUBWF binToBcd_00000_2_i, W
0278  1803  	BTFSC STATUS,C
0279  2AD4  	GOTO	label53
02D2  0AF8  	INCF binToBcd_00000_2_i, F
02D3  2A76  	GOTO	label44
02D4        label53

        // Shift one
        iBcd <<= 1;
027A  1003  	BCF STATUS,C
027B  0DF4  	RLF binToBcd_00000_1_iBcd, F
027C  0DF5  	RLF binToBcd_00000_1_iBcd+D'1', F

        // If the bit is set, add one
        if (iBin & iTest)
027D  0876  	MOVF binToBcd_00000_1_iTest, W
027E  0572  	ANDWF binToBcd_00000_arg_iBin, W
027F  1D03  	BTFSS STATUS,Z
0280  2A85  	GOTO	label45
0281  0877  	MOVF binToBcd_00000_1_iTest+D'1', W
0282  0573  	ANDWF binToBcd_00000_arg_iBin+D'1', W
0283  1903  	BTFSC STATUS,Z
0284  2A88  	GOTO	label46
0285        label45

            iBcd++;
0285  0AF4  	INCF binToBcd_00000_1_iBcd, F
0286  1903  	BTFSC STATUS,Z
0287  0AF5  	INCF binToBcd_00000_1_iBcd+D'1', F
0288        label46

        
        // Add 3 to any BCD column 5 or greater
        if ((iBcd & 0x0F) > 0x04)
0288  300F  	MOVLW 0x0F
0289  0574  	ANDWF binToBcd_00000_1_iBcd, W
028A  00F9  	MOVWF CompTempVar599
028B  01FA  	CLRF CompTempVar600
028C  0879  	MOVF CompTempVar599, W
028D  3C04  	SUBLW 0x04
028E  087A  	MOVF CompTempVar600, W
028F  1803  	BTFSC STATUS,C
0290  1D03  	BTFSS STATUS,Z
0291  1BFA  	BTFSC CompTempVar600,7
0292  2A97  	GOTO	label47

            iBcd += 3;
0293  3003  	MOVLW 0x03
0294  07F4  	ADDWF binToBcd_00000_1_iBcd, F
0295  1803  	BTFSC STATUS,C
0296  0AF5  	INCF binToBcd_00000_1_iBcd+D'1', F
0297        label47

        if ((iBcd & 0xF0) > 0x49)
0297  30F0  	MOVLW 0xF0
0298  0574  	ANDWF binToBcd_00000_1_iBcd, W
0299  00FB  	MOVWF CompTempVar601
029A  01FC  	CLRF CompTempVar602
029B  087B  	MOVF CompTempVar601, W
029C  3C49  	SUBLW 0x49
029D  087C  	MOVF CompTempVar602, W
029E  1803  	BTFSC STATUS,C
029F  1D03  	BTFSS STATUS,Z
02A0  1BFC  	BTFSC CompTempVar602,7
02A1  2AA6  	GOTO	label48

            iBcd += 0x30;
02A2  3030  	MOVLW 0x30
02A3  07F4  	ADDWF binToBcd_00000_1_iBcd, F
02A4  1803  	BTFSC STATUS,C
02A5  0AF5  	INCF binToBcd_00000_1_iBcd+D'1', F
02A6        label48

        if ((iBcd & 0xF00) > 0x499)
02A6  3000  	MOVLW 0x00
02A7  0574  	ANDWF binToBcd_00000_1_iBcd, W
02A8  00FD  	MOVWF CompTempVar603
02A9  0875  	MOVF binToBcd_00000_1_iBcd+D'1', W
02AA  390F  	ANDLW 0x0F
02AB  00FE  	MOVWF CompTempVar604
02AC  087E  	MOVF CompTempVar604, W
02AD  3C04  	SUBLW 0x04
02AE  1D03  	BTFSS STATUS,Z
02AF  2AB2  	GOTO	label49
02B0  087D  	MOVF CompTempVar603, W
02B1  3C99  	SUBLW 0x99
02B2        label49
02B2  1803  	BTFSC STATUS,C
02B3  2AB8  	GOTO	label50
02B4  1BFE  	BTFSC CompTempVar604,7
02B5  2AB8  	GOTO	label50
02B8        label50

            iBcd += 0x300;
02B6  3003  	MOVLW 0x03
02B7  07F5  	ADDWF binToBcd_00000_1_iBcd+D'1', F

        if ((iBcd & 0xF000) > 0x4999)
02B8  3000  	MOVLW 0x00
02B9  0574  	ANDWF binToBcd_00000_1_iBcd, W
02BA  1683  	BSF STATUS, RP0
02BB  00A0  	MOVWF CompTempVar605
02BC  1283  	BCF STATUS, RP0
02BD  0875  	MOVF binToBcd_00000_1_iBcd+D'1', W
02BE  39F0  	ANDLW 0xF0
02BF  1683  	BSF STATUS, RP0
02C0  00A1  	MOVWF CompTempVar606
02C1  0821  	MOVF CompTempVar606, W
02C2  3C49  	SUBLW 0x49
02C3  1D03  	BTFSS STATUS,Z
02C4  2AC7  	GOTO	label51
02C5  0820  	MOVF CompTempVar605, W
02C6  3C99  	SUBLW 0x99
02C7        label51
02C7  1803  	BTFSC STATUS,C
02C8  2ACE  	GOTO	label52
02C9  1BA1  	BTFSC CompTempVar606,7
02CA  2ACE  	GOTO	label52
02CE        label52

            iBcd += 0x3000;
02CB  3030  	MOVLW 0x30
02CC  1283  	BCF STATUS, RP0
02CD  07F5  	ADDWF binToBcd_00000_1_iBcd+D'1', F

        
        // move the test bit
        iTest >>= 1;
02CE  1283  	BCF STATUS, RP0
02CF  0D77  	RLF binToBcd_00000_1_iTest+D'1', W
02D0  0CF7  	RRF binToBcd_00000_1_iTest+D'1', F
02D1  0CF6  	RRF binToBcd_00000_1_iTest, F

    }

    return iBcd;
02D4  0874  	MOVF binToBcd_00000_1_iBcd, W
02D5  00F8  	MOVWF CompTempVarRet598
02D6  0875  	MOVF binToBcd_00000_1_iBcd+D'1', W
02D7  00F9  	MOVWF CompTempVarRet598+D'1'

}
02D8  0008  	RETURN



/*********************************************************************************************
  displayTemp()
  Used to split the 16 bit integer returned from the ds18b20 into parts for display
  cTempH - upper 8 bits
  cTempL - lower 8 bits
*********************************************************************************************/
void convertTemp() {

    // convert both bytes to a 16bit int - e.g. 0000 0001 0100 0110 (1 and 70, gives 326)
    
    signed int iTemp = (cTempH << 8) | cTempL;
073E  1283  	BCF STATUS, RP0
073F  1303  	BCF STATUS, RP1
0740  01EC  	CLRF convertTem_00029_1_iTemp
0741  0849  	MOVF gbl_cTempH, W
0742  00ED  	MOVWF convertTem_00029_1_iTemp+D'1'
0743  084A  	MOVF gbl_cTempL, W
0744  04EC  	IORWF convertTem_00029_1_iTemp, F

    
    // Celcius
    gbDS3231IsMinus = (iTemp < 0);
0745  01CB  	CLRF gbl_gbDS3231IsMinus
0746  1BED  	BTFSC convertTem_00029_1_iTemp+D'1',7
0747  0ACB  	INCF gbl_gbDS3231IsMinus, F

    if (gbDS3231IsMinus) {
0748  08CB  	MOVF gbl_gbDS3231IsMinus, F
0749  1903  	BTFSC STATUS,Z
074A  2F50  	GOTO	label127

        iTemp = ~iTemp + 1;
074B  09EC  	COMF convertTem_00029_1_iTemp, F
074C  09ED  	COMF convertTem_00029_1_iTemp+D'1', F
074D  0AEC  	INCF convertTem_00029_1_iTemp, F
074E  1903  	BTFSC STATUS,Z
074F  0AED  	INCF convertTem_00029_1_iTemp+D'1', F
0750        label127

    }
    // this gets celcius * 100 - https://www.phanderson.com/PIC/PICC/sourceboost/ds18b20_1.html
    int iValue = (6 * iTemp) + (iTemp / 4);
0750  3006  	MOVLW 0x06
0751  00F2  	MOVWF __mul_16s__0000F_arg_a
0752  01F3  	CLRF __mul_16s__0000F_arg_a+D'1'
0753  086C  	MOVF convertTem_00029_1_iTemp, W
0754  00F4  	MOVWF __mul_16s__0000F_arg_b
0755  086D  	MOVF convertTem_00029_1_iTemp+D'1', W
0756  00F5  	MOVWF __mul_16s__0000F_arg_b+D'1'
0757  2481  	CALL __mul_16s__0000F
0758  0879  	MOVF CompTempVarRet388, W
0759  00EE  	MOVWF convertTem_00029_1_iValue
075A  087A  	MOVF CompTempVarRet388+D'1', W
075B  00F1  	MOVWF CompTempVar622
075C  086C  	MOVF convertTem_00029_1_iTemp, W
075D  00F0  	MOVWF CompTempVar619
075E  086D  	MOVF convertTem_00029_1_iTemp+D'1', W
075F  00EF  	MOVWF convertTem_00029_1_iValue+D'1'
0760  0D6D  	RLF convertTem_00029_1_iTemp+D'1', W
0761  0CEF  	RRF convertTem_00029_1_iValue+D'1', F
0762  0CF0  	RRF CompTempVar619, F
0763  0D6D  	RLF convertTem_00029_1_iTemp+D'1', W
0764  0CEF  	RRF convertTem_00029_1_iValue+D'1', F
0765  0CF0  	RRF CompTempVar619, F
0766  0870  	MOVF CompTempVar619, W
0767  07EE  	ADDWF convertTem_00029_1_iValue, F
0768  0871  	MOVF CompTempVar622, W
0769  1803  	BTFSC STATUS,C
076A  0AEF  	INCF convertTem_00029_1_iValue+D'1', F
076B  07EF  	ADDWF convertTem_00029_1_iValue+D'1', F


    // Split the temperature reading into digits
    
    // simple way, but more program memory needed for PIC12 or PIC16 (more than 100 words more)
    //giDS3231ValueBCD = iValue / 1000;
    //giDS3231ValueBCD += (iValue / 100) % 10;
    //giDS3231ValueBCD += (iValue / 10) % 10;
    //giDS3231ValueBCD += iValue % 10;
    
    // Double Dabble
    giDS3231ValueBCD = binToBcd(iValue);
076C  086E  	MOVF convertTem_00029_1_iValue, W
076D  00F2  	MOVWF binToBcd_00000_arg_iBin
076E  086F  	MOVF convertTem_00029_1_iValue+D'1', W
076F  00F3  	MOVWF binToBcd_00000_arg_iBin+D'1'
0770  2270  	CALL binToBcd_00000
0771  0878  	MOVF CompTempVarRet598, W
0772  00B3  	MOVWF gbl_giDS3231ValueBCD
0773  0879  	MOVF CompTempVarRet598+D'1', W
0774  00B4  	MOVWF gbl_giDS3231ValueBCD+D'1'

    
    // less program memory needed - may be slower executing
    // https://electronics.stackexchange.com/questions/158563/how-to-split-a-floating-point-number-into-individual-digits
    /*giDS3231ValueBCD = 0;

    // incrementing variables for each digit
    // determine to thousands digit
    while (iValue >= 1000) {
        iValue = iValue - 1000;
        // each time we take off 1000, the digit is incremented
        giDS3231ValueBCD += 0x1000;
    }

    // determine to hundreds digit
    while (iValue >= 100) {
        iValue = iValue - 100;
        // each time we take off 100, the digit is incremented
        giDS3231ValueBCD += 0x100;
    }

    // determine to tens digit
    while (iValue >= 10) {
        iValue = iValue - 10;
        // each time we take off 10, the left most digit is incremented
        giDS3231ValueBCD += 0x10;
    }

    // the last digit is what's left on iValue
    giDS3231ValueBCD += iValue;*/
}
0775  0008  	RETURN


/*********************************************************************************************
  startTemp()
  Sends the Convert T [44h] function command to the ds18b20
*********************************************************************************************/
void startTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // 44 is the convert function
    oneWireTxBytes(0xCC, 0x44);
0650  30CC  	MOVLW 0xCC
0651  1283  	BCF STATUS, RP0
0652  1303  	BCF STATUS, RP1
0653  00EC  	MOVWF oneWireTxB_00019_arg_cData
0654  3044  	MOVLW 0x44
0655  00ED  	MOVWF oneWireTxB_00019_arg_cData2
0656  21FC  	CALL oneWireTxB_00019

}
0657  0008  	RETURN


/*********************************************************************************************
  startTemp()
  Sends the Read Scratchpad [BEh] function command to the ds18b20
*********************************************************************************************/
void readTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // BE indicates to read scratchpad
    oneWireTxBytes(0xCC, 0xBE);
0658  30CC  	MOVLW 0xCC
0659  1283  	BCF STATUS, RP0
065A  1303  	BCF STATUS, RP1
065B  00EC  	MOVWF oneWireTxB_00019_arg_cData
065C  30BE  	MOVLW 0xBE
065D  00ED  	MOVWF oneWireTxB_00019_arg_cData2
065E  21FC  	CALL oneWireTxB_00019

    // Now get the temperature from the scratchpad
    // This is in the first two bytes - so get those only and ignore the rest
    cTempL = oneWireRxByte();
065F  2203  	CALL oneWireRxB_0001A
0660  086D  	MOVF CompTempVarRet550, W
0661  00CA  	MOVWF gbl_cTempL

    cTempH = oneWireRxByte();
0662  2203  	CALL oneWireRxB_0001A
0663  086D  	MOVF CompTempVarRet550, W
0664  00C9  	MOVWF gbl_cTempH

}
0665  0008  	RETURN


/*********************************************************************************************
  char bcdAdjust(char bcd, char bcdMax, char bcdMin)
  Increment or Decrement a BCD variable for sending to the DS3231, within a given range
  Must set iBcdAdjustment first
*********************************************************************************************/
char bcdAdjust(char bcd, char bcdMax, char bcdMin) {

    if (iBcdAdjustment == 1) {
01BF  0368  	DECF gbl_iBcdAdjustment, W
01C0  1D03  	BTFSS STATUS,Z
01C1  29D5  	GOTO	label37
01D5        label37

        // Increment
        // if at maximum, reset to minimum
        if (bcd == bcdMax)
01C2  086E  	MOVF bcdAdjust_00000_arg_bcdMax, W
01C3  066D  	XORWF bcdAdjust_00000_arg_bcd, W
01C4  1D03  	BTFSS STATUS,Z
01C5  29C9  	GOTO	label35
01C9        label35

            bcd = bcdMin;
01C6  086F  	MOVF bcdAdjust_00000_arg_bcdMin, W
01C7  00ED  	MOVWF bcdAdjust_00000_arg_bcd

        else if ((bcd & 0x0F) == 9)
01C8  29E6  	GOTO	label40
01C9  300F  	MOVLW 0x0F
01CA  056D  	ANDWF bcdAdjust_00000_arg_bcd, W
01CB  00F0  	MOVWF CompTempVar608
01CC  0870  	MOVF CompTempVar608, W
01CD  3A09  	XORLW 0x09
01CE  1D03  	BTFSS STATUS,Z
01CF  29D3  	GOTO	label36
01D3        label36

            bcd += 0x10;
01D0  3010  	MOVLW 0x10
01D1  07ED  	ADDWF bcdAdjust_00000_arg_bcd, F

        else
01D2  29E6  	GOTO	label40

            bcd++;
01D3  0AED  	INCF bcdAdjust_00000_arg_bcd, F

    } else {
01D4  29E6  	GOTO	label40

        // Decrement
        // if at minimum, reset to maximum
        if (bcd == bcdMin)
01D5  086F  	MOVF bcdAdjust_00000_arg_bcdMin, W
01D6  066D  	XORWF bcdAdjust_00000_arg_bcd, W
01D7  1D03  	BTFSS STATUS,Z
01D8  29DC  	GOTO	label38
01DC        label38

            bcd = bcdMax;
01D9  086E  	MOVF bcdAdjust_00000_arg_bcdMax, W
01DA  00ED  	MOVWF bcdAdjust_00000_arg_bcd

        else if ((bcd & 0x0F) == 0)
01DB  29E6  	GOTO	label40
01DC  300F  	MOVLW 0x0F
01DD  056D  	ANDWF bcdAdjust_00000_arg_bcd, W
01DE  00F0  	MOVWF CompTempVar609
01DF  08F0  	MOVF CompTempVar609, F
01E0  1D03  	BTFSS STATUS,Z
01E1  29E5  	GOTO	label39
01E5        label39

            bcd -= 0x10;
01E2  3010  	MOVLW 0x10
01E3  02ED  	SUBWF bcdAdjust_00000_arg_bcd, F

        else
01E4  29E6  	GOTO	label40
01E6        label40

            bcd--;
01E5  03ED  	DECF bcdAdjust_00000_arg_bcd, F

    }
    return bcd;
01E6  086D  	MOVF bcdAdjust_00000_arg_bcd, W
01E7  00F0  	MOVWF CompTempVarRet607

}
01E8  0008  	RETURN


/*********************************************************************************************
  adjustDateTime()
  Increment or Decrement a BCD variable for sending to the DS3231, within a given range
  Must set iBcdAdjustment first
*********************************************************************************************/
void adjustDateTime() {

    switch (gcSetMode) {

        case 1:
0407  1283  	BCF STATUS, RP0
0408  1303  	BCF STATUS, RP1
0409  084F  	MOVF gbl_gcSetMode, W
040A  3A01  	XORLW 0x01
040B  1903  	BTFSC STATUS,Z
040C  2C1D  	GOTO	label69
041D        label69

            // Setting year
            gBcdYear = bcdAdjust(gBcdYear, 0x99, 0x00);
041D  083B  	MOVF gbl_gBcdYear, W
041E  00ED  	MOVWF bcdAdjust_00000_arg_bcd
041F  3099  	MOVLW 0x99
0420  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
0421  01EF  	CLRF bcdAdjust_00000_arg_bcdMin
0422  21BF  	CALL bcdAdjust_00000
0423  0870  	MOVF CompTempVarRet607, W
0424  00BB  	MOVWF gbl_gBcdYear

            break;
        case 2:
040D  3A03  	XORLW 0x03
040E  1903  	BTFSC STATUS,Z
040F  2C26  	GOTO	label70
0426        label70

            // Setting month
            gBcdMonth = bcdAdjust(gBcdMonth, 0x12, 0x01);
0426  083A  	MOVF gbl_gBcdMonth, W
0427  00ED  	MOVWF bcdAdjust_00000_arg_bcd
0428  3012  	MOVLW 0x12
0429  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
042A  3001  	MOVLW 0x01
042B  00EF  	MOVWF bcdAdjust_00000_arg_bcdMin
042C  21BF  	CALL bcdAdjust_00000
042D  0870  	MOVF CompTempVarRet607, W
042E  00BA  	MOVWF gbl_gBcdMonth

            break;
        case 3:
0410  3A01  	XORLW 0x01
0411  1903  	BTFSC STATUS,Z
0412  2C30  	GOTO	label71
0430        label71

            // Setting day of month
            char iMonth = gBcdMonth;
0430  083A  	MOVF gbl_gBcdMonth, W
0431  00EB  	MOVWF adjustDate_00024_1_iMonth

            if (iMonth & 0xF0)
0432  30F0  	MOVLW 0xF0
0433  056B  	ANDWF adjustDate_00024_1_iMonth, W
0434  1903  	BTFSC STATUS,Z
0435  2C3B  	GOTO	label72
043B        label72

                iMonth += (gBcdMonth >> 4);
0436  0E3A  	SWAPF gbl_gBcdMonth, W
0437  390F  	ANDLW 0x0F
0438  00ED  	MOVWF CompTempVar610
0439  086D  	MOVF CompTempVar610, W
043A  07EB  	ADDWF adjustDate_00024_1_iMonth, F

            iMonth--; // Make 0 to 11 index based
043B  03EB  	DECF adjustDate_00024_1_iMonth, F

            char bcdMaxDay = gDaysInMonth[iMonth]; 
043C  083C  	MOVF gbl_gDaysInMonth, W
043D  00F3  	MOVWF __rom_get_00000_arg_objNumb
043E  086B  	MOVF adjustDate_00024_1_iMonth, W
043F  00F4  	MOVWF __rom_get_00000_arg_idx
0440  2030  	CALL __rom_get_00000
0441  00EC  	MOVWF adjustDate_00024_1_bcdMaxDay

            // If February, adjust max days for leap years
            if (iMonth == 1) {
0442  036B  	DECF adjustDate_00024_1_iMonth, W
0443  118A  	BCF PCLATH,3
0444  120A  	BCF PCLATH,4
0445  1D03  	BTFSS STATUS,Z
0446  2C5D  	GOTO	label75

                // See if the 24 leap years since 2000 match the current year
                for (char i = 0; i < 24; i++) {
0447  01ED  	CLRF adjustDate_00024_16_i
0448        label73
0448  3018  	MOVLW 0x18
0449  026D  	SUBWF adjustDate_00024_16_i, W
044A  1803  	BTFSC STATUS,C
044B  2C5D  	GOTO	label75
045B  0AED  	INCF adjustDate_00024_16_i, F
045C  2C48  	GOTO	label73
045D        label75

                    if (gLeapYears[i] == gBcdYear) {
044C  083D  	MOVF gbl_gLeapYears, W
044D  00F3  	MOVWF __rom_get_00000_arg_objNumb
044E  086D  	MOVF adjustDate_00024_16_i, W
044F  00F4  	MOVWF __rom_get_00000_arg_idx
0450  2030  	CALL __rom_get_00000
0451  00EE  	MOVWF CompTempVar611
0452  083B  	MOVF gbl_gBcdYear, W
0453  066E  	XORWF CompTempVar611, W
0454  118A  	BCF PCLATH,3
0455  120A  	BCF PCLATH,4
0456  1D03  	BTFSS STATUS,Z
0457  2C5B  	GOTO	label74
045B        label74

                        bcdMaxDay = 0x29;
0458  3029  	MOVLW 0x29
0459  00EC  	MOVWF adjustDate_00024_1_bcdMaxDay

                        break;
045A  2C5D  	GOTO	label75

                    }
                }
            }
            gBcdDayOfMonth = bcdAdjust(gBcdDayOfMonth, bcdMaxDay, 0x01);
045D  0839  	MOVF gbl_gBcdDayOfMonth, W
045E  00ED  	MOVWF bcdAdjust_00000_arg_bcd
045F  086C  	MOVF adjustDate_00024_1_bcdMaxDay, W
0460  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
0461  3001  	MOVLW 0x01
0462  00EF  	MOVWF bcdAdjust_00000_arg_bcdMin
0463  21BF  	CALL bcdAdjust_00000
0464  0870  	MOVF CompTempVarRet607, W
0465  00B9  	MOVWF gbl_gBcdDayOfMonth

            break;
        case 4:
0413  3A07  	XORLW 0x07
0414  1903  	BTFSC STATUS,Z
0415  2C67  	GOTO	label76
0467        label76

            // Setting day of week
            gDayOfWeek = bcdAdjust(gDayOfWeek, 0x07, 0x01);
0467  0838  	MOVF gbl_gDayOfWeek, W
0468  00ED  	MOVWF bcdAdjust_00000_arg_bcd
0469  3007  	MOVLW 0x07
046A  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
046B  3001  	MOVLW 0x01
046C  00EF  	MOVWF bcdAdjust_00000_arg_bcdMin
046D  21BF  	CALL bcdAdjust_00000
046E  0870  	MOVF CompTempVarRet607, W
046F  00B8  	MOVWF gbl_gDayOfWeek

        case 5:
0416  3A01  	XORLW 0x01
0417  1903  	BTFSC STATUS,Z
0418  2C70  	GOTO	label77
0470        label77

            // Setting hour
            gBcdHour = bcdAdjust(gBcdHour, 0x23, 0x00);
0470  0837  	MOVF gbl_gBcdHour, W
0471  00ED  	MOVWF bcdAdjust_00000_arg_bcd
0472  3023  	MOVLW 0x23
0473  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
0474  01EF  	CLRF bcdAdjust_00000_arg_bcdMin
0475  21BF  	CALL bcdAdjust_00000
0476  0870  	MOVF CompTempVarRet607, W
0477  00B7  	MOVWF gbl_gBcdHour

        case 6:
0419  3A03  	XORLW 0x03
041A  1903  	BTFSC STATUS,Z
041B  2C78  	GOTO	label78
0478        label78

            // Setting minute
            gBcdMinute = bcdAdjust(gBcdMinute, 0x59, 0x00);
0478  0836  	MOVF gbl_gBcdMinute, W
0479  00ED  	MOVWF bcdAdjust_00000_arg_bcd
047A  3059  	MOVLW 0x59
047B  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
047C  01EF  	CLRF bcdAdjust_00000_arg_bcdMin
047D  21BF  	CALL bcdAdjust_00000
047E  0870  	MOVF CompTempVarRet607, W
047F  00B6  	MOVWF gbl_gBcdMinute

    }
}
041C  0008  	RETURN
0425  0008  	RETURN
042F  0008  	RETURN
0466  0008  	RETURN
0480  0008  	RETURN


/*********************************************************************************************
  adjustTrigger()
  Increment or Decrement a trigger time or temperate
  Must set iBcdAdjustment first
*********************************************************************************************/
void adjustTrigger() {

    switch (gcTriggerMode) {

        case 1:
036F  1283  	BCF STATUS, RP0
0370  1303  	BCF STATUS, RP1
0371  0850  	MOVF gbl_gcTriggerMode, W
0372  3A01  	XORLW 0x01
0373  1903  	BTFSC STATUS,Z
0374  2B97  	GOTO	label57
0397        label57

            // White LED on hour
            gBcdWhiteOnHour = bcdAdjust(gBcdWhiteOnHour, 0x23, 0x00);
0397  0852  	MOVF gbl_gBcdWhiteOnHour, W
0398  00ED  	MOVWF bcdAdjust_00000_arg_bcd
0399  3023  	MOVLW 0x23
039A  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
039B  01EF  	CLRF bcdAdjust_00000_arg_bcdMin
039C  21BF  	CALL bcdAdjust_00000
039D  0870  	MOVF CompTempVarRet607, W
039E  00D2  	MOVWF gbl_gBcdWhiteOnHour

            break;
        case 2:
0375  3A03  	XORLW 0x03
0376  1903  	BTFSC STATUS,Z
0377  2BA0  	GOTO	label58
03A0        label58

            // White LED on minute
            gBcdWhiteOnMinute = bcdAdjust(gBcdWhiteOnMinute, 0x59, 0x00);
03A0  0851  	MOVF gbl_gBcdWhiteOnMinute, W
03A1  00ED  	MOVWF bcdAdjust_00000_arg_bcd
03A2  3059  	MOVLW 0x59
03A3  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
03A4  01EF  	CLRF bcdAdjust_00000_arg_bcdMin
03A5  21BF  	CALL bcdAdjust_00000
03A6  0870  	MOVF CompTempVarRet607, W
03A7  00D1  	MOVWF gbl_gBcdWhiteOnMinute

            break;
        case 3:
0378  3A01  	XORLW 0x01
0379  1903  	BTFSC STATUS,Z
037A  2BA9  	GOTO	label59
03A9        label59

            // White LED off hour
            gBcdWhiteOffHour = bcdAdjust(gBcdWhiteOffHour, 0x23, 0x00);
03A9  0854  	MOVF gbl_gBcdWhiteOffHour, W
03AA  00ED  	MOVWF bcdAdjust_00000_arg_bcd
03AB  3023  	MOVLW 0x23
03AC  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
03AD  01EF  	CLRF bcdAdjust_00000_arg_bcdMin
03AE  21BF  	CALL bcdAdjust_00000
03AF  0870  	MOVF CompTempVarRet607, W
03B0  00D4  	MOVWF gbl_gBcdWhiteOffHour

            break;
        case 4:
037B  3A07  	XORLW 0x07
037C  1903  	BTFSC STATUS,Z
037D  2BB2  	GOTO	label60
03B2        label60

            // White LED off minute
            gBcdWhiteOffMinute = bcdAdjust(gBcdWhiteOffMinute, 0x59, 0x00);
03B2  0853  	MOVF gbl_gBcdWhiteOffMinute, W
03B3  00ED  	MOVWF bcdAdjust_00000_arg_bcd
03B4  3059  	MOVLW 0x59
03B5  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
03B6  01EF  	CLRF bcdAdjust_00000_arg_bcdMin
03B7  21BF  	CALL bcdAdjust_00000
03B8  0870  	MOVF CompTempVarRet607, W
03B9  00D3  	MOVWF gbl_gBcdWhiteOffMinute

            break;
        case 5:
037E  3A01  	XORLW 0x01
037F  1903  	BTFSC STATUS,Z
0380  2BBB  	GOTO	label61
03BB        label61

            // Blue LED on hour
            gBcdBlueOnHour = bcdAdjust(gBcdBlueOnHour, 0x23, 0x00);
03BB  0856  	MOVF gbl_gBcdBlueOnHour, W
03BC  00ED  	MOVWF bcdAdjust_00000_arg_bcd
03BD  3023  	MOVLW 0x23
03BE  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
03BF  01EF  	CLRF bcdAdjust_00000_arg_bcdMin
03C0  21BF  	CALL bcdAdjust_00000
03C1  0870  	MOVF CompTempVarRet607, W
03C2  00D6  	MOVWF gbl_gBcdBlueOnHour

            break;
        case 6:
0381  3A03  	XORLW 0x03
0382  1903  	BTFSC STATUS,Z
0383  2BC4  	GOTO	label62
03C4        label62

            // Blue LED on minute
            gBcdBlueOnMinute = bcdAdjust(gBcdBlueOnMinute, 0x59, 0x00);
03C4  0855  	MOVF gbl_gBcdBlueOnMinute, W
03C5  00ED  	MOVWF bcdAdjust_00000_arg_bcd
03C6  3059  	MOVLW 0x59
03C7  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
03C8  01EF  	CLRF bcdAdjust_00000_arg_bcdMin
03C9  21BF  	CALL bcdAdjust_00000
03CA  0870  	MOVF CompTempVarRet607, W
03CB  00D5  	MOVWF gbl_gBcdBlueOnMinute

            break;
        case 7:
0384  3A01  	XORLW 0x01
0385  1903  	BTFSC STATUS,Z
0386  2BCD  	GOTO	label63
03CD        label63

            // Blue LED off hour
            gBcdBlueOffHour = bcdAdjust(gBcdBlueOffHour, 0x23, 0x00);
03CD  0858  	MOVF gbl_gBcdBlueOffHour, W
03CE  00ED  	MOVWF bcdAdjust_00000_arg_bcd
03CF  3023  	MOVLW 0x23
03D0  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
03D1  01EF  	CLRF bcdAdjust_00000_arg_bcdMin
03D2  21BF  	CALL bcdAdjust_00000
03D3  0870  	MOVF CompTempVarRet607, W
03D4  00D8  	MOVWF gbl_gBcdBlueOffHour

            break;
        case 8:
0387  3A0F  	XORLW 0x0F
0388  1903  	BTFSC STATUS,Z
0389  2BD6  	GOTO	label64
03D6        label64

            // Blue LED off minute
            gBcdBlueOffMinute = bcdAdjust(gBcdBlueOffMinute, 0x59, 0x00);
03D6  0857  	MOVF gbl_gBcdBlueOffMinute, W
03D7  00ED  	MOVWF bcdAdjust_00000_arg_bcd
03D8  3059  	MOVLW 0x59
03D9  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
03DA  01EF  	CLRF bcdAdjust_00000_arg_bcdMin
03DB  21BF  	CALL bcdAdjust_00000
03DC  0870  	MOVF CompTempVarRet607, W
03DD  00D7  	MOVWF gbl_gBcdBlueOffMinute

            break;
        case 9:
038A  3A01  	XORLW 0x01
038B  1903  	BTFSC STATUS,Z
038C  2BDF  	GOTO	label65
03DF        label65

            // Fan on temp - between 20 and 40 degrees C
            gBcdFanOnTemp = bcdAdjust(gBcdFanOnTemp, 0x40, 0x20);
03DF  0859  	MOVF gbl_gBcdFanOnTemp, W
03E0  00ED  	MOVWF bcdAdjust_00000_arg_bcd
03E1  3040  	MOVLW 0x40
03E2  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
03E3  3020  	MOVLW 0x20
03E4  00EF  	MOVWF bcdAdjust_00000_arg_bcdMin
03E5  21BF  	CALL bcdAdjust_00000
03E6  0870  	MOVF CompTempVarRet607, W
03E7  00D9  	MOVWF gbl_gBcdFanOnTemp

            break;
        case 10:
038D  3A03  	XORLW 0x03
038E  1903  	BTFSC STATUS,Z
038F  2BE9  	GOTO	label66
03E9        label66

            // Fan off temp - off must be lower than on, min 20 degrees C
            gBcdFanOffTemp = bcdAdjust(gBcdFanOffTemp, gBcdFanOffTemp, 0x20);
03E9  085A  	MOVF gbl_gBcdFanOffTemp, W
03EA  00ED  	MOVWF bcdAdjust_00000_arg_bcd
03EB  085A  	MOVF gbl_gBcdFanOffTemp, W
03EC  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
03ED  3020  	MOVLW 0x20
03EE  00EF  	MOVWF bcdAdjust_00000_arg_bcdMin
03EF  21BF  	CALL bcdAdjust_00000
03F0  0870  	MOVF CompTempVarRet607, W
03F1  00DA  	MOVWF gbl_gBcdFanOffTemp

            break;
        case 11:
0390  3A01  	XORLW 0x01
0391  1903  	BTFSC STATUS,Z
0392  2BF3  	GOTO	label67
03F3        label67

            // Heater on temp - between 20 and 40 degrees C
            gBcdHeaterOnTemp = bcdAdjust(gBcdHeaterOnTemp, 0x40, 0x20);
03F3  085B  	MOVF gbl_gBcdHeaterOnTemp, W
03F4  00ED  	MOVWF bcdAdjust_00000_arg_bcd
03F5  3040  	MOVLW 0x40
03F6  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
03F7  3020  	MOVLW 0x20
03F8  00EF  	MOVWF bcdAdjust_00000_arg_bcdMin
03F9  21BF  	CALL bcdAdjust_00000
03FA  0870  	MOVF CompTempVarRet607, W
03FB  00DB  	MOVWF gbl_gBcdHeaterOnTemp

            break;
        case 12:
0393  3A07  	XORLW 0x07
0394  1903  	BTFSC STATUS,Z
0395  2BFD  	GOTO	label68
03FD        label68

            // Heater off temp - off must be higher than on - max 40 degrees C
            gBcdHeaterOffTemp = bcdAdjust(gBcdHeaterOffTemp, 0x40, gBcdHeaterOnTemp);
03FD  085C  	MOVF gbl_gBcdHeaterOffTemp, W
03FE  00ED  	MOVWF bcdAdjust_00000_arg_bcd
03FF  3040  	MOVLW 0x40
0400  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
0401  085B  	MOVF gbl_gBcdHeaterOnTemp, W
0402  00EF  	MOVWF bcdAdjust_00000_arg_bcdMin
0403  21BF  	CALL bcdAdjust_00000
0404  0870  	MOVF CompTempVarRet607, W
0405  00DC  	MOVWF gbl_gBcdHeaterOffTemp

            break;
    }
}
0396  0008  	RETURN
039F  0008  	RETURN
03A8  0008  	RETURN
03B1  0008  	RETURN
03BA  0008  	RETURN
03C3  0008  	RETURN
03CC  0008  	RETURN
03D5  0008  	RETURN
03DE  0008  	RETURN
03E8  0008  	RETURN
03F2  0008  	RETURN
03FC  0008  	RETURN
0406  0008  	RETURN


void processKeys() {

    switch (tm1638Keys) {

        case 1:
0666  1283  	BCF STATUS, RP0
0667  1303  	BCF STATUS, RP1
0668  0865  	MOVF gbl_tm1638Keys, W
0669  3A01  	XORLW 0x01
066A  1903  	BTFSC STATUS,Z
066B  2E82  	GOTO	label117
0682        label117

            // Toggle white light on/off
            WHITE_LED = !WHITE_LED;
0682  01EB  	CLRF CompTempVar612
0683  1C87  	BTFSS gbl_portc,1
0684  0AEB  	INCF CompTempVar612, F
0685  186B  	BTFSC CompTempVar612,0
0686  1487  	BSF gbl_portc,1
0687  1C6B  	BTFSS CompTempVar612,0
0688  1087  	BCF gbl_portc,1

            break;
        case 2:
066C  3A03  	XORLW 0x03
066D  1903  	BTFSC STATUS,Z
066E  2E8A  	GOTO	label118
068A        label118

            // Toggle blue light on/off
            BLUE_LED = !BLUE_LED;
068A  01EB  	CLRF CompTempVar613
068B  1D07  	BTFSS gbl_portc,2
068C  0AEB  	INCF CompTempVar613, F
068D  186B  	BTFSC CompTempVar613,0
068E  1507  	BSF gbl_portc,2
068F  1C6B  	BTFSS CompTempVar613,0
0690  1107  	BCF gbl_portc,2

            break;
        case 3:
066F  3A01  	XORLW 0x01
0670  1903  	BTFSC STATUS,Z
0671  2E92  	GOTO	label119
0692        label119

            // Toggle fan on/off
            FAN = !FAN;
0692  01EB  	CLRF CompTempVar614
0693  1C85  	BTFSS gbl_porta,1
0694  0AEB  	INCF CompTempVar614, F
0695  186B  	BTFSC CompTempVar614,0
0696  1485  	BSF gbl_porta,1
0697  1C6B  	BTFSS CompTempVar614,0
0698  1085  	BCF gbl_porta,1

            break;
        case 4:
0672  3A07  	XORLW 0x07
0673  1903  	BTFSC STATUS,Z
0674  2E9A  	GOTO	label120
069A        label120

            // Display temp C/temp F/date
            gcDisplayMode++;
069A  0ACE  	INCF gbl_gcDisplayMode, F

            if (gcDisplayMode > 2)
069B  084E  	MOVF gbl_gcDisplayMode, W
069C  3C02  	SUBLW 0x02
069D  1C03  	BTFSS STATUS,C

                gcDisplayMode = 0;
069E  01CE  	CLRF gbl_gcDisplayMode

            break;
        case 5:
0675  3A01  	XORLW 0x01
0676  1903  	BTFSC STATUS,Z
0677  2EA0  	GOTO	label121
06A0        label121

            // Set
            gcSetMode++;
06A0  0ACF  	INCF gbl_gcSetMode, F

            if (gcSetMode > 6) {
06A1  084F  	MOVF gbl_gcSetMode, W
06A2  3C06  	SUBLW 0x06
06A3  1803  	BTFSC STATUS,C

                ds3231WriteDateTime();
06A5  2234  	CALL ds3231Writ_0001C

                gcSetMode = 0;
06A6  01CF  	CLRF gbl_gcSetMode

            }
            break;
        case 6:
0678  3A03  	XORLW 0x03
0679  1903  	BTFSC STATUS,Z
067A  2EA8  	GOTO	label122
06A8        label122

            // Adjust down
            iBcdAdjustment = 0;
06A8  01E8  	CLRF gbl_iBcdAdjustment

            if (gcSetMode) {
06A9  08CF  	MOVF gbl_gcSetMode, F
06AA  1903  	BTFSC STATUS,Z
06AB  2EAE  	GOTO	label123
06AE        label123

                adjustDateTime();
06AC  2407  	CALL adjustDate_00024

            } else if (gcTriggerMode) {
06AE  08D0  	MOVF gbl_gcTriggerMode, F
06AF  1D03  	BTFSS STATUS,Z

                adjustTrigger();
06B0  236F  	CALL adjustTrig_00025

            }
            break;
        case 7:
067B  3A01  	XORLW 0x01
067C  1903  	BTFSC STATUS,Z
067D  2EB2  	GOTO	label124
06B2        label124

            iBcdAdjustment = 1;
06B2  3001  	MOVLW 0x01
06B3  00E8  	MOVWF gbl_iBcdAdjustment

            // Adjust up
            if (gcSetMode) {
06B4  08CF  	MOVF gbl_gcSetMode, F
06B5  1903  	BTFSC STATUS,Z
06B6  2EB9  	GOTO	label125
06B9        label125

                adjustDateTime();
06B7  2407  	CALL adjustDate_00024

            } else if (gcTriggerMode) {
06B9  08D0  	MOVF gbl_gcTriggerMode, F
06BA  1D03  	BTFSS STATUS,Z

                adjustTrigger();
06BB  236F  	CALL adjustTrig_00025

            }
            break;
        case 8:
067E  3A0F  	XORLW 0x0F
067F  1903  	BTFSC STATUS,Z
0680  2EBD  	GOTO	label126
06BD        label126

            // Timer
            gcTriggerMode++;
06BD  0AD0  	INCF gbl_gcTriggerMode, F

            if (gcTriggerMode > 12) {
06BE  0850  	MOVF gbl_gcTriggerMode, W
06BF  3C0C  	SUBLW 0x0C
06C0  1803  	BTFSC STATUS,C

                gcTriggerMode = 0;
06C2  01D0  	CLRF gbl_gcTriggerMode

                at24c32WriteAll(); // Exiting trigger mode, save the new triggers to EEPROM chip
06C3  22FE  	CALL at24c32Wri_00027

            }
            break;
    }
}
0681  0008  	RETURN
0689  0008  	RETURN
0691  0008  	RETURN
0699  0008  	RETURN
069F  0008  	RETURN
06A4  0008  	RETURN
06A7  0008  	RETURN
06AD  0008  	RETURN
06B1  0008  	RETURN
06B8  0008  	RETURN
06BC  0008  	RETURN
06C1  0008  	RETURN
06C4  0008  	RETURN


void main() {

    initialise();
0776  26DD  	CALL initialise_00000

    //convertTemp();
    tm1638UpdateDisplay();
0777  24AA  	CALL tm1638Upda_00020


    // Endless loop
    while(1) {
0778        label128

        // Task scheduler
        // If there are tasks to be performed, find out the
        // most recent task from the array and execute it
        while (cTask > 0) {
0778  084C  	MOVF gbl_cTask, W
0779  3C00  	SUBLW 0x00
077A  1803  	BTFSC STATUS,C
077B  2F78  	GOTO	label128

            if (cTask.TASK_TIMER1) {
077C  1D4C  	BTFSS gbl_cTask,2
077D  2FCB  	GOTO	label137
07CB        label137

                if (gcSetMode == 0) {
077E  08CF  	MOVF gbl_gcSetMode, F
077F  1D03  	BTFSS STATUS,Z
0780  2F97  	GOTO	label132

                    ds3231ReadDateTime();
0781  2714  	CALL ds3231Read_0001D

                    if ((gBcdSeconds == 0x29) || (gBcdSeconds == 0x59)) {
0782  0835  	MOVF gbl_gBcdSeconds, W
0783  3A29  	XORLW 0x29
0784  1903  	BTFSC STATUS,Z
0785  2F8A  	GOTO	label129
0786  0835  	MOVF gbl_gBcdSeconds, W
0787  3A59  	XORLW 0x59
0788  1D03  	BTFSS STATUS,Z
0789  2F8D  	GOTO	label130
078A        label129
078D        label130

                        // Ask to convert for temperature reading at 29 seconds or 59 seconds past the minute
                        oneWireBusReset();
078A  26C5  	CALL oneWireBus_00017

                        startTemp();
078B  2650  	CALL startTemp_00000

                    } else if ((gBcdSeconds == 0) || (gBcdSeconds == 0x30)) {
078C  2F97  	GOTO	label132
078D  08B5  	MOVF gbl_gBcdSeconds, F
078E  1903  	BTFSC STATUS,Z
078F  2F94  	GOTO	label131
0790  0835  	MOVF gbl_gBcdSeconds, W
0791  3A30  	XORLW 0x30
0792  1D03  	BTFSS STATUS,Z
0793  2F97  	GOTO	label132
0794        label131
0797        label132
07D6  2F78  	GOTO	label128

                        // 1 second later, read the converted temperature
                        oneWireBusReset();
0794  26C5  	CALL oneWireBus_00017

                        readTemp(); 
0795  2658  	CALL readTemp_00000

                        // store it in the array, next display refresh will pick it up
                        convertTemp();
0796  273E  	CALL convertTem_00029

                    }
                }
                // Trigger white led
                if ((gBcdHour == gBcdWhiteOnHour) && (gBcdMinute == gBcdWhiteOnMinute)) {
0797  0852  	MOVF gbl_gBcdWhiteOnHour, W
0798  0637  	XORWF gbl_gBcdHour, W
0799  1D03  	BTFSS STATUS,Z
079A  2F9F  	GOTO	label133
079B  0851  	MOVF gbl_gBcdWhiteOnMinute, W
079C  0636  	XORWF gbl_gBcdMinute, W
079D  1903  	BTFSC STATUS,Z

                    WHITE_LED = 1;
079E  1487  	BSF gbl_portc,1
079F        label133

                }
                if ((gBcdHour == gBcdWhiteOffHour) && (gBcdMinute == gBcdWhiteOffMinute)) {
079F  0854  	MOVF gbl_gBcdWhiteOffHour, W
07A0  0637  	XORWF gbl_gBcdHour, W
07A1  1D03  	BTFSS STATUS,Z
07A2  2FA7  	GOTO	label134
07A3  0853  	MOVF gbl_gBcdWhiteOffMinute, W
07A4  0636  	XORWF gbl_gBcdMinute, W
07A5  1903  	BTFSC STATUS,Z

                    WHITE_LED = 0;
07A6  1087  	BCF gbl_portc,1
07A7        label134

                }
                // Trigger blue led
                if ((gBcdHour == gBcdBlueOnHour) && (gBcdMinute == gBcdBlueOnMinute)) {
07A7  0856  	MOVF gbl_gBcdBlueOnHour, W
07A8  0637  	XORWF gbl_gBcdHour, W
07A9  1D03  	BTFSS STATUS,Z
07AA  2FAF  	GOTO	label135
07AB  0855  	MOVF gbl_gBcdBlueOnMinute, W
07AC  0636  	XORWF gbl_gBcdMinute, W
07AD  1903  	BTFSC STATUS,Z

                    BLUE_LED = 1;
07AE  1507  	BSF gbl_portc,2
07AF        label135

                }
                if ((gBcdHour == gBcdBlueOffHour) && (gBcdMinute == gBcdBlueOffMinute)) {
07AF  0858  	MOVF gbl_gBcdBlueOffHour, W
07B0  0637  	XORWF gbl_gBcdHour, W
07B1  1D03  	BTFSS STATUS,Z
07B2  2FB7  	GOTO	label136
07B3  0857  	MOVF gbl_gBcdBlueOffMinute, W
07B4  0636  	XORWF gbl_gBcdMinute, W
07B5  1903  	BTFSC STATUS,Z

                    BLUE_LED = 0;
07B6  1107  	BCF gbl_portc,2
07B7        label136

                }
                // Trigger fan
                char cTempTruncated = giDS3231ValueBCD >> 8;
07B7  0834  	MOVF gbl_giDS3231ValueBCD+D'1', W
07B8  00EB  	MOVWF main_8_cTempTruncated

                if (cTempTruncated == gBcdFanOnTemp) {
07B9  0859  	MOVF gbl_gBcdFanOnTemp, W
07BA  066B  	XORWF main_8_cTempTruncated, W
07BB  1903  	BTFSC STATUS,Z

                    FAN = 1;
07BC  1485  	BSF gbl_porta,1

                }
                if (cTempTruncated == gBcdFanOffTemp) {
07BD  085A  	MOVF gbl_gBcdFanOffTemp, W
07BE  066B  	XORWF main_8_cTempTruncated, W
07BF  1903  	BTFSC STATUS,Z

                    FAN = 0;
07C0  1085  	BCF gbl_porta,1

                }
                if (cTempTruncated == gBcdHeaterOnTemp) {
07C1  085B  	MOVF gbl_gBcdHeaterOnTemp, W
07C2  066B  	XORWF main_8_cTempTruncated, W
07C3  1903  	BTFSC STATUS,Z

                    HEATER = 1;
07C4  1405  	BSF gbl_porta,0

                }
                if (cTempTruncated == gBcdHeaterOffTemp) {
07C5  085C  	MOVF gbl_gBcdHeaterOffTemp, W
07C6  066B  	XORWF main_8_cTempTruncated, W
07C7  1903  	BTFSC STATUS,Z

                    HEATER = 0;
07C8  1005  	BCF gbl_porta,0

                }
                // Display time and temp or date on TM1638
                tm1638UpdateDisplay();
07C9  24AA  	CALL tm1638Upda_00020

                
                cTask.TASK_TIMER1 = 0;
07CA  114C  	BCF gbl_cTask,2

            }
            if (cTask.TASK_TIMER2) {
07CB  1ECC  	BTFSS gbl_cTask,5
07CC  2FD2  	GOTO	label138
07D2        label138

                // If in set mode, update the display every ~half second to flash a digit
                if (gcSetMode > 0)
07CD  084F  	MOVF gbl_gcSetMode, W
07CE  3C00  	SUBLW 0x00
07CF  1C03  	BTFSS STATUS,C

                    tm1638UpdateDisplay();
07D0  24AA  	CALL tm1638Upda_00020

                cTask.TASK_TIMER2 = 0;
07D1  12CC  	BCF gbl_cTask,5

            }
            // Poll keys
            tm1638ReadKeys();
07D2  262C  	CALL tm1638Read_00022

            if (tm1638Keys != 0) {
07D3  08E5  	MOVF gbl_tm1638Keys, F
07D4  1D03  	BTFSS STATUS,Z

                processKeys();
07D5  2666  	CALL processKey_00026

            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
// I2C Communications Library for I2C MASTER
////////////////////////////////////////////////////////////////////////////
// Author(s): Andrew Smallridge
// Date 15 November 2004
//
// Copyright(C) 2004-2006 Andrew Smallridge
// Copyright(C) 2004-2010 Pavel Baranov
// Copyright(C) 2004-2010 David Hobday
// Existing constants predefined for i2c hardware driver and i2s software
// emulation for the PIC 18F2xx and 18F4xx processors. For hardware support
// on other PICs the constants must be mapped to the corresponding register
// map of the target device
////////////////////////////////////////////////////////////////////////////

/*
////////////////////////////////////////////////////////////////////////////
//	The following three sections should be copied to the user's program:
//		i2c master hardware / software mode definition
//		i2c software implementation template arguments and variables
// 		i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////
// i2c master hardware / software mode definition
//
// For i2c hardware support comment out the #define use_ic2_SW line
////////////////////////////////////////////////////////////////////////////
//#define use_i2c_SW

#if defined use_i2c_SW
////////////////////////////////////////////////////////////////////////////
// i2c software implementation template arguments and variables
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)

// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and software emalated i2c RAM locations. These constants are
// then used by the templated functions. When changing the address of an emulated
// register the corresponding constant mapping must also be changed.
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3					

#else
////////////////////////////////////////////////////////////////////////////
// i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP |i2c_HW)

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and PIC's i2c register locations. These constants are
// then used by the templated functions. 
#define PORTC		0x0f82
#define TRISC		0x0f94
#define e_SSPCON1	0xfc6
#define e_SSPCON2	0xfc5
#define e_SSPSTAT	0xfc7
#define e_SSPADD	0xfc8
#define e_SSPBUF	0xfc9
#define e_SSPIF_PIR	0xf9e
#define e_BCLIF_PIR	0xfa1
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3

#endif

*/


////////////////////////////////////////////////////////////////////////////
// Define the common i2c template structure
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL	template <unsigned char T_SCL_BIT, unsigned short T_SCL_PORT,	\
					unsigned short T_SCL_TRIS, unsigned char T_SDA_BIT, 			\
					unsigned short T_SDA_PORT, unsigned short T_SDA_TRIS,			\
					unsigned short T_i2c_SSPCON1, unsigned short T_i2c_SSPCON2, 	\
					unsigned short T_i2c_SSPSTAT, unsigned short T_i2c_SSPBUF, 		\
					unsigned char T_i2c_SSPIF_BIT, unsigned short T_i2c_SSPIF_PIR,	\
					unsigned char T_i2c_BCLIF_BIT, unsigned short T_i2c_BCLIF_PIR,	\
					unsigned char T_i2c_SMP_BIT, unsigned short T_i2c_SSPADD, 		\
					unsigned char T_MODE>

////////////////////////////////////////////////////////////////////////////
// Define the common i2c template parameters
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL_ARGS	T_SCL_BIT, T_SCL_PORT, T_SCL_TRIS, T_SDA_BIT, 			\
						T_SDA_PORT, T_SDA_TRIS, T_i2c_SSPCON1, T_i2c_SSPCON2, 	\
						T_i2c_SSPSTAT, T_i2c_SSPBUF, T_i2c_SSPIF_BIT, 			\
						T_i2c_SSPIF_PIR, T_i2c_BCLIF_BIT, T_i2c_BCLIF_PIR,		\
						T_i2c_SMP_BIT, T_i2c_SSPADD, T_MODE

////////////////////////////////////////////////////////////////////////////
// Helpers that hide template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_init	i2c_INIT<i2c_ARGS>
#define i2c_start	i2c_START<i2c_ARGS>
#define i2c_restart	i2c_RESTART<i2c_ARGS>
#define i2c_stop	i2c_STOP<i2c_ARGS>
#define i2c_read	i2c_READ<i2c_ARGS>
#define i2c_write	i2c_WRITE<i2c_ARGS>


////////////////////////////////////////////////////////////////////////////
// I2C Control Status Bits - Emulates the PIC18F hardware I2C implementation
////////////////////////////////////////////////////////////////////////////
// define I2C i2C_SSPCON1 control bits
#define	i2c_WCOL	7
#define	i2c_SSPOV	6
#define	i2c_SSPEN	5
#define	i2c_CKP		4
#define	i2c_SSPM3	3
#define	i2c_SSPM2	2
#define	i2c_SSPM1	1
#define	i2c_SSPM0	0

// define I2C SSPCON2 control bits
#define	i2c_GCEN 	7
#define	i2c_ACKSTAT	6
#define	i2c_ACKDT	5
#define	i2c_ACKEN	4
#define	i2c_RCEN	3
#define	i2c_PEN		2
#define	i2c_RSEN	1
#define	i2c_SEN		0

// define I2C SSPSTAT status bits
#define	i2c_DA		5
#define	i2c_P		4
#define	i2c_S		3
#define	i2c_RW		2
#define	i2c_UA		1
#define	i2c_BF		0


////////////////////////////////////////////////////////////////////////////
// I2C Control Flag Bits
////////////////////////////////////////////////////////////////////////////
// define I2C Mode bits
#define	i2c_HW			0x01
#define	i2c_400KHz		0x02	// 100KHz or 400KHz I2C clock (set = 400KHz)
#define	i2c_reset_wdt	0x04
#define i2c_SMP			0x80	


////////////////////////////////////////////////////////////////////////////
// I2C software constants
////////////////////////////////////////////////////////////////////////////
#define	dly 10	// number of 1us delay increments



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Start Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL 
void i2c_START(void)

{
	// Initiate the I2C START condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	delay_us(dly);
010E  300A  	MOVLW 0x0A
010F  1283  	BCF STATUS, RP0
0110  1303  	BCF STATUS, RP1
0111  00F1  	MOVWF delay_us_00000_arg_del
0112  2010  	CALL delay_us_00000

	l_bclif = 0; // initialise the collision flag for this command
0113  11C6  	BCF i2c_START_00000_1_l_bclif,3

	l_sspif = 0;
0114  11C5  	BCF i2c_START_00000_1_l_sspif,3

		
	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
			
		l_sen = 1; // initiate START condition	

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation			
		l_sen = 1; // initiate START condition
0115  1441  	BSF i2c_START_00000_1_l_sen,0

		l_scl_tris = 1; // ensure the SCL line is high
0116  1683  	BSF STATUS, RP0
0117  1587  	BSF i2c_START_00000_1_l_scl_tris,3

		l_sda_tris = 1; // ensure the SDA line is high	
0118  1607  	BSF i2c_START_00000_1_l_sda_tris,4

		l_scl = 0; // prepare to set SCL line low
0119  1283  	BCF STATUS, RP0
011A  1187  	BCF i2c_START_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low
011B  1207  	BCF i2c_START_00000_1_l_sda,4

		
		if (l_scl && l_sda)
011C  1D87  	BTFSS i2c_START_00000_1_l_scl,3
011D  293B  	GOTO	label23
011E  1E07  	BTFSS i2c_START_00000_1_l_sda,4
011F  293B  	GOTO	label23
013B        label23

		{
			// good sign - no collision detected
			delay_us(dly);
0120  300A  	MOVLW 0x0A
0121  00F1  	MOVWF delay_us_00000_arg_del
0122  2010  	CALL delay_us_00000

			
			if (!l_scl) // ensure the clock is still high
0123  1987  	BTFSC i2c_START_00000_1_l_scl,3
0124  2929  	GOTO	label22
0129        label22

			{
				l_bclif = 1;
0125  15C6  	BSF i2c_START_00000_1_l_bclif,3

				l_s = 1;
0126  15C2  	BSF i2c_START_00000_1_l_s,3

				l_sen = 0;
0127  1041  	BCF i2c_START_00000_1_l_sen,0

				return;
			}
					
			l_sda = 0; // prepare to set SDA line low
0129  1207  	BCF i2c_START_00000_1_l_sda,4

			l_sda_tris = 0; // SDA to output (driven low)
012A  1683  	BSF STATUS, RP0
012B  1207  	BCF i2c_START_00000_1_l_sda_tris,4


			delay_us(dly);					
012C  300A  	MOVLW 0x0A
012D  1283  	BCF STATUS, RP0
012E  00F1  	MOVWF delay_us_00000_arg_del
012F  2010  	CALL delay_us_00000

			l_scl = 0; // prepare to set SCL line low
0130  1187  	BCF i2c_START_00000_1_l_scl,3

			l_scl_tris = 0; // SCL to output (driven low)
0131  1683  	BSF STATUS, RP0
0132  1187  	BCF i2c_START_00000_1_l_scl_tris,3


			delay_us(dly);					
0133  300A  	MOVLW 0x0A
0134  1283  	BCF STATUS, RP0
0135  00F1  	MOVWF delay_us_00000_arg_del
0136  2010  	CALL delay_us_00000

			l_s = 1; // set 'S' bit flag (start bit detected)
0137  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0; // clear flag
0138  1041  	BCF i2c_START_00000_1_l_sen,0

			l_sspif = 1; // flag end of start condition interrupt	
0139  15C5  	BSF i2c_START_00000_1_l_sspif,3

		}
		else
		{
			// here is SDA or SCL are low at the start - indicates a bus collision
			l_bclif = 1;
013B  15C6  	BSF i2c_START_00000_1_l_bclif,3

			l_s = 1; // set 'S' bit flag (start bit detected)
013C  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0;
013D  1041  	BCF i2c_START_00000_1_l_sen,0

			l_rsen = 0;
013E  10C1  	BCF i2c_START_00000_1_l_rsen,1

			l_pen = 0;
013F  1141  	BCF i2c_START_00000_1_l_pen,2

			l_rcen = 0;								
0140  11C1  	BCF i2c_START_00000_1_l_rcen,3

			l_acken = 0;			
0141  1241  	BCF i2c_START_00000_1_l_acken,4

		}
	}
}
0128  0008  	RETURN
013A  0008  	RETURN
0142  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Restart Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_RESTART(void)
{
	// Initiate the I2C RESTART condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
			
	delay_us(dly);
	l_bclif = 0; // initialise the collision flag for this command
	l_sspif = 0;

	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_rsen = 1; // initiate RESTART condition
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation	
		l_rsen = 1;
		l_scl = 0;
		l_sda = 0;
		
		if (!l_scl)
		{
			// good sign - no other I2C activity in progress
			l_sda_tris = 1; // float SDA line high	(should already be in this condition)	
			delay_us(dly);
		
			// about to float the clock line
			// ensure the data line is still high
			if (!l_sda)
			{
				// problem - SDA is low, a bus collision has occurred				
				l_bclif = 1; // set the bus collision flag	
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_scl_tris = 1; // float SCL line (high)	
				return;
			}
												
			l_scl_tris = 1; // float SCL line (high)

			// wait until any clock stretching has finished
			while (!l_scl)
				if (T_MODE & i2c_reset_wdt)
					clear_wdt();	
			delay_us(dly);
			
			// here we are about to drive SDA low
			// first ensure SCL is still high
			if (!l_scl)
			{
				// problem - SCL is low, a bus collision has occurred
				l_bclif = 1; // set the bus collision flag
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_sda_tris = 1; // float SDA line (high)
				return;
			}
				
			l_sda_tris = 0; // drive SDA low
			l_s = 1; // set 'S' bit flag (start bit detected)

			delay_us(dly);
			l_scl_tris = 0; // drive SCL low
			l_rsen = 0;
			l_pen = 0;
			l_sen = 0;			
			l_rcen = 0;								
			l_acken = 0;			
			l_sspif = 1; // flag end of start condition interrupt
		}
		else
		{
			// SCL is high at the start
			// some other I2C activity in progress		
			l_rsen = 0; // clear flag
			// exit without further action
		}
	}
}



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Stop Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_STOP(void)

{ 
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_p@T_i2c_SSPSTAT.i2c_P; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;

	l_bclif = 0; // initialise the collision flag for this command
00DE  1283  	BCF STATUS, RP0
00DF  1303  	BCF STATUS, RP1
00E0  11C6  	BCF i2c_STOP_00000_1_l_bclif,3

	l_sspif = 0;
00E1  11C5  	BCF i2c_STOP_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_pen = 1; // initiate STOP condition on the I2C bus	
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
		
	}
	else
	{
		//	Software I2C implementation
		l_pen = 1; // initiate STOP condition on the I2C bus
00E2  1541  	BSF i2c_STOP_00000_1_l_pen,2

		delay_us(dly);
00E3  300A  	MOVLW 0x0A
00E4  00F1  	MOVWF delay_us_00000_arg_del
00E5  2010  	CALL delay_us_00000

		
		l_scl = 0; // prepare to set SCL line low
00E6  1187  	BCF i2c_STOP_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low
00E7  1207  	BCF i2c_STOP_00000_1_l_sda,4

		l_scl_tris = 0; // drive SCL line low (should already be low)
00E8  1683  	BSF STATUS, RP0
00E9  1187  	BCF i2c_STOP_00000_1_l_scl_tris,3

		l_sda_tris = 0; // drive SDA line low
00EA  1207  	BCF i2c_STOP_00000_1_l_sda_tris,4


		delay_us(dly);		
00EB  300A  	MOVLW 0x0A
00EC  1283  	BCF STATUS, RP0
00ED  00F1  	MOVWF delay_us_00000_arg_del
00EE  2010  	CALL delay_us_00000

		l_scl_tris = 1; // float SCL line (high)
00EF  1683  	BSF STATUS, RP0
00F0  1587  	BSF i2c_STOP_00000_1_l_scl_tris,3

		
		// wait until any clock stretching has finished
		while (!l_scl)
00F1        label18
00F1  1283  	BCF STATUS, RP0
00F2  1987  	BTFSC i2c_STOP_00000_1_l_scl,3
00F3  28F6  	GOTO	label19
00F5  28F1  	GOTO	label18
00F6        label19

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
00F4  0064  	CLRWDT

						
		delay_us(dly);
00F6  300A  	MOVLW 0x0A
00F7  00F1  	MOVWF delay_us_00000_arg_del
00F8  2010  	CALL delay_us_00000

		l_sda_tris = 1; // float SDA line
00F9  1683  	BSF STATUS, RP0
00FA  1607  	BSF i2c_STOP_00000_1_l_sda_tris,4

		delay_us(dly);		
00FB  300A  	MOVLW 0x0A
00FC  1283  	BCF STATUS, RP0
00FD  00F1  	MOVWF delay_us_00000_arg_del
00FE  2010  	CALL delay_us_00000

		
		// here the SDA line should be high - if not a collision has occurred				
		if (!l_sda || !l_scl)
00FF  1E07  	BTFSS i2c_STOP_00000_1_l_sda,4
0100  2903  	GOTO	label20
0101  1987  	BTFSC i2c_STOP_00000_1_l_scl,3
0102  2907  	GOTO	label21
0103        label20
0107        label21

		{
			// problem - SDA or SCL is low, a bus collision has occurred
			l_bclif = 1; // set the bus collision flag	
0103  15C6  	BSF i2c_STOP_00000_1_l_bclif,3

			l_s = 0; // clear 'S' bit flag
0104  11C2  	BCF i2c_STOP_00000_1_l_s,3

			l_pen = 0; // clear flag
0105  1141  	BCF i2c_STOP_00000_1_l_pen,2

		}
		else
		{		
			l_p = 1;
0107  1642  	BSF i2c_STOP_00000_1_l_p,4

			l_pen = 0;
0108  1141  	BCF i2c_STOP_00000_1_l_pen,2

			l_sen = 0;
0109  1041  	BCF i2c_STOP_00000_1_l_sen,0

			l_rsen = 0;			
010A  10C1  	BCF i2c_STOP_00000_1_l_rsen,1

			l_rcen = 0;								
010B  11C1  	BCF i2c_STOP_00000_1_l_rcen,3

			l_acken = 0;
010C  1241  	BCF i2c_STOP_00000_1_l_acken,4

		}
	}
}
0106  0008  	RETURN
010D  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Write Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_WRITE(unsigned char i2c_data)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;	
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
	
	char BitMask;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
008D  11C6  	BCF i2c_WRITE_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
008E  11C5  	BCF i2c_WRITE_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
				
		l_wcol = 0; // clear write collision flag	
		i2c_SSPBUF = i2c_data;

		// test if a write collision occurred
		if (l_wcol)
			return (1); // error exit	

		// wait until MSSP Tx register is empty
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
								
		return (0); // successful exit
	}

	// here for i2c software driver
	l_wcol = 0; // clear write collision flag	
008F  13C0  	BCF i2c_WRITE_00000_1_l_wcol,7

	i2c_SSPBUF = i2c_data;
0090  086E  	MOVF i2c_WRITE_00000_arg_i2c_data, W
0091  00C4  	MOVWF i2c_WRITE_00000_1_i2c_SSPBUF

	
	l_scl = 0; // prepare to set SCL line low
0092  1187  	BCF i2c_WRITE_00000_1_l_scl,3

	l_sda = 0; // prepare to set SDA line low
0093  1207  	BCF i2c_WRITE_00000_1_l_sda,4

	l_rw = 0; // signal we are doing a write
0094  1142  	BCF i2c_WRITE_00000_1_l_rw,2


	for (BitMask = 0x80; BitMask; BitMask>>=1)
0095  3080  	MOVLW 0x80
0096  00EF  	MOVWF i2c_WRITE_00000_1_BitMask
0097        label10
0097  08EF  	MOVF i2c_WRITE_00000_1_BitMask, F
0098  1903  	BTFSC STATUS,Z
0099  28BA  	GOTO	label15
00B7  1003  	BCF STATUS,C
00B8  0CEF  	RRF i2c_WRITE_00000_1_BitMask, F
00B9  2897  	GOTO	label10
00BA        label15

	{
		if (i2c_data & BitMask)
009A  086F  	MOVF i2c_WRITE_00000_1_BitMask, W
009B  056E  	ANDWF i2c_WRITE_00000_arg_i2c_data, W
009C  1903  	BTFSC STATUS,Z
009D  28A1  	GOTO	label11
00A1        label11

			l_sda_tris = 1; // float SDA high	
009E  1683  	BSF STATUS, RP0
009F  1607  	BSF i2c_WRITE_00000_1_l_sda_tris,4

		else
00A0  28A3  	GOTO	label12
00A3        label12

			l_sda_tris = 0; // drive SDA low
00A1  1683  	BSF STATUS, RP0
00A2  1207  	BCF i2c_WRITE_00000_1_l_sda_tris,4

		delay_us(dly);
00A3  300A  	MOVLW 0x0A
00A4  1283  	BCF STATUS, RP0
00A5  00F1  	MOVWF delay_us_00000_arg_del
00A6  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
00A7  1683  	BSF STATUS, RP0
00A8  1587  	BSF i2c_WRITE_00000_1_l_scl_tris,3


		// wait until any clock stretching has finished
		while (!l_scl)
00A9        label13
00A9  1283  	BCF STATUS, RP0
00AA  1987  	BTFSC i2c_WRITE_00000_1_l_scl,3
00AB  28AE  	GOTO	label14
00AD  28A9  	GOTO	label13
00AE        label14

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
00AC  0064  	CLRWDT

		delay_us(dly);
00AE  300A  	MOVLW 0x0A
00AF  00F1  	MOVWF delay_us_00000_arg_del
00B0  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low	
00B1  1683  	BSF STATUS, RP0
00B2  1187  	BCF i2c_WRITE_00000_1_l_scl_tris,3

		delay_us(dly);
00B3  300A  	MOVLW 0x0A
00B4  1283  	BCF STATUS, RP0
00B5  00F1  	MOVWF delay_us_00000_arg_del
00B6  2010  	CALL delay_us_00000

	}
	// serialized out the data
	// now get the status		
	// set SSPIF
	l_sspif = 1;
00BA  15C5  	BSF i2c_WRITE_00000_1_l_sspif,3

	l_acken = 1;
00BB  1641  	BSF i2c_WRITE_00000_1_l_acken,4

	l_ackdt = 0;
00BC  12C1  	BCF i2c_WRITE_00000_1_l_ackdt,5

	l_sda_tris = 1; // float SDA high
00BD  1683  	BSF STATUS, RP0
00BE  1607  	BSF i2c_WRITE_00000_1_l_sda_tris,4

	
	delay_us(dly);
00BF  300A  	MOVLW 0x0A
00C0  1283  	BCF STATUS, RP0
00C1  00F1  	MOVWF delay_us_00000_arg_del
00C2  2010  	CALL delay_us_00000

	
	l_scl_tris = 1; // float SCL high
00C3  1683  	BSF STATUS, RP0
00C4  1587  	BSF i2c_WRITE_00000_1_l_scl_tris,3

	
	// wait until any clock stretching has finished
	while (!l_scl)
00C5        label16
00C5  1283  	BCF STATUS, RP0
00C6  1987  	BTFSC i2c_WRITE_00000_1_l_scl,3
00C7  28CA  	GOTO	label17
00C9  28C5  	GOTO	label16
00CA        label17

		if (T_MODE & i2c_reset_wdt)
			clear_wdt();	
00C8  0064  	CLRWDT

	delay_us(dly);
00CA  300A  	MOVLW 0x0A
00CB  00F1  	MOVWF delay_us_00000_arg_del
00CC  2010  	CALL delay_us_00000


	// get the status bit
	local_ack = l_sda;
00CD  1070  	BCF i2c_WRITE_00000_1_local_ack,0
00CE  1A07  	BTFSC i2c_WRITE_00000_1_l_sda,4
00CF  1470  	BSF i2c_WRITE_00000_1_local_ack,0

	delay_us(dly);
00D0  300A  	MOVLW 0x0A
00D1  00F1  	MOVWF delay_us_00000_arg_del
00D2  2010  	CALL delay_us_00000


	l_scl_tris = 0; // drive SCL low	
00D3  1683  	BSF STATUS, RP0
00D4  1187  	BCF i2c_WRITE_00000_1_l_scl_tris,3

	l_acken = 0;
00D5  1283  	BCF STATUS, RP0
00D6  1241  	BCF i2c_WRITE_00000_1_l_acken,4

	delay_us(dly);
00D7  300A  	MOVLW 0x0A
00D8  00F1  	MOVWF delay_us_00000_arg_del
00D9  2010  	CALL delay_us_00000

	return(local_ack);
00DA  01F1  	CLRF CompTempVarRet551
00DB  1870  	BTFSC i2c_WRITE_00000_1_local_ack,0
00DC  0AF1  	INCF CompTempVarRet551, F

}
00DD  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Read Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_READ(char ack_status)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	char BitMask;
	char i2c_data;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
015F  11C6  	BCF i2c_READ_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
0160  11C5  	BCF i2c_READ_00000_1_l_sspif,3

	l_wcol = 0; // clear write collision flag	
0161  13C0  	BCF i2c_READ_00000_1_l_wcol,7


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// enable master for 1 byte reception	
		l_rcen = 1;

		// wait until byte received
		while(!l_sspif || !l_bf)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// read the byte from the Rx register
		i2c_data = i2c_SSPBUF;			
			
		// wait until the bus is idle		
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		if (ack_status)
			l_ackdt = 1; // preset ack bit
		else
			l_ackdt = 0; // preset ack bit

		l_sspif = 0;
		l_acken = 1; // acknowledge sequence enable

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();								
	}
	else
	{
		// here for i2c software driver
		l_rcen = 1;
0162  15C1  	BSF i2c_READ_00000_1_l_rcen,3

		l_ackdt = ack_status;
0163  186E  	BTFSC i2c_READ_00000_arg_ack_status,0
0164  16C1  	BSF i2c_READ_00000_1_l_ackdt,5
0165  1C6E  	BTFSS i2c_READ_00000_arg_ack_status,0
0166  12C1  	BCF i2c_READ_00000_1_l_ackdt,5

		l_rw = 1;
0167  1542  	BSF i2c_READ_00000_1_l_rw,2

		l_scl = 0; // prepare to set SCL line low
0168  1187  	BCF i2c_READ_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low	
0169  1207  	BCF i2c_READ_00000_1_l_sda,4


		// prepare to serialize in the byte
		l_sda_tris = 1; // float SDA
016A  1683  	BSF STATUS, RP0
016B  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

		delay_us(dly);
016C  300A  	MOVLW 0x0A
016D  1283  	BCF STATUS, RP0
016E  00F1  	MOVWF delay_us_00000_arg_del
016F  2010  	CALL delay_us_00000

		i2c_data = 0;
0170  01F0  	CLRF i2c_READ_00000_1_i2c_data

		for (BitMask = 0x80; BitMask; BitMask>>=1)
0171  3080  	MOVLW 0x80
0172  00EF  	MOVWF i2c_READ_00000_1_BitMask
0173        label26
0173  08EF  	MOVF i2c_READ_00000_1_BitMask, F
0174  1903  	BTFSC STATUS,Z
0175  2990  	GOTO	label30
018D  1003  	BCF STATUS,C
018E  0CEF  	RRF i2c_READ_00000_1_BitMask, F
018F  2973  	GOTO	label26
0190        label30

		{
			l_scl_tris = 1; // float SCL high
0176  1683  	BSF STATUS, RP0
0177  1587  	BSF i2c_READ_00000_1_l_scl_tris,3

			// wait until any clock stretching has finished
			while (!l_scl)
0178        label27
0178  1283  	BCF STATUS, RP0
0179  1987  	BTFSC i2c_READ_00000_1_l_scl,3
017A  297D  	GOTO	label28
017C  2978  	GOTO	label27
017D        label28

				if (T_MODE & i2c_reset_wdt)
					clear_wdt();		
017B  0064  	CLRWDT

			delay_us(dly);
017D  300A  	MOVLW 0x0A
017E  00F1  	MOVWF delay_us_00000_arg_del
017F  2010  	CALL delay_us_00000


			// read the current bit
			l_sda_tris = 1; // float SDA
0180  1683  	BSF STATUS, RP0
0181  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

			if (l_sda)
0182  1283  	BCF STATUS, RP0
0183  1E07  	BTFSS i2c_READ_00000_1_l_sda,4
0184  2987  	GOTO	label29
0187        label29

				i2c_data |= BitMask;
0185  086F  	MOVF i2c_READ_00000_1_BitMask, W
0186  04F0  	IORWF i2c_READ_00000_1_i2c_data, F

			l_scl_tris = 0; // drive SCL low
0187  1683  	BSF STATUS, RP0
0188  1187  	BCF i2c_READ_00000_1_l_scl_tris,3

			delay_us(dly);
0189  300A  	MOVLW 0x0A
018A  1283  	BCF STATUS, RP0
018B  00F1  	MOVWF delay_us_00000_arg_del
018C  2010  	CALL delay_us_00000

		}
		// flag receive complete			
		l_sspif = 1;
0190  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		l_rcen = 0;
0191  11C1  	BCF i2c_READ_00000_1_l_rcen,3

		
		// set the ACK state
		if (ack_status)	
0192  08EE  	MOVF i2c_READ_00000_arg_ack_status, F
0193  1903  	BTFSC STATUS,Z
0194  2998  	GOTO	label31
0198        label31

			l_sda_tris = 1; // float SDA high
0195  1683  	BSF STATUS, RP0
0196  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

		else
0197  299A  	GOTO	label32
019A        label32

			l_sda_tris = 0; // drive SDA low
0198  1683  	BSF STATUS, RP0
0199  1207  	BCF i2c_READ_00000_1_l_sda_tris,4

		delay_us(dly);
019A  300A  	MOVLW 0x0A
019B  1283  	BCF STATUS, RP0
019C  00F1  	MOVWF delay_us_00000_arg_del
019D  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
019E  1683  	BSF STATUS, RP0
019F  1587  	BSF i2c_READ_00000_1_l_scl_tris,3


		// wait until any clock stretching has finished
		while (!l_scl)
01A0        label33
01A0  1283  	BCF STATUS, RP0
01A1  1987  	BTFSC i2c_READ_00000_1_l_scl,3
01A2  29A5  	GOTO	label34
01A4  29A0  	GOTO	label33
01A5        label34

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
01A3  0064  	CLRWDT

	
		l_sspif = 0; // clear SSPIF
01A5  11C5  	BCF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
01A6  300A  	MOVLW 0x0A
01A7  00F1  	MOVWF delay_us_00000_arg_del
01A8  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low		
01A9  1683  	BSF STATUS, RP0
01AA  1187  	BCF i2c_READ_00000_1_l_scl_tris,3

		l_sspif = 1;
01AB  1283  	BCF STATUS, RP0
01AC  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
01AD  300A  	MOVLW 0x0A
01AE  00F1  	MOVWF delay_us_00000_arg_del
01AF  2010  	CALL delay_us_00000

	}
	return(i2c_data);
01B0  0870  	MOVF i2c_READ_00000_1_i2c_data, W
01B1  00F1  	MOVWF CompTempVarRet552

}
01B2  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Initialization
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_INIT(unsigned char i2c_divisor)

{
	volatile unsigned char i2c_SSPADD@T_i2c_SSPADD, i2c_SSPSTAT@T_i2c_SSPSTAT;
	volatile unsigned char i2c_SSPCON1@T_i2c_SSPCON1,i2c_SSPCON2@T_i2c_SSPCON2;

	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_sspen@T_i2c_SSPCON1.i2c_SSPEN, l_smp@T_i2c_SSPSTAT.T_i2c_SMP_BIT;

	l_sda_tris = 1;
0221  1683  	BSF STATUS, RP0
0222  1607  	BSF i2c_INIT_00000_1_l_sda_tris,4

	l_scl_tris = 1;
0223  1587  	BSF i2c_INIT_00000_1_l_scl_tris,3

	
	i2c_SSPCON1 = 0x00; // initialise the I2C control register (mirrors HW SSPCON1)	
0224  1283  	BCF STATUS, RP0
0225  01C0  	CLRF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPADD = i2c_divisor; // get the I2C baud rate divisor
0226  086C  	MOVF i2c_INIT_00000_arg_i2c_divisor, W
0227  00C3  	MOVWF i2c_INIT_00000_1_i2c_SSPADD

	i2c_SSPCON1 = 0x08; // initialise the I2C control register (mirrors HW SSPCON1)	
0228  3008  	MOVLW 0x08
0229  00C0  	MOVWF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPCON2 = 0x00; // initialise the I2C control register (mirrors HW SSPCON2)	
022A  01C1  	CLRF i2c_INIT_00000_1_i2c_SSPCON2

	
	i2c_SSPSTAT = 0x00; // initialise the I2C status register (mirrors HW SSPSTAT)
022B  01C2  	CLRF i2c_INIT_00000_1_i2c_SSPSTAT

	
	if (T_MODE & i2c_SMP)
		l_smp = 1;
022C  17C2  	BSF i2c_INIT_00000_1_l_smp,7


	l_sspif = 0; // initialise the I2C SSP interrupt status
022D  11C5  	BCF i2c_INIT_00000_1_l_sspif,3

	l_bclif = 0; // initialise the I2C BCL interrupt status
022E  11C6  	BCF i2c_INIT_00000_1_l_bclif,3

	l_sda = 0;
022F  1207  	BCF i2c_INIT_00000_1_l_sda,4

	l_scl = 0;
0230  1187  	BCF i2c_INIT_00000_1_l_scl,3

	l_sspen = 1; // enable I2C
0231  16C0  	BSF i2c_INIT_00000_1_l_sspen,5

	
	i2c_STOP<_I2C_TEMPL_ARGS>();
0232  20DE  	CALL i2c_STOP_00000

}
0233  0008  	RETURN







////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  2FD7  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B0  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00B1  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00B2  	MOVWF Int1BContext+D'2'
000D  158A  	BSF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2835  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010  3003  	MOVLW 0x03
0011  07F1  	ADDWF delay_us_00000_arg_del, F
0012  0CF1  	RRF delay_us_00000_arg_del, F
0013  0CF1  	RRF delay_us_00000_arg_del, F
0014  307F  	MOVLW 0x7F
0015  05F1  	ANDWF delay_us_00000_arg_del, F
0016        label1
0016  0000  	NOP
0017  0BF1  	DECFSZ delay_us_00000_arg_del, F
0018  2816  	GOTO	label1
0019  0008  	RETURN
001A        ; } delay_us function end

001A        delay_10us_00000
001A        ; { delay_10us ; function begin
001A        label2
001A  0000  	NOP
001B  0000  	NOP
001C  0000  	NOP
001D  0000  	NOP
001E  0000  	NOP
001F  0000  	NOP
0020  0000  	NOP
0021  0BF1  	DECFSZ delay_10us_00000_arg_del, F
0022  281A  	GOTO	label2
0023  0008  	RETURN
0024        ; } delay_10us function end

0024        delay_ms_00000
0024        ; { delay_ms ; function begin
0024  08EB  	MOVF delay_ms_00000_arg_del, F
0025  1D03  	BTFSS STATUS,Z
0026  2828  	GOTO	label3
0027  0008  	RETURN
0028        label3
0028  30F9  	MOVLW 0xF9
0029        label4
0029  3EFF  	ADDLW 0xFF
002A  1D03  	BTFSS STATUS,Z
002B  2829  	GOTO	label4
002C  0000  	NOP
002D  0BEB  	DECFSZ delay_ms_00000_arg_del, F
002E  2828  	GOTO	label3
002F  0008  	RETURN
0030        ; } delay_ms function end

0030        __rom_get_00000
0030        ; { __rom_get ; function begin
0030  0873  	MOVF __rom_get_00000_arg_objNumb, W
0031  00F6  	MOVWF __rom_get_00000_1_romAddr+D'1'
0032  01F5  	CLRF __rom_get_00000_1_romAddr
0033  1003  	BCF STATUS,C
0034  0DF6  	RLF __rom_get_00000_1_romAddr+D'1', F
0035  0DF5  	RLF __rom_get_00000_1_romAddr, F
0036  0DF6  	RLF __rom_get_00000_1_romAddr+D'1', F
0037  0DF5  	RLF __rom_get_00000_1_romAddr, F
0038  07F6  	ADDWF __rom_get_00000_1_romAddr+D'1', F
0039  1803  	BTFSC STATUS,C
003A  0AF5  	INCF __rom_get_00000_1_romAddr, F
003B  07F6  	ADDWF __rom_get_00000_1_romAddr+D'1', F
003C  1803  	BTFSC STATUS,C
003D  0AF5  	INCF __rom_get_00000_1_romAddr, F
003E  3049  	MOVLW	LOW( label5 )
003F  07F6  	ADDWF __rom_get_00000_1_romAddr+D'1', F
0040  1803  	BTFSC STATUS,C
0041  0AF5  	INCF __rom_get_00000_1_romAddr, F
0042  3000  	MOVLW	HIGH( label5 )
0043  0775  	ADDWF __rom_get_00000_1_romAddr, W
0044  008A  	MOVWF PCLATH
0045  0874  	MOVF __rom_get_00000_arg_idx, W
0046  00F5  	MOVWF __rom_get_00000_1_romAddr
0047  0876  	MOVF __rom_get_00000_1_romAddr+D'1', W
0048  0082  	MOVWF PCL
0049        label5
0049  3000  	MOVLW	HIGH( label6 )
004A  008A  	MOVWF PCLATH
004B  3000  	MOVLW	HIGH( label7 )
004C  00F6  	MOVWF __rom_get_00000_1_romAddr+D'1'
004D  305F  	MOVLW	LOW( label7 )
004E  2858  	GOTO	label6
004F  3000  	MOVLW	HIGH( label6 )
0050  008A  	MOVWF PCLATH
0051  3000  	MOVLW	HIGH( label8 )
0052  00F6  	MOVWF __rom_get_00000_1_romAddr+D'1'
0053  306B  	MOVLW	LOW( label8 )
0054  2858  	GOTO	label6
0055  3000  	MOVLW	HIGH( label9 )
0056  00F6  	MOVWF __rom_get_00000_1_romAddr+D'1'
0057  3083  	MOVLW	LOW( label9 )
0058        label6
0058  07F5  	ADDWF __rom_get_00000_1_romAddr, F
0059  1803  	BTFSC STATUS,C
005A  0AF6  	INCF __rom_get_00000_1_romAddr+D'1', F
005B  0876  	MOVF __rom_get_00000_1_romAddr+D'1', W
005C  008A  	MOVWF PCLATH
005D  0875  	MOVF __rom_get_00000_1_romAddr, W
005E  0082  	MOVWF PCL
005F        label7
005F  3431  	RETLW 0x31
0060  3428  	RETLW 0x28
0061  3431  	RETLW 0x31
0062  3430  	RETLW 0x30
0063  3431  	RETLW 0x31
0064  3430  	RETLW 0x30
0065  3431  	RETLW 0x31
0066  3431  	RETLW 0x31
0067  3430  	RETLW 0x30
0068  3431  	RETLW 0x31
0069  3430  	RETLW 0x30
006A  3431  	RETLW 0x31
006B        label8
006B  3404  	RETLW 0x04
006C  3408  	RETLW 0x08
006D  3412  	RETLW 0x12
006E  3416  	RETLW 0x16
006F  3420  	RETLW 0x20
0070  3424  	RETLW 0x24
0071  3428  	RETLW 0x28
0072  3432  	RETLW 0x32
0073  3436  	RETLW 0x36
0074  3440  	RETLW 0x40
0075  3444  	RETLW 0x44
0076  3448  	RETLW 0x48
0077  3452  	RETLW 0x52
0078  3456  	RETLW 0x56
0079  3460  	RETLW 0x60
007A  3464  	RETLW 0x64
007B  3468  	RETLW 0x68
007C  3472  	RETLW 0x72
007D  3476  	RETLW 0x76
007E  3480  	RETLW 0x80
007F  3484  	RETLW 0x84
0080  3488  	RETLW 0x88
0081  3492  	RETLW 0x92
0082  3496  	RETLW 0x96
0083        label9
0083  343F  	RETLW 0x3F
0084  3406  	RETLW 0x06
0085  345B  	RETLW 0x5B
0086  344F  	RETLW 0x4F
0087  3466  	RETLW 0x66
0088  346D  	RETLW 0x6D
0089  347D  	RETLW 0x7D
008A  3407  	RETLW 0x07
008B  347F  	RETLW 0x7F
008C  346F  	RETLW 0x6F
008D        ; } __rom_get function end














0481        __mul_16s__0000F
0481        ; { __mul_16s_16s__16 ; function begin
0481  01F6  	CLRF __mul_16s__0000F_1_i
0482  01F9  	CLRF CompTempVarRet388
0483  01FA  	CLRF CompTempVarRet388+D'1'
0484  0872  	MOVF __mul_16s__0000F_arg_a, W
0485  00F7  	MOVWF __mul_16s__0000F_1_t
0486  0873  	MOVF __mul_16s__0000F_arg_a+D'1', W
0487  00F8  	MOVWF __mul_16s__0000F_1_t+D'1'
0488  1FF5  	BTFSS __mul_16s__0000F_arg_b+D'1',7
0489  2C90  	GOTO	label79
048A  17F6  	BSF __mul_16s__0000F_1_i,7
048B  09F4  	COMF __mul_16s__0000F_arg_b, F
048C  09F5  	COMF __mul_16s__0000F_arg_b+D'1', F
048D  0AF4  	INCF __mul_16s__0000F_arg_b, F
048E  1903  	BTFSC gbl_status,2
048F  0AF5  	INCF __mul_16s__0000F_arg_b+D'1', F
0490        label79
0490  1A76  	BTFSC __mul_16s__0000F_1_i,4
0491  2CA2  	GOTO	label81
0492  1C74  	BTFSS __mul_16s__0000F_arg_b,0
0493  2C9A  	GOTO	label80
0494  0877  	MOVF __mul_16s__0000F_1_t, W
0495  07F9  	ADDWF CompTempVarRet388, F
0496  0878  	MOVF __mul_16s__0000F_1_t+D'1', W
0497  1803  	BTFSC gbl_status,0
0498  0F78  	INCFSZ __mul_16s__0000F_1_t+D'1', W
0499  07FA  	ADDWF CompTempVarRet388+D'1', F
049A        label80
049A  1003  	BCF gbl_status,0
049B  0CF5  	RRF __mul_16s__0000F_arg_b+D'1', F
049C  0CF4  	RRF __mul_16s__0000F_arg_b, F
049D  1003  	BCF gbl_status,0
049E  0DF7  	RLF __mul_16s__0000F_1_t, F
049F  0DF8  	RLF __mul_16s__0000F_1_t+D'1', F
04A0  0AF6  	INCF __mul_16s__0000F_1_i, F
04A1  2C90  	GOTO	label79
04A2        label81
04A2  1FF6  	BTFSS __mul_16s__0000F_1_i,7
04A3  0008  	RETURN
04A4  09F9  	COMF CompTempVarRet388, F
04A5  09FA  	COMF CompTempVarRet388+D'1', F
04A6  0AF9  	INCF CompTempVarRet388, F
04A7  1903  	BTFSC gbl_status,2
04A8  0AFA  	INCF CompTempVarRet388+D'1', F
04A9  0008  	RETURN
04AA        ; } __mul_16s_16s__16 function end






























07D7        _startup

0832  118A  	BCF PCLATH,3
0833  120A  	BCF PCLATH,4
0834  2F76  	GOTO	main

2007  3FB1  	DW 0x3FB1
