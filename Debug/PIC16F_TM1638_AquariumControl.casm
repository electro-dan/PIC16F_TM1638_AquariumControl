;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 8.01
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

#ifndef _PIC16F_TM1638_AquariumControl_H_
#define _PIC16F_TM1638_AquariumControl_H_

#define TASK_TIMER1 2
#define TASK_TIMER1_START 3
#define TASK_TIMER1_READ 4
#define TASK_TIMER2 5

#define oneWireBus (porta.6)
#define oneWireTris (trisa.6)
#define tm1638dio (porta.1)
#define tm1638clk (porta.0)
#define tm1638dioTris (trisa.1)
#define tm1638strobe (porta.7)
#define WHITE_LED (portb.5)
#define BLUE_LED (portb.4)
#define FAN (portb.3)
#define HEATER (portb.2)

// This means timer 1 will overflow when 1 cycle completes, generating the interrupt
#define TMR1HV 0xFF
#define TMR1LV 0xFF

// i2c options
#define use_i2c_SW
// clock SCL on GP0, data SDA on GP1
#define i2c_ARGS	2, PORTA, TRISA, 3, PORTA, TRISA, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)
// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3

#define ds3231_addr 0xD0

// Time and date variables
char gBcdSeconds = 0; // 0 to 59
077A  1283  	BCF STATUS, RP0
077B  1303  	BCF STATUS, RP1
077C  01B5  	CLRF gbl_gBcdSeconds

char gBcdMinute = 0; // 0 to 59
077D  01B6  	CLRF gbl_gBcdMinute

char gBcdHour = 0; // 0 to 23 or 1 to 12. Also contains 12/24 setting at bit 6. If 12 hour, AM/PM uses bit 5
077E  01B7  	CLRF gbl_gBcdHour

char gDayOfWeek = 1; // 1 to 7
077F  3001  	MOVLW 0x01
0780  00B8  	MOVWF gbl_gDayOfWeek

char gBcdDayOfMonth = 1; // 1 to 31
0781  3001  	MOVLW 0x01
0782  00B9  	MOVWF gbl_gBcdDayOfMonth

char gBcdMonth = 1; // 1 to 12 + century at bit 7
0783  3001  	MOVLW 0x01
0784  00BA  	MOVWF gbl_gBcdMonth

char gBcdYear = 0x23; // Init to 0x23
0785  3023  	MOVLW 0x23
0786  00BB  	MOVWF gbl_gBcdYear

rom char *gDaysInMonth = {0x31, 0x28, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31}; // Days in each month
0787  3000  	MOVLW 0x00
0788  00BC  	MOVWF gbl_gDaysInMonth

rom char *gLeapYears = {0x04, 0x08, 0x12, 0x16, 0x20, 0x24, 0x28, 0x32, 0x36, 0x40, 0x44, 0x48, 0x52, 0x56, 0x60, 0x64, 0x68, 0x72, 0x76, 0x80, 0x84, 0x88, 0x92, 0x96}; // List of leap years
0789  3001  	MOVLW 0x01
078A  00BD  	MOVWF gbl_gLeapYears


// Timer variables
char iTimer2Counts = 0;
078B  01BE  	CLRF gbl_iTimer2Counts

char iFlashDigitOff = 0;
078C  01BF  	CLRF gbl_iFlashDigitOff

char iDigitToFlash = 8; // 8 = no digit to flash
078D  3008  	MOVLW 0x08
078E  00C8  	MOVWF gbl_iDigitToFlash


// Hold the upper and lower bytes from the ds18b0x
char cTempH = 0;
078F  01C9  	CLRF gbl_cTempH

char cTempL = 0;
0790  01CA  	CLRF gbl_cTempL

//char iDecimalPosition = 2;

int giDS3231ValueBCD = 0;
0791  01B3  	CLRF gbl_giDS3231ValueBCD
0792  01B4  	CLRF gbl_giDS3231ValueBCD+D'1'

char gbDS3231IsMinus = 0;
0793  01CB  	CLRF gbl_gbDS3231IsMinus


char cTask = 0; // Used for task scheduler
0794  01CC  	CLRF gbl_cTask


// States
bool gbWhiteOn = 0;
0795  104D  	BCF gbl_gbWhiteOn,0

bool gbBlueOn = 0;
0796  10CD  	BCF gbl_gbBlueOn,1

bool gbFanOn = 0;
0797  114D  	BCF gbl_gbFanOn,2

bool gbHeaterOn = 0;
0798  11CD  	BCF gbl_gbHeaterOn,3

bool gbFlashOff = 0;
0799  124D  	BCF gbl_gbFlashOff,4

char gcDisplayMode = 0;
079A  01CE  	CLRF gbl_gcDisplayMode

char gcSetMode = 0;
079B  01CF  	CLRF gbl_gcSetMode

char gcTriggerMode = 0;
079C  01D0  	CLRF gbl_gcTriggerMode


// Triggers
char gBcdWhiteOnMinute = 0; // 0 to 59
079D  01D1  	CLRF gbl_gBcdWhiteOnMinute

char gBcdWhiteOnHour = 0; // 0 to 23
079E  01D2  	CLRF gbl_gBcdWhiteOnHour

char gBcdWhiteOffMinute = 0; // 0 to 59
079F  01D3  	CLRF gbl_gBcdWhiteOffMinute

char gBcdWhiteOffHour = 0; // 0 to 23
07A0  01D4  	CLRF gbl_gBcdWhiteOffHour


char gBcdBlueOnMinute = 0; // 0 to 59
07A1  01D5  	CLRF gbl_gBcdBlueOnMinute

char gBcdBlueOnHour = 0; // 0 to 23
07A2  01D6  	CLRF gbl_gBcdBlueOnHour

char gBcdBlueOffMinute = 0; // 0 to 59
07A3  01D7  	CLRF gbl_gBcdBlueOffMinute

char gBcdBlueOffHour = 0; // 0 to 23
07A4  01D8  	CLRF gbl_gBcdBlueOffHour


char gBcdFanOnTemp = 0x28; // Degrees C
07A5  3028  	MOVLW 0x28
07A6  00D9  	MOVWF gbl_gBcdFanOnTemp

char gBcdFanOffTemp = 0x27; // Degrees C
07A7  3027  	MOVLW 0x27
07A8  00DA  	MOVWF gbl_gBcdFanOffTemp


char gBcdHeaterOnTemp = 0x24; // Degrees C
07A9  3024  	MOVLW 0x24
07AA  00DB  	MOVWF gbl_gBcdHeaterOnTemp

char gBcdHeaterOffTemp = 0x25; // Degrees C
07AB  3025  	MOVLW 0x25
07AC  00DC  	MOVWF gbl_gBcdHeaterOffTemp


// Used to output the segments from numbers
char tm1638MaxDigits = 8;
07AD  3008  	MOVLW 0x08
07AE  00DD  	MOVWF gbl_tm1638MaxDigits

rom char *tm1638DisplayNumtoSeg = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f};
07AF  3002  	MOVLW 0x02
07B0  00DE  	MOVWF gbl_tm1638DisplayNumtoSeg

char tm1638Dot = 0x80;
07B1  3080  	MOVLW 0x80
07B2  00DF  	MOVWF gbl_tm1638Dot

char tm1638Brightness = 7; // 0 to 7
07B3  3007  	MOVLW 0x07
07B4  00E0  	MOVWF gbl_tm1638Brightness

// 0x40 [01000000] = indicate command to display data
char tm1638ByteSetData = 0x40;
07B5  3040  	MOVLW 0x40
07B6  00E1  	MOVWF gbl_tm1638ByteSetData

// 0x42 [01000010] = indicate command to read data
char tm1638ByteReadData = 0x42;
07B7  3042  	MOVLW 0x42
07B8  00E2  	MOVWF gbl_tm1638ByteReadData

// 0xC0 [11000000] = write out all bytes
char tm1638ByteSetAddr = 0xC0;
07B9  30C0  	MOVLW 0xC0
07BA  00E3  	MOVWF gbl_tm1638ByteSetAddr

// 0x88 [10001000] - Display ON, plus brightness
char tm1638ByteSetOn = 0x88;
07BB  3088  	MOVLW 0x88
07BC  00E4  	MOVWF gbl_tm1638ByteSetOn


// Copy of the data to write / on the display
char tm1638Data[] = {0, 0, 0, 0, 0, 0, 0, 0};
07BD  01A0  	CLRF gbl_tm1638Data
07BE  01A1  	CLRF gbl_tm1638Data+D'1'
07BF  01A2  	CLRF gbl_tm1638Data+D'2'
07C0  01A3  	CLRF gbl_tm1638Data+D'3'
07C1  01A4  	CLRF gbl_tm1638Data+D'4'
07C2  01A5  	CLRF gbl_tm1638Data+D'5'
07C3  01A6  	CLRF gbl_tm1638Data+D'6'
07C4  01A7  	CLRF gbl_tm1638Data+D'7'

// Copy of the LED status
char tm1638LEDs[] = {0, 0, 0, 0, 0, 0, 0, 0};
07C5  01A8  	CLRF gbl_tm1638LEDs
07C6  01A9  	CLRF gbl_tm1638LEDs+D'1'
07C7  01AA  	CLRF gbl_tm1638LEDs+D'2'
07C8  01AB  	CLRF gbl_tm1638LEDs+D'3'
07C9  01AC  	CLRF gbl_tm1638LEDs+D'4'
07CA  01AD  	CLRF gbl_tm1638LEDs+D'5'
07CB  01AE  	CLRF gbl_tm1638LEDs+D'6'
07CC  01AF  	CLRF gbl_tm1638LEDs+D'7'

// Copy of the keys
char tm1638Keys = 0;
07CD  01E5  	CLRF gbl_tm1638Keys

// For printing
char iPrintStartDigit = 0;
07CE  01E6  	CLRF gbl_iPrintStartDigit

char iPrintDotDigit = 8;
07CF  3008  	MOVLW 0x08
07D0  00E7  	MOVWF gbl_iPrintDotDigit

// For adjusting bcd numbers up 1 or down !1
char iBcdAdjustment = 1;
07D1  3001  	MOVLW 0x01
07D2  00E8  	MOVWF gbl_iBcdAdjustment


// DS18B20 functions
char oneWireIsPresent = 0;
07D3  01E9  	CLRF gbl_oneWireIsPresent

char oneWireResetStage = 0;
07D4  01EA  	CLRF gbl_oneWireResetStage

void oneWireBusReset();
void oneWireTxByte(char data);
void oneWireTxBytes(char data, char data2);
char oneWireRxByte();

// EEPROM functions
void eepromWriteAll();
char eepromWrite(char address, char data);
void eepromReadAll();
char eepromRead(char address);

// DS3231 functions
void ds3231Write(char ds3231Reg, char bWrite);
void ds3231Init();
void ds3231Start();
void ds3231Stop();
void ds3231WriteDateTime();
void ds3231ReadDateTime();

// TM1638 functions
void tm1638ByteWrite(char bWrite);
void bcdTo7Seg(char iBcdIn);
void tm1638UpdateDisplay();
void tm1638ReadKeys();

// General functions
int binToBcd(int iBin);
void startTemp();
void readTemp();

char bcdAdjust(char bcd, char bcdMax, char bcdMin);
void adjustDateTime();
void adjustTrigger();
void processKeys();

#endif

#include <system.h>
#include <i2c_driver.h>
#include "PIC16F_TM1638_AquariumControl.h"

//Target PIC16F628A configuration word
#pragma DATA _CONFIG, _PWRTE_OFF & _WDT_OFF & _INTRC_OSC_NOCLKOUT & _CP_OFF & _LVP_OFF & _BODEN_OFF & _MCLRE_OFF

//Set clock frequency
#pragma CLOCK_FREQ	4000000

/***********************************************************************************
  EEPROM read and write methods
************************************************************************************/
void eepromWriteAll() {
    char didWrite = 0;
    // only write value if it is different
    didWrite += eepromWrite(1, gBcdWhiteOnMinute);
    didWrite += eepromWrite(2, gBcdWhiteOnHour);
    didWrite += eepromWrite(3, gBcdWhiteOffMinute);
    didWrite += eepromWrite(4, gBcdWhiteOffHour);
    didWrite += eepromWrite(5, gBcdBlueOnMinute);
    didWrite += eepromWrite(6, gBcdBlueOnHour);
    didWrite += eepromWrite(7, gBcdBlueOffMinute);
    didWrite += eepromWrite(8, gBcdBlueOffHour);
    didWrite += eepromWrite(9, gBcdFanOnTemp);
    didWrite += eepromWrite(10, gBcdFanOffTemp);
    didWrite += eepromWrite(11, gBcdHeaterOnTemp);
    didWrite += eepromWrite(12, gBcdHeaterOffTemp);
    
    if (didWrite)
        eepromWrite(0, 10); // To indicate EEPROM has been saved
}

char eepromWrite(char address, char data) {
    char didWrite = 0;
    if (eepromRead(address) != data) {
        char intconsave = intcon;
        
        // Load address and data
        eeadr = address;
        eedata = data;
    
        eecon1.WREN = 1; // Enable writes
        
        // Required write sequence
        intcon = 0;
        eecon2 = 0x55; // Write 55h
        eecon2 = 0xAA; // Write 0AAh
        eecon1.WR = 1; // Set WR bit to begin write
        intcon = intconsave;
        eecon1.WREN = 0; // Disable writes on write complete (EEIF set)
        while(!pir1.EEIF); // Wait for the interrupt bit EEIF to be set
        pir1.EEIF = 0; // Clear EEIF
        didWrite = 1;
    }
    return didWrite;
}

/******************************************************
  Function to read the current variables from ROM
*******************************************************/
void eepromReadAll() {

    // Read initial values from EEPROM
    // Do not read other variables if the EEPROM has not been saved before
    // as all default will be 0xFF
    if (eepromRead(0) == 10) {
021D  1283  	BCF STATUS, RP0
021E  1303  	BCF STATUS, RP1
021F  01EB  	CLRF eepromRead_00000_arg_address
0220  2142  	CALL eepromRead_00000
0221  086C  	MOVF CompTempVarRet550, W
0222  3A0A  	XORLW 0x0A
0223  1D03  	BTFSS STATUS,Z

        gBcdWhiteOnMinute = eepromRead(1);
0225  3001  	MOVLW 0x01
0226  00EB  	MOVWF eepromRead_00000_arg_address
0227  2142  	CALL eepromRead_00000
0228  086C  	MOVF CompTempVarRet550, W
0229  00D1  	MOVWF gbl_gBcdWhiteOnMinute

        gBcdWhiteOnHour = eepromRead(2);
022A  3002  	MOVLW 0x02
022B  00EB  	MOVWF eepromRead_00000_arg_address
022C  2142  	CALL eepromRead_00000
022D  086C  	MOVF CompTempVarRet550, W
022E  00D2  	MOVWF gbl_gBcdWhiteOnHour

        gBcdWhiteOffMinute = eepromRead(3);
022F  3003  	MOVLW 0x03
0230  00EB  	MOVWF eepromRead_00000_arg_address
0231  2142  	CALL eepromRead_00000
0232  086C  	MOVF CompTempVarRet550, W
0233  00D3  	MOVWF gbl_gBcdWhiteOffMinute

        gBcdWhiteOffHour = eepromRead(4);
0234  3004  	MOVLW 0x04
0235  00EB  	MOVWF eepromRead_00000_arg_address
0236  2142  	CALL eepromRead_00000
0237  086C  	MOVF CompTempVarRet550, W
0238  00D4  	MOVWF gbl_gBcdWhiteOffHour

        gBcdBlueOnMinute = eepromRead(5);
0239  3005  	MOVLW 0x05
023A  00EB  	MOVWF eepromRead_00000_arg_address
023B  2142  	CALL eepromRead_00000
023C  086C  	MOVF CompTempVarRet550, W
023D  00D5  	MOVWF gbl_gBcdBlueOnMinute

        gBcdBlueOnHour = eepromRead(6);
023E  3006  	MOVLW 0x06
023F  00EB  	MOVWF eepromRead_00000_arg_address
0240  2142  	CALL eepromRead_00000
0241  086C  	MOVF CompTempVarRet550, W
0242  00D6  	MOVWF gbl_gBcdBlueOnHour

        gBcdBlueOffMinute = eepromRead(7);
0243  3007  	MOVLW 0x07
0244  00EB  	MOVWF eepromRead_00000_arg_address
0245  2142  	CALL eepromRead_00000
0246  086C  	MOVF CompTempVarRet550, W
0247  00D7  	MOVWF gbl_gBcdBlueOffMinute

        gBcdBlueOffHour = eepromRead(8);
0248  3008  	MOVLW 0x08
0249  00EB  	MOVWF eepromRead_00000_arg_address
024A  2142  	CALL eepromRead_00000
024B  086C  	MOVF CompTempVarRet550, W
024C  00D8  	MOVWF gbl_gBcdBlueOffHour

        gBcdFanOnTemp = eepromRead(9);
024D  3009  	MOVLW 0x09
024E  00EB  	MOVWF eepromRead_00000_arg_address
024F  2142  	CALL eepromRead_00000
0250  086C  	MOVF CompTempVarRet550, W
0251  00D9  	MOVWF gbl_gBcdFanOnTemp

        gBcdFanOffTemp = eepromRead(10);
0252  300A  	MOVLW 0x0A
0253  00EB  	MOVWF eepromRead_00000_arg_address
0254  2142  	CALL eepromRead_00000
0255  086C  	MOVF CompTempVarRet550, W
0256  00DA  	MOVWF gbl_gBcdFanOffTemp

        gBcdHeaterOnTemp = eepromRead(11);
0257  300B  	MOVLW 0x0B
0258  00EB  	MOVWF eepromRead_00000_arg_address
0259  2142  	CALL eepromRead_00000
025A  086C  	MOVF CompTempVarRet550, W
025B  00DB  	MOVWF gbl_gBcdHeaterOnTemp

        gBcdHeaterOffTemp = eepromRead(12);
025C  300C  	MOVLW 0x0C
025D  00EB  	MOVWF eepromRead_00000_arg_address
025E  2142  	CALL eepromRead_00000
025F  086C  	MOVF CompTempVarRet550, W
0260  00DC  	MOVWF gbl_gBcdHeaterOffTemp

    }
}
0224  0008  	RETURN
0261  0008  	RETURN


char eepromRead(char address) {

    // Load address
    eeadr = address;
0142  086B  	MOVF eepromRead_00000_arg_address, W
0143  1683  	BSF STATUS, RP0
0144  009B  	MOVWF gbl_eeadr


    // Read, data is available in eedata the next cycle.
    eecon1.RD = 1;
0145  141C  	BSF gbl_eecon1,0

    
    // Return value
    return eedata;
0146  081A  	MOVF gbl_eedata, W
0147  1283  	BCF STATUS, RP0
0148  00EC  	MOVWF CompTempVarRet550

}
0149  0008  	RETURN

    
/*********************************************************************************************
  oneWireBusReset()
  First part of the reset routine - drive the bus low for 500us
*********************************************************************************************/
void oneWireBusReset() {

    char isPresent;
    oneWireTris = 1; // start with high
0673  1683  	BSF STATUS, RP0
0674  1303  	BCF STATUS, RP1
0675  1705  	BSF gbl_trisa,6

    isPresent = 0;
0676  1283  	BCF STATUS, RP0
0677  01EC  	CLRF oneWireBus_00013_1_isPresent

    // Send the reset pulse - drive low for 500us
    oneWireBus = 0;      
0678  1305  	BCF gbl_porta,6

    oneWireTris = 0;
0679  1683  	BSF STATUS, RP0
067A  1305  	BCF gbl_trisa,6

    delay_10us(50);
067B  3032  	MOVLW 0x32
067C  00F1  	MOVWF delay_10us_00000_arg_del
067D  201A  	CALL delay_10us_00000

    // Release line and wait 70us for PD Pulse
    oneWireTris = 1;
067E  1705  	BSF gbl_trisa,6

    delay_10us(7);
067F  3007  	MOVLW 0x07
0680  00F1  	MOVWF delay_10us_00000_arg_del
0681  201A  	CALL delay_10us_00000

    // Now sample, if there is a sensor on the bus, the line should be low
    if (oneWireBus) {
0682  1283  	BCF STATUS, RP0
0683  1B05  	BTFSC gbl_porta,6

        oneWireIsPresent = 0; // no devices
0684  01E9  	CLRF gbl_oneWireIsPresent

    }
    delay_10us(50);
0685  3032  	MOVLW 0x32
0686  00F1  	MOVWF delay_10us_00000_arg_del
0687  201A  	CALL delay_10us_00000

}
0688  0008  	RETURN


/*********************************************************************************************
  oneWireTxByte(char data)
  Transmits a single byte from the bus
*********************************************************************************************/
void oneWireTxByte(char cData) {

    char cTemp = 1;
0127  3001  	MOVLW 0x01
0128  00EF  	MOVWF oneWireTxB_00014_1_cTemp

    // Loop through the eight bits in the byte
    for (char i = 0; i < 8; i++) {
0129  01F0  	CLRF oneWireTxB_00014_2_i
012A        label22
012A  3008  	MOVLW 0x08
012B  0270  	SUBWF oneWireTxB_00014_2_i, W
012C  1803  	BTFSC STATUS,C
0140  0AF0  	INCF oneWireTxB_00014_2_i, F
0141  292A  	GOTO	label22

        // Send the LSB first

        // Drive the line low initially for 3us
        oneWireTris = 0;
012E  1683  	BSF STATUS, RP0
012F  1305  	BCF gbl_trisa,6

        oneWireBus = 0;
0130  1283  	BCF STATUS, RP0
0131  1305  	BCF gbl_porta,6


        // Delay not needed for 4MHz PIC
        //delay_us(3); // Delay 3us
        
        if (cData & cTemp) {
0132  086F  	MOVF oneWireTxB_00014_1_cTemp, W
0133  056E  	ANDWF oneWireTxB_00014_arg_cData, W
0134  1903  	BTFSC STATUS,Z
0135  2938  	GOTO	label23

            oneWireTris = 1; // Release the bus
0136  1683  	BSF STATUS, RP0
0137  1705  	BSF gbl_trisa,6

        }
        
        delay_10us(5); // Delay 60us - 50us works fine with code delays
0138  3005  	MOVLW 0x05
0139  00F1  	MOVWF delay_10us_00000_arg_del
013A  201A  	CALL delay_10us_00000

        oneWireTris = 1; // Release the bus
013B  1683  	BSF STATUS, RP0
013C  1705  	BSF gbl_trisa,6

        
        // move the test bit
        cTemp <<= 1;
013D  1003  	BCF STATUS,C
013E  1283  	BCF STATUS, RP0
013F  0DEF  	RLF oneWireTxB_00014_1_cTemp, F

    }
}
012D  0008  	RETURN


/*********************************************************************************************
  oneWireTxBytes(char data, char data2)
  Transmits a 2 bytes from the bus
*********************************************************************************************/
void oneWireTxBytes(char cData, char cData2) {

    // Reset first - done in main
    //oneWireBusReset();
    // Send first byte
    oneWireTxByte(cData);
0193  086C  	MOVF oneWireTxB_00015_arg_cData, W
0194  00EE  	MOVWF oneWireTxB_00014_arg_cData
0195  2127  	CALL oneWireTxB_00014

    // Send second byte
    oneWireTxByte(cData2);
0196  086D  	MOVF oneWireTxB_00015_arg_cData2, W
0197  00EE  	MOVWF oneWireTxB_00014_arg_cData
0198  2127  	CALL oneWireTxB_00014

}
0199  0008  	RETURN


/*********************************************************************************************
  oneWireRxByte()
  Receives a single byte from the bus
*********************************************************************************************/
char oneWireRxByte() {

    char cDataIn = 0;
019A  1283  	BCF STATUS, RP0
019B  1303  	BCF STATUS, RP1
019C  01EC  	CLRF oneWireRxB_00016_1_cDataIn

    // Loop through the eight bits in the byte
    for(char i = 0; i < 8; i++) {
019D  01ED  	CLRF oneWireRxB_00016_2_i
019E        label31
019E  3008  	MOVLW 0x08
019F  026D  	SUBWF oneWireRxB_00016_2_i, W
01A0  1803  	BTFSC STATUS,C
01A1  29B5  	GOTO	label32
01B3  0AED  	INCF oneWireRxB_00016_2_i, F
01B4  299E  	GOTO	label31
01B5        label32

        // Bring bus low for 15us
        oneWireTris = 0;
01A2  1683  	BSF STATUS, RP0
01A3  1305  	BCF gbl_trisa,6

        oneWireBus = 0;
01A4  1283  	BCF STATUS, RP0
01A5  1305  	BCF gbl_porta,6


        // Delay not needed for 4MHz PIC
        //delay_us(15); // Delay 15us

        // Release bus for 6us, this is enough time for the slave to respond
        oneWireTris = 1;
01A6  1683  	BSF STATUS, RP0
01A7  1705  	BSF gbl_trisa,6

        delay_us(6); // Delay 6us
01A8  3006  	MOVLW 0x06
01A9  00F0  	MOVWF delay_us_00000_arg_del
01AA  2010  	CALL delay_us_00000

        
        // Shift data already received left
        cDataIn >>= 1;
01AB  1003  	BCF STATUS,C
01AC  1283  	BCF STATUS, RP0
01AD  0CEC  	RRF oneWireRxB_00016_1_cDataIn, F

        // Check the value of the onewire bus - set the MSB of cDataIn if so
        if (oneWireBus)
01AE  1B05  	BTFSC gbl_porta,6

            cDataIn.7 = 1;
01AF  17EC  	BSF oneWireRxB_00016_1_cDataIn,7


        // To finish time slot
        delay_10us(6); // 60us
01B0  3006  	MOVLW 0x06
01B1  00F1  	MOVWF delay_10us_00000_arg_del
01B2  201A  	CALL delay_10us_00000

    } 
    
    return cDataIn;
01B5  086C  	MOVF oneWireRxB_00016_1_cDataIn, W
01B6  00ED  	MOVWF CompTempVarRet548

}
01B7  0008  	RETURN


/*********************************************************************************************
 ds3231Write(char ds3231Reg, char bWrite)
 Write one byte
*********************************************************************************************/
void ds3231Write(char ds3231Reg, char bWrite) {

	i2c_start();
014A  20F2  	CALL i2c_START_00000

	i2c_write(ds3231_addr); // address + write
014B  30D0  	MOVLW 0xD0
014C  00ED  	MOVWF i2c_WRITE_00000_arg_i2c_data
014D  2077  	CALL i2c_WRITE_00000

	i2c_write(ds3231Reg); // start at address
014E  086B  	MOVF ds3231Writ_0001A_arg_ds3231Reg, W
014F  00ED  	MOVWF i2c_WRITE_00000_arg_i2c_data
0150  2077  	CALL i2c_WRITE_00000

	i2c_write(bWrite); // start at address
0151  086C  	MOVF ds3231Writ_0001A_arg_bWrite, W
0152  00ED  	MOVWF i2c_WRITE_00000_arg_i2c_data
0153  2077  	CALL i2c_WRITE_00000

	i2c_stop();
0154  20C4  	CALL i2c_STOP_00000

}
0155  0008  	RETURN


/*********************************************************************************************
 ds3231Init()
 Initialise the DS3231
*********************************************************************************************/
void ds3231Init() {

	/* control register 0Eh
    bit7 EOSC   Enable Oscillator (1 if oscillator must be stopped when on battery)
    bit6 BBSQW  Battery Backed Square Wave
    bit5 CONV   Convert temperature (1 forces a conversion NOW)
    bit4 RS2    Rate select - frequency of square wave output
    bit3 RS1    Rate select
    bit2 INTCN  Interrupt control (1 for use of the alarms and to disable square wave)
    bit1 A2IE   Alarm2 interrupt enable (1 to enable)
    bit0 A1IE   Alarm1 interrupt enable (1 to enable)
    */
	ds3231Write(0x0E, 0x80);
0285  300E  	MOVLW 0x0E
0286  1283  	BCF STATUS, RP0
0287  1303  	BCF STATUS, RP1
0288  00EB  	MOVWF ds3231Writ_0001A_arg_ds3231Reg
0289  3080  	MOVLW 0x80
028A  00EC  	MOVWF ds3231Writ_0001A_arg_bWrite
028B  214A  	CALL ds3231Writ_0001A

	/* Status Register 0Fh
    bit7 OSF     Oscillator Stop Flag
    bit3 EN32kHz Enable 32kHz Output
    bit2 BSY     Busy
    bit1 A2F     Alarm 2 Flag
    bit0 A1F     Alarm 1 Flag
    */
	ds3231Write(0x0F, 0x80);
028C  300F  	MOVLW 0x0F
028D  00EB  	MOVWF ds3231Writ_0001A_arg_ds3231Reg
028E  3080  	MOVLW 0x80
028F  00EC  	MOVWF ds3231Writ_0001A_arg_bWrite
0290  214A  	CALL ds3231Writ_0001A

}
0291  0008  	RETURN


/*********************************************************************************************
 ds3231Start()
 Start the DS3231
*********************************************************************************************/
void ds3231Start() {

	ds3231Write(0x0F, 0x00);
027E  300F  	MOVLW 0x0F
027F  1283  	BCF STATUS, RP0
0280  1303  	BCF STATUS, RP1
0281  00EB  	MOVWF ds3231Writ_0001A_arg_ds3231Reg
0282  01EC  	CLRF ds3231Writ_0001A_arg_bWrite
0283  214A  	CALL ds3231Writ_0001A

}
0284  0008  	RETURN


/*********************************************************************************************
 ds3231Stop()
 Stop the DS3231
*********************************************************************************************/
void ds3231Stop() {
	ds3231Write(0x0F, 0x80);
}

/*********************************************************************************************
 ds3231WriteDateTime()
 Write the date to the DS3231
*********************************************************************************************/
void ds3231WriteDateTime() {

	i2c_start();
0262  20F2  	CALL i2c_START_00000

	i2c_write(ds3231_addr); // address + write
0263  30D0  	MOVLW 0xD0
0264  00ED  	MOVWF i2c_WRITE_00000_arg_i2c_data
0265  2077  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
0266  01ED  	CLRF i2c_WRITE_00000_arg_i2c_data
0267  2077  	CALL i2c_WRITE_00000

	i2c_write(0); // seconds
0268  01ED  	CLRF i2c_WRITE_00000_arg_i2c_data
0269  2077  	CALL i2c_WRITE_00000

	i2c_write(gBcdMinute); // minutes
026A  0836  	MOVF gbl_gBcdMinute, W
026B  00ED  	MOVWF i2c_WRITE_00000_arg_i2c_data
026C  2077  	CALL i2c_WRITE_00000

	i2c_write(gBcdHour); // hours
026D  0837  	MOVF gbl_gBcdHour, W
026E  00ED  	MOVWF i2c_WRITE_00000_arg_i2c_data
026F  2077  	CALL i2c_WRITE_00000

	i2c_write(gDayOfWeek); // day of week
0270  0838  	MOVF gbl_gDayOfWeek, W
0271  00ED  	MOVWF i2c_WRITE_00000_arg_i2c_data
0272  2077  	CALL i2c_WRITE_00000

	i2c_write(gBcdDayOfMonth); // day of month
0273  0839  	MOVF gbl_gBcdDayOfMonth, W
0274  00ED  	MOVWF i2c_WRITE_00000_arg_i2c_data
0275  2077  	CALL i2c_WRITE_00000

	i2c_write(gBcdMonth); // month + century
0276  083A  	MOVF gbl_gBcdMonth, W
0277  00ED  	MOVWF i2c_WRITE_00000_arg_i2c_data
0278  2077  	CALL i2c_WRITE_00000

	i2c_write(gBcdYear); // year
0279  083B  	MOVF gbl_gBcdYear, W
027A  00ED  	MOVWF i2c_WRITE_00000_arg_i2c_data
027B  2077  	CALL i2c_WRITE_00000

	i2c_stop();
027C  20C4  	CALL i2c_STOP_00000

}
027D  0008  	RETURN


/*********************************************************************************************
 ds3231ReadDateTime()
 Write the date to the DS3231
*********************************************************************************************/
void ds3231ReadDateTime() {

	i2c_start();
06B5  20F2  	CALL i2c_START_00000

	i2c_write(ds3231_addr); // address + read
06B6  30D0  	MOVLW 0xD0
06B7  00ED  	MOVWF i2c_WRITE_00000_arg_i2c_data
06B8  2077  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
06B9  01ED  	CLRF i2c_WRITE_00000_arg_i2c_data
06BA  2077  	CALL i2c_WRITE_00000

	i2c_stop();
06BB  20C4  	CALL i2c_STOP_00000

	
	i2c_start();
06BC  20F2  	CALL i2c_START_00000

	i2c_write(ds3231_addr + 1); // address + read
06BD  30D1  	MOVLW 0xD1
06BE  00ED  	MOVWF i2c_WRITE_00000_arg_i2c_data
06BF  2077  	CALL i2c_WRITE_00000

	gBcdSeconds = i2c_read(0); // ack
06C0  01EC  	CLRF i2c_READ_00000_arg_ack_status
06C1  21B8  	CALL i2c_READ_00000
06C2  086F  	MOVF CompTempVarRet552, W
06C3  00B5  	MOVWF gbl_gBcdSeconds

	gBcdMinute = i2c_read(0); // ack
06C4  01EC  	CLRF i2c_READ_00000_arg_ack_status
06C5  21B8  	CALL i2c_READ_00000
06C6  086F  	MOVF CompTempVarRet552, W
06C7  00B6  	MOVWF gbl_gBcdMinute

	gBcdHour = i2c_read(0); // ack
06C8  01EC  	CLRF i2c_READ_00000_arg_ack_status
06C9  21B8  	CALL i2c_READ_00000
06CA  086F  	MOVF CompTempVarRet552, W
06CB  00B7  	MOVWF gbl_gBcdHour

	gDayOfWeek = i2c_read(0); // ack
06CC  01EC  	CLRF i2c_READ_00000_arg_ack_status
06CD  21B8  	CALL i2c_READ_00000
06CE  086F  	MOVF CompTempVarRet552, W
06CF  00B8  	MOVWF gbl_gDayOfWeek

	gBcdDayOfMonth = i2c_read(0); // ack
06D0  01EC  	CLRF i2c_READ_00000_arg_ack_status
06D1  21B8  	CALL i2c_READ_00000
06D2  086F  	MOVF CompTempVarRet552, W
06D3  00B9  	MOVWF gbl_gBcdDayOfMonth

	gBcdMonth = i2c_read(0); // ack
06D4  01EC  	CLRF i2c_READ_00000_arg_ack_status
06D5  21B8  	CALL i2c_READ_00000
06D6  086F  	MOVF CompTempVarRet552, W
06D7  00BA  	MOVWF gbl_gBcdMonth

	gBcdYear = i2c_read(1); // nack
06D8  3001  	MOVLW 0x01
06D9  00EC  	MOVWF i2c_READ_00000_arg_ack_status
06DA  21B8  	CALL i2c_READ_00000
06DB  086F  	MOVF CompTempVarRet552, W
06DC  00BB  	MOVWF gbl_gBcdYear

	i2c_stop();
06DD  20C4  	CALL i2c_STOP_00000

}
06DE  0008  	RETURN


/*********************************************************************************************
 tm1638ByteWrite(char bWrite)
 Write one byte
*********************************************************************************************/
void tm1638ByteWrite(char bWrite) {

    for (char i = 0; i < 8; i++) {
0180  01F0  	CLRF tm1638Byte_0001E_2_i
0181        label30
0181  3008  	MOVLW 0x08
0182  0270  	SUBWF tm1638Byte_0001E_2_i, W
0183  1803  	BTFSC STATUS,C
0191  0AF0  	INCF tm1638Byte_0001E_2_i, F
0192  2981  	GOTO	label30

        tm1638dio = (bWrite & 0x01);
0185  3001  	MOVLW 0x01
0186  056F  	ANDWF tm1638Byte_0001E_arg_bWrite, W
0187  00F1  	MOVWF CompTempVar553
0188  1871  	BTFSC CompTempVar553,0
0189  1485  	BSF gbl_porta,1
018A  1C71  	BTFSS CompTempVar553,0
018B  1085  	BCF gbl_porta,1

        tm1638clk = 0;
018C  1005  	BCF gbl_porta,0

        bWrite = (bWrite >> 1);
018D  08EF  	MOVF tm1638Byte_0001E_arg_bWrite, F
018E  1003  	BCF STATUS,C
018F  0CEF  	RRF tm1638Byte_0001E_arg_bWrite, F

        tm1638clk = 1;
0190  1405  	BSF gbl_porta,0

    }
}
0184  0008  	RETURN


void bcdTo7Seg(char iBcdIn) {

    char s7SegDisplay = 0;
02F8  01F1  	CLRF bcdTo7Seg_00000_1_s7SegDisplay

    iPrintStartDigit++; // Increment to last digit
02F9  1283  	BCF STATUS, RP0
02FA  1303  	BCF STATUS, RP1
02FB  0AE6  	INCF gbl_iPrintStartDigit, F

    char sDigit = iPrintStartDigit;
02FC  0866  	MOVF gbl_iPrintStartDigit, W
02FD  00F2  	MOVWF bcdTo7Seg_00000_1_sDigit

    // Work backwards
    for (sDigit; sDigit == iPrintStartDigit - 1; sDigit--) {
02FE        label52
02FE  0366  	DECF gbl_iPrintStartDigit, W
02FF  0672  	XORWF bcdTo7Seg_00000_1_sDigit, W
0300  1D03  	BTFSS STATUS,Z
0301  2B1D  	GOTO	label54
031B  03F2  	DECF bcdTo7Seg_00000_1_sDigit, F
031C  2AFE  	GOTO	label52
031D        label54

        s7SegDisplay = tm1638DisplayNumtoSeg[iBcdIn & 0x0F];
0302  085E  	MOVF gbl_tm1638DisplayNumtoSeg, W
0303  00F3  	MOVWF __rom_get_00000_arg_objNumb
0304  300F  	MOVLW 0x0F
0305  0570  	ANDWF bcdTo7Seg_00000_arg_iBcdIn, W
0306  00F4  	MOVWF __rom_get_00000_arg_idx
0307  2024  	CALL __rom_get_00000
0308  00F1  	MOVWF bcdTo7Seg_00000_1_s7SegDisplay

        if (sDigit == iPrintDotDigit)
0309  0867  	MOVF gbl_iPrintDotDigit, W
030A  0672  	XORWF bcdTo7Seg_00000_1_sDigit, W
030B  118A  	BCF PCLATH,3
030C  120A  	BCF PCLATH,4
030D  1D03  	BTFSS STATUS,Z
030E  2B11  	GOTO	label53
0311        label53

            s7SegDisplay += tm1638Dot;
030F  085F  	MOVF gbl_tm1638Dot, W
0310  07F1  	ADDWF bcdTo7Seg_00000_1_s7SegDisplay, F

        tm1638Data[sDigit] = s7SegDisplay;
0311  1383  	BCF	STATUS,IRP
0312  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
0313  0084  	MOVWF FSR
0314  0872  	MOVF bcdTo7Seg_00000_1_sDigit, W
0315  0784  	ADDWF FSR, F
0316  0871  	MOVF bcdTo7Seg_00000_1_s7SegDisplay, W
0317  0080  	MOVWF INDF

        iBcdIn >>= 4;
0318  0EF0  	SWAPF bcdTo7Seg_00000_arg_iBcdIn, F
0319  300F  	MOVLW 0x0F
031A  05F0  	ANDWF bcdTo7Seg_00000_arg_iBcdIn, F

    }
    iPrintStartDigit++; // Increment to next digit
031D  0AE6  	INCF gbl_iPrintStartDigit, F

}
031E  0008  	RETURN



/*********************************************************************************************
 tm1638UpdateDisplay()
 Publish the tm1638Data and tm1638LEDs arrays to the display
*********************************************************************************************/
void tm1638UpdateDisplay() {

    
    // Display current temperature unless set, trigger or alt display mode is active
    if (gcDisplayMode | gcSetMode | gcTriggerMode) {
045A  1283  	BCF STATUS, RP0
045B  1303  	BCF STATUS, RP1
045C  084F  	MOVF gbl_gcSetMode, W
045D  044E  	IORWF gbl_gcDisplayMode, W
045E  00EC  	MOVWF CompTempVar556
045F  0850  	MOVF gbl_gcTriggerMode, W
0460  046C  	IORWF CompTempVar556, W
0461  1903  	BTFSC STATUS,Z
0462  2D6E  	GOTO	label101
056E        label101

        if (gcSetMode == 1) {
0463  034F  	DECF gbl_gcSetMode, W
0464  1D03  	BTFSS STATUS,Z
0465  2C74  	GOTO	label80
0474        label80

            iDigitToFlash = 3;
0466  3003  	MOVLW 0x03
0467  00C8  	MOVWF gbl_iDigitToFlash

            // Display year
            // Start printing from digit 0
            iPrintStartDigit = 0;
0468  01E6  	CLRF gbl_iPrintStartDigit

            iPrintDotDigit = 1;
0469  3001  	MOVLW 0x01
046A  00E7  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(0x20); // Display 20 in digits 0 and 1 (+dot on 1)
046B  3020  	MOVLW 0x20
046C  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
046D  22F8  	CALL bcdTo7Seg_00000

            iPrintDotDigit = 3;
046E  3003  	MOVLW 0x03
046F  00E7  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(gBcdYear); // Display year in digits 2 and 3 (+dot on 3)
0470  083B  	MOVF gbl_gBcdYear, W
0471  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0472  22F8  	CALL bcdTo7Seg_00000

        } else if (gcSetMode == 4) {
0473  2D80  	GOTO	label102
0474  084F  	MOVF gbl_gcSetMode, W
0475  3A04  	XORLW 0x04
0476  1D03  	BTFSS STATUS,Z
0477  2C8A  	GOTO	label81
048A        label81

            iDigitToFlash = 3;
0478  3003  	MOVLW 0x03
0479  00C8  	MOVWF gbl_iDigitToFlash

            // Display day of week
            tm1638Data[0] = 0x5E; // d
047A  305E  	MOVLW 0x5E
047B  00A0  	MOVWF gbl_tm1638Data

            tm1638Data[1] = 0x5F; // a
047C  305F  	MOVLW 0x5F
047D  00A1  	MOVWF gbl_tm1638Data+D'1'

            tm1638Data[2] = 0x6E; // y
047E  306E  	MOVLW 0x6E
047F  00A2  	MOVWF gbl_tm1638Data+D'2'

            tm1638Data[3] = tm1638DisplayNumtoSeg[gDayOfWeek] + tm1638Dot;
0480  085E  	MOVF gbl_tm1638DisplayNumtoSeg, W
0481  00F3  	MOVWF __rom_get_00000_arg_objNumb
0482  0838  	MOVF gbl_gDayOfWeek, W
0483  00F4  	MOVWF __rom_get_00000_arg_idx
0484  2024  	CALL __rom_get_00000
0485  075F  	ADDWF gbl_tm1638Dot, W
0486  00A3  	MOVWF gbl_tm1638Data+D'3'

        } else if (gcTriggerMode) {
0487  118A  	BCF PCLATH,3
0488  120A  	BCF PCLATH,4
0489  2D80  	GOTO	label102
048A  08D0  	MOVF gbl_gcTriggerMode, F
048B  1903  	BTFSC STATUS,Z
048C  2D46  	GOTO	label94
0546        label94

            iPrintDotDigit = 5;
048D  3005  	MOVLW 0x05
048E  00E7  	MOVWF gbl_iPrintDotDigit

            switch (gcTriggerMode) {
04B4  2D80  	GOTO	label102

                case 1:
048F  0850  	MOVF gbl_gcTriggerMode, W
0490  3A01  	XORLW 0x01
0491  1903  	BTFSC STATUS,Z
0492  2CB5  	GOTO	label82
04B5        label82

                    // White LED on hour
                    tm1638Data[0] = 0x38; // L
04B5  3038  	MOVLW 0x38
04B6  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x30; // I
04B7  3030  	MOVLW 0x30
04B8  00A1  	MOVWF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x3f; // O
04B9  303F  	MOVLW 0x3F
04BA  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x54; // n
04BB  3054  	MOVLW 0x54
04BC  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
04BD  3005  	MOVLW 0x05
04BE  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
04BF  3004  	MOVLW 0x04
04C0  00E6  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOnHour); // Display hour in digits 4 and 5 (dot on 5)
04C1  0852  	MOVF gbl_gBcdWhiteOnHour, W
04C2  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
04C3  22F8  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdWhiteOnMinute); // Display minute in digits 6 and 7 (no dot)
04C4  0851  	MOVF gbl_gBcdWhiteOnMinute, W
04C5  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
04C6  22F8  	CALL bcdTo7Seg_00000

                    break;
04C7  2D80  	GOTO	label102

                case 2:
0493  3A03  	XORLW 0x03
0494  1903  	BTFSC STATUS,Z
0495  2CC8  	GOTO	label83
04C8        label83

                    // White LED on minute
                    iDigitToFlash = 7;
04C8  3007  	MOVLW 0x07
04C9  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
04CA  3006  	MOVLW 0x06
04CB  00E6  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOnMinute); // Display minute in digits 6 and 7 (no dot)
04CC  0851  	MOVF gbl_gBcdWhiteOnMinute, W
04CD  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
04CE  22F8  	CALL bcdTo7Seg_00000

                    break;
04CF  2D80  	GOTO	label102

                case 3:
0496  3A01  	XORLW 0x01
0497  1903  	BTFSC STATUS,Z
0498  2CD0  	GOTO	label84
04D0        label84

                    // White LED off hour
                    tm1638Data[3] = 0x71; // F
04D0  3071  	MOVLW 0x71
04D1  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
04D2  3005  	MOVLW 0x05
04D3  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
04D4  3004  	MOVLW 0x04
04D5  00E6  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOffHour); 
04D6  0854  	MOVF gbl_gBcdWhiteOffHour, W
04D7  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
04D8  22F8  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdWhiteOffMinute); // Display minute in digits 6 and 7 (no dot)
04D9  0853  	MOVF gbl_gBcdWhiteOffMinute, W
04DA  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
04DB  22F8  	CALL bcdTo7Seg_00000

                    break;
04DC  2D80  	GOTO	label102

                case 4:
0499  3A07  	XORLW 0x07
049A  1903  	BTFSC STATUS,Z
049B  2CDD  	GOTO	label85
04DD        label85

                    // White LED off minute
                    iDigitToFlash = 7;
04DD  3007  	MOVLW 0x07
04DE  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
04DF  3006  	MOVLW 0x06
04E0  00E6  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOffMinute); // Display minute in digits 6 and 7 (no dot)
04E1  0853  	MOVF gbl_gBcdWhiteOffMinute, W
04E2  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
04E3  22F8  	CALL bcdTo7Seg_00000

                    break;
04E4  2D80  	GOTO	label102

                case 5:
049C  3A01  	XORLW 0x01
049D  1903  	BTFSC STATUS,Z
049E  2CE5  	GOTO	label86
04E5        label86

                    // Blue LED on hour
                    tm1638Data[0] = 0x7C; // b
04E5  307C  	MOVLW 0x7C
04E6  00A0  	MOVWF gbl_tm1638Data

                    //tm1638Data[1] = 0x30; // l
                    //tm1638Data[2] = 0x3f; // O
                    tm1638Data[3] = 0x54; // n
04E7  3054  	MOVLW 0x54
04E8  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
04E9  3005  	MOVLW 0x05
04EA  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
04EB  3004  	MOVLW 0x04
04EC  00E6  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOnHour); // Display hour in digits 4 and 5 (dot on 5)
04ED  0856  	MOVF gbl_gBcdBlueOnHour, W
04EE  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
04EF  22F8  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlueOnMinute); // Display minute in digits 6 and 7 (no dot)
04F0  0855  	MOVF gbl_gBcdBlueOnMinute, W
04F1  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
04F2  22F8  	CALL bcdTo7Seg_00000

                    break;
04F3  2D80  	GOTO	label102

                case 6:
049F  3A03  	XORLW 0x03
04A0  1903  	BTFSC STATUS,Z
04A1  2CF4  	GOTO	label87
04F4        label87

                    // Blue LED on minute
                    iDigitToFlash = 7;
04F4  3007  	MOVLW 0x07
04F5  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
04F6  3006  	MOVLW 0x06
04F7  00E6  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOnMinute); // Display minute in digits 6 and 7 (no dot)
04F8  0855  	MOVF gbl_gBcdBlueOnMinute, W
04F9  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
04FA  22F8  	CALL bcdTo7Seg_00000

                    break;
04FB  2D80  	GOTO	label102

                case 7:
04A2  3A01  	XORLW 0x01
04A3  1903  	BTFSC STATUS,Z
04A4  2CFC  	GOTO	label88
04FC        label88

                    // Blue LED off hour
                    tm1638Data[3] = 0x71; // F
04FC  3071  	MOVLW 0x71
04FD  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
04FE  3005  	MOVLW 0x05
04FF  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
0500  3004  	MOVLW 0x04
0501  00E6  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOffHour); // Display hour in digits 4 and 5 (dot on 5)
0502  0858  	MOVF gbl_gBcdBlueOffHour, W
0503  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0504  22F8  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlueOffMinute); // Display minute in digits 6 and 7 (no dot)
0505  0857  	MOVF gbl_gBcdBlueOffMinute, W
0506  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0507  22F8  	CALL bcdTo7Seg_00000

                    break;
0508  2D80  	GOTO	label102

                case 8:
04A5  3A0F  	XORLW 0x0F
04A6  1903  	BTFSC STATUS,Z
04A7  2D09  	GOTO	label89
0509        label89

                    // Blue LED off minute
                    iDigitToFlash = 7;
0509  3007  	MOVLW 0x07
050A  00C8  	MOVWF gbl_iDigitToFlash

                    bcdTo7Seg(gBcdBlueOffMinute); // Display minute in digits 6 and 7 (no dot)
050B  0857  	MOVF gbl_gBcdBlueOffMinute, W
050C  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
050D  22F8  	CALL bcdTo7Seg_00000

                    break;
050E  2D80  	GOTO	label102

                case 9:
04A8  3A01  	XORLW 0x01
04A9  1903  	BTFSC STATUS,Z
04AA  2D0F  	GOTO	label90
050F        label90

                    // Fan on temperature
                    tm1638Data[0] = 0x38; // F
050F  3038  	MOVLW 0x38
0510  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x30; // a
0511  3030  	MOVLW 0x30
0512  00A1  	MOVWF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x54; // n
0513  3054  	MOVLW 0x54
0514  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x00; // 
0515  01A3  	CLRF gbl_tm1638Data+D'3'

                    tm1638Data[4] = 0x3f; // O
0516  303F  	MOVLW 0x3F
0517  00A4  	MOVWF gbl_tm1638Data+D'4'

                    tm1638Data[5] = 0x54; // n
0518  3054  	MOVLW 0x54
0519  00A5  	MOVWF gbl_tm1638Data+D'5'

                    iDigitToFlash = 7;
051A  3007  	MOVLW 0x07
051B  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
051C  3006  	MOVLW 0x06
051D  00E6  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdFanOnTemp); // Display celcius in digits 6 and 7 (no dot)
051E  0859  	MOVF gbl_gBcdFanOnTemp, W
051F  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0520  22F8  	CALL bcdTo7Seg_00000

                    break;
0521  2D80  	GOTO	label102

                case 10:
04AB  3A03  	XORLW 0x03
04AC  1903  	BTFSC STATUS,Z
04AD  2D22  	GOTO	label91
0522        label91

                    // Fan off temperature
                    tm1638Data[5] = 0x71; // f
0522  3071  	MOVLW 0x71
0523  00A5  	MOVWF gbl_tm1638Data+D'5'

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0524  3006  	MOVLW 0x06
0525  00E6  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdFanOffTemp); // Display celcius in digits 6 and 7 (no dot)
0526  085A  	MOVF gbl_gBcdFanOffTemp, W
0527  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0528  22F8  	CALL bcdTo7Seg_00000

                    break;
0529  2D80  	GOTO	label102

                case 11:
04AE  3A01  	XORLW 0x01
04AF  1903  	BTFSC STATUS,Z
04B0  2D2A  	GOTO	label92
052A        label92

                    // Heater on temperature
                    tm1638Data[0] = 0x38; // H
052A  3038  	MOVLW 0x38
052B  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x7B; // e
052C  307B  	MOVLW 0x7B
052D  00A1  	MOVWF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x30; // a
052E  3030  	MOVLW 0x30
052F  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x78; // t
0530  3078  	MOVLW 0x78
0531  00A3  	MOVWF gbl_tm1638Data+D'3'

                    tm1638Data[4] = 0x3f; // O
0532  303F  	MOVLW 0x3F
0533  00A4  	MOVWF gbl_tm1638Data+D'4'

                    tm1638Data[5] = 0x54; // n
0534  3054  	MOVLW 0x54
0535  00A5  	MOVWF gbl_tm1638Data+D'5'

                    iDigitToFlash = 7;
0536  3007  	MOVLW 0x07
0537  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0538  3006  	MOVLW 0x06
0539  00E6  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdHeaterOnTemp); // Display celcius in digits 6 and 7 (no dot)
053A  085B  	MOVF gbl_gBcdHeaterOnTemp, W
053B  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
053C  22F8  	CALL bcdTo7Seg_00000

                    break;
053D  2D80  	GOTO	label102

                case 12:
04B1  3A07  	XORLW 0x07
04B2  1903  	BTFSC STATUS,Z
04B3  2D3E  	GOTO	label93
053E        label93

                    // Heater off temperature
                    tm1638Data[5] = 0x71; // f
053E  3071  	MOVLW 0x71
053F  00A5  	MOVWF gbl_tm1638Data+D'5'

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0540  3006  	MOVLW 0x06
0541  00E6  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdHeaterOffTemp); // Display celcius in digits 6 and 7 (no dot)
0542  085C  	MOVF gbl_gBcdHeaterOffTemp, W
0543  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0544  22F8  	CALL bcdTo7Seg_00000

                    break;
            }
        } else {
0545  2D80  	GOTO	label102

            switch (gcSetMode) {
0562        label100

                case 2:
0546  084F  	MOVF gbl_gcSetMode, W
0547  3A02  	XORLW 0x02
0548  1903  	BTFSC STATUS,Z
0549  2D54  	GOTO	label95
0554        label95

                    iDigitToFlash = 3;
0554  3003  	MOVLW 0x03
0555  00C8  	MOVWF gbl_iDigitToFlash

                    break;
0556  2D62  	GOTO	label100

                case 3:
054A  3A01  	XORLW 0x01
054B  1903  	BTFSC STATUS,Z
054C  2D57  	GOTO	label96
0557        label96

                    iDigitToFlash = 1;
0557  3001  	MOVLW 0x01
0558  00C8  	MOVWF gbl_iDigitToFlash

                    break;
0559  2D62  	GOTO	label100

                case 5:
054D  3A06  	XORLW 0x06
054E  1903  	BTFSC STATUS,Z
054F  2D5A  	GOTO	label97
055A        label97

                    iDigitToFlash = 5;
055A  3005  	MOVLW 0x05
055B  00C8  	MOVWF gbl_iDigitToFlash

                    break;
055C  2D62  	GOTO	label100

                case 6:
0550  3A03  	XORLW 0x03
0551  1903  	BTFSC STATUS,Z
0552  2D5D  	GOTO	label98
055D        label98

                    iDigitToFlash = 7;
055D  3007  	MOVLW 0x07
055E  00C8  	MOVWF gbl_iDigitToFlash

                    break;
055F  2D62  	GOTO	label100

                default:
0553  2D60  	GOTO	label99
0560        label99

                    iDigitToFlash = 8;
0560  3008  	MOVLW 0x08
0561  00C8  	MOVWF gbl_iDigitToFlash

            }
            // Display date DD.MM
            iPrintStartDigit = 0;
0562  01E6  	CLRF gbl_iPrintStartDigit

            iPrintDotDigit = 1;
0563  3001  	MOVLW 0x01
0564  00E7  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(gBcdDayOfMonth); // Display day of month in digits 0 and 1 (+dot on 1)
0565  0839  	MOVF gbl_gBcdDayOfMonth, W
0566  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0567  22F8  	CALL bcdTo7Seg_00000

            iPrintDotDigit = 3;
0568  3003  	MOVLW 0x03
0569  00E7  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(gBcdMonth); // Display month in digits 2 and 3 (+dot on 3)
056A  083A  	MOVF gbl_gBcdMonth, W
056B  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
056C  22F8  	CALL bcdTo7Seg_00000

        }
    } else {
056D  2D80  	GOTO	label102

        // translate DS3231 temperature to digit values
        iPrintDotDigit = 1;
056E  3001  	MOVLW 0x01
056F  00E7  	MOVWF gbl_iPrintDotDigit

        /*
        No support for -10 or below - aquarium should never get that cold!
        if (gbDS3231IsMinus && (giDS3231ValueBCD & 0xF000)) {
            // If minus and value less than or equal -10 (checked as >1000), shift the digits right
            giDS3231ValueBCD >>= 4;
            iPrintDotDigit = 2;
        }*/
        // Display current temperature in digits 0 to 3 (+dot on 1, or 2 if <=-10)
        iPrintStartDigit = 0;
0570  01E6  	CLRF gbl_iPrintStartDigit

        bcdTo7Seg(giDS3231ValueBCD);
0571  0833  	MOVF gbl_giDS3231ValueBCD, W
0572  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0573  22F8  	CALL bcdTo7Seg_00000

        bcdTo7Seg(giDS3231ValueBCD >> 8);
0574  0834  	MOVF gbl_giDS3231ValueBCD+D'1', W
0575  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0576  22F8  	CALL bcdTo7Seg_00000


        // left fill zeroes with blanks up to the digit before the decimal place
        if (tm1638Data[0] == 0x3f)
0577  0820  	MOVF gbl_tm1638Data, W
0578  3A3F  	XORLW 0x3F
0579  1903  	BTFSC STATUS,Z

            tm1638Data[0] = 0;
057A  01A0  	CLRF gbl_tm1638Data

        // If minus, overwrite left most digit with minus sign
        if (gbDS3231IsMinus)
057B  08CB  	MOVF gbl_gbDS3231IsMinus, F
057C  1903  	BTFSC STATUS,Z
057D  2D80  	GOTO	label102
0580        label102

            tm1638Data[0] = 0x40;
057E  3040  	MOVLW 0x40
057F  00A0  	MOVWF gbl_tm1638Data

    }

    // HH.MM in last 4 digits of TM1638
    if (!gcTriggerMode) {
0580  08D0  	MOVF gbl_gcTriggerMode, F
0581  1D03  	BTFSS STATUS,Z
0582  2D8D  	GOTO	label103
058D        label103

        iPrintStartDigit = 4;
0583  3004  	MOVLW 0x04
0584  00E6  	MOVWF gbl_iPrintStartDigit

        iPrintDotDigit = 5;
0585  3005  	MOVLW 0x05
0586  00E7  	MOVWF gbl_iPrintDotDigit

        bcdTo7Seg(gBcdHour); // Display hour in digits 4 and 5 (dot on 5)
0587  0837  	MOVF gbl_gBcdHour, W
0588  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0589  22F8  	CALL bcdTo7Seg_00000

        bcdTo7Seg(gBcdMinute); // Display minute in digits 6 and 7 (no dot)
058A  0836  	MOVF gbl_gBcdMinute, W
058B  00F0  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
058C  22F8  	CALL bcdTo7Seg_00000

    }

    // Light LED for set mode
    char cCompareSetMode = gcSetMode + 2;
058D  3002  	MOVLW 0x02
058E  074F  	ADDWF gbl_gcSetMode, W
058F  00ED  	MOVWF tm1638Upda_0001F_1_cCompar_00020

    for (char i = 2; i < 8; i++) {
0590  3002  	MOVLW 0x02
0591  00EF  	MOVWF tm1638Upda_0001F_3_i
0592        label104
0592  3008  	MOVLW 0x08
0593  026F  	SUBWF tm1638Upda_0001F_3_i, W
0594  1803  	BTFSC STATUS,C
0595  2DAB  	GOTO	label107
05A9  0AEF  	INCF tm1638Upda_0001F_3_i, F
05AA  2D92  	GOTO	label104
05AB        label107

        if (i == cCompareSetMode)
0596  086D  	MOVF tm1638Upda_0001F_1_cCompar_00020, W
0597  066F  	XORWF tm1638Upda_0001F_3_i, W
0598  1D03  	BTFSS STATUS,Z
0599  2DA2  	GOTO	label105
05A2        label105

            tm1638LEDs[i] = 1;
059A  1383  	BCF	STATUS,IRP
059B  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
059C  0084  	MOVWF FSR
059D  086F  	MOVF tm1638Upda_0001F_3_i, W
059E  0784  	ADDWF FSR, F
059F  3001  	MOVLW 0x01
05A0  0080  	MOVWF INDF

        else
05A1  2DA9  	GOTO	label106
05A9        label106

            tm1638LEDs[i] = 0;
05A2  1383  	BCF	STATUS,IRP
05A3  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
05A4  0084  	MOVWF FSR
05A5  086F  	MOVF tm1638Upda_0001F_3_i, W
05A6  0784  	ADDWF FSR, F
05A7  3000  	MOVLW 0x00
05A8  0080  	MOVWF INDF

    }
    tm1638LEDs[0] = HEATER;
05AB  01A8  	CLRF gbl_tm1638LEDs
05AC  1906  	BTFSC gbl_portb,2
05AD  0AA8  	INCF gbl_tm1638LEDs, F

    tm1638LEDs[1] = FAN;
05AE  01A9  	CLRF gbl_tm1638LEDs+D'1'
05AF  1986  	BTFSC gbl_portb,3
05B0  0AA9  	INCF gbl_tm1638LEDs+D'1', F


    // Write 0x40 [01000000] to indicate command to display data - [Write data to display register]
    tm1638strobe = 0;
05B1  1385  	BCF gbl_porta,7

    tm1638ByteWrite(tm1638ByteSetData);
05B2  0861  	MOVF gbl_tm1638ByteSetData, W
05B3  00EF  	MOVWF tm1638Byte_0001E_arg_bWrite
05B4  2180  	CALL tm1638Byte_0001E

    tm1638strobe = 1;
05B5  1785  	BSF gbl_porta,7

    
    tm1638strobe = 0;
05B6  1385  	BCF gbl_porta,7

    // Specify the display address 0xC0 [11000000] then write out all 8 bytes
    tm1638ByteWrite(tm1638ByteSetAddr);
05B7  0863  	MOVF gbl_tm1638ByteSetAddr, W
05B8  00EF  	MOVWF tm1638Byte_0001E_arg_bWrite
05B9  2180  	CALL tm1638Byte_0001E

    for (char i = 0; i < tm1638MaxDigits; i++) {
05BA  01EE  	CLRF tm1638Upda_0001F_2_i
05BB        label108
05BB  085D  	MOVF gbl_tm1638MaxDigits, W
05BC  026E  	SUBWF tm1638Upda_0001F_2_i, W
05BD  1803  	BTFSC STATUS,C
05BE  2DDA  	GOTO	label111
05D8  0AEE  	INCF tm1638Upda_0001F_2_i, F
05D9  2DBB  	GOTO	label108
05DA        label111

        if (iFlashDigitOff.0 && (i == iDigitToFlash))
05BF  1C3F  	BTFSS gbl_iFlashDigitOff,0
05C0  2DC8  	GOTO	label109
05C1  0848  	MOVF gbl_iDigitToFlash, W
05C2  066E  	XORWF tm1638Upda_0001F_2_i, W
05C3  1D03  	BTFSS STATUS,Z
05C4  2DC8  	GOTO	label109
05C8        label109

            tm1638ByteWrite(0);
05C5  01EF  	CLRF tm1638Byte_0001E_arg_bWrite
05C6  2180  	CALL tm1638Byte_0001E

        else
05C7  2DD0  	GOTO	label110
05D0        label110

            tm1638ByteWrite(tm1638Data[i]);
05C8  1383  	BCF	STATUS,IRP
05C9  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
05CA  0084  	MOVWF FSR
05CB  086E  	MOVF tm1638Upda_0001F_2_i, W
05CC  0784  	ADDWF FSR, F
05CD  0800  	MOVF INDF, W
05CE  00EF  	MOVWF tm1638Byte_0001E_arg_bWrite
05CF  2180  	CALL tm1638Byte_0001E

        tm1638ByteWrite(tm1638LEDs[i]);
05D0  1383  	BCF	STATUS,IRP
05D1  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
05D2  0084  	MOVWF FSR
05D3  086E  	MOVF tm1638Upda_0001F_2_i, W
05D4  0784  	ADDWF FSR, F
05D5  0800  	MOVF INDF, W
05D6  00EF  	MOVWF tm1638Byte_0001E_arg_bWrite
05D7  2180  	CALL tm1638Byte_0001E

    }
    tm1638strobe = 1;
05DA  1785  	BSF gbl_porta,7

}
05DB  0008  	RETURN


/*********************************************************************************************
 tm1638ReadKeys()
 Reads the keys status into tm1638Keys
*********************************************************************************************/
void tm1638ReadKeys() {

    // Write 0x42 [01000010] to indicate command to read data
    tm1638strobe = 0;
05DC  1283  	BCF STATUS, RP0
05DD  1303  	BCF STATUS, RP1
05DE  1385  	BCF gbl_porta,7

    tm1638ByteWrite(tm1638ByteReadData);
05DF  0862  	MOVF gbl_tm1638ByteReadData, W
05E0  00EF  	MOVWF tm1638Byte_0001E_arg_bWrite
05E1  2180  	CALL tm1638Byte_0001E

    
    tm1638dioTris = 1; // Set data pin to input
05E2  1683  	BSF STATUS, RP0
05E3  1485  	BSF gbl_trisa,1

    char tm1638KeysTemp = 32;
05E4  3020  	MOVLW 0x20
05E5  1283  	BCF STATUS, RP0
05E6  00EB  	MOVWF tm1638Read_00021_1_tm1638K_00022

    // Read 4 bytes
    for (char i = 0; i < 32; i++) {
05E7  01EC  	CLRF tm1638Read_00021_2_i
05E8        label112
05E8  3020  	MOVLW 0x20
05E9  026C  	SUBWF tm1638Read_00021_2_i, W
05EA  1803  	BTFSC STATUS,C
05EB  2DF9  	GOTO	label114
05F7  0AEC  	INCF tm1638Read_00021_2_i, F
05F8  2DE8  	GOTO	label112
05F9        label114

        tm1638KeysTemp--;
05EC  03EB  	DECF tm1638Read_00021_1_tm1638K_00022, F

        tm1638clk = 0;
05ED  1005  	BCF gbl_porta,0

        delay_us(1);
05EE  3001  	MOVLW 0x01
05EF  00F0  	MOVWF delay_us_00000_arg_del
05F0  2010  	CALL delay_us_00000

        if(tm1638dio)
05F1  1C85  	BTFSS gbl_porta,1
05F2  2DF6  	GOTO	label113
05F6        label113

            tm1638KeysTemp = (tm1638KeysTemp << 1);
05F3  08EB  	MOVF tm1638Read_00021_1_tm1638K_00022, F
05F4  1003  	BCF STATUS,C
05F5  0DEB  	RLF tm1638Read_00021_1_tm1638K_00022, F

        tm1638clk = 1;
05F6  1405  	BSF gbl_porta,0

    }
    tm1638dioTris = 0; // Set data pin to output
05F9  1683  	BSF STATUS, RP0
05FA  1085  	BCF gbl_trisa,1

    tm1638strobe = 1;
05FB  1283  	BCF STATUS, RP0
05FC  1785  	BSF gbl_porta,7


    tm1638Keys = tm1638KeysTemp;
05FD  086B  	MOVF tm1638Read_00021_1_tm1638K_00022, W
05FE  00E5  	MOVWF gbl_tm1638Keys

}
05FF  0008  	RETURN


/*********************************************************************************************
  Function called once only to initialise variables and
  setup the PIC registers
*********************************************************************************************/
void initialise() {

    pcon.OSCF = 1; // 4MHz internal osc
0689  1683  	BSF STATUS, RP0
068A  1303  	BCF STATUS, RP1
068B  158E  	BSF gbl_pcon,3


    // Configure port A
    /*
    RA7     OUT TM1638 STB
    RA6     IN/OUT DS18B20
    RA5     
    RA4     ICSP VPP
    RA3     IN/OUT DS3231M I2C SDA
    RA2     IN/OUT DS3231M I2C CLK
    RA1     IN/OUT TM1638 DIO
    RA0     OUT TM1638 CLK
    */
    trisa = 0x0C;
068C  300C  	MOVLW 0x0C
068D  0085  	MOVWF gbl_trisa

    porta = 0x00; // 
068E  1283  	BCF STATUS, RP0
068F  0185  	CLRF gbl_porta

    
    // Configure port B
    /*      
    RB7     ICSP PGD
    RB6     IN SQW DS3231M + ICSP PGC
    RB5     OUT WHITE LIGHT PWM
    RB4     OUT BLUE LIGHT PWM
    RB3     OUT FANS
    RB2     OUT HEATER
    RB1     
    RB0     
    */
    trisb = 0x00; // all outputs
0690  1683  	BSF STATUS, RP0
0691  0186  	CLRF gbl_trisb

    portb = 0x00; // all off by default
0692  1283  	BCF STATUS, RP0
0693  0186  	CLRF gbl_portb


    option_reg = 0;
0694  1683  	BSF STATUS, RP0
0695  0181  	CLRF gbl_option_reg

    option_reg.NOT_RBPU = 1; // disable port b pull ups
0696  1781  	BSF gbl_option_reg,7


    // ADC setup
    cmcon = 7; // disable all comparators so port a is usable as digital io
0697  3007  	MOVLW 0x07
0698  1283  	BCF STATUS, RP0
0699  009F  	MOVWF gbl_cmcon



    // Setup timer 0, used for PWM
    // https://labprojectsbd.com/2021/03/31/pwm-pulse-generation-using-pic12f675-micro-controller/
    // Timer calculator: http://eng-serve.com/pic/pic_timer.html
    // Timer0 Registers Prescaler= 16 - TMR0 Preset = 0 - Freq = 244.14 Hz - Period = 0.004096 seconds
    //option_reg.T0CS = 0; // bit 5  TMR0 Clock Source Select bit...0 = Internal Clock (CLKO) 1 = Transition on T0CKI pin
    //option_reg.T0SE = 0; // bit 4 TMR0 Source Edge Select bit 0 = low/high 1 = high/low
    //option_reg.PSA = 0; // bit 3  Prescaler Assignment bit...0 = Prescaler is assigned to the Timer0
    //option_reg.PS2 = 0; // bits 2-0  PS2:PS0: Prescaler Rate Select bits
    /*option_reg.PS1 = 1;
    option_reg.PS0 = 1;
    tmr0 = 0; // preset for timer register
    intcon.T0IF = 0; // Clear timer 1 interrupt flag bit
    intcon.T0IE = 1; // Timer 1 interrupt enabled*/

    // Setup timer 1, used to update clock display and periodically ask for a temperature reading
    // Timer 1 setup - interrupt on DS3231 SQW 1Hz
    // Timer1 Registers Prescaler= 1 - TMR1 Preset = 65535 - Freq = 1 Hz
    // Bits 5-4 T1CKPS1:T1CKPS0 = 00: Prescaler Rate Select bits, 00 = 1:1 prescaler
    // Bit 3 T1OSCEN = 0: Timer1 LP Oscillator Enable Control bit, 0 = off
    // Bit 2 NOT_T1SYNC = 1: Timer1 External Clock Input Synchronization Control bit, 1 = Do not synchronize external clock input
    // Bit 1 TMR1CS = 1: Timer1 Clock Source Select bit, 1 = External clock from T1OSO/T1CKI pin (on the rising edge)
    // Bit 0 TMR1ON = 0: Timer1 On Bit, 0 = off
    t1con = 0b00000110;
069A  3006  	MOVLW 0x06
069B  0090  	MOVWF gbl_t1con

    tmr1h = TMR1HV;      // preset for timer1 MSB register
069C  30FF  	MOVLW 0xFF
069D  008F  	MOVWF gbl_tmr1h

    tmr1l = TMR1LV;      // preset for timer1 LSB register
069E  008E  	MOVWF gbl_tmr1l

    pie1.TMR1IE = 1;     // Timer 1 interrupt
069F  1683  	BSF STATUS, RP0
06A0  140C  	BSF gbl_pie1,0

    
    // Setup timer 2, used for flashing display
    // Timer calculator: http://eng-serve.com/pic/pic_timer.html
    //Timer2 Registers Prescaler= 16 - TMR2 PostScaler = 16 - PR2 = 195 - Freq = 20.03 Hz - Period = 0.049920 seconds
    t2con |= 120; // bits 6-3 Post scaler 1:1 thru 1:16
06A1  3078  	MOVLW 0x78
06A2  1283  	BCF STATUS, RP0
06A3  0492  	IORWF gbl_t2con, F

    t2con.TMR2ON = 1; // bit 2 turn timer2 on;
06A4  1512  	BSF gbl_t2con,2

    t2con.T2CKPS1 = 1; // bits 1-0  Prescaler Rate Select bits
06A5  1492  	BSF gbl_t2con,1

    //t2con.T2CKPS0 = 0;
    pr2 = 195; // PR2 (Timer2 Match value)
06A6  30C3  	MOVLW 0xC3
06A7  1683  	BSF STATUS, RP0
06A8  0092  	MOVWF gbl_pr2


    // No task at initialisation
    cTask = 0;
06A9  1283  	BCF STATUS, RP0
06AA  01CC  	CLRF gbl_cTask

    
    // Enable interrupts
    intcon.GIE = 1;
06AB  178B  	BSF gbl_intcon,7

    intcon.PEIE = 1;
06AC  170B  	BSF gbl_intcon,6


    // Read in variables from EEPROM
    eepromReadAll(); 
06AD  221D  	CALL eepromRead_00019


	i2c_init(1); 
06AE  3001  	MOVLW 0x01
06AF  00EB  	MOVWF i2c_INIT_00000_arg_i2c_divisor
06B0  220A  	CALL i2c_INIT_00000

	ds3231Init();
06B1  2285  	CALL ds3231Init_00000

	ds3231WriteDateTime();
06B2  2262  	CALL ds3231Writ_0001C

	ds3231Start();
06B3  227E  	CALL ds3231Star_0001B

}
06B4  0008  	RETURN



/*********************************************************************************************
  interrupt()
  Interrupt handler
*********************************************************************************************/
void interrupt() {

    // Handle timer1 interrupt - delay counter from DS3231
    if (pir1.TMR1IF) {
07D8  1283  	BCF STATUS, RP0
07D9  1303  	BCF STATUS, RP1
07DA  1C0C  	BTFSS gbl_pir1,0
07DB  2FE1  	GOTO	label138
07E1        label138

        tmr1h = TMR1HV;      // preset for timer1 MSB register
07DC  30FF  	MOVLW 0xFF
07DD  008F  	MOVWF gbl_tmr1h

        tmr1l = TMR1LV;      // preset for timer1 LSB register
07DE  008E  	MOVWF gbl_tmr1l


        pir1.TMR1IF = 0;     // Clear interrupt flag
07DF  100C  	BCF gbl_pir1,0

        cTask.TASK_TIMER1 = 1;
07E0  154C  	BSF gbl_cTask,2

    }
    
    // Interrupt on timer2 - flash digit delay
    if (pir1.TMR2IF) {
07E1  1C8C  	BTFSS gbl_pir1,1
07E2  2FEC  	GOTO	label140
07EC        label140

        iTimer2Counts++;
07E3  0ABE  	INCF gbl_iTimer2Counts, F

        if (iTimer2Counts > 9) {
07E4  083E  	MOVF gbl_iTimer2Counts, W
07E5  3C09  	SUBLW 0x09
07E6  1803  	BTFSC STATUS,C
07E7  2FEB  	GOTO	label139
07EB        label139

            iFlashDigitOff++;
07E8  0ABF  	INCF gbl_iFlashDigitOff, F

            iTimer2Counts = 0;
07E9  01BE  	CLRF gbl_iTimer2Counts

            cTask.TASK_TIMER2 = 1;
07EA  16CC  	BSF gbl_cTask,5

        }
        // Clear interrupt flag
        pir1.TMR2IF = 0; 
07EB  108C  	BCF gbl_pir1,1

    }
}
07EC  0E32  	SWAPF Int1BContext+D'2', W
07ED  0084  	MOVWF FSR
07EE  0E31  	SWAPF Int1BContext+D'1', W
07EF  008A  	MOVWF PCLATH
07F0  0E30  	SWAPF Int1BContext, W
07F1  0083  	MOVWF STATUS
07F2  0EFF  	SWAPF Int1Context, F
07F3  0E7F  	SWAPF Int1Context, W
07F4  0009  	RETFIE


int binToBcd(int iBin) {

    int iBcd = 0; // 16-bit BCD value - only supporting up to 9999
0292  01F4  	CLRF binToBcd_00000_1_iBcd
0293  01F5  	CLRF binToBcd_00000_1_iBcd+D'1'

    int iTest = 32768; // Start testing from MSB
0294  01F6  	CLRF binToBcd_00000_1_iTest
0295  3080  	MOVLW 0x80
0296  00F7  	MOVWF binToBcd_00000_1_iTest+D'1'

    // Loop through the 16 bits in the two bytes
    for (char i = 0; i < 16; i++) {
0297  01F8  	CLRF binToBcd_00000_2_i
0298        label42
0298  3010  	MOVLW 0x10
0299  0278  	SUBWF binToBcd_00000_2_i, W
029A  1803  	BTFSC STATUS,C
029B  2AF3  	GOTO	label51
02F1  0AF8  	INCF binToBcd_00000_2_i, F
02F2  2A98  	GOTO	label42
02F3        label51

        // Shift one
        iBcd <<= 1;
029C  1003  	BCF STATUS,C
029D  0DF4  	RLF binToBcd_00000_1_iBcd, F
029E  0DF5  	RLF binToBcd_00000_1_iBcd+D'1', F

        // If the bit is set, add one
        if (iBin & iTest)
029F  0876  	MOVF binToBcd_00000_1_iTest, W
02A0  0572  	ANDWF binToBcd_00000_arg_iBin, W
02A1  1D03  	BTFSS STATUS,Z
02A2  2AA7  	GOTO	label43
02A3  0877  	MOVF binToBcd_00000_1_iTest+D'1', W
02A4  0573  	ANDWF binToBcd_00000_arg_iBin+D'1', W
02A5  1903  	BTFSC STATUS,Z
02A6  2AAA  	GOTO	label44
02A7        label43

            iBcd++;
02A7  0AF4  	INCF binToBcd_00000_1_iBcd, F
02A8  1903  	BTFSC STATUS,Z
02A9  0AF5  	INCF binToBcd_00000_1_iBcd+D'1', F
02AA        label44

        
        // Add 3 to any BCD column 5 or greater
        if ((iBcd & 0x0F) > 0x04)
02AA  300F  	MOVLW 0x0F
02AB  0574  	ANDWF binToBcd_00000_1_iBcd, W
02AC  00F9  	MOVWF CompTempVar598
02AD  01FA  	CLRF CompTempVar599
02AE  0879  	MOVF CompTempVar598, W
02AF  3C04  	SUBLW 0x04
02B0  087A  	MOVF CompTempVar599, W
02B1  1803  	BTFSC STATUS,C
02B2  1D03  	BTFSS STATUS,Z
02B3  1BFA  	BTFSC CompTempVar599,7
02B4  2AB9  	GOTO	label45

            iBcd += 3;
02B5  3003  	MOVLW 0x03
02B6  07F4  	ADDWF binToBcd_00000_1_iBcd, F
02B7  1803  	BTFSC STATUS,C
02B8  0AF5  	INCF binToBcd_00000_1_iBcd+D'1', F
02B9        label45

        if ((iBcd & 0xF0) > 0x49)
02B9  30F0  	MOVLW 0xF0
02BA  0574  	ANDWF binToBcd_00000_1_iBcd, W
02BB  00FB  	MOVWF CompTempVar600
02BC  01FC  	CLRF CompTempVar601
02BD  087B  	MOVF CompTempVar600, W
02BE  3C49  	SUBLW 0x49
02BF  087C  	MOVF CompTempVar601, W
02C0  1803  	BTFSC STATUS,C
02C1  1D03  	BTFSS STATUS,Z
02C2  1BFC  	BTFSC CompTempVar601,7
02C3  2AC8  	GOTO	label46

            iBcd += 0x30;
02C4  3030  	MOVLW 0x30
02C5  07F4  	ADDWF binToBcd_00000_1_iBcd, F
02C6  1803  	BTFSC STATUS,C
02C7  0AF5  	INCF binToBcd_00000_1_iBcd+D'1', F
02C8        label46

        if ((iBcd & 0xF00) > 0x499)
02C8  3000  	MOVLW 0x00
02C9  0574  	ANDWF binToBcd_00000_1_iBcd, W
02CA  00FD  	MOVWF CompTempVar602
02CB  0875  	MOVF binToBcd_00000_1_iBcd+D'1', W
02CC  390F  	ANDLW 0x0F
02CD  00FE  	MOVWF CompTempVar603
02CE  087E  	MOVF CompTempVar603, W
02CF  3C04  	SUBLW 0x04
02D0  1D03  	BTFSS STATUS,Z
02D1  2AD4  	GOTO	label47
02D2  087D  	MOVF CompTempVar602, W
02D3  3C99  	SUBLW 0x99
02D4        label47
02D4  1803  	BTFSC STATUS,C
02D5  2ADA  	GOTO	label48
02D6  1BFE  	BTFSC CompTempVar603,7
02D7  2ADA  	GOTO	label48
02DA        label48

            iBcd += 0x300;
02D8  3003  	MOVLW 0x03
02D9  07F5  	ADDWF binToBcd_00000_1_iBcd+D'1', F

        if ((iBcd & 0xF000) > 0x4999)
02DA  3000  	MOVLW 0x00
02DB  0574  	ANDWF binToBcd_00000_1_iBcd, W
02DC  1683  	BSF STATUS, RP0
02DD  1303  	BCF STATUS, RP1
02DE  00A0  	MOVWF CompTempVar604
02DF  0875  	MOVF binToBcd_00000_1_iBcd+D'1', W
02E0  39F0  	ANDLW 0xF0
02E1  00A1  	MOVWF CompTempVar605
02E2  0821  	MOVF CompTempVar605, W
02E3  3C49  	SUBLW 0x49
02E4  1D03  	BTFSS STATUS,Z
02E5  2AE8  	GOTO	label49
02E6  0820  	MOVF CompTempVar604, W
02E7  3C99  	SUBLW 0x99
02E8        label49
02E8  1803  	BTFSC STATUS,C
02E9  2AEE  	GOTO	label50
02EA  1BA1  	BTFSC CompTempVar605,7
02EB  2AEE  	GOTO	label50
02EE        label50

            iBcd += 0x3000;
02EC  3030  	MOVLW 0x30
02ED  07F5  	ADDWF binToBcd_00000_1_iBcd+D'1', F

        
        // move the test bit
        iTest >>= 1;
02EE  0D77  	RLF binToBcd_00000_1_iTest+D'1', W
02EF  0CF7  	RRF binToBcd_00000_1_iTest+D'1', F
02F0  0CF6  	RRF binToBcd_00000_1_iTest, F

    }

    return iBcd;
02F3  0874  	MOVF binToBcd_00000_1_iBcd, W
02F4  00F8  	MOVWF CompTempVarRet597
02F5  0875  	MOVF binToBcd_00000_1_iBcd+D'1', W
02F6  00F9  	MOVWF CompTempVarRet597+D'1'

}
02F7  0008  	RETURN



/*********************************************************************************************
  displayTemp()
  Used to split the 16 bit integer returned from the ds18b20 into parts for display
  cTempH - upper 8 bits
  cTempL - lower 8 bits
*********************************************************************************************/
void convertTemp() {

    // convert both bytes to a 16bit int - e.g. 0000 0001 0100 0110 (1 and 70, gives 326)
    
    signed int iTemp = (cTempH << 8) | cTempL;
06DF  1283  	BCF STATUS, RP0
06E0  1303  	BCF STATUS, RP1
06E1  01EC  	CLRF convertTem_00026_1_iTemp
06E2  0849  	MOVF gbl_cTempH, W
06E3  00ED  	MOVWF convertTem_00026_1_iTemp+D'1'
06E4  084A  	MOVF gbl_cTempL, W
06E5  04EC  	IORWF convertTem_00026_1_iTemp, F

    
    // Celcius
    gbDS3231IsMinus = (iTemp < 0);
06E6  01CB  	CLRF gbl_gbDS3231IsMinus
06E7  1BED  	BTFSC convertTem_00026_1_iTemp+D'1',7
06E8  0ACB  	INCF gbl_gbDS3231IsMinus, F

    if (gbDS3231IsMinus) {
06E9  08CB  	MOVF gbl_gbDS3231IsMinus, F
06EA  1903  	BTFSC STATUS,Z
06EB  2EF1  	GOTO	label125

        iTemp = ~iTemp + 1;
06EC  09EC  	COMF convertTem_00026_1_iTemp, F
06ED  09ED  	COMF convertTem_00026_1_iTemp+D'1', F
06EE  0AEC  	INCF convertTem_00026_1_iTemp, F
06EF  1903  	BTFSC STATUS,Z
06F0  0AED  	INCF convertTem_00026_1_iTemp+D'1', F
06F1        label125

    }
    // this gets celcius * 100 - https://www.phanderson.com/PIC/PICC/sourceboost/ds18b20_1.html
    int iValue = (6 * iTemp) + (iTemp / 4);
06F1  3006  	MOVLW 0x06
06F2  00F2  	MOVWF __mul_16s__0000F_arg_a
06F3  01F3  	CLRF __mul_16s__0000F_arg_a+D'1'
06F4  086C  	MOVF convertTem_00026_1_iTemp, W
06F5  00F4  	MOVWF __mul_16s__0000F_arg_b
06F6  086D  	MOVF convertTem_00026_1_iTemp+D'1', W
06F7  00F5  	MOVWF __mul_16s__0000F_arg_b+D'1'
06F8  2431  	CALL __mul_16s__0000F
06F9  0879  	MOVF CompTempVarRet386, W
06FA  00EE  	MOVWF convertTem_00026_1_iValue
06FB  087A  	MOVF CompTempVarRet386+D'1', W
06FC  00F1  	MOVWF CompTempVar621
06FD  086C  	MOVF convertTem_00026_1_iTemp, W
06FE  00F0  	MOVWF CompTempVar618
06FF  086D  	MOVF convertTem_00026_1_iTemp+D'1', W
0700  00EF  	MOVWF convertTem_00026_1_iValue+D'1'
0701  0D6D  	RLF convertTem_00026_1_iTemp+D'1', W
0702  0CEF  	RRF convertTem_00026_1_iValue+D'1', F
0703  0CF0  	RRF CompTempVar618, F
0704  0D6D  	RLF convertTem_00026_1_iTemp+D'1', W
0705  0CEF  	RRF convertTem_00026_1_iValue+D'1', F
0706  0CF0  	RRF CompTempVar618, F
0707  0870  	MOVF CompTempVar618, W
0708  07EE  	ADDWF convertTem_00026_1_iValue, F
0709  0871  	MOVF CompTempVar621, W
070A  1803  	BTFSC STATUS,C
070B  0AEF  	INCF convertTem_00026_1_iValue+D'1', F
070C  07EF  	ADDWF convertTem_00026_1_iValue+D'1', F


    // Split the temperature reading into digits
    
    // simple way, but more program memory needed for PIC12 or PIC16 (more than 100 words more)
    //giDS3231ValueBCD = iValue / 1000;
    //giDS3231ValueBCD += (iValue / 100) % 10;
    //giDS3231ValueBCD += (iValue / 10) % 10;
    //giDS3231ValueBCD += iValue % 10;
    
    // Double Dabble
    giDS3231ValueBCD = binToBcd(iValue);
070D  086E  	MOVF convertTem_00026_1_iValue, W
070E  00F2  	MOVWF binToBcd_00000_arg_iBin
070F  086F  	MOVF convertTem_00026_1_iValue+D'1', W
0710  00F3  	MOVWF binToBcd_00000_arg_iBin+D'1'
0711  2292  	CALL binToBcd_00000
0712  0878  	MOVF CompTempVarRet597, W
0713  1283  	BCF STATUS, RP0
0714  1303  	BCF STATUS, RP1
0715  00B3  	MOVWF gbl_giDS3231ValueBCD
0716  0879  	MOVF CompTempVarRet597+D'1', W
0717  00B4  	MOVWF gbl_giDS3231ValueBCD+D'1'

    
    // less program memory needed - may be slower executing
    // https://electronics.stackexchange.com/questions/158563/how-to-split-a-floating-point-number-into-individual-digits
    /*giDS3231ValueBCD = 0;

    // incrementing variables for each digit
    // determine to thousands digit
    while (iValue >= 1000) {
        iValue = iValue - 1000;
        // each time we take off 1000, the digit is incremented
        giDS3231ValueBCD += 0x1000;
    }

    // determine to hundreds digit
    while (iValue >= 100) {
        iValue = iValue - 100;
        // each time we take off 100, the digit is incremented
        giDS3231ValueBCD += 0x100;
    }

    // determine to tens digit
    while (iValue >= 10) {
        iValue = iValue - 10;
        // each time we take off 10, the left most digit is incremented
        giDS3231ValueBCD += 0x10;
    }

    // the last digit is what's left on iValue
    giDS3231ValueBCD += iValue;*/
}
0718  0008  	RETURN


/*********************************************************************************************
  startTemp()
  Sends the Convert T [44h] function command to the ds18b20
*********************************************************************************************/
void startTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // 44 is the convert function
    oneWireTxBytes(0xCC, 0x44);
0600  30CC  	MOVLW 0xCC
0601  1283  	BCF STATUS, RP0
0602  1303  	BCF STATUS, RP1
0603  00EC  	MOVWF oneWireTxB_00015_arg_cData
0604  3044  	MOVLW 0x44
0605  00ED  	MOVWF oneWireTxB_00015_arg_cData2
0606  2193  	CALL oneWireTxB_00015

}
0607  0008  	RETURN


/*********************************************************************************************
  startTemp()
  Sends the Read Scratchpad [BEh] function command to the ds18b20
*********************************************************************************************/
void readTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // BE indicates to read scratchpad
    oneWireTxBytes(0xCC, 0xBE);
0608  30CC  	MOVLW 0xCC
0609  1283  	BCF STATUS, RP0
060A  1303  	BCF STATUS, RP1
060B  00EC  	MOVWF oneWireTxB_00015_arg_cData
060C  30BE  	MOVLW 0xBE
060D  00ED  	MOVWF oneWireTxB_00015_arg_cData2
060E  2193  	CALL oneWireTxB_00015

    // Now get the temperature from the scratchpad
    // This is in the first two bytes - so get those only and ignore the rest
    cTempL = oneWireRxByte();
060F  219A  	CALL oneWireRxB_00016
0610  086D  	MOVF CompTempVarRet548, W
0611  00CA  	MOVWF gbl_cTempL

    cTempH = oneWireRxByte();
0612  219A  	CALL oneWireRxB_00016
0613  086D  	MOVF CompTempVarRet548, W
0614  00C9  	MOVWF gbl_cTempH

}
0615  0008  	RETURN


/*********************************************************************************************
  char bcdAdjust(char bcd, char bcdMax, char bcdMin)
  Increment or Decrement a BCD variable for sending to the DS3231, within a given range
  Must set iBcdAdjustment first
*********************************************************************************************/
char bcdAdjust(char bcd, char bcdMax, char bcdMin) {

    if (iBcdAdjustment == 1) {
0156  0368  	DECF gbl_iBcdAdjustment, W
0157  1D03  	BTFSS STATUS,Z
0158  296C  	GOTO	label26
016C        label26

        // Increment
        // if at maximum, reset to minimum
        if (bcd == bcdMax)
0159  086E  	MOVF bcdAdjust_00000_arg_bcdMax, W
015A  066D  	XORWF bcdAdjust_00000_arg_bcd, W
015B  1D03  	BTFSS STATUS,Z
015C  2960  	GOTO	label24
0160        label24

            bcd = bcdMin;
015D  086F  	MOVF bcdAdjust_00000_arg_bcdMin, W
015E  00ED  	MOVWF bcdAdjust_00000_arg_bcd

        else if ((bcd & 0x0F) == 9)
015F  297D  	GOTO	label29
0160  300F  	MOVLW 0x0F
0161  056D  	ANDWF bcdAdjust_00000_arg_bcd, W
0162  00F0  	MOVWF CompTempVar607
0163  0870  	MOVF CompTempVar607, W
0164  3A09  	XORLW 0x09
0165  1D03  	BTFSS STATUS,Z
0166  296A  	GOTO	label25
016A        label25

            bcd += 0x10;
0167  3010  	MOVLW 0x10
0168  07ED  	ADDWF bcdAdjust_00000_arg_bcd, F

        else
0169  297D  	GOTO	label29

            bcd++;
016A  0AED  	INCF bcdAdjust_00000_arg_bcd, F

    } else {
016B  297D  	GOTO	label29

        // Decrement
        // if at minimum, reset to maximum
        if (bcd == bcdMin)
016C  086F  	MOVF bcdAdjust_00000_arg_bcdMin, W
016D  066D  	XORWF bcdAdjust_00000_arg_bcd, W
016E  1D03  	BTFSS STATUS,Z
016F  2973  	GOTO	label27
0173        label27

            bcd = bcdMax;
0170  086E  	MOVF bcdAdjust_00000_arg_bcdMax, W
0171  00ED  	MOVWF bcdAdjust_00000_arg_bcd

        else if ((bcd & 0x0F) == 0)
0172  297D  	GOTO	label29
0173  300F  	MOVLW 0x0F
0174  056D  	ANDWF bcdAdjust_00000_arg_bcd, W
0175  00F0  	MOVWF CompTempVar608
0176  08F0  	MOVF CompTempVar608, F
0177  1D03  	BTFSS STATUS,Z
0178  297C  	GOTO	label28
017C        label28

            bcd -= 0x10;
0179  3010  	MOVLW 0x10
017A  02ED  	SUBWF bcdAdjust_00000_arg_bcd, F

        else
017B  297D  	GOTO	label29
017D        label29

            bcd--;
017C  03ED  	DECF bcdAdjust_00000_arg_bcd, F

    }
    return bcd;
017D  086D  	MOVF bcdAdjust_00000_arg_bcd, W
017E  00F0  	MOVWF CompTempVarRet606

}
017F  0008  	RETURN


/*********************************************************************************************
  adjustDateTime()
  Increment or Decrement a BCD variable for sending to the DS3231, within a given range
  Must set iBcdAdjustment first
*********************************************************************************************/
void adjustDateTime() {

    switch (gcSetMode) {

        case 1:
03B7  1283  	BCF STATUS, RP0
03B8  1303  	BCF STATUS, RP1
03B9  084F  	MOVF gbl_gcSetMode, W
03BA  3A01  	XORLW 0x01
03BB  1903  	BTFSC STATUS,Z
03BC  2BCD  	GOTO	label67
03CD        label67

            // Setting year
            gBcdYear = bcdAdjust(gBcdYear, 0x99, 0x00);
03CD  083B  	MOVF gbl_gBcdYear, W
03CE  00ED  	MOVWF bcdAdjust_00000_arg_bcd
03CF  3099  	MOVLW 0x99
03D0  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
03D1  01EF  	CLRF bcdAdjust_00000_arg_bcdMin
03D2  2156  	CALL bcdAdjust_00000
03D3  0870  	MOVF CompTempVarRet606, W
03D4  00BB  	MOVWF gbl_gBcdYear

            break;
        case 2:
03BD  3A03  	XORLW 0x03
03BE  1903  	BTFSC STATUS,Z
03BF  2BD6  	GOTO	label68
03D6        label68

            // Setting month
            gBcdMonth = bcdAdjust(gBcdMonth, 0x12, 0x01);
03D6  083A  	MOVF gbl_gBcdMonth, W
03D7  00ED  	MOVWF bcdAdjust_00000_arg_bcd
03D8  3012  	MOVLW 0x12
03D9  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
03DA  3001  	MOVLW 0x01
03DB  00EF  	MOVWF bcdAdjust_00000_arg_bcdMin
03DC  2156  	CALL bcdAdjust_00000
03DD  0870  	MOVF CompTempVarRet606, W
03DE  00BA  	MOVWF gbl_gBcdMonth

            break;
        case 3:
03C0  3A01  	XORLW 0x01
03C1  1903  	BTFSC STATUS,Z
03C2  2BE0  	GOTO	label69
03E0        label69

            // Setting day of month
            char iMonth = gBcdMonth;
03E0  083A  	MOVF gbl_gBcdMonth, W
03E1  00EB  	MOVWF adjustDate_00023_1_iMonth

            if (iMonth & 0xF0)
03E2  30F0  	MOVLW 0xF0
03E3  056B  	ANDWF adjustDate_00023_1_iMonth, W
03E4  1903  	BTFSC STATUS,Z
03E5  2BEB  	GOTO	label70
03EB        label70

                iMonth += (gBcdMonth >> 4);
03E6  0E3A  	SWAPF gbl_gBcdMonth, W
03E7  390F  	ANDLW 0x0F
03E8  00ED  	MOVWF CompTempVar609
03E9  086D  	MOVF CompTempVar609, W
03EA  07EB  	ADDWF adjustDate_00023_1_iMonth, F

            iMonth--; // Make 0 to 11 index based
03EB  03EB  	DECF adjustDate_00023_1_iMonth, F

            char bcdMaxDay = gDaysInMonth[iMonth]; 
03EC  083C  	MOVF gbl_gDaysInMonth, W
03ED  00F3  	MOVWF __rom_get_00000_arg_objNumb
03EE  086B  	MOVF adjustDate_00023_1_iMonth, W
03EF  00F4  	MOVWF __rom_get_00000_arg_idx
03F0  2024  	CALL __rom_get_00000
03F1  00EC  	MOVWF adjustDate_00023_1_bcdMaxDay

            // If February, adjust max days for leap years
            if (iMonth == 1) {
03F2  036B  	DECF adjustDate_00023_1_iMonth, W
03F3  118A  	BCF PCLATH,3
03F4  120A  	BCF PCLATH,4
03F5  1D03  	BTFSS STATUS,Z
03F6  2C0D  	GOTO	label73

                // See if the 24 leap years since 2000 match the current year
                for (char i = 0; i < 24; i++) {
03F7  01ED  	CLRF adjustDate_00023_16_i
03F8        label71
03F8  3018  	MOVLW 0x18
03F9  026D  	SUBWF adjustDate_00023_16_i, W
03FA  1803  	BTFSC STATUS,C
03FB  2C0D  	GOTO	label73
040B  0AED  	INCF adjustDate_00023_16_i, F
040C  2BF8  	GOTO	label71
040D        label73

                    if (gLeapYears[i] == gBcdYear) {
03FC  083D  	MOVF gbl_gLeapYears, W
03FD  00F3  	MOVWF __rom_get_00000_arg_objNumb
03FE  086D  	MOVF adjustDate_00023_16_i, W
03FF  00F4  	MOVWF __rom_get_00000_arg_idx
0400  2024  	CALL __rom_get_00000
0401  00EE  	MOVWF CompTempVar610
0402  083B  	MOVF gbl_gBcdYear, W
0403  066E  	XORWF CompTempVar610, W
0404  118A  	BCF PCLATH,3
0405  120A  	BCF PCLATH,4
0406  1D03  	BTFSS STATUS,Z
0407  2C0B  	GOTO	label72
040B        label72

                        bcdMaxDay = 0x29;
0408  3029  	MOVLW 0x29
0409  00EC  	MOVWF adjustDate_00023_1_bcdMaxDay

                        break;
040A  2C0D  	GOTO	label73

                    }
                }
            }
            gBcdDayOfMonth = bcdAdjust(gBcdDayOfMonth, bcdMaxDay, 0x01);
040D  0839  	MOVF gbl_gBcdDayOfMonth, W
040E  00ED  	MOVWF bcdAdjust_00000_arg_bcd
040F  086C  	MOVF adjustDate_00023_1_bcdMaxDay, W
0410  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
0411  3001  	MOVLW 0x01
0412  00EF  	MOVWF bcdAdjust_00000_arg_bcdMin
0413  2156  	CALL bcdAdjust_00000
0414  0870  	MOVF CompTempVarRet606, W
0415  00B9  	MOVWF gbl_gBcdDayOfMonth

            break;
        case 4:
03C3  3A07  	XORLW 0x07
03C4  1903  	BTFSC STATUS,Z
03C5  2C17  	GOTO	label74
0417        label74

            // Setting day of week
            gDayOfWeek = bcdAdjust(gDayOfWeek, 0x07, 0x01);
0417  0838  	MOVF gbl_gDayOfWeek, W
0418  00ED  	MOVWF bcdAdjust_00000_arg_bcd
0419  3007  	MOVLW 0x07
041A  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
041B  3001  	MOVLW 0x01
041C  00EF  	MOVWF bcdAdjust_00000_arg_bcdMin
041D  2156  	CALL bcdAdjust_00000
041E  0870  	MOVF CompTempVarRet606, W
041F  00B8  	MOVWF gbl_gDayOfWeek

        case 5:
03C6  3A01  	XORLW 0x01
03C7  1903  	BTFSC STATUS,Z
03C8  2C20  	GOTO	label75
0420        label75

            // Setting hour
            gBcdHour = bcdAdjust(gBcdHour, 0x23, 0x00);
0420  0837  	MOVF gbl_gBcdHour, W
0421  00ED  	MOVWF bcdAdjust_00000_arg_bcd
0422  3023  	MOVLW 0x23
0423  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
0424  01EF  	CLRF bcdAdjust_00000_arg_bcdMin
0425  2156  	CALL bcdAdjust_00000
0426  0870  	MOVF CompTempVarRet606, W
0427  00B7  	MOVWF gbl_gBcdHour

        case 6:
03C9  3A03  	XORLW 0x03
03CA  1903  	BTFSC STATUS,Z
03CB  2C28  	GOTO	label76
0428        label76

            // Setting minute
            gBcdMinute = bcdAdjust(gBcdMinute, 0x59, 0x00);
0428  0836  	MOVF gbl_gBcdMinute, W
0429  00ED  	MOVWF bcdAdjust_00000_arg_bcd
042A  3059  	MOVLW 0x59
042B  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
042C  01EF  	CLRF bcdAdjust_00000_arg_bcdMin
042D  2156  	CALL bcdAdjust_00000
042E  0870  	MOVF CompTempVarRet606, W
042F  00B6  	MOVWF gbl_gBcdMinute

    }
}
03CC  0008  	RETURN
03D5  0008  	RETURN
03DF  0008  	RETURN
0416  0008  	RETURN
0430  0008  	RETURN


/*********************************************************************************************
  adjustTrigger()
  Increment or Decrement a trigger time or temperate
  Must set iBcdAdjustment first
*********************************************************************************************/
void adjustTrigger() {

    switch (gcTriggerMode) {

        case 1:
031F  1283  	BCF STATUS, RP0
0320  1303  	BCF STATUS, RP1
0321  0850  	MOVF gbl_gcTriggerMode, W
0322  3A01  	XORLW 0x01
0323  1903  	BTFSC STATUS,Z
0324  2B47  	GOTO	label55
0347        label55

            // White LED on hour
            gBcdWhiteOnHour = bcdAdjust(gBcdWhiteOnHour, 0x23, 0x00);
0347  0852  	MOVF gbl_gBcdWhiteOnHour, W
0348  00ED  	MOVWF bcdAdjust_00000_arg_bcd
0349  3023  	MOVLW 0x23
034A  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
034B  01EF  	CLRF bcdAdjust_00000_arg_bcdMin
034C  2156  	CALL bcdAdjust_00000
034D  0870  	MOVF CompTempVarRet606, W
034E  00D2  	MOVWF gbl_gBcdWhiteOnHour

            break;
        case 2:
0325  3A03  	XORLW 0x03
0326  1903  	BTFSC STATUS,Z
0327  2B50  	GOTO	label56
0350        label56

            // White LED on minute
            gBcdWhiteOnMinute = bcdAdjust(gBcdWhiteOnMinute, 0x59, 0x00);
0350  0851  	MOVF gbl_gBcdWhiteOnMinute, W
0351  00ED  	MOVWF bcdAdjust_00000_arg_bcd
0352  3059  	MOVLW 0x59
0353  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
0354  01EF  	CLRF bcdAdjust_00000_arg_bcdMin
0355  2156  	CALL bcdAdjust_00000
0356  0870  	MOVF CompTempVarRet606, W
0357  00D1  	MOVWF gbl_gBcdWhiteOnMinute

            break;
        case 3:
0328  3A01  	XORLW 0x01
0329  1903  	BTFSC STATUS,Z
032A  2B59  	GOTO	label57
0359        label57

            // White LED off hour
            gBcdWhiteOffHour = bcdAdjust(gBcdWhiteOffHour, 0x23, 0x00);
0359  0854  	MOVF gbl_gBcdWhiteOffHour, W
035A  00ED  	MOVWF bcdAdjust_00000_arg_bcd
035B  3023  	MOVLW 0x23
035C  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
035D  01EF  	CLRF bcdAdjust_00000_arg_bcdMin
035E  2156  	CALL bcdAdjust_00000
035F  0870  	MOVF CompTempVarRet606, W
0360  00D4  	MOVWF gbl_gBcdWhiteOffHour

            break;
        case 4:
032B  3A07  	XORLW 0x07
032C  1903  	BTFSC STATUS,Z
032D  2B62  	GOTO	label58
0362        label58

            // White LED off minute
            gBcdWhiteOffMinute = bcdAdjust(gBcdWhiteOffMinute, 0x59, 0x00);
0362  0853  	MOVF gbl_gBcdWhiteOffMinute, W
0363  00ED  	MOVWF bcdAdjust_00000_arg_bcd
0364  3059  	MOVLW 0x59
0365  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
0366  01EF  	CLRF bcdAdjust_00000_arg_bcdMin
0367  2156  	CALL bcdAdjust_00000
0368  0870  	MOVF CompTempVarRet606, W
0369  00D3  	MOVWF gbl_gBcdWhiteOffMinute

            break;
        case 5:
032E  3A01  	XORLW 0x01
032F  1903  	BTFSC STATUS,Z
0330  2B6B  	GOTO	label59
036B        label59

            // Blue LED on hour
            gBcdBlueOnHour = bcdAdjust(gBcdBlueOnHour, 0x23, 0x00);
036B  0856  	MOVF gbl_gBcdBlueOnHour, W
036C  00ED  	MOVWF bcdAdjust_00000_arg_bcd
036D  3023  	MOVLW 0x23
036E  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
036F  01EF  	CLRF bcdAdjust_00000_arg_bcdMin
0370  2156  	CALL bcdAdjust_00000
0371  0870  	MOVF CompTempVarRet606, W
0372  00D6  	MOVWF gbl_gBcdBlueOnHour

            break;
        case 6:
0331  3A03  	XORLW 0x03
0332  1903  	BTFSC STATUS,Z
0333  2B74  	GOTO	label60
0374        label60

            // Blue LED on minute
            gBcdBlueOnMinute = bcdAdjust(gBcdBlueOnMinute, 0x59, 0x00);
0374  0855  	MOVF gbl_gBcdBlueOnMinute, W
0375  00ED  	MOVWF bcdAdjust_00000_arg_bcd
0376  3059  	MOVLW 0x59
0377  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
0378  01EF  	CLRF bcdAdjust_00000_arg_bcdMin
0379  2156  	CALL bcdAdjust_00000
037A  0870  	MOVF CompTempVarRet606, W
037B  00D5  	MOVWF gbl_gBcdBlueOnMinute

            break;
        case 7:
0334  3A01  	XORLW 0x01
0335  1903  	BTFSC STATUS,Z
0336  2B7D  	GOTO	label61
037D        label61

            // Blue LED off hour
            gBcdBlueOffHour = bcdAdjust(gBcdBlueOffHour, 0x23, 0x00);
037D  0858  	MOVF gbl_gBcdBlueOffHour, W
037E  00ED  	MOVWF bcdAdjust_00000_arg_bcd
037F  3023  	MOVLW 0x23
0380  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
0381  01EF  	CLRF bcdAdjust_00000_arg_bcdMin
0382  2156  	CALL bcdAdjust_00000
0383  0870  	MOVF CompTempVarRet606, W
0384  00D8  	MOVWF gbl_gBcdBlueOffHour

            break;
        case 8:
0337  3A0F  	XORLW 0x0F
0338  1903  	BTFSC STATUS,Z
0339  2B86  	GOTO	label62
0386        label62

            // Blue LED off minute
            gBcdBlueOffMinute = bcdAdjust(gBcdBlueOffMinute, 0x59, 0x00);
0386  0857  	MOVF gbl_gBcdBlueOffMinute, W
0387  00ED  	MOVWF bcdAdjust_00000_arg_bcd
0388  3059  	MOVLW 0x59
0389  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
038A  01EF  	CLRF bcdAdjust_00000_arg_bcdMin
038B  2156  	CALL bcdAdjust_00000
038C  0870  	MOVF CompTempVarRet606, W
038D  00D7  	MOVWF gbl_gBcdBlueOffMinute

            break;
        case 9:
033A  3A01  	XORLW 0x01
033B  1903  	BTFSC STATUS,Z
033C  2B8F  	GOTO	label63
038F        label63

            // Fan on temp - between 20 and 40 degrees C
            gBcdFanOnTemp = bcdAdjust(gBcdFanOnTemp, 0x40, 0x20);
038F  0859  	MOVF gbl_gBcdFanOnTemp, W
0390  00ED  	MOVWF bcdAdjust_00000_arg_bcd
0391  3040  	MOVLW 0x40
0392  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
0393  3020  	MOVLW 0x20
0394  00EF  	MOVWF bcdAdjust_00000_arg_bcdMin
0395  2156  	CALL bcdAdjust_00000
0396  0870  	MOVF CompTempVarRet606, W
0397  00D9  	MOVWF gbl_gBcdFanOnTemp

            break;
        case 10:
033D  3A03  	XORLW 0x03
033E  1903  	BTFSC STATUS,Z
033F  2B99  	GOTO	label64
0399        label64

            // Fan off temp - off must be lower than on, min 20 degrees C
            gBcdFanOffTemp = bcdAdjust(gBcdFanOffTemp, gBcdFanOffTemp, 0x20);
0399  085A  	MOVF gbl_gBcdFanOffTemp, W
039A  00ED  	MOVWF bcdAdjust_00000_arg_bcd
039B  085A  	MOVF gbl_gBcdFanOffTemp, W
039C  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
039D  3020  	MOVLW 0x20
039E  00EF  	MOVWF bcdAdjust_00000_arg_bcdMin
039F  2156  	CALL bcdAdjust_00000
03A0  0870  	MOVF CompTempVarRet606, W
03A1  00DA  	MOVWF gbl_gBcdFanOffTemp

            break;
        case 11:
0340  3A01  	XORLW 0x01
0341  1903  	BTFSC STATUS,Z
0342  2BA3  	GOTO	label65
03A3        label65

            // Heater on temp - between 20 and 40 degrees C
            gBcdHeaterOnTemp = bcdAdjust(gBcdHeaterOnTemp, 0x40, 0x20);
03A3  085B  	MOVF gbl_gBcdHeaterOnTemp, W
03A4  00ED  	MOVWF bcdAdjust_00000_arg_bcd
03A5  3040  	MOVLW 0x40
03A6  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
03A7  3020  	MOVLW 0x20
03A8  00EF  	MOVWF bcdAdjust_00000_arg_bcdMin
03A9  2156  	CALL bcdAdjust_00000
03AA  0870  	MOVF CompTempVarRet606, W
03AB  00DB  	MOVWF gbl_gBcdHeaterOnTemp

            break;
        case 12:
0343  3A07  	XORLW 0x07
0344  1903  	BTFSC STATUS,Z
0345  2BAD  	GOTO	label66
03AD        label66

            // Heater off temp - off must be higher than on - max 40 degrees C
            gBcdHeaterOffTemp = bcdAdjust(gBcdHeaterOffTemp, 0x40, gBcdHeaterOnTemp);
03AD  085C  	MOVF gbl_gBcdHeaterOffTemp, W
03AE  00ED  	MOVWF bcdAdjust_00000_arg_bcd
03AF  3040  	MOVLW 0x40
03B0  00EE  	MOVWF bcdAdjust_00000_arg_bcdMax
03B1  085B  	MOVF gbl_gBcdHeaterOnTemp, W
03B2  00EF  	MOVWF bcdAdjust_00000_arg_bcdMin
03B3  2156  	CALL bcdAdjust_00000
03B4  0870  	MOVF CompTempVarRet606, W
03B5  00DC  	MOVWF gbl_gBcdHeaterOffTemp

            break;
    }
}
0346  0008  	RETURN
034F  0008  	RETURN
0358  0008  	RETURN
0361  0008  	RETURN
036A  0008  	RETURN
0373  0008  	RETURN
037C  0008  	RETURN
0385  0008  	RETURN
038E  0008  	RETURN
0398  0008  	RETURN
03A2  0008  	RETURN
03AC  0008  	RETURN
03B6  0008  	RETURN


void processKeys() {

    switch (tm1638Keys) {

        case 1:
0616  1283  	BCF STATUS, RP0
0617  1303  	BCF STATUS, RP1
0618  0865  	MOVF gbl_tm1638Keys, W
0619  3A01  	XORLW 0x01
061A  1903  	BTFSC STATUS,Z
061B  2E32  	GOTO	label115
0632        label115

            // Toggle white light on/off
            WHITE_LED = !WHITE_LED;
0632  01EB  	CLRF CompTempVar611
0633  1E86  	BTFSS gbl_portb,5
0634  0AEB  	INCF CompTempVar611, F
0635  186B  	BTFSC CompTempVar611,0
0636  1686  	BSF gbl_portb,5
0637  1C6B  	BTFSS CompTempVar611,0
0638  1286  	BCF gbl_portb,5

            break;
        case 2:
061C  3A03  	XORLW 0x03
061D  1903  	BTFSC STATUS,Z
061E  2E3A  	GOTO	label116
063A        label116

            // Toggle blue light on/off
            BLUE_LED = !BLUE_LED;
063A  01EB  	CLRF CompTempVar612
063B  1E06  	BTFSS gbl_portb,4
063C  0AEB  	INCF CompTempVar612, F
063D  186B  	BTFSC CompTempVar612,0
063E  1606  	BSF gbl_portb,4
063F  1C6B  	BTFSS CompTempVar612,0
0640  1206  	BCF gbl_portb,4

            break;
        case 3:
061F  3A01  	XORLW 0x01
0620  1903  	BTFSC STATUS,Z
0621  2E42  	GOTO	label117
0642        label117

            // Toggle fan on/off
            FAN = !FAN;
0642  01EB  	CLRF CompTempVar613
0643  1D86  	BTFSS gbl_portb,3
0644  0AEB  	INCF CompTempVar613, F
0645  186B  	BTFSC CompTempVar613,0
0646  1586  	BSF gbl_portb,3
0647  1C6B  	BTFSS CompTempVar613,0
0648  1186  	BCF gbl_portb,3

            break;
        case 4:
0622  3A07  	XORLW 0x07
0623  1903  	BTFSC STATUS,Z
0624  2E4A  	GOTO	label118
064A        label118

            // Display temp C/temp F/date
            gcDisplayMode++;
064A  0ACE  	INCF gbl_gcDisplayMode, F

            if (gcDisplayMode > 2)
064B  084E  	MOVF gbl_gcDisplayMode, W
064C  3C02  	SUBLW 0x02
064D  1C03  	BTFSS STATUS,C

                gcDisplayMode = 0;
064E  01CE  	CLRF gbl_gcDisplayMode

            break;
        case 5:
0625  3A01  	XORLW 0x01
0626  1903  	BTFSC STATUS,Z
0627  2E50  	GOTO	label119
0650        label119

            // Set
            gcSetMode++;
0650  0ACF  	INCF gbl_gcSetMode, F

            if (gcSetMode > 6) {
0651  084F  	MOVF gbl_gcSetMode, W
0652  3C06  	SUBLW 0x06
0653  1803  	BTFSC STATUS,C

                ds3231WriteDateTime();
0655  2262  	CALL ds3231Writ_0001C

                gcSetMode = 0;
0656  01CF  	CLRF gbl_gcSetMode

            }
            break;
        case 6:
0628  3A03  	XORLW 0x03
0629  1903  	BTFSC STATUS,Z
062A  2E58  	GOTO	label120
0658        label120

            // Adjust down
            iBcdAdjustment = 0;
0658  01E8  	CLRF gbl_iBcdAdjustment

            if (gcSetMode) {
0659  08CF  	MOVF gbl_gcSetMode, F
065A  1903  	BTFSC STATUS,Z
065B  2E5E  	GOTO	label121
065E        label121

                adjustDateTime();
065C  23B7  	CALL adjustDate_00023

            } else if (gcTriggerMode) {
065E  08D0  	MOVF gbl_gcTriggerMode, F
065F  1D03  	BTFSS STATUS,Z

                adjustTrigger();
0660  231F  	CALL adjustTrig_00024

            }
            break;
        case 7:
062B  3A01  	XORLW 0x01
062C  1903  	BTFSC STATUS,Z
062D  2E62  	GOTO	label122
0662        label122

            iBcdAdjustment = 1;
0662  3001  	MOVLW 0x01
0663  00E8  	MOVWF gbl_iBcdAdjustment

            // Adjust up
            if (gcSetMode) {
0664  08CF  	MOVF gbl_gcSetMode, F
0665  1903  	BTFSC STATUS,Z
0666  2E69  	GOTO	label123
0669        label123

                adjustDateTime();
0667  23B7  	CALL adjustDate_00023

            } else if (gcTriggerMode) {
0669  08D0  	MOVF gbl_gcTriggerMode, F
066A  1D03  	BTFSS STATUS,Z

                adjustTrigger();
066B  231F  	CALL adjustTrig_00024

            }
            break;
        case 8:
062E  3A0F  	XORLW 0x0F
062F  1903  	BTFSC STATUS,Z
0630  2E6D  	GOTO	label124
066D        label124

            // Timer
            gcTriggerMode++;
066D  0AD0  	INCF gbl_gcTriggerMode, F

            if (gcTriggerMode > 12)
066E  0850  	MOVF gbl_gcTriggerMode, W
066F  3C0C  	SUBLW 0x0C
0670  1C03  	BTFSS STATUS,C

                gcTriggerMode = 0;
0671  01D0  	CLRF gbl_gcTriggerMode

            break;
    }
}
0631  0008  	RETURN
0639  0008  	RETURN
0641  0008  	RETURN
0649  0008  	RETURN
064F  0008  	RETURN
0654  0008  	RETURN
0657  0008  	RETURN
065D  0008  	RETURN
0661  0008  	RETURN
0668  0008  	RETURN
066C  0008  	RETURN
0672  0008  	RETURN


void main() {

    initialise();
0719  2689  	CALL initialise_00000

    //convertTemp();
    tm1638UpdateDisplay();
071A  245A  	CALL tm1638Upda_0001F


    // Endless loop
    while(1) {
071B        label126

        // Task scheduler
        // If there are tasks to be performed, find out the
        // most recent task from the array and execute it
        while (cTask > 0) {
071B  084C  	MOVF gbl_cTask, W
071C  3C00  	SUBLW 0x00
071D  1803  	BTFSC STATUS,C
071E  2F1B  	GOTO	label126

            if (cTask.TASK_TIMER1) {
071F  1D4C  	BTFSS gbl_cTask,2
0720  2F6E  	GOTO	label135
076E        label135

                if (gcSetMode == 0) {
0721  08CF  	MOVF gbl_gcSetMode, F
0722  1D03  	BTFSS STATUS,Z
0723  2F3A  	GOTO	label130

                    ds3231ReadDateTime();
0724  26B5  	CALL ds3231Read_0001D

                    if ((gBcdSeconds == 0x29) || (gBcdSeconds == 0x59)) {
0725  0835  	MOVF gbl_gBcdSeconds, W
0726  3A29  	XORLW 0x29
0727  1903  	BTFSC STATUS,Z
0728  2F2D  	GOTO	label127
0729  0835  	MOVF gbl_gBcdSeconds, W
072A  3A59  	XORLW 0x59
072B  1D03  	BTFSS STATUS,Z
072C  2F30  	GOTO	label128
072D        label127
0730        label128

                        // Ask to convert for temperature reading at 29 seconds or 59 seconds past the minute
                        oneWireBusReset();
072D  2673  	CALL oneWireBus_00013

                        startTemp();
072E  2600  	CALL startTemp_00000

                    } else if ((gBcdSeconds == 0) || (gBcdSeconds == 0x30)) {
072F  2F3A  	GOTO	label130
0730  08B5  	MOVF gbl_gBcdSeconds, F
0731  1903  	BTFSC STATUS,Z
0732  2F37  	GOTO	label129
0733  0835  	MOVF gbl_gBcdSeconds, W
0734  3A30  	XORLW 0x30
0735  1D03  	BTFSS STATUS,Z
0736  2F3A  	GOTO	label130
0737        label129
073A        label130
0779  2F1B  	GOTO	label126

                        // 1 second later, read the converted temperature
                        oneWireBusReset();
0737  2673  	CALL oneWireBus_00013

                        readTemp(); 
0738  2608  	CALL readTemp_00000

                        // store it in the array, next display refresh will pick it up
                        convertTemp();
0739  26DF  	CALL convertTem_00026

                    }
                }
                // Trigger white led
                if ((gBcdHour == gBcdWhiteOnHour) && (gBcdMinute == gBcdWhiteOnMinute)) {
073A  0852  	MOVF gbl_gBcdWhiteOnHour, W
073B  0637  	XORWF gbl_gBcdHour, W
073C  1D03  	BTFSS STATUS,Z
073D  2F42  	GOTO	label131
073E  0851  	MOVF gbl_gBcdWhiteOnMinute, W
073F  0636  	XORWF gbl_gBcdMinute, W
0740  1903  	BTFSC STATUS,Z

                    WHITE_LED = 1;
0741  1686  	BSF gbl_portb,5
0742        label131

                }
                if ((gBcdHour == gBcdWhiteOffHour) && (gBcdMinute == gBcdWhiteOffMinute)) {
0742  0854  	MOVF gbl_gBcdWhiteOffHour, W
0743  0637  	XORWF gbl_gBcdHour, W
0744  1D03  	BTFSS STATUS,Z
0745  2F4A  	GOTO	label132
0746  0853  	MOVF gbl_gBcdWhiteOffMinute, W
0747  0636  	XORWF gbl_gBcdMinute, W
0748  1903  	BTFSC STATUS,Z

                    WHITE_LED = 0;
0749  1286  	BCF gbl_portb,5
074A        label132

                }
                // Trigger blue led
                if ((gBcdHour == gBcdBlueOnHour) && (gBcdMinute == gBcdBlueOnMinute)) {
074A  0856  	MOVF gbl_gBcdBlueOnHour, W
074B  0637  	XORWF gbl_gBcdHour, W
074C  1D03  	BTFSS STATUS,Z
074D  2F52  	GOTO	label133
074E  0855  	MOVF gbl_gBcdBlueOnMinute, W
074F  0636  	XORWF gbl_gBcdMinute, W
0750  1903  	BTFSC STATUS,Z

                    BLUE_LED = 1;
0751  1606  	BSF gbl_portb,4
0752        label133

                }
                if ((gBcdHour == gBcdBlueOffHour) && (gBcdMinute == gBcdBlueOffMinute)) {
0752  0858  	MOVF gbl_gBcdBlueOffHour, W
0753  0637  	XORWF gbl_gBcdHour, W
0754  1D03  	BTFSS STATUS,Z
0755  2F5A  	GOTO	label134
0756  0857  	MOVF gbl_gBcdBlueOffMinute, W
0757  0636  	XORWF gbl_gBcdMinute, W
0758  1903  	BTFSC STATUS,Z

                    BLUE_LED = 0;
0759  1206  	BCF gbl_portb,4
075A        label134

                }
                // Trigger fan
                char cTempTruncated = giDS3231ValueBCD >> 8;
075A  0834  	MOVF gbl_giDS3231ValueBCD+D'1', W
075B  00EB  	MOVWF main_8_cTempTruncated

                if (cTempTruncated == gBcdFanOnTemp) {
075C  0859  	MOVF gbl_gBcdFanOnTemp, W
075D  066B  	XORWF main_8_cTempTruncated, W
075E  1903  	BTFSC STATUS,Z

                    FAN = 1;
075F  1586  	BSF gbl_portb,3

                }
                if (cTempTruncated == gBcdFanOffTemp) {
0760  085A  	MOVF gbl_gBcdFanOffTemp, W
0761  066B  	XORWF main_8_cTempTruncated, W
0762  1903  	BTFSC STATUS,Z

                    FAN = 0;
0763  1186  	BCF gbl_portb,3

                }
                if (cTempTruncated == gBcdHeaterOnTemp) {
0764  085B  	MOVF gbl_gBcdHeaterOnTemp, W
0765  066B  	XORWF main_8_cTempTruncated, W
0766  1903  	BTFSC STATUS,Z

                    HEATER = 1;
0767  1506  	BSF gbl_portb,2

                }
                if (cTempTruncated == gBcdHeaterOffTemp) {
0768  085C  	MOVF gbl_gBcdHeaterOffTemp, W
0769  066B  	XORWF main_8_cTempTruncated, W
076A  1903  	BTFSC STATUS,Z

                    HEATER = 0;
076B  1106  	BCF gbl_portb,2

                }
                // Display time and temp or date on TM1638
                tm1638UpdateDisplay();
076C  245A  	CALL tm1638Upda_0001F

                
                cTask.TASK_TIMER1 = 0;
076D  114C  	BCF gbl_cTask,2

            }
            if (cTask.TASK_TIMER2) {
076E  1ECC  	BTFSS gbl_cTask,5
076F  2F75  	GOTO	label136
0775        label136

                // If in set mode, update the display every ~half second to flash a digit
                if (gcSetMode > 0)
0770  084F  	MOVF gbl_gcSetMode, W
0771  3C00  	SUBLW 0x00
0772  1C03  	BTFSS STATUS,C

                    tm1638UpdateDisplay();
0773  245A  	CALL tm1638Upda_0001F

                cTask.TASK_TIMER2 = 0;
0774  12CC  	BCF gbl_cTask,5

            }
            // Poll keys
            tm1638ReadKeys();
0775  25DC  	CALL tm1638Read_00021

            if (tm1638Keys != 0) {
0776  08E5  	MOVF gbl_tm1638Keys, F
0777  1D03  	BTFSS STATUS,Z

                processKeys();
0778  2616  	CALL processKey_00025

            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
// I2C Communications Library for I2C MASTER
////////////////////////////////////////////////////////////////////////////
// Author(s): Andrew Smallridge
// Date 15 November 2004
//
// Copyright(C) 2004-2006 Andrew Smallridge
// Copyright(C) 2004-2010 Pavel Baranov
// Copyright(C) 2004-2010 David Hobday
// Existing constants predefined for i2c hardware driver and i2s software
// emulation for the PIC 18F2xx and 18F4xx processors. For hardware support
// on other PICs the constants must be mapped to the corresponding register
// map of the target device
////////////////////////////////////////////////////////////////////////////

/*
////////////////////////////////////////////////////////////////////////////
//	The following three sections should be copied to the user's program:
//		i2c master hardware / software mode definition
//		i2c software implementation template arguments and variables
// 		i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////
// i2c master hardware / software mode definition
//
// For i2c hardware support comment out the #define use_ic2_SW line
////////////////////////////////////////////////////////////////////////////
//#define use_i2c_SW

#if defined use_i2c_SW
////////////////////////////////////////////////////////////////////////////
// i2c software implementation template arguments and variables
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)

// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and software emalated i2c RAM locations. These constants are
// then used by the templated functions. When changing the address of an emulated
// register the corresponding constant mapping must also be changed.
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3					

#else
////////////////////////////////////////////////////////////////////////////
// i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP |i2c_HW)

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and PIC's i2c register locations. These constants are
// then used by the templated functions. 
#define PORTC		0x0f82
#define TRISC		0x0f94
#define e_SSPCON1	0xfc6
#define e_SSPCON2	0xfc5
#define e_SSPSTAT	0xfc7
#define e_SSPADD	0xfc8
#define e_SSPBUF	0xfc9
#define e_SSPIF_PIR	0xf9e
#define e_BCLIF_PIR	0xfa1
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3

#endif

*/


////////////////////////////////////////////////////////////////////////////
// Define the common i2c template structure
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL	template <unsigned char T_SCL_BIT, unsigned short T_SCL_PORT,	\
					unsigned short T_SCL_TRIS, unsigned char T_SDA_BIT, 			\
					unsigned short T_SDA_PORT, unsigned short T_SDA_TRIS,			\
					unsigned short T_i2c_SSPCON1, unsigned short T_i2c_SSPCON2, 	\
					unsigned short T_i2c_SSPSTAT, unsigned short T_i2c_SSPBUF, 		\
					unsigned char T_i2c_SSPIF_BIT, unsigned short T_i2c_SSPIF_PIR,	\
					unsigned char T_i2c_BCLIF_BIT, unsigned short T_i2c_BCLIF_PIR,	\
					unsigned char T_i2c_SMP_BIT, unsigned short T_i2c_SSPADD, 		\
					unsigned char T_MODE>

////////////////////////////////////////////////////////////////////////////
// Define the common i2c template parameters
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL_ARGS	T_SCL_BIT, T_SCL_PORT, T_SCL_TRIS, T_SDA_BIT, 			\
						T_SDA_PORT, T_SDA_TRIS, T_i2c_SSPCON1, T_i2c_SSPCON2, 	\
						T_i2c_SSPSTAT, T_i2c_SSPBUF, T_i2c_SSPIF_BIT, 			\
						T_i2c_SSPIF_PIR, T_i2c_BCLIF_BIT, T_i2c_BCLIF_PIR,		\
						T_i2c_SMP_BIT, T_i2c_SSPADD, T_MODE

////////////////////////////////////////////////////////////////////////////
// Helpers that hide template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_init	i2c_INIT<i2c_ARGS>
#define i2c_start	i2c_START<i2c_ARGS>
#define i2c_restart	i2c_RESTART<i2c_ARGS>
#define i2c_stop	i2c_STOP<i2c_ARGS>
#define i2c_read	i2c_READ<i2c_ARGS>
#define i2c_write	i2c_WRITE<i2c_ARGS>


////////////////////////////////////////////////////////////////////////////
// I2C Control Status Bits - Emulates the PIC18F hardware I2C implementation
////////////////////////////////////////////////////////////////////////////
// define I2C i2C_SSPCON1 control bits
#define	i2c_WCOL	7
#define	i2c_SSPOV	6
#define	i2c_SSPEN	5
#define	i2c_CKP		4
#define	i2c_SSPM3	3
#define	i2c_SSPM2	2
#define	i2c_SSPM1	1
#define	i2c_SSPM0	0

// define I2C SSPCON2 control bits
#define	i2c_GCEN 	7
#define	i2c_ACKSTAT	6
#define	i2c_ACKDT	5
#define	i2c_ACKEN	4
#define	i2c_RCEN	3
#define	i2c_PEN		2
#define	i2c_RSEN	1
#define	i2c_SEN		0

// define I2C SSPSTAT status bits
#define	i2c_DA		5
#define	i2c_P		4
#define	i2c_S		3
#define	i2c_RW		2
#define	i2c_UA		1
#define	i2c_BF		0


////////////////////////////////////////////////////////////////////////////
// I2C Control Flag Bits
////////////////////////////////////////////////////////////////////////////
// define I2C Mode bits
#define	i2c_HW			0x01
#define	i2c_400KHz		0x02	// 100KHz or 400KHz I2C clock (set = 400KHz)
#define	i2c_reset_wdt	0x04
#define i2c_SMP			0x80	


////////////////////////////////////////////////////////////////////////////
// I2C software constants
////////////////////////////////////////////////////////////////////////////
#define	dly 10	// number of 1us delay increments



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Start Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL 
void i2c_START(void)

{
	// Initiate the I2C START condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	delay_us(dly);
00F2  300A  	MOVLW 0x0A
00F3  00F0  	MOVWF delay_us_00000_arg_del
00F4  2010  	CALL delay_us_00000

	l_bclif = 0; // initialise the collision flag for this command
00F5  1283  	BCF STATUS, RP0
00F6  1303  	BCF STATUS, RP1
00F7  11C6  	BCF i2c_START_00000_1_l_bclif,3

	l_sspif = 0;
00F8  11C5  	BCF i2c_START_00000_1_l_sspif,3

		
	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
			
		l_sen = 1; // initiate START condition	

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation			
		l_sen = 1; // initiate START condition
00F9  1441  	BSF i2c_START_00000_1_l_sen,0

		l_scl_tris = 1; // ensure the SCL line is high
00FA  1683  	BSF STATUS, RP0
00FB  1505  	BSF i2c_START_00000_1_l_scl_tris,2

		l_sda_tris = 1; // ensure the SDA line is high	
00FC  1585  	BSF i2c_START_00000_1_l_sda_tris,3

		l_scl = 0; // prepare to set SCL line low
00FD  1283  	BCF STATUS, RP0
00FE  1105  	BCF i2c_START_00000_1_l_scl,2

		l_sda = 0; // prepare to set SDA line low
00FF  1185  	BCF i2c_START_00000_1_l_sda,3

		
		if (l_scl && l_sda)
0100  1D05  	BTFSS i2c_START_00000_1_l_scl,2
0101  291F  	GOTO	label21
0102  1D85  	BTFSS i2c_START_00000_1_l_sda,3
0103  291F  	GOTO	label21
011F        label21

		{
			// good sign - no collision detected
			delay_us(dly);
0104  300A  	MOVLW 0x0A
0105  00F0  	MOVWF delay_us_00000_arg_del
0106  2010  	CALL delay_us_00000

			
			if (!l_scl) // ensure the clock is still high
0107  1905  	BTFSC i2c_START_00000_1_l_scl,2
0108  290D  	GOTO	label20
010D        label20

			{
				l_bclif = 1;
0109  15C6  	BSF i2c_START_00000_1_l_bclif,3

				l_s = 1;
010A  15C2  	BSF i2c_START_00000_1_l_s,3

				l_sen = 0;
010B  1041  	BCF i2c_START_00000_1_l_sen,0

				return;
			}
					
			l_sda = 0; // prepare to set SDA line low
010D  1185  	BCF i2c_START_00000_1_l_sda,3

			l_sda_tris = 0; // SDA to output (driven low)
010E  1683  	BSF STATUS, RP0
010F  1185  	BCF i2c_START_00000_1_l_sda_tris,3


			delay_us(dly);					
0110  300A  	MOVLW 0x0A
0111  00F0  	MOVWF delay_us_00000_arg_del
0112  2010  	CALL delay_us_00000

			l_scl = 0; // prepare to set SCL line low
0113  1283  	BCF STATUS, RP0
0114  1105  	BCF i2c_START_00000_1_l_scl,2

			l_scl_tris = 0; // SCL to output (driven low)
0115  1683  	BSF STATUS, RP0
0116  1105  	BCF i2c_START_00000_1_l_scl_tris,2


			delay_us(dly);					
0117  300A  	MOVLW 0x0A
0118  00F0  	MOVWF delay_us_00000_arg_del
0119  2010  	CALL delay_us_00000

			l_s = 1; // set 'S' bit flag (start bit detected)
011A  1283  	BCF STATUS, RP0
011B  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0; // clear flag
011C  1041  	BCF i2c_START_00000_1_l_sen,0

			l_sspif = 1; // flag end of start condition interrupt	
011D  15C5  	BSF i2c_START_00000_1_l_sspif,3

		}
		else
		{
			// here is SDA or SCL are low at the start - indicates a bus collision
			l_bclif = 1;
011F  15C6  	BSF i2c_START_00000_1_l_bclif,3

			l_s = 1; // set 'S' bit flag (start bit detected)
0120  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0;
0121  1041  	BCF i2c_START_00000_1_l_sen,0

			l_rsen = 0;
0122  10C1  	BCF i2c_START_00000_1_l_rsen,1

			l_pen = 0;
0123  1141  	BCF i2c_START_00000_1_l_pen,2

			l_rcen = 0;								
0124  11C1  	BCF i2c_START_00000_1_l_rcen,3

			l_acken = 0;			
0125  1241  	BCF i2c_START_00000_1_l_acken,4

		}
	}
}
010C  0008  	RETURN
011E  0008  	RETURN
0126  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Restart Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_RESTART(void)
{
	// Initiate the I2C RESTART condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
			
	delay_us(dly);
	l_bclif = 0; // initialise the collision flag for this command
	l_sspif = 0;

	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_rsen = 1; // initiate RESTART condition
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation	
		l_rsen = 1;
		l_scl = 0;
		l_sda = 0;
		
		if (!l_scl)
		{
			// good sign - no other I2C activity in progress
			l_sda_tris = 1; // float SDA line high	(should already be in this condition)	
			delay_us(dly);
		
			// about to float the clock line
			// ensure the data line is still high
			if (!l_sda)
			{
				// problem - SDA is low, a bus collision has occurred				
				l_bclif = 1; // set the bus collision flag	
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_scl_tris = 1; // float SCL line (high)	
				return;
			}
												
			l_scl_tris = 1; // float SCL line (high)

			// wait until any clock stretching has finished
			while (!l_scl)
				if (T_MODE & i2c_reset_wdt)
					clear_wdt();	
			delay_us(dly);
			
			// here we are about to drive SDA low
			// first ensure SCL is still high
			if (!l_scl)
			{
				// problem - SCL is low, a bus collision has occurred
				l_bclif = 1; // set the bus collision flag
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_sda_tris = 1; // float SDA line (high)
				return;
			}
				
			l_sda_tris = 0; // drive SDA low
			l_s = 1; // set 'S' bit flag (start bit detected)

			delay_us(dly);
			l_scl_tris = 0; // drive SCL low
			l_rsen = 0;
			l_pen = 0;
			l_sen = 0;			
			l_rcen = 0;								
			l_acken = 0;			
			l_sspif = 1; // flag end of start condition interrupt
		}
		else
		{
			// SCL is high at the start
			// some other I2C activity in progress		
			l_rsen = 0; // clear flag
			// exit without further action
		}
	}
}



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Stop Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_STOP(void)

{ 
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_p@T_i2c_SSPSTAT.i2c_P; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;

	l_bclif = 0; // initialise the collision flag for this command
00C4  1283  	BCF STATUS, RP0
00C5  1303  	BCF STATUS, RP1
00C6  11C6  	BCF i2c_STOP_00000_1_l_bclif,3

	l_sspif = 0;
00C7  11C5  	BCF i2c_STOP_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_pen = 1; // initiate STOP condition on the I2C bus	
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
		
	}
	else
	{
		//	Software I2C implementation
		l_pen = 1; // initiate STOP condition on the I2C bus
00C8  1541  	BSF i2c_STOP_00000_1_l_pen,2

		delay_us(dly);
00C9  300A  	MOVLW 0x0A
00CA  00F0  	MOVWF delay_us_00000_arg_del
00CB  2010  	CALL delay_us_00000

		
		l_scl = 0; // prepare to set SCL line low
00CC  1105  	BCF i2c_STOP_00000_1_l_scl,2

		l_sda = 0; // prepare to set SDA line low
00CD  1185  	BCF i2c_STOP_00000_1_l_sda,3

		l_scl_tris = 0; // drive SCL line low (should already be low)
00CE  1683  	BSF STATUS, RP0
00CF  1105  	BCF i2c_STOP_00000_1_l_scl_tris,2

		l_sda_tris = 0; // drive SDA line low
00D0  1185  	BCF i2c_STOP_00000_1_l_sda_tris,3


		delay_us(dly);		
00D1  300A  	MOVLW 0x0A
00D2  00F0  	MOVWF delay_us_00000_arg_del
00D3  2010  	CALL delay_us_00000

		l_scl_tris = 1; // float SCL line (high)
00D4  1505  	BSF i2c_STOP_00000_1_l_scl_tris,2

		
		// wait until any clock stretching has finished
		while (!l_scl)
00D5        label16
00D5  1283  	BCF STATUS, RP0
00D6  1905  	BTFSC i2c_STOP_00000_1_l_scl,2
00D7  28DA  	GOTO	label17
00D9  28D5  	GOTO	label16
00DA        label17

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
00D8  0064  	CLRWDT

						
		delay_us(dly);
00DA  300A  	MOVLW 0x0A
00DB  00F0  	MOVWF delay_us_00000_arg_del
00DC  2010  	CALL delay_us_00000

		l_sda_tris = 1; // float SDA line
00DD  1683  	BSF STATUS, RP0
00DE  1585  	BSF i2c_STOP_00000_1_l_sda_tris,3

		delay_us(dly);		
00DF  300A  	MOVLW 0x0A
00E0  00F0  	MOVWF delay_us_00000_arg_del
00E1  2010  	CALL delay_us_00000

		
		// here the SDA line should be high - if not a collision has occurred				
		if (!l_sda || !l_scl)
00E2  1283  	BCF STATUS, RP0
00E3  1D85  	BTFSS i2c_STOP_00000_1_l_sda,3
00E4  28E7  	GOTO	label18
00E5  1905  	BTFSC i2c_STOP_00000_1_l_scl,2
00E6  28EB  	GOTO	label19
00E7        label18
00EB        label19

		{
			// problem - SDA or SCL is low, a bus collision has occurred
			l_bclif = 1; // set the bus collision flag	
00E7  15C6  	BSF i2c_STOP_00000_1_l_bclif,3

			l_s = 0; // clear 'S' bit flag
00E8  11C2  	BCF i2c_STOP_00000_1_l_s,3

			l_pen = 0; // clear flag
00E9  1141  	BCF i2c_STOP_00000_1_l_pen,2

		}
		else
		{		
			l_p = 1;
00EB  1642  	BSF i2c_STOP_00000_1_l_p,4

			l_pen = 0;
00EC  1141  	BCF i2c_STOP_00000_1_l_pen,2

			l_sen = 0;
00ED  1041  	BCF i2c_STOP_00000_1_l_sen,0

			l_rsen = 0;			
00EE  10C1  	BCF i2c_STOP_00000_1_l_rsen,1

			l_rcen = 0;								
00EF  11C1  	BCF i2c_STOP_00000_1_l_rcen,3

			l_acken = 0;
00F0  1241  	BCF i2c_STOP_00000_1_l_acken,4

		}
	}
}
00EA  0008  	RETURN
00F1  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Write Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_WRITE(unsigned char i2c_data)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;	
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
	
	char BitMask;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
0077  11C6  	BCF i2c_WRITE_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
0078  11C5  	BCF i2c_WRITE_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
				
		l_wcol = 0; // clear write collision flag	
		i2c_SSPBUF = i2c_data;

		// test if a write collision occurred
		if (l_wcol)
			return (1); // error exit	

		// wait until MSSP Tx register is empty
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
								
		return (0); // successful exit
	}

	// here for i2c software driver
	l_wcol = 0; // clear write collision flag	
0079  13C0  	BCF i2c_WRITE_00000_1_l_wcol,7

	i2c_SSPBUF = i2c_data;
007A  086D  	MOVF i2c_WRITE_00000_arg_i2c_data, W
007B  00C4  	MOVWF i2c_WRITE_00000_1_i2c_SSPBUF

	
	l_scl = 0; // prepare to set SCL line low
007C  1105  	BCF i2c_WRITE_00000_1_l_scl,2

	l_sda = 0; // prepare to set SDA line low
007D  1185  	BCF i2c_WRITE_00000_1_l_sda,3

	l_rw = 0; // signal we are doing a write
007E  1142  	BCF i2c_WRITE_00000_1_l_rw,2


	for (BitMask = 0x80; BitMask; BitMask>>=1)
007F  3080  	MOVLW 0x80
0080  00EE  	MOVWF i2c_WRITE_00000_1_BitMask
0081        label8
0081  08EE  	MOVF i2c_WRITE_00000_1_BitMask, F
0082  1903  	BTFSC STATUS,Z
0083  28A2  	GOTO	label13
009E  1003  	BCF STATUS,C
009F  1283  	BCF STATUS, RP0
00A0  0CEE  	RRF i2c_WRITE_00000_1_BitMask, F
00A1  2881  	GOTO	label8
00A2        label13

	{
		if (i2c_data & BitMask)
0084  086E  	MOVF i2c_WRITE_00000_1_BitMask, W
0085  056D  	ANDWF i2c_WRITE_00000_arg_i2c_data, W
0086  1903  	BTFSC STATUS,Z
0087  288B  	GOTO	label9
008B        label9

			l_sda_tris = 1; // float SDA high	
0088  1683  	BSF STATUS, RP0
0089  1585  	BSF i2c_WRITE_00000_1_l_sda_tris,3

		else
008A  288D  	GOTO	label10
008D        label10

			l_sda_tris = 0; // drive SDA low
008B  1683  	BSF STATUS, RP0
008C  1185  	BCF i2c_WRITE_00000_1_l_sda_tris,3

		delay_us(dly);
008D  300A  	MOVLW 0x0A
008E  00F0  	MOVWF delay_us_00000_arg_del
008F  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
0090  1505  	BSF i2c_WRITE_00000_1_l_scl_tris,2


		// wait until any clock stretching has finished
		while (!l_scl)
0091        label11
0091  1283  	BCF STATUS, RP0
0092  1905  	BTFSC i2c_WRITE_00000_1_l_scl,2
0093  2896  	GOTO	label12
0095  2891  	GOTO	label11
0096        label12

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
0094  0064  	CLRWDT

		delay_us(dly);
0096  300A  	MOVLW 0x0A
0097  00F0  	MOVWF delay_us_00000_arg_del
0098  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low	
0099  1683  	BSF STATUS, RP0
009A  1105  	BCF i2c_WRITE_00000_1_l_scl_tris,2

		delay_us(dly);
009B  300A  	MOVLW 0x0A
009C  00F0  	MOVWF delay_us_00000_arg_del
009D  2010  	CALL delay_us_00000

	}
	// serialized out the data
	// now get the status		
	// set SSPIF
	l_sspif = 1;
00A2  15C5  	BSF i2c_WRITE_00000_1_l_sspif,3

	l_acken = 1;
00A3  1641  	BSF i2c_WRITE_00000_1_l_acken,4

	l_ackdt = 0;
00A4  12C1  	BCF i2c_WRITE_00000_1_l_ackdt,5

	l_sda_tris = 1; // float SDA high
00A5  1683  	BSF STATUS, RP0
00A6  1585  	BSF i2c_WRITE_00000_1_l_sda_tris,3

	
	delay_us(dly);
00A7  300A  	MOVLW 0x0A
00A8  00F0  	MOVWF delay_us_00000_arg_del
00A9  2010  	CALL delay_us_00000

	
	l_scl_tris = 1; // float SCL high
00AA  1505  	BSF i2c_WRITE_00000_1_l_scl_tris,2

	
	// wait until any clock stretching has finished
	while (!l_scl)
00AB        label14
00AB  1283  	BCF STATUS, RP0
00AC  1905  	BTFSC i2c_WRITE_00000_1_l_scl,2
00AD  28B0  	GOTO	label15
00AF  28AB  	GOTO	label14
00B0        label15

		if (T_MODE & i2c_reset_wdt)
			clear_wdt();	
00AE  0064  	CLRWDT

	delay_us(dly);
00B0  300A  	MOVLW 0x0A
00B1  00F0  	MOVWF delay_us_00000_arg_del
00B2  2010  	CALL delay_us_00000


	// get the status bit
	local_ack = l_sda;
00B3  106F  	BCF i2c_WRITE_00000_1_local_ack,0
00B4  1985  	BTFSC i2c_WRITE_00000_1_l_sda,3
00B5  146F  	BSF i2c_WRITE_00000_1_local_ack,0

	delay_us(dly);
00B6  300A  	MOVLW 0x0A
00B7  00F0  	MOVWF delay_us_00000_arg_del
00B8  2010  	CALL delay_us_00000


	l_scl_tris = 0; // drive SCL low	
00B9  1683  	BSF STATUS, RP0
00BA  1105  	BCF i2c_WRITE_00000_1_l_scl_tris,2

	l_acken = 0;
00BB  1283  	BCF STATUS, RP0
00BC  1241  	BCF i2c_WRITE_00000_1_l_acken,4

	delay_us(dly);
00BD  300A  	MOVLW 0x0A
00BE  00F0  	MOVWF delay_us_00000_arg_del
00BF  2010  	CALL delay_us_00000

	return(local_ack);
00C0  01F0  	CLRF CompTempVarRet551
00C1  186F  	BTFSC i2c_WRITE_00000_1_local_ack,0
00C2  0AF0  	INCF CompTempVarRet551, F

}
00C3  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Read Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_READ(char ack_status)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	char BitMask;
	char i2c_data;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
01B8  11C6  	BCF i2c_READ_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
01B9  11C5  	BCF i2c_READ_00000_1_l_sspif,3

	l_wcol = 0; // clear write collision flag	
01BA  13C0  	BCF i2c_READ_00000_1_l_wcol,7


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// enable master for 1 byte reception	
		l_rcen = 1;

		// wait until byte received
		while(!l_sspif || !l_bf)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// read the byte from the Rx register
		i2c_data = i2c_SSPBUF;			
			
		// wait until the bus is idle		
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		if (ack_status)
			l_ackdt = 1; // preset ack bit
		else
			l_ackdt = 0; // preset ack bit

		l_sspif = 0;
		l_acken = 1; // acknowledge sequence enable

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();								
	}
	else
	{
		// here for i2c software driver
		l_rcen = 1;
01BB  15C1  	BSF i2c_READ_00000_1_l_rcen,3

		l_ackdt = ack_status;
01BC  186C  	BTFSC i2c_READ_00000_arg_ack_status,0
01BD  16C1  	BSF i2c_READ_00000_1_l_ackdt,5
01BE  1C6C  	BTFSS i2c_READ_00000_arg_ack_status,0
01BF  12C1  	BCF i2c_READ_00000_1_l_ackdt,5

		l_rw = 1;
01C0  1542  	BSF i2c_READ_00000_1_l_rw,2

		l_scl = 0; // prepare to set SCL line low
01C1  1105  	BCF i2c_READ_00000_1_l_scl,2

		l_sda = 0; // prepare to set SDA line low	
01C2  1185  	BCF i2c_READ_00000_1_l_sda,3


		// prepare to serialize in the byte
		l_sda_tris = 1; // float SDA
01C3  1683  	BSF STATUS, RP0
01C4  1585  	BSF i2c_READ_00000_1_l_sda_tris,3

		delay_us(dly);
01C5  300A  	MOVLW 0x0A
01C6  00F0  	MOVWF delay_us_00000_arg_del
01C7  2010  	CALL delay_us_00000

		i2c_data = 0;
01C8  1283  	BCF STATUS, RP0
01C9  01EE  	CLRF i2c_READ_00000_1_i2c_data

		for (BitMask = 0x80; BitMask; BitMask>>=1)
01CA  3080  	MOVLW 0x80
01CB  00ED  	MOVWF i2c_READ_00000_1_BitMask
01CC        label33
01CC  08ED  	MOVF i2c_READ_00000_1_BitMask, F
01CD  1903  	BTFSC STATUS,Z
01CE  29E9  	GOTO	label37
01E5  1003  	BCF STATUS,C
01E6  1283  	BCF STATUS, RP0
01E7  0CED  	RRF i2c_READ_00000_1_BitMask, F
01E8  29CC  	GOTO	label33
01E9        label37

		{
			l_scl_tris = 1; // float SCL high
01CF  1683  	BSF STATUS, RP0
01D0  1505  	BSF i2c_READ_00000_1_l_scl_tris,2

			// wait until any clock stretching has finished
			while (!l_scl)
01D1        label34
01D1  1283  	BCF STATUS, RP0
01D2  1905  	BTFSC i2c_READ_00000_1_l_scl,2
01D3  29D6  	GOTO	label35
01D5  29D1  	GOTO	label34
01D6        label35

				if (T_MODE & i2c_reset_wdt)
					clear_wdt();		
01D4  0064  	CLRWDT

			delay_us(dly);
01D6  300A  	MOVLW 0x0A
01D7  00F0  	MOVWF delay_us_00000_arg_del
01D8  2010  	CALL delay_us_00000


			// read the current bit
			l_sda_tris = 1; // float SDA
01D9  1683  	BSF STATUS, RP0
01DA  1585  	BSF i2c_READ_00000_1_l_sda_tris,3

			if (l_sda)
01DB  1283  	BCF STATUS, RP0
01DC  1D85  	BTFSS i2c_READ_00000_1_l_sda,3
01DD  29E0  	GOTO	label36
01E0        label36

				i2c_data |= BitMask;
01DE  086D  	MOVF i2c_READ_00000_1_BitMask, W
01DF  04EE  	IORWF i2c_READ_00000_1_i2c_data, F

			l_scl_tris = 0; // drive SCL low
01E0  1683  	BSF STATUS, RP0
01E1  1105  	BCF i2c_READ_00000_1_l_scl_tris,2

			delay_us(dly);
01E2  300A  	MOVLW 0x0A
01E3  00F0  	MOVWF delay_us_00000_arg_del
01E4  2010  	CALL delay_us_00000

		}
		// flag receive complete			
		l_sspif = 1;
01E9  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		l_rcen = 0;
01EA  11C1  	BCF i2c_READ_00000_1_l_rcen,3

		
		// set the ACK state
		if (ack_status)	
01EB  08EC  	MOVF i2c_READ_00000_arg_ack_status, F
01EC  1903  	BTFSC STATUS,Z
01ED  29F1  	GOTO	label38
01F1        label38

			l_sda_tris = 1; // float SDA high
01EE  1683  	BSF STATUS, RP0
01EF  1585  	BSF i2c_READ_00000_1_l_sda_tris,3

		else
01F0  29F3  	GOTO	label39
01F3        label39

			l_sda_tris = 0; // drive SDA low
01F1  1683  	BSF STATUS, RP0
01F2  1185  	BCF i2c_READ_00000_1_l_sda_tris,3

		delay_us(dly);
01F3  300A  	MOVLW 0x0A
01F4  00F0  	MOVWF delay_us_00000_arg_del
01F5  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
01F6  1505  	BSF i2c_READ_00000_1_l_scl_tris,2


		// wait until any clock stretching has finished
		while (!l_scl)
01F7        label40
01F7  1283  	BCF STATUS, RP0
01F8  1905  	BTFSC i2c_READ_00000_1_l_scl,2
01F9  29FC  	GOTO	label41
01FB  29F7  	GOTO	label40
01FC        label41

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
01FA  0064  	CLRWDT

	
		l_sspif = 0; // clear SSPIF
01FC  11C5  	BCF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
01FD  300A  	MOVLW 0x0A
01FE  00F0  	MOVWF delay_us_00000_arg_del
01FF  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low		
0200  1683  	BSF STATUS, RP0
0201  1105  	BCF i2c_READ_00000_1_l_scl_tris,2

		l_sspif = 1;
0202  1283  	BCF STATUS, RP0
0203  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
0204  300A  	MOVLW 0x0A
0205  00F0  	MOVWF delay_us_00000_arg_del
0206  2010  	CALL delay_us_00000

	}
	return(i2c_data);
0207  086E  	MOVF i2c_READ_00000_1_i2c_data, W
0208  00EF  	MOVWF CompTempVarRet552

}
0209  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Initialization
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_INIT(unsigned char i2c_divisor)

{
	volatile unsigned char i2c_SSPADD@T_i2c_SSPADD, i2c_SSPSTAT@T_i2c_SSPSTAT;
	volatile unsigned char i2c_SSPCON1@T_i2c_SSPCON1,i2c_SSPCON2@T_i2c_SSPCON2;

	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_sspen@T_i2c_SSPCON1.i2c_SSPEN, l_smp@T_i2c_SSPSTAT.T_i2c_SMP_BIT;

	l_sda_tris = 1;
020A  1683  	BSF STATUS, RP0
020B  1585  	BSF i2c_INIT_00000_1_l_sda_tris,3

	l_scl_tris = 1;
020C  1505  	BSF i2c_INIT_00000_1_l_scl_tris,2

	
	i2c_SSPCON1 = 0x00; // initialise the I2C control register (mirrors HW SSPCON1)	
020D  1283  	BCF STATUS, RP0
020E  01C0  	CLRF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPADD = i2c_divisor; // get the I2C baud rate divisor
020F  086B  	MOVF i2c_INIT_00000_arg_i2c_divisor, W
0210  00C3  	MOVWF i2c_INIT_00000_1_i2c_SSPADD

	i2c_SSPCON1 = 0x08; // initialise the I2C control register (mirrors HW SSPCON1)	
0211  3008  	MOVLW 0x08
0212  00C0  	MOVWF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPCON2 = 0x00; // initialise the I2C control register (mirrors HW SSPCON2)	
0213  01C1  	CLRF i2c_INIT_00000_1_i2c_SSPCON2

	
	i2c_SSPSTAT = 0x00; // initialise the I2C status register (mirrors HW SSPSTAT)
0214  01C2  	CLRF i2c_INIT_00000_1_i2c_SSPSTAT

	
	if (T_MODE & i2c_SMP)
		l_smp = 1;
0215  17C2  	BSF i2c_INIT_00000_1_l_smp,7


	l_sspif = 0; // initialise the I2C SSP interrupt status
0216  11C5  	BCF i2c_INIT_00000_1_l_sspif,3

	l_bclif = 0; // initialise the I2C BCL interrupt status
0217  11C6  	BCF i2c_INIT_00000_1_l_bclif,3

	l_sda = 0;
0218  1185  	BCF i2c_INIT_00000_1_l_sda,3

	l_scl = 0;
0219  1105  	BCF i2c_INIT_00000_1_l_scl,2

	l_sspen = 1; // enable I2C
021A  16C0  	BSF i2c_INIT_00000_1_l_sspen,5

	
	i2c_STOP<_I2C_TEMPL_ARGS>();
021B  20C4  	CALL i2c_STOP_00000

}
021C  0008  	RETURN







////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  2F7A  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B0  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00B1  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00B2  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2FD8  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010  3003  	MOVLW 0x03
0011  07F0  	ADDWF delay_us_00000_arg_del, F
0012  0CF0  	RRF delay_us_00000_arg_del, F
0013  0CF0  	RRF delay_us_00000_arg_del, F
0014  307F  	MOVLW 0x7F
0015  05F0  	ANDWF delay_us_00000_arg_del, F
0016        label1
0016  0000  	NOP
0017  0BF0  	DECFSZ delay_us_00000_arg_del, F
0018  2816  	GOTO	label1
0019  0008  	RETURN
001A        ; } delay_us function end

001A        delay_10us_00000
001A        ; { delay_10us ; function begin
001A        label2
001A  0000  	NOP
001B  0000  	NOP
001C  0000  	NOP
001D  0000  	NOP
001E  0000  	NOP
001F  0000  	NOP
0020  0000  	NOP
0021  0BF1  	DECFSZ delay_10us_00000_arg_del, F
0022  281A  	GOTO	label2
0023  0008  	RETURN
0024        ; } delay_10us function end

0024        __rom_get_00000
0024        ; { __rom_get ; function begin
0024  0873  	MOVF __rom_get_00000_arg_objNumb, W
0025  00F6  	MOVWF __rom_get_00000_1_romAddr+D'1'
0026  01F5  	CLRF __rom_get_00000_1_romAddr
0027  1003  	BCF STATUS,C
0028  0DF6  	RLF __rom_get_00000_1_romAddr+D'1', F
0029  0DF5  	RLF __rom_get_00000_1_romAddr, F
002A  0DF6  	RLF __rom_get_00000_1_romAddr+D'1', F
002B  0DF5  	RLF __rom_get_00000_1_romAddr, F
002C  3037  	MOVLW	LOW( label3 )
002D  07F6  	ADDWF __rom_get_00000_1_romAddr+D'1', F
002E  1803  	BTFSC STATUS,C
002F  0AF5  	INCF __rom_get_00000_1_romAddr, F
0030  3000  	MOVLW	HIGH( label3 )
0031  0775  	ADDWF __rom_get_00000_1_romAddr, W
0032  008A  	MOVWF PCLATH
0033  0874  	MOVF __rom_get_00000_arg_idx, W
0034  00F5  	MOVWF __rom_get_00000_1_romAddr
0035  0876  	MOVF __rom_get_00000_1_romAddr+D'1', W
0036  0082  	MOVWF PCL
0037        label3
0037  3000  	MOVLW	HIGH( label5 )
0038  00F6  	MOVWF __rom_get_00000_1_romAddr+D'1'
0039  3049  	MOVLW	LOW( label5 )
003A  2842  	GOTO	label4
003B  3000  	MOVLW	HIGH( label6 )
003C  00F6  	MOVWF __rom_get_00000_1_romAddr+D'1'
003D  3055  	MOVLW	LOW( label6 )
003E  2842  	GOTO	label4
003F  3000  	MOVLW	HIGH( label7 )
0040  00F6  	MOVWF __rom_get_00000_1_romAddr+D'1'
0041  306D  	MOVLW	LOW( label7 )
0042        label4
0042  07F5  	ADDWF __rom_get_00000_1_romAddr, F
0043  1803  	BTFSC STATUS,C
0044  0AF6  	INCF __rom_get_00000_1_romAddr+D'1', F
0045  0876  	MOVF __rom_get_00000_1_romAddr+D'1', W
0046  008A  	MOVWF PCLATH
0047  0875  	MOVF __rom_get_00000_1_romAddr, W
0048  0082  	MOVWF PCL
0049        label5
0049  3431  	RETLW 0x31
004A  3428  	RETLW 0x28
004B  3431  	RETLW 0x31
004C  3430  	RETLW 0x30
004D  3431  	RETLW 0x31
004E  3430  	RETLW 0x30
004F  3431  	RETLW 0x31
0050  3431  	RETLW 0x31
0051  3430  	RETLW 0x30
0052  3431  	RETLW 0x31
0053  3430  	RETLW 0x30
0054  3431  	RETLW 0x31
0055        label6
0055  3404  	RETLW 0x04
0056  3408  	RETLW 0x08
0057  3412  	RETLW 0x12
0058  3416  	RETLW 0x16
0059  3420  	RETLW 0x20
005A  3424  	RETLW 0x24
005B  3428  	RETLW 0x28
005C  3432  	RETLW 0x32
005D  3436  	RETLW 0x36
005E  3440  	RETLW 0x40
005F  3444  	RETLW 0x44
0060  3448  	RETLW 0x48
0061  3452  	RETLW 0x52
0062  3456  	RETLW 0x56
0063  3460  	RETLW 0x60
0064  3464  	RETLW 0x64
0065  3468  	RETLW 0x68
0066  3472  	RETLW 0x72
0067  3476  	RETLW 0x76
0068  3480  	RETLW 0x80
0069  3484  	RETLW 0x84
006A  3488  	RETLW 0x88
006B  3492  	RETLW 0x92
006C  3496  	RETLW 0x96
006D        label7
006D  343F  	RETLW 0x3F
006E  3406  	RETLW 0x06
006F  345B  	RETLW 0x5B
0070  344F  	RETLW 0x4F
0071  3466  	RETLW 0x66
0072  346D  	RETLW 0x6D
0073  347D  	RETLW 0x7D
0074  3407  	RETLW 0x07
0075  347F  	RETLW 0x7F
0076  346F  	RETLW 0x6F
0077        ; } __rom_get function end














0431        __mul_16s__0000F
0431        ; { __mul_16s_16s__16 ; function begin
0431  01F6  	CLRF __mul_16s__0000F_1_i
0432  01F9  	CLRF CompTempVarRet386
0433  01FA  	CLRF CompTempVarRet386+D'1'
0434  0872  	MOVF __mul_16s__0000F_arg_a, W
0435  00F7  	MOVWF __mul_16s__0000F_1_t
0436  0873  	MOVF __mul_16s__0000F_arg_a+D'1', W
0437  00F8  	MOVWF __mul_16s__0000F_1_t+D'1'
0438  1FF5  	BTFSS __mul_16s__0000F_arg_b+D'1',7
0439  2C40  	GOTO	label77
043A  17F6  	BSF __mul_16s__0000F_1_i,7
043B  09F4  	COMF __mul_16s__0000F_arg_b, F
043C  09F5  	COMF __mul_16s__0000F_arg_b+D'1', F
043D  0AF4  	INCF __mul_16s__0000F_arg_b, F
043E  1903  	BTFSC gbl_status,2
043F  0AF5  	INCF __mul_16s__0000F_arg_b+D'1', F
0440        label77
0440  1A76  	BTFSC __mul_16s__0000F_1_i,4
0441  2C52  	GOTO	label79
0442  1C74  	BTFSS __mul_16s__0000F_arg_b,0
0443  2C4A  	GOTO	label78
0444  0877  	MOVF __mul_16s__0000F_1_t, W
0445  07F9  	ADDWF CompTempVarRet386, F
0446  0878  	MOVF __mul_16s__0000F_1_t+D'1', W
0447  1803  	BTFSC gbl_status,0
0448  0F78  	INCFSZ __mul_16s__0000F_1_t+D'1', W
0449  07FA  	ADDWF CompTempVarRet386+D'1', F
044A        label78
044A  1003  	BCF gbl_status,0
044B  0CF5  	RRF __mul_16s__0000F_arg_b+D'1', F
044C  0CF4  	RRF __mul_16s__0000F_arg_b, F
044D  1003  	BCF gbl_status,0
044E  0DF7  	RLF __mul_16s__0000F_1_t, F
044F  0DF8  	RLF __mul_16s__0000F_1_t+D'1', F
0450  0AF6  	INCF __mul_16s__0000F_1_i, F
0451  2C40  	GOTO	label77
0452        label79
0452  1FF6  	BTFSS __mul_16s__0000F_1_i,7
0453  0008  	RETURN
0454  09F9  	COMF CompTempVarRet386, F
0455  09FA  	COMF CompTempVarRet386+D'1', F
0456  0AF9  	INCF CompTempVarRet386, F
0457  1903  	BTFSC gbl_status,2
0458  0AFA  	INCF CompTempVarRet386+D'1', F
0459  0008  	RETURN
045A        ; } __mul_16s_16s__16 function end






























077A        _startup

07D5  118A  	BCF PCLATH,3
07D6  120A  	BCF PCLATH,4
07D7  2F19  	GOTO	main

2007  3F18  	DW 0x3F18
