;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 8.01
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

#ifndef _PIC16F_TM1638_AquariumControl_H_
#define _PIC16F_TM1638_AquariumControl_H_

// Tasks
#define TASK_TIMER0 1
#define TASK_TIMER1 2

// Port bits
#define oneWireBus (portc.5)
#define oneWireTris (trisc.5)
#define tm1638dio (portb.1)
#define tm1638dioTris (trisb.1)
#define tm1638clk (portb.2)
#define tm1638strobe (portb.3)
#define WHITE_LED (portc.1)
#define BLUE_LED (portc.2)
#define FAN (porta.1)
#define HEATER (porta.0)

// Timer 0 preload
#define TMR0PRELOAD 61
// This means timer 1 will overflow when 1 cycle completes, generating the interrupt
#define TMR1HV 0xFF
#define TMR1LV 0xFF

// I2C initialisation for built in software handling
// i2c options
#define use_i2c_SW
// clock SCL on RA3, data SDA on RA4
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)
// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3


// I2C addresses (8 bit)
#define ds3231Addr 0xD0 // Left shifted 7 bit address 0x68
#define at24c32Addr 0xAE // Left shifted 7 bit address 0x57

// Time and date variables
char gBcdSecond = 0; // 0 to 0x59
0A00  1283  	BCF STATUS, RP0
0A01  1303  	BCF STATUS, RP1
0A02  01B5  	CLRF gbl_gBcdSecond

char gBcdMinute = 0; // 0 to 0x59
0A03  01B6  	CLRF gbl_gBcdMinute

char gBcdHour = 0; // 0 to 0x23 or 1 to 0x12. Also contains 12/24 setting at bit 6. If 12 hour, AM/PM uses bit 5
0A04  01B7  	CLRF gbl_gBcdHour

char gDayOfWeek = 1; // 1 to 7
0A05  3001  	MOVLW 0x01
0A06  00B8  	MOVWF gbl_gDayOfWeek

char gBcdDayOfMonth = 1; // 1 to 0x31
0A07  3001  	MOVLW 0x01
0A08  00B9  	MOVWF gbl_gBcdDayOfMonth

char gBcdMonth = 1; // 1 to 0x12 + century at bit 7
0A09  3001  	MOVLW 0x01
0A0A  00BA  	MOVWF gbl_gBcdMonth

char gBcdYear = 0x23; // Init to 0x23
0A0B  3023  	MOVLW 0x23
0A0C  00BB  	MOVWF gbl_gBcdYear

// Days in each month
rom char *gDaysInMonth = {0x31, 0x28, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31};
0A0D  3000  	MOVLW 0x00
0A0E  00BC  	MOVWF gbl_gDaysInMonth

// List of leap years, where the Feb days will be 29 instead
rom char *gLeapYears = {0x04, 0x08, 0x12, 0x16, 0x20, 0x24, 0x28, 0x32, 0x36, 0x40, 0x44, 0x48, 0x52, 0x56, 0x60, 0x64, 0x68, 0x72, 0x76, 0x80, 0x84, 0x88, 0x92, 0x96};
0A0F  3001  	MOVLW 0x01
0A10  00BD  	MOVWF gbl_gLeapYears


// Timer variables
char iTimer0FlashCounts = 0;
0A11  01BE  	CLRF gbl_iTimer0FlashCounts

char iTimer0KeyCounts = 0;
0A12  01BF  	CLRF gbl_iTimer0KeyCounts

char iFlashDigitOff = 0;
0A13  01C8  	CLRF gbl_iFlashDigitOff

char iDigitToFlash = 8; // 8 = no digit to flash
0A14  3008  	MOVLW 0x08
0A15  00C9  	MOVWF gbl_iDigitToFlash


// Hold the upper and lower bytes from the ds18b20
char cTempH = 1;
0A16  3001  	MOVLW 0x01
0A17  00CA  	MOVWF gbl_cTempH

char cTempL = 70;
0A18  3046  	MOVLW 0x46
0A19  00CB  	MOVWF gbl_cTempL

//char iDecimalPosition = 2;

int giDS3231ValueBCD = 0x0000;
0A1A  01B3  	CLRF gbl_giDS3231ValueBCD
0A1B  01B4  	CLRF gbl_giDS3231ValueBCD+D'1'

char giDS3231ValueTruncCBCD = 0x00;
0A1C  01CC  	CLRF gbl_giDS3231ValueTruncCBCD

char gbDS3231IsMinus = 0;
0A1D  01CD  	CLRF gbl_gbDS3231IsMinus


char cTask = 0; // Used for task scheduler
0A1E  01CE  	CLRF gbl_cTask


// States
bool gbFanOn = 0;
0A1F  104F  	BCF gbl_gbFanOn,0

bool gbHeaterOn = 0;
0A20  10CF  	BCF gbl_gbHeaterOn,1

char gcDisplayMode = 0;
0A21  01D0  	CLRF gbl_gcDisplayMode

char gcSetMode = 0;
0A22  01D1  	CLRF gbl_gcSetMode

char gcHourMode = 0;
0A23  01D2  	CLRF gbl_gcHourMode

char gcTriggerMode = 0;
0A24  01D3  	CLRF gbl_gcTriggerMode


// Triggers
char gBcdWhiteOnMinute = 0; // 0 to 59
0A25  01D4  	CLRF gbl_gBcdWhiteOnMinute

char gBcdWhiteOnHour = 0; // 0 to 23
0A26  01D5  	CLRF gbl_gBcdWhiteOnHour

char gBcdWhiteOffMinute = 0; // 0 to 59
0A27  01D6  	CLRF gbl_gBcdWhiteOffMinute

char gBcdWhiteOffHour = 0; // 0 to 23
0A28  01D7  	CLRF gbl_gBcdWhiteOffHour


char gBcdBlueOnMinute = 0; // 0 to 59
0A29  01D8  	CLRF gbl_gBcdBlueOnMinute

char gBcdBlueOnHour = 0; // 0 to 23
0A2A  01D9  	CLRF gbl_gBcdBlueOnHour

char gBcdBlueOffMinute = 0; // 0 to 59
0A2B  01DA  	CLRF gbl_gBcdBlueOffMinute

char gBcdBlueOffHour = 0; // 0 to 23
0A2C  01DB  	CLRF gbl_gBcdBlueOffHour


char gBcdBlue2OnMinute = 0; // 0 to 59
0A2D  01DC  	CLRF gbl_gBcdBlue2OnMinute

char gBcdBlue2OnHour = 0; // 0 to 23
0A2E  01DD  	CLRF gbl_gBcdBlue2OnHour

char gBcdBlue2OffMinute = 0; // 0 to 59
0A2F  01DE  	CLRF gbl_gBcdBlue2OffMinute

char gBcdBlue2OffHour = 0; // 0 to 23
0A30  01DF  	CLRF gbl_gBcdBlue2OffHour


char gBcdFanOnTemp = 0x28; // Degrees C
0A31  3028  	MOVLW 0x28
0A32  00E0  	MOVWF gbl_gBcdFanOnTemp

char gBcdFanOffTemp = 0x27; // Degrees C
0A33  3027  	MOVLW 0x27
0A34  00E1  	MOVWF gbl_gBcdFanOffTemp


char gBcdHeaterOnTemp = 0x24; // Degrees C
0A35  3024  	MOVLW 0x24
0A36  00E2  	MOVWF gbl_gBcdHeaterOnTemp

char gBcdHeaterOffTemp = 0x25; // Degrees C
0A37  3025  	MOVLW 0x25
0A38  00E3  	MOVWF gbl_gBcdHeaterOffTemp


// Used to output the segments from numbers
char tm1638MaxDigits = 8;
0A39  3008  	MOVLW 0x08
0A3A  00E4  	MOVWF gbl_tm1638MaxDigits

rom char *tm1638DisplayNumtoSeg = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F};
0A3B  3002  	MOVLW 0x02
0A3C  00E5  	MOVWF gbl_tm1638DisplayNumtoSeg

char tm1638Dot = 0x80;
0A3D  3080  	MOVLW 0x80
0A3E  00E6  	MOVWF gbl_tm1638Dot

char tm1638Brightness = 7; // 0 to 7
0A3F  3007  	MOVLW 0x07
0A40  00E7  	MOVWF gbl_tm1638Brightness

// 0x40 [01000000] = indicate command to display data
char tm1638ByteSetData = 0x40;
0A41  3040  	MOVLW 0x40
0A42  00E8  	MOVWF gbl_tm1638ByteSetData

// 0x42 [01000010] = indicate command to read data
char tm1638ByteReadData = 0x42;
0A43  3042  	MOVLW 0x42
0A44  00E9  	MOVWF gbl_tm1638ByteReadData

// 0xC0 [11000000] = write out all bytes
char tm1638ByteSetAddr = 0xC0;
0A45  30C0  	MOVLW 0xC0
0A46  00EA  	MOVWF gbl_tm1638ByteSetAddr

// 0x88 [10001000] - Display ON, plus brightness
char tm1638ByteSetOn = 0x88;
0A47  3088  	MOVLW 0x88
0A48  00EB  	MOVWF gbl_tm1638ByteSetOn


// Copy of the data to write / on the display
char tm1638Data[] = {0, 0, 0, 0, 0, 0, 0, 0};
0A49  01A0  	CLRF gbl_tm1638Data
0A4A  01A1  	CLRF gbl_tm1638Data+D'1'
0A4B  01A2  	CLRF gbl_tm1638Data+D'2'
0A4C  01A3  	CLRF gbl_tm1638Data+D'3'
0A4D  01A4  	CLRF gbl_tm1638Data+D'4'
0A4E  01A5  	CLRF gbl_tm1638Data+D'5'
0A4F  01A6  	CLRF gbl_tm1638Data+D'6'
0A50  01A7  	CLRF gbl_tm1638Data+D'7'

// Copy of the LED status
char tm1638LEDs[] = {0, 0, 0, 0, 0, 0, 0, 0};
0A51  01A8  	CLRF gbl_tm1638LEDs
0A52  01A9  	CLRF gbl_tm1638LEDs+D'1'
0A53  01AA  	CLRF gbl_tm1638LEDs+D'2'
0A54  01AB  	CLRF gbl_tm1638LEDs+D'3'
0A55  01AC  	CLRF gbl_tm1638LEDs+D'4'
0A56  01AD  	CLRF gbl_tm1638LEDs+D'5'
0A57  01AE  	CLRF gbl_tm1638LEDs+D'6'
0A58  01AF  	CLRF gbl_tm1638LEDs+D'7'

// Copy of the keys
char tm1638Keys = 0;
0A59  01EC  	CLRF gbl_tm1638Keys

char tm1638KeysOld = 0;
0A5A  01ED  	CLRF gbl_tm1638KeysOld

// For printing
char iPrintStartDigit = 0;
0A5B  01EE  	CLRF gbl_iPrintStartDigit

char iPrintDotDigit = 8;
0A5C  3008  	MOVLW 0x08
0A5D  00EF  	MOVWF gbl_iPrintDotDigit

// For adjusting bcd numbers up 1 or down !1
char iBcdAdjustment = 1;
0A5E  3001  	MOVLW 0x01
0A5F  00F0  	MOVWF gbl_iBcdAdjustment


// DS18B20 functions
char oneWireIsPresent = 0;
0A60  01F1  	CLRF gbl_oneWireIsPresent

char oneWireResetStage = 0;
0A61  01F2  	CLRF gbl_oneWireResetStage

void oneWireBusReset();
void oneWireTxByte(char data);
void oneWireTxBytes(char data, char data2);
char oneWireRxByte();

// AT24C32 (EEPROM)
void at24c32WriteAll();
void at24c32ReadAll();

// DS3231 functions
void ds3231Write(char ds3231Reg, char bWrite);
void ds3231Init();
void ds3231Start();
void ds3231Stop();
void ds3231WriteDateTime();
void ds3231ReadDateTime();
char ds3231ReadRegister(char cRegAddress);

// TM1638 functions
void tm1638ByteWrite(char bWrite);
void tm1638DisplayOn();
void nibbleTo7Seg(char bNibble);
void bcdTo7Seg(char iBcdIn);
void zeroToBlank(char iDigit);
void tm1638UpdateDisplay();
void tm1638ReadKeys();

// General functions
int binToBcd(int iBin);
void convertTemp();
void startTemp();
void readTemp();

char bcdAdjust(char bcd, char bcdMax, char bcdMin);
void adjustDateTime();
void adjustTrigger();
void processKeys();

#endif

#include <system.h>
#include <i2c_driver.h>
#include "PIC16F_TM1638_AquariumControl.h"

//Target PIC16F628A configuration word
#pragma DATA _CONFIG, _BODEN_OFF & _PWRTE_ON & _WDT_OFF & _CP_OFF & _XT_OSC // Brown out reset off, Power-up Timer on, Watchdog timer off, Code Protection off, XT oscillator

//Set clock frequency (for software delays) - 4MHz
#pragma CLOCK_FREQ	4000000


/*********************************************************************************************
  void oneWireBusReset()
  First part of the reset routine - drive the bus low for 500us
*********************************************************************************************/
void oneWireBusReset() {

    char isPresent;
    oneWireTris = 1; // start with high
0892  1683  	BSF STATUS, RP0
0893  1303  	BCF STATUS, RP1
0894  1687  	BSF gbl_trisc,5

    isPresent = 0;
0895  1283  	BCF STATUS, RP0
0896  01F3  	CLRF oneWireBus_00014_1_isPresent

    // Send the reset pulse - drive low for 500us
    oneWireBus = 0;
0897  1287  	BCF gbl_portc,5

    oneWireTris = 0;
0898  1683  	BSF STATUS, RP0
0899  1287  	BCF gbl_trisc,5

    delay_10us(50);
089A  3032  	MOVLW 0x32
089B  1283  	BCF STATUS, RP0
089C  00F8  	MOVWF delay_10us_00000_arg_del
089D  118A  	BCF PCLATH,3
089E  207A  	CALL delay_10us_00000

    // Release line and wait 70us for PD Pulse
    oneWireTris = 1;
089F  1683  	BSF STATUS, RP0
08A0  1687  	BSF gbl_trisc,5

    delay_10us(7);
08A1  3007  	MOVLW 0x07
08A2  1283  	BCF STATUS, RP0
08A3  00F8  	MOVWF delay_10us_00000_arg_del
08A4  207A  	CALL delay_10us_00000

    // Now sample, if there is a sensor on the bus, the line should be low
    if (oneWireBus) {
08A5  1A87  	BTFSC gbl_portc,5

        oneWireIsPresent = 0; // no devices
08A6  01F1  	CLRF gbl_oneWireIsPresent

    }
    delay_10us(50);
08A7  3032  	MOVLW 0x32
08A8  00F8  	MOVWF delay_10us_00000_arg_del
08A9  207A  	CALL delay_10us_00000

}
08AA  0008  	RETURN


/*********************************************************************************************
  void oneWireTxByte(char data)
  Transmits a single byte from the bus
*********************************************************************************************/
void oneWireTxByte(char cData) {

    char cTemp = 1;
0183  3001  	MOVLW 0x01
0184  00F6  	MOVWF oneWireTxB_00015_1_cTemp

    // Loop through the eight bits in the byte
    for (char i = 0; i < 8; i++) {
0185  01F7  	CLRF oneWireTxB_00015_2_i
0186        label26
0186  3008  	MOVLW 0x08
0187  0277  	SUBWF oneWireTxB_00015_2_i, W
0188  1803  	BTFSC STATUS,C
019D  0AF7  	INCF oneWireTxB_00015_2_i, F
019E  2986  	GOTO	label26

        // Send the LSB first

        // Drive the line low initially for 3us
        oneWireTris = 0;
018A  1683  	BSF STATUS, RP0
018B  1287  	BCF gbl_trisc,5

        oneWireBus = 0;
018C  1283  	BCF STATUS, RP0
018D  1287  	BCF gbl_portc,5


        // Delay not needed for 4MHz PIC
        //delay_us(3); // Delay 3us

        if (cData & cTemp) {
018E  0876  	MOVF oneWireTxB_00015_1_cTemp, W
018F  0575  	ANDWF oneWireTxB_00015_arg_cData, W
0190  1903  	BTFSC STATUS,Z
0191  2994  	GOTO	label27

            oneWireTris = 1; // Release the bus
0192  1683  	BSF STATUS, RP0
0193  1687  	BSF gbl_trisc,5

        }

        delay_10us(5); // Delay 60us - 50us works fine with code delays
0194  3005  	MOVLW 0x05
0195  1283  	BCF STATUS, RP0
0196  00F8  	MOVWF delay_10us_00000_arg_del
0197  207A  	CALL delay_10us_00000

        oneWireTris = 1; // Release the bus
0198  1683  	BSF STATUS, RP0
0199  1687  	BSF gbl_trisc,5


        // move the test bit
        cTemp <<= 1;
019A  1003  	BCF STATUS,C
019B  1283  	BCF STATUS, RP0
019C  0DF6  	RLF oneWireTxB_00015_1_cTemp, F

    }
}
0189  0008  	RETURN


/*********************************************************************************************
  void oneWireTxBytes(char data, char data2)
  Transmits a 2 bytes from the bus
*********************************************************************************************/
void oneWireTxBytes(char cData, char cData2) {

    // Reset first - done in main
    //oneWireBusReset();
    // Send first byte
    oneWireTxByte(cData);
04E1  0873  	MOVF oneWireTxB_00016_arg_cData, W
04E2  00F5  	MOVWF oneWireTxB_00015_arg_cData
04E3  2183  	CALL oneWireTxB_00015

    // Send second byte
    oneWireTxByte(cData2);
04E4  0874  	MOVF oneWireTxB_00016_arg_cData2, W
04E5  00F5  	MOVWF oneWireTxB_00015_arg_cData
04E6  2183  	CALL oneWireTxB_00015

}
04E7  0008  	RETURN


/*********************************************************************************************
  char oneWireRxByte()
  Receives a single byte from the bus
*********************************************************************************************/
char oneWireRxByte() {

    char cDataIn = 0;
04E8  1283  	BCF STATUS, RP0
04E9  1303  	BCF STATUS, RP1
04EA  01F3  	CLRF oneWireRxB_00017_1_cDataIn

    // Loop through the eight bits in the byte
    for(char i = 0; i < 8; i++) {
04EB  01F4  	CLRF oneWireRxB_00017_2_i
04EC        label100
04EC  3008  	MOVLW 0x08
04ED  0274  	SUBWF oneWireRxB_00017_2_i, W
04EE  1803  	BTFSC STATUS,C
04EF  2D03  	GOTO	label101
0501  0AF4  	INCF oneWireRxB_00017_2_i, F
0502  2CEC  	GOTO	label100
0503        label101

        // Shift data already received left
        cDataIn >>= 1;
04F0  1003  	BCF STATUS,C
04F1  0CF3  	RRF oneWireRxB_00017_1_cDataIn, F


        // Bring bus low for 1us
        oneWireTris = 0;
04F2  1683  	BSF STATUS, RP0
04F3  1287  	BCF gbl_trisc,5

        oneWireBus = 0;
04F4  1283  	BCF STATUS, RP0
04F5  1287  	BCF gbl_portc,5

        // no delay needed here for 4MHz PIC
        // Release bus
        oneWireTris = 1;
04F6  1683  	BSF STATUS, RP0
04F7  1687  	BSF gbl_trisc,5


        // Sample within 15us
        // delay overhead 10us, unit delay 1us, resolution 4 units
        delay_us(4); // Delay 15us
04F8  3004  	MOVLW 0x04
04F9  1283  	BCF STATUS, RP0
04FA  00F9  	MOVWF delay_us_00000_arg_del
04FB  2010  	CALL delay_us_00000


        // Check the value of the onewire bus - set the MSB of cDataIn if so
        if (oneWireBus)
04FC  1A87  	BTFSC gbl_portc,5

            cDataIn.7 = 1;
04FD  17F3  	BSF oneWireRxB_00017_1_cDataIn,7


        // To finish time slot
        delay_10us(6); // 60us
04FE  3006  	MOVLW 0x06
04FF  00F8  	MOVWF delay_10us_00000_arg_del
0500  207A  	CALL delay_10us_00000

    }

    return cDataIn;
0503  0873  	MOVF oneWireRxB_00017_1_cDataIn, W
0504  00F4  	MOVWF CompTempVarRet549

}
0505  0008  	RETURN




/*********************************************************************************************
  void at24c32WriteAll()
  Write multiple bytes
  from https://www.instructables.com/The-Most-Comprehensive-Guide-to-Programming-the-AT/
*********************************************************************************************/
void at24c32WriteAll() {

	i2c_start();
05EC  212A  	CALL i2c_START_00000

	i2c_write(at24c32Addr); // address + write
05ED  30AE  	MOVLW 0xAE
05EE  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
05EF  20A9  	CALL i2c_WRITE_00000

	// start at address 0
	i2c_write(0); // First word address (only 4 bits of the 12 bit byte address)
05F0  01F6  	CLRF i2c_WRITE_00000_arg_i2c_data
05F1  20A9  	CALL i2c_WRITE_00000

	i2c_write(0); // Second word address
05F2  01F6  	CLRF i2c_WRITE_00000_arg_i2c_data
05F3  20A9  	CALL i2c_WRITE_00000

	// Write data bytes
	// We're only writing 18 bytes here, so no need to worry about row rollover after 32 bytes
	i2c_write(0x44); // To indicate AT24C32 has been written to
05F4  3044  	MOVLW 0x44
05F5  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
05F6  20A9  	CALL i2c_WRITE_00000

	i2c_write(gBcdWhiteOnMinute);
05F7  0854  	MOVF gbl_gBcdWhiteOnMinute, W
05F8  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
05F9  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOnHour);
05FA  0855  	MOVF gbl_gBcdWhiteOnHour, W
05FB  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
05FC  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOffMinute);
05FD  0856  	MOVF gbl_gBcdWhiteOffMinute, W
05FE  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
05FF  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOffHour);
0600  0857  	MOVF gbl_gBcdWhiteOffHour, W
0601  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
0602  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOnMinute);
0603  0858  	MOVF gbl_gBcdBlueOnMinute, W
0604  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
0605  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOnHour);
0606  0859  	MOVF gbl_gBcdBlueOnHour, W
0607  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
0608  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOffMinute);
0609  085A  	MOVF gbl_gBcdBlueOffMinute, W
060A  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
060B  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOffHour);
060C  085B  	MOVF gbl_gBcdBlueOffHour, W
060D  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
060E  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdFanOnTemp);
060F  0860  	MOVF gbl_gBcdFanOnTemp, W
0610  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
0611  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdFanOffTemp);
0612  0861  	MOVF gbl_gBcdFanOffTemp, W
0613  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
0614  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdHeaterOnTemp);
0615  0862  	MOVF gbl_gBcdHeaterOnTemp, W
0616  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
0617  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdHeaterOffTemp);
0618  0863  	MOVF gbl_gBcdHeaterOffTemp, W
0619  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
061A  20A9  	CALL i2c_WRITE_00000

    i2c_write(gcHourMode);
061B  0852  	MOVF gbl_gcHourMode, W
061C  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
061D  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlue2OnMinute);
061E  085C  	MOVF gbl_gBcdBlue2OnMinute, W
061F  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
0620  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlue2OnHour);
0621  085D  	MOVF gbl_gBcdBlue2OnHour, W
0622  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
0623  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlue2OffMinute);
0624  085E  	MOVF gbl_gBcdBlue2OffMinute, W
0625  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
0626  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlue2OffHour);
0627  085F  	MOVF gbl_gBcdBlue2OffHour, W
0628  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
0629  20A9  	CALL i2c_WRITE_00000

	i2c_stop();
062A  20FA  	CALL i2c_STOP_00000

	delay_ms(10); // Write Cycle Time
062B  300A  	MOVLW 0x0A
062C  00F4  	MOVWF delay_ms_00000_arg_del
062D  2084  	CALL delay_ms_00000

}
062E  0008  	RETURN


/*********************************************************************************************
  void at24c32ReadAll()
  Read all bytes
*********************************************************************************************/
void at24c32ReadAll() {

	i2c_start();
062F  212A  	CALL i2c_START_00000

	i2c_write(at24c32Addr); // address + write
0630  30AE  	MOVLW 0xAE
0631  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
0632  20A9  	CALL i2c_WRITE_00000

	// start at address 0
	i2c_write(0); // First word address (only 4 bits of the 12 bit byte address)
0633  01F6  	CLRF i2c_WRITE_00000_arg_i2c_data
0634  20A9  	CALL i2c_WRITE_00000

	i2c_write(0); // Second word address
0635  01F6  	CLRF i2c_WRITE_00000_arg_i2c_data
0636  20A9  	CALL i2c_WRITE_00000

	i2c_stop(); // Don't actually write a byte, just stop
0637  20FA  	CALL i2c_STOP_00000


	i2c_start();
0638  212A  	CALL i2c_START_00000

	i2c_write(at24c32Addr + 1); // address + read
0639  30AF  	MOVLW 0xAF
063A  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
063B  20A9  	CALL i2c_WRITE_00000

	char hasWritten = i2c_read(0); // ack
063C  01F6  	CLRF i2c_READ_00000_arg_ack_status
063D  21F5  	CALL i2c_READ_00000
063E  0879  	MOVF CompTempVarRet551, W
063F  00F4  	MOVWF at24c32Rea_00019_1_hasWritten

	if (hasWritten != 0x44) {
0640  0874  	MOVF at24c32Rea_00019_1_hasWritten, W
0641  3A44  	XORLW 0x44
0642  1903  	BTFSC STATUS,Z
0643  2E48  	GOTO	label106
0648        label106

		i2c_read(1); // nack
0644  3001  	MOVLW 0x01
0645  00F6  	MOVWF i2c_READ_00000_arg_ack_status
0646  21F5  	CALL i2c_READ_00000

	} else {
0647  2E8D  	GOTO	label107
068D        label107

		gBcdWhiteOnMinute = i2c_read(0); // ack
0648  01F6  	CLRF i2c_READ_00000_arg_ack_status
0649  21F5  	CALL i2c_READ_00000
064A  0879  	MOVF CompTempVarRet551, W
064B  00D4  	MOVWF gbl_gBcdWhiteOnMinute

		gBcdWhiteOnHour = i2c_read(0); // ack
064C  01F6  	CLRF i2c_READ_00000_arg_ack_status
064D  21F5  	CALL i2c_READ_00000
064E  0879  	MOVF CompTempVarRet551, W
064F  00D5  	MOVWF gbl_gBcdWhiteOnHour

		gBcdWhiteOffMinute = i2c_read(0); // ack
0650  01F6  	CLRF i2c_READ_00000_arg_ack_status
0651  21F5  	CALL i2c_READ_00000
0652  0879  	MOVF CompTempVarRet551, W
0653  00D6  	MOVWF gbl_gBcdWhiteOffMinute

		gBcdWhiteOffHour = i2c_read(0); // ack
0654  01F6  	CLRF i2c_READ_00000_arg_ack_status
0655  21F5  	CALL i2c_READ_00000
0656  0879  	MOVF CompTempVarRet551, W
0657  00D7  	MOVWF gbl_gBcdWhiteOffHour

		gBcdBlueOnMinute = i2c_read(0); // ack
0658  01F6  	CLRF i2c_READ_00000_arg_ack_status
0659  21F5  	CALL i2c_READ_00000
065A  0879  	MOVF CompTempVarRet551, W
065B  00D8  	MOVWF gbl_gBcdBlueOnMinute

		gBcdBlueOnHour = i2c_read(0); // ack
065C  01F6  	CLRF i2c_READ_00000_arg_ack_status
065D  21F5  	CALL i2c_READ_00000
065E  0879  	MOVF CompTempVarRet551, W
065F  00D9  	MOVWF gbl_gBcdBlueOnHour

		gBcdBlueOffMinute = i2c_read(0); // ack
0660  01F6  	CLRF i2c_READ_00000_arg_ack_status
0661  21F5  	CALL i2c_READ_00000
0662  0879  	MOVF CompTempVarRet551, W
0663  00DA  	MOVWF gbl_gBcdBlueOffMinute

		gBcdBlueOffHour = i2c_read(0); // ack
0664  01F6  	CLRF i2c_READ_00000_arg_ack_status
0665  21F5  	CALL i2c_READ_00000
0666  0879  	MOVF CompTempVarRet551, W
0667  00DB  	MOVWF gbl_gBcdBlueOffHour

		gBcdFanOnTemp = i2c_read(0); // ack
0668  01F6  	CLRF i2c_READ_00000_arg_ack_status
0669  21F5  	CALL i2c_READ_00000
066A  0879  	MOVF CompTempVarRet551, W
066B  00E0  	MOVWF gbl_gBcdFanOnTemp

		gBcdFanOffTemp = i2c_read(0); // ack
066C  01F6  	CLRF i2c_READ_00000_arg_ack_status
066D  21F5  	CALL i2c_READ_00000
066E  0879  	MOVF CompTempVarRet551, W
066F  00E1  	MOVWF gbl_gBcdFanOffTemp

		gBcdHeaterOnTemp = i2c_read(0); // ack
0670  01F6  	CLRF i2c_READ_00000_arg_ack_status
0671  21F5  	CALL i2c_READ_00000
0672  0879  	MOVF CompTempVarRet551, W
0673  00E2  	MOVWF gbl_gBcdHeaterOnTemp

		gBcdHeaterOffTemp = i2c_read(0); // ack
0674  01F6  	CLRF i2c_READ_00000_arg_ack_status
0675  21F5  	CALL i2c_READ_00000
0676  0879  	MOVF CompTempVarRet551, W
0677  00E3  	MOVWF gbl_gBcdHeaterOffTemp

		gcHourMode = i2c_read(0); // ack
0678  01F6  	CLRF i2c_READ_00000_arg_ack_status
0679  21F5  	CALL i2c_READ_00000
067A  0879  	MOVF CompTempVarRet551, W
067B  00D2  	MOVWF gbl_gcHourMode

		gBcdBlue2OnMinute = i2c_read(0); // ack
067C  01F6  	CLRF i2c_READ_00000_arg_ack_status
067D  21F5  	CALL i2c_READ_00000
067E  0879  	MOVF CompTempVarRet551, W
067F  00DC  	MOVWF gbl_gBcdBlue2OnMinute

		gBcdBlue2OnHour = i2c_read(0); // ack
0680  01F6  	CLRF i2c_READ_00000_arg_ack_status
0681  21F5  	CALL i2c_READ_00000
0682  0879  	MOVF CompTempVarRet551, W
0683  00DD  	MOVWF gbl_gBcdBlue2OnHour

		gBcdBlue2OffMinute = i2c_read(0); // ack
0684  01F6  	CLRF i2c_READ_00000_arg_ack_status
0685  21F5  	CALL i2c_READ_00000
0686  0879  	MOVF CompTempVarRet551, W
0687  00DE  	MOVWF gbl_gBcdBlue2OffMinute

		gBcdBlue2OffHour = i2c_read(1); // nack
0688  3001  	MOVLW 0x01
0689  00F6  	MOVWF i2c_READ_00000_arg_ack_status
068A  21F5  	CALL i2c_READ_00000
068B  0879  	MOVF CompTempVarRet551, W
068C  00DF  	MOVWF gbl_gBcdBlue2OffHour

	}
	i2c_stop();
068D  20FA  	CALL i2c_STOP_00000

}
068E  0008  	RETURN



/*********************************************************************************************
  void ds3231Write(char ds3231Reg, char bWrite)
  Write one byte
*********************************************************************************************/
void ds3231Write(char ds3231Reg, char bWrite) {

	i2c_start();
0249  212A  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
024A  30D0  	MOVLW 0xD0
024B  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
024C  20A9  	CALL i2c_WRITE_00000

	i2c_write(ds3231Reg); // start at address
024D  0874  	MOVF ds3231Writ_0001A_arg_ds3231Reg, W
024E  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
024F  20A9  	CALL i2c_WRITE_00000

	i2c_write(bWrite); // start at address
0250  0875  	MOVF ds3231Writ_0001A_arg_bWrite, W
0251  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
0252  20A9  	CALL i2c_WRITE_00000

	i2c_stop();
0253  20FA  	CALL i2c_STOP_00000

}
0254  0008  	RETURN


/*********************************************************************************************
  void ds3231Init()
  Initialise the DS3231
  from https://github.com/adafruit/RTClib
*********************************************************************************************/
void ds3231Init() {

	/* control register 0Eh
    bit7 EOSC   Enable Oscillator (1 if oscillator must be stopped when on battery)
    bit6 BBSQW  Battery Backed Square Wave - 0 means square wave disabled when VCC falls below VPF (power fail voltage)
    bit5 CONV   Convert temperature (1 forces a conversion)
    bit4 RS2    Rate select - frequency of square wave output - NA for DS3231M
    bit3 RS1    Rate select - NA for DS3231M
    bit2 INTCN  Interrupt control (1 for use of the alarms and to disable square wave)
    bit1 A2IE   Alarm2 interrupt enable (1 to enable)
    bit0 A1IE   Alarm1 interrupt enable (1 to enable)
    */
	ds3231Write(0x0E, 0x00);
054A  300E  	MOVLW 0x0E
054B  1283  	BCF STATUS, RP0
054C  1303  	BCF STATUS, RP1
054D  00F4  	MOVWF ds3231Writ_0001A_arg_ds3231Reg
054E  01F5  	CLRF ds3231Writ_0001A_arg_bWrite
054F  2249  	CALL ds3231Writ_0001A

	/* Status Register 0Fh
    bit7 OSF     Oscillator stopped flag - clear oscillator stop flag at init
    bit3 EN32kHz Enable 32kHz Output - 0 for disabled
    bit2 BSY     Busy
    bit1 A2F     Alarm 2 Flag
    bit0 A1F     Alarm 1 Flag
    */
	ds3231Write(0x0F, 0x00);
0550  300F  	MOVLW 0x0F
0551  00F4  	MOVWF ds3231Writ_0001A_arg_ds3231Reg
0552  01F5  	CLRF ds3231Writ_0001A_arg_bWrite
0553  2249  	CALL ds3231Writ_0001A

}
0554  0008  	RETURN


/*********************************************************************************************
  void ds3231WriteDateTime()
  Write the date to the DS3231
*********************************************************************************************/
void ds3231WriteDateTime() {

	i2c_start();
0519  212A  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
051A  30D0  	MOVLW 0xD0
051B  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
051C  20A9  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
051D  01F6  	CLRF i2c_WRITE_00000_arg_i2c_data
051E  20A9  	CALL i2c_WRITE_00000

	i2c_write(0); // seconds
051F  01F6  	CLRF i2c_WRITE_00000_arg_i2c_data
0520  20A9  	CALL i2c_WRITE_00000

	i2c_write(gBcdMinute); // minutes
0521  0836  	MOVF gbl_gBcdMinute, W
0522  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
0523  20A9  	CALL i2c_WRITE_00000

	i2c_write(gBcdHour); // hours
0524  0837  	MOVF gbl_gBcdHour, W
0525  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
0526  20A9  	CALL i2c_WRITE_00000

	i2c_write(gDayOfWeek); // day of week
0527  0838  	MOVF gbl_gDayOfWeek, W
0528  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
0529  20A9  	CALL i2c_WRITE_00000

	i2c_write(gBcdDayOfMonth); // day of month
052A  0839  	MOVF gbl_gBcdDayOfMonth, W
052B  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
052C  20A9  	CALL i2c_WRITE_00000

	i2c_write(gBcdMonth); // month + century
052D  083A  	MOVF gbl_gBcdMonth, W
052E  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
052F  20A9  	CALL i2c_WRITE_00000

	i2c_write(gBcdYear); // year
0530  083B  	MOVF gbl_gBcdYear, W
0531  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
0532  20A9  	CALL i2c_WRITE_00000

	i2c_stop();
0533  20FA  	CALL i2c_STOP_00000

}
0534  0008  	RETURN


/*********************************************************************************************
  void ds3231ReadDateTime()
  Write the date to the DS3231
*********************************************************************************************/
void ds3231ReadDateTime() {

	i2c_start();
08EA  118A  	BCF PCLATH,3
08EB  212A  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
08EC  30D0  	MOVLW 0xD0
08ED  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
08EE  20A9  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
08EF  01F6  	CLRF i2c_WRITE_00000_arg_i2c_data
08F0  20A9  	CALL i2c_WRITE_00000

	i2c_stop();
08F1  20FA  	CALL i2c_STOP_00000


	i2c_start();
08F2  212A  	CALL i2c_START_00000

	i2c_write(ds3231Addr + 1); // address + read
08F3  30D1  	MOVLW 0xD1
08F4  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
08F5  20A9  	CALL i2c_WRITE_00000

	gBcdSecond = i2c_read(0); // ack
08F6  01F6  	CLRF i2c_READ_00000_arg_ack_status
08F7  21F5  	CALL i2c_READ_00000
08F8  0879  	MOVF CompTempVarRet551, W
08F9  00B5  	MOVWF gbl_gBcdSecond

	gBcdMinute = i2c_read(0); // ack
08FA  01F6  	CLRF i2c_READ_00000_arg_ack_status
08FB  21F5  	CALL i2c_READ_00000
08FC  0879  	MOVF CompTempVarRet551, W
08FD  00B6  	MOVWF gbl_gBcdMinute

	gBcdHour = i2c_read(0); // ack
08FE  01F6  	CLRF i2c_READ_00000_arg_ack_status
08FF  21F5  	CALL i2c_READ_00000
0900  0879  	MOVF CompTempVarRet551, W
0901  00B7  	MOVWF gbl_gBcdHour

	gDayOfWeek = i2c_read(0); // ack
0902  01F6  	CLRF i2c_READ_00000_arg_ack_status
0903  21F5  	CALL i2c_READ_00000
0904  0879  	MOVF CompTempVarRet551, W
0905  00B8  	MOVWF gbl_gDayOfWeek

	gBcdDayOfMonth = i2c_read(0); // ack
0906  01F6  	CLRF i2c_READ_00000_arg_ack_status
0907  21F5  	CALL i2c_READ_00000
0908  0879  	MOVF CompTempVarRet551, W
0909  00B9  	MOVWF gbl_gBcdDayOfMonth

	gBcdMonth = i2c_read(0); // ack
090A  01F6  	CLRF i2c_READ_00000_arg_ack_status
090B  21F5  	CALL i2c_READ_00000
090C  0879  	MOVF CompTempVarRet551, W
090D  00BA  	MOVWF gbl_gBcdMonth

	gBcdYear = i2c_read(1); // nack
090E  3001  	MOVLW 0x01
090F  00F6  	MOVWF i2c_READ_00000_arg_ack_status
0910  21F5  	CALL i2c_READ_00000
0911  0879  	MOVF CompTempVarRet551, W
0912  00BB  	MOVWF gbl_gBcdYear

	i2c_stop();
0913  20FA  	CALL i2c_STOP_00000

}
0914  0008  	RETURN


/*********************************************************************************************
  char ds3231ReadRegister(char cRegAddress)
  Read one byte from a given DS3231 register address
*********************************************************************************************/
char ds3231ReadRegister(char cRegAddress) {

	char cStatus;
	i2c_start();
0535  212A  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
0536  30D0  	MOVLW 0xD0
0537  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
0538  20A9  	CALL i2c_WRITE_00000

	i2c_write(cRegAddress); // start at requested address
0539  0874  	MOVF ds3231Read_0001D_arg_cRegAddress, W
053A  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
053B  20A9  	CALL i2c_WRITE_00000

	i2c_stop();
053C  20FA  	CALL i2c_STOP_00000


	i2c_start();
053D  212A  	CALL i2c_START_00000

	i2c_write(ds3231Addr + 1); // address + read
053E  30D1  	MOVLW 0xD1
053F  00F6  	MOVWF i2c_WRITE_00000_arg_i2c_data
0540  20A9  	CALL i2c_WRITE_00000

	cStatus = i2c_read(1); // read the byte, then nack
0541  3001  	MOVLW 0x01
0542  00F6  	MOVWF i2c_READ_00000_arg_ack_status
0543  21F5  	CALL i2c_READ_00000
0544  0879  	MOVF CompTempVarRet551, W
0545  00F5  	MOVWF ds3231Read_0001D_1_cStatus

    i2c_stop();
0546  20FA  	CALL i2c_STOP_00000

    return cStatus;
0547  0875  	MOVF ds3231Read_0001D_1_cStatus, W
0548  00F6  	MOVWF CompTempVarRet552

}
0549  0008  	RETURN




/*********************************************************************************************
  void tm1638ByteWrite(char bWrite)
  Write one byte
  from http://www.piclearning.net/280/pic-and-tm1638-ledkey-module.php
*********************************************************************************************/
void tm1638ByteWrite(char bWrite) {

    for (char i = 0; i < 8; i++) {
0170  01F8  	CLRF tm1638Byte_0001E_2_i
0171        label25
0171  3008  	MOVLW 0x08
0172  0278  	SUBWF tm1638Byte_0001E_2_i, W
0173  1803  	BTFSC STATUS,C
0181  0AF8  	INCF tm1638Byte_0001E_2_i, F
0182  2971  	GOTO	label25

        tm1638dio = (bWrite & 0x01);
0175  3001  	MOVLW 0x01
0176  0577  	ANDWF tm1638Byte_0001E_arg_bWrite, W
0177  00F9  	MOVWF CompTempVar553
0178  1879  	BTFSC CompTempVar553,0
0179  1486  	BSF gbl_portb,1
017A  1C79  	BTFSS CompTempVar553,0
017B  1086  	BCF gbl_portb,1

        tm1638clk = 0;
017C  1106  	BCF gbl_portb,2

        bWrite = (bWrite >> 1);
017D  08F7  	MOVF tm1638Byte_0001E_arg_bWrite, F
017E  1003  	BCF STATUS,C
017F  0CF7  	RRF tm1638Byte_0001E_arg_bWrite, F

        tm1638clk = 1;
0180  1506  	BSF gbl_portb,2

    }
}
0174  0008  	RETURN


/*********************************************************************************************
  void tm1638DisplayOn()
  Turns the display on, with defined brightness
*********************************************************************************************/
void tm1638DisplayOn() {

    // Write 0x8F [10001000] to set display ON with pulse width 14/16
    tm1638strobe = 0;
04D9  1283  	BCF STATUS, RP0
04DA  1303  	BCF STATUS, RP1
04DB  1186  	BCF gbl_portb,3

    tm1638ByteWrite(0x88);
04DC  3088  	MOVLW 0x88
04DD  00F7  	MOVWF tm1638Byte_0001E_arg_bWrite
04DE  2170  	CALL tm1638Byte_0001E

    tm1638strobe = 1;
04DF  1586  	BSF gbl_portb,3

}
04E0  0008  	RETURN




/*********************************************************************************************
  void nibbleTo7Seg(char iNibble)
  Convert a single nibble into the 7-segment representation (two digits)
  7-segment digit to be written will be iPrintStartDigit, which is auto-incremented after
  If iPrintDotDigit matches, the dot on the display digit will be added
*********************************************************************************************/
void nibbleTo7Seg(char bNibble) {

	char s7SegDisplay = tm1638DisplayNumtoSeg[bNibble & 0x0F];
0090  0865  	MOVF gbl_tm1638DisplayNumtoSeg, W
0091  00FC  	MOVWF __rom_get_00000_arg_objNumb
0092  300F  	MOVLW 0x0F
0093  057A  	ANDWF nibbleTo7S_00020_arg_bNibble, W
0094  00FD  	MOVWF __rom_get_00000_arg_idx
0095  201A  	CALL __rom_get_00000
0096  1283  	BCF STATUS, RP0
0097  00FB  	MOVWF nibbleTo7S_00020_1_s7SegDisplay

	if (iPrintStartDigit == iPrintDotDigit)
0098  086F  	MOVF gbl_iPrintDotDigit, W
0099  066E  	XORWF gbl_iPrintStartDigit, W
009A  118A  	BCF PCLATH,3
009B  120A  	BCF PCLATH,4
009C  1D03  	BTFSS STATUS,Z
009D  28A0  	GOTO	label10
00A0        label10

        s7SegDisplay |= tm1638Dot;
009E  0866  	MOVF gbl_tm1638Dot, W
009F  04FB  	IORWF nibbleTo7S_00020_1_s7SegDisplay, F

    tm1638Data[iPrintStartDigit] = s7SegDisplay;
00A0  1383  	BCF	STATUS,IRP
00A1  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
00A2  0084  	MOVWF FSR
00A3  086E  	MOVF gbl_iPrintStartDigit, W
00A4  0784  	ADDWF FSR, F
00A5  087B  	MOVF nibbleTo7S_00020_1_s7SegDisplay, W
00A6  0080  	MOVWF INDF

    iPrintStartDigit++;
00A7  0AEE  	INCF gbl_iPrintStartDigit, F

}
00A8  0008  	RETURN


/*********************************************************************************************
  void bcdTo7Seg(char iBcdIn)
  Convert a single bcd byte into the 7-segment representation (two digits)
*********************************************************************************************/
void bcdTo7Seg(char iBcdIn) {

    nibbleTo7Seg(iBcdIn >> 4);
0255  0E79  	SWAPF bcdTo7Seg_00000_arg_iBcdIn, W
0256  390F  	ANDLW 0x0F
0257  00FA  	MOVWF nibbleTo7S_00020_arg_bNibble
0258  2090  	CALL nibbleTo7S_00020

    nibbleTo7Seg(iBcdIn);
0259  0879  	MOVF bcdTo7Seg_00000_arg_iBcdIn, W
025A  00FA  	MOVWF nibbleTo7S_00020_arg_bNibble
025B  2090  	CALL nibbleTo7S_00020

}
025C  0008  	RETURN


/*********************************************************************************************
  void zeroToBlank(char iDigit)
  For the given digit, change a zero to blank. Used for removing left filled zeroes
*********************************************************************************************/
void zeroToBlank(char iDigit) {

    // replace zero with blank
    if (tm1638Data[iDigit] == 0x3F)
015F  1383  	BCF	STATUS,IRP
0160  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
0161  0084  	MOVWF FSR
0162  0879  	MOVF zeroToBlan_00021_arg_iDigit, W
0163  0784  	ADDWF FSR, F
0164  0800  	MOVF INDF, W
0165  3A3F  	XORLW 0x3F
0166  1D03  	BTFSS STATUS,Z

        tm1638Data[iDigit] = 0;
0168  1383  	BCF	STATUS,IRP
0169  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
016A  0084  	MOVWF FSR
016B  0879  	MOVF zeroToBlan_00021_arg_iDigit, W
016C  0784  	ADDWF FSR, F
016D  3000  	MOVLW 0x00
016E  0080  	MOVWF INDF


}
0167  0008  	RETURN
016F  0008  	RETURN


/*********************************************************************************************
  void tm1638UpdateDisplay()
  Publish the tm1638Data and tm1638LEDs arrays to the display
*********************************************************************************************/
void tm1638UpdateDisplay() {


    // Display current temperature unless set, trigger or alt display mode is active
    if ((gcDisplayMode == 2) | gcSetMode | gcTriggerMode) {
02B4  1283  	BCF STATUS, RP0
02B5  1303  	BCF STATUS, RP1
02B6  01F4  	CLRF CompTempVar559
02B7  3002  	MOVLW 0x02
02B8  0250  	SUBWF gbl_gcDisplayMode, W
02B9  1903  	BTFSC STATUS,Z
02BA  0AF4  	INCF CompTempVar559, F
02BB  0851  	MOVF gbl_gcSetMode, W
02BC  04F4  	IORWF CompTempVar559, F
02BD  0853  	MOVF gbl_gcTriggerMode, W
02BE  0474  	IORWF CompTempVar559, W
02BF  1903  	BTFSC STATUS,Z
02C0  2C23  	GOTO	label82
0423        label82

        if (gcSetMode == 1) {
02C1  0351  	DECF gbl_gcSetMode, W
02C2  1D03  	BTFSS STATUS,Z
02C3  2AD0  	GOTO	label54
02D0        label54

            // Display year in the first 4 digits, for setting RTC year
            // Start printing from digit 0
            iDigitToFlash = 3; // 4th digit will flash
02C4  3003  	MOVLW 0x03
02C5  00C9  	MOVWF gbl_iDigitToFlash

            iPrintStartDigit = 0;
02C6  01EE  	CLRF gbl_iPrintStartDigit

            iPrintDotDigit = 3;
02C7  3003  	MOVLW 0x03
02C8  00EF  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(0x20); // Display 20 in digits 0 and 1 (no dot)
02C9  3020  	MOVLW 0x20
02CA  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02CB  2255  	CALL bcdTo7Seg_00000

            bcdTo7Seg(gBcdYear); // Display year in digits 2 and 3 (+dot on 3)
02CC  083B  	MOVF gbl_gBcdYear, W
02CD  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02CE  2255  	CALL bcdTo7Seg_00000

        } else if (gcSetMode == 4) {
02CF  2C51  	GOTO	label85
02D0  0851  	MOVF gbl_gcSetMode, W
02D1  3A04  	XORLW 0x04
02D2  1D03  	BTFSS STATUS,Z
02D3  2AE7  	GOTO	label55
02E7        label55

            // Display day of week - 'day' followed by number 1 to 7 on 4th digit, for setting RTC day of week
            iDigitToFlash = 3; // 4th digit will flash
02D4  3003  	MOVLW 0x03
02D5  00C9  	MOVWF gbl_iDigitToFlash

            tm1638Data[0] = 0x5E; // d
02D6  305E  	MOVLW 0x5E
02D7  00A0  	MOVWF gbl_tm1638Data

            tm1638Data[1] = 0x5F; // a
02D8  305F  	MOVLW 0x5F
02D9  00A1  	MOVWF gbl_tm1638Data+D'1'

            tm1638Data[2] = 0x6E; // y
02DA  306E  	MOVLW 0x6E
02DB  00A2  	MOVWF gbl_tm1638Data+D'2'

            tm1638Data[3] = tm1638DisplayNumtoSeg[gDayOfWeek] + tm1638Dot;
02DC  0865  	MOVF gbl_tm1638DisplayNumtoSeg, W
02DD  00FC  	MOVWF __rom_get_00000_arg_objNumb
02DE  0838  	MOVF gbl_gDayOfWeek, W
02DF  00FD  	MOVWF __rom_get_00000_arg_idx
02E0  201A  	CALL __rom_get_00000
02E1  1283  	BCF STATUS, RP0
02E2  0766  	ADDWF gbl_tm1638Dot, W
02E3  00A3  	MOVWF gbl_tm1638Data+D'3'

        } else if (gcSetMode == 5) {
02E4  118A  	BCF PCLATH,3
02E5  120A  	BCF PCLATH,4
02E6  2C51  	GOTO	label85
02E7  0851  	MOVF gbl_gcSetMode, W
02E8  3A05  	XORLW 0x05
02E9  1D03  	BTFSS STATUS,Z
02EA  2AFD  	GOTO	label58
02FD        label58

            // Display 24h or 12h setting in first 4 digits, for setting the time display preference
            iDigitToFlash = 1; // 2nd digit will flash
02EB  3001  	MOVLW 0x01
02EC  00C9  	MOVWF gbl_iDigitToFlash

            if (gcHourMode) {
02ED  08D2  	MOVF gbl_gcHourMode, F
02EE  1903  	BTFSC STATUS,Z
02EF  2AF5  	GOTO	label56
02F5        label56

				tm1638Data[0] = 0x06; // 1
02F0  3006  	MOVLW 0x06
02F1  00A0  	MOVWF gbl_tm1638Data

				tm1638Data[1] = 0x5B; // 2
02F2  305B  	MOVLW 0x5B
02F3  00A1  	MOVWF gbl_tm1638Data+D'1'

			} else {
02F4  2AF9  	GOTO	label57
02F9        label57

				tm1638Data[0] = 0x5B; // 2
02F5  305B  	MOVLW 0x5B
02F6  00A0  	MOVWF gbl_tm1638Data

				tm1638Data[1] = 0x66; // 4
02F7  3066  	MOVLW 0x66
02F8  00A1  	MOVWF gbl_tm1638Data+D'1'

			}
            tm1638Data[2] = 0x74; // h
02F9  3074  	MOVLW 0x74
02FA  00A2  	MOVWF gbl_tm1638Data+D'2'

            tm1638Data[3] = 0x00; // blank
02FB  01A3  	CLRF gbl_tm1638Data+D'3'

        } else if (gcTriggerMode) {
02FC  2C51  	GOTO	label85
02FD  08D3  	MOVF gbl_gcTriggerMode, F
02FE  1903  	BTFSC STATUS,Z
02FF  2BF6  	GOTO	label75
03F6        label75

            // Show relevant display of trigger time or temperature
            iPrintDotDigit = 5;
0300  3005  	MOVLW 0x05
0301  00EF  	MOVWF gbl_iPrintDotDigit

            switch (gcTriggerMode) {
0333  2C51  	GOTO	label85

                case 1:
0302  0853  	MOVF gbl_gcTriggerMode, W
0303  3A01  	XORLW 0x01
0304  1903  	BTFSC STATUS,Z
0305  2B34  	GOTO	label59
0334        label59

                    // White LED on hour, shows as 'L On' followed by hh:mm with 6th digit flashing
                    tm1638Data[0] = 0x38; // L
0334  3038  	MOVLW 0x38
0335  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x00; // space
0336  01A1  	CLRF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x3F; // O
0337  303F  	MOVLW 0x3F
0338  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x54; // n
0339  3054  	MOVLW 0x54
033A  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
033B  3005  	MOVLW 0x05
033C  00C9  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
033D  3004  	MOVLW 0x04
033E  00EE  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOnHour); // Display hour in digits 4 and 5 (dot on 5)
033F  0855  	MOVF gbl_gBcdWhiteOnHour, W
0340  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0341  2255  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdWhiteOnMinute); // Display minute in digits 6 and 7 (no dot)
0342  0854  	MOVF gbl_gBcdWhiteOnMinute, W
0343  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0344  2255  	CALL bcdTo7Seg_00000

                    break;
0345  2C51  	GOTO	label85

                case 2:
0306  3A03  	XORLW 0x03
0307  1903  	BTFSC STATUS,Z
0308  2B46  	GOTO	label60
0346        label60

                    // White LED on minute, shows as 'L On' followed by hh:mm with 8th digit flashing
                    iDigitToFlash = 7;
0346  3007  	MOVLW 0x07
0347  00C9  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0348  3006  	MOVLW 0x06
0349  00EE  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOnMinute); // Display minute in digits 6 and 7 (no dot)
034A  0854  	MOVF gbl_gBcdWhiteOnMinute, W
034B  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
034C  2255  	CALL bcdTo7Seg_00000

                    break;
034D  2C51  	GOTO	label85

                case 3:
0309  3A01  	XORLW 0x01
030A  1903  	BTFSC STATUS,Z
030B  2B4E  	GOTO	label61
034E        label61

                    // White LED off hour, shows as 'L OF' followed by hh:mm with 6th digit flashing
                    tm1638Data[3] = 0x71; // F
034E  3071  	MOVLW 0x71
034F  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
0350  3005  	MOVLW 0x05
0351  00C9  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
0352  3004  	MOVLW 0x04
0353  00EE  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOffHour);
0354  0857  	MOVF gbl_gBcdWhiteOffHour, W
0355  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0356  2255  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdWhiteOffMinute); // Display minute in digits 6 and 7 (no dot)
0357  0856  	MOVF gbl_gBcdWhiteOffMinute, W
0358  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0359  2255  	CALL bcdTo7Seg_00000

                    break;
035A  2C51  	GOTO	label85

                case 4:
030C  3A07  	XORLW 0x07
030D  1903  	BTFSC STATUS,Z
030E  2B5B  	GOTO	label62
035B        label62

                    // White LED off minute, shows as 'L OF' followed by hh:mm with 8th digit flashing
                    iDigitToFlash = 7;
035B  3007  	MOVLW 0x07
035C  00C9  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
035D  3006  	MOVLW 0x06
035E  00EE  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOffMinute); // Display minute in digits 6 and 7 (no dot)
035F  0856  	MOVF gbl_gBcdWhiteOffMinute, W
0360  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0361  2255  	CALL bcdTo7Seg_00000

                    break;
0362  2C51  	GOTO	label85

                case 5:
030F  3A01  	XORLW 0x01
0310  1903  	BTFSC STATUS,Z
0311  2B63  	GOTO	label63
0363        label63

                    // 1st Blue LED on hour, shows as 'b1On' followed by hh:mm with 6th digit flashing
                    tm1638Data[0] = 0x7C; // b
0363  307C  	MOVLW 0x7C
0364  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x06; // 1
0365  3006  	MOVLW 0x06
0366  00A1  	MOVWF gbl_tm1638Data+D'1'

                    //tm1638Data[2] = 0x3F; // O
                    tm1638Data[3] = 0x54; // n
0367  3054  	MOVLW 0x54
0368  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
0369  3005  	MOVLW 0x05
036A  00C9  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
036B  3004  	MOVLW 0x04
036C  00EE  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOnHour); // Display hour in digits 4 and 5 (dot on 5)
036D  0859  	MOVF gbl_gBcdBlueOnHour, W
036E  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
036F  2255  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlueOnMinute); // Display minute in digits 6 and 7 (no dot)
0370  0858  	MOVF gbl_gBcdBlueOnMinute, W
0371  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0372  2255  	CALL bcdTo7Seg_00000

                    break;
0373  2C51  	GOTO	label85

                case 6:
0312  3A03  	XORLW 0x03
0313  1903  	BTFSC STATUS,Z
0314  2B74  	GOTO	label64
0374        label64

                    // 1st Blue LED on minute, shows as 'b1On' followed by hh:mm with 8th digit flashing
                    iDigitToFlash = 7;
0374  3007  	MOVLW 0x07
0375  00C9  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0376  3006  	MOVLW 0x06
0377  00EE  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOnMinute); // Display minute in digits 6 and 7 (no dot)
0378  0858  	MOVF gbl_gBcdBlueOnMinute, W
0379  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
037A  2255  	CALL bcdTo7Seg_00000

                    break;
037B  2C51  	GOTO	label85

                case 7:
0315  3A01  	XORLW 0x01
0316  1903  	BTFSC STATUS,Z
0317  2B7C  	GOTO	label65
037C        label65

                    // 1st Blue LED off hour, shows as 'b1OF' followed by hh:mm with 6th digit flashing
                    tm1638Data[3] = 0x71; // F
037C  3071  	MOVLW 0x71
037D  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
037E  3005  	MOVLW 0x05
037F  00C9  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
0380  3004  	MOVLW 0x04
0381  00EE  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOffHour); // Display hour in digits 4 and 5 (dot on 5)
0382  085B  	MOVF gbl_gBcdBlueOffHour, W
0383  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0384  2255  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlueOffMinute); // Display minute in digits 6 and 7 (no dot)
0385  085A  	MOVF gbl_gBcdBlueOffMinute, W
0386  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0387  2255  	CALL bcdTo7Seg_00000

                    break;
0388  2C51  	GOTO	label85

                case 8:
0318  3A0F  	XORLW 0x0F
0319  1903  	BTFSC STATUS,Z
031A  2B89  	GOTO	label66
0389        label66

                    // 1st Blue LED off minute, shows as 'b1OF' followed by hh:mm with 8th digit flashing
                    iDigitToFlash = 7;
0389  3007  	MOVLW 0x07
038A  00C9  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
038B  3006  	MOVLW 0x06
038C  00EE  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOffMinute); // Display minute in digits 6 and 7 (no dot)
038D  085A  	MOVF gbl_gBcdBlueOffMinute, W
038E  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
038F  2255  	CALL bcdTo7Seg_00000

                    break;
0390  2C51  	GOTO	label85

                case 9:
031B  3A01  	XORLW 0x01
031C  1903  	BTFSC STATUS,Z
031D  2B91  	GOTO	label67
0391        label67

                    // 2nd Blue LED on hour, shows as 'b2On' followed by hh:mm with 6th digit flashing
                    tm1638Data[0] = 0x7C; // b
0391  307C  	MOVLW 0x7C
0392  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x5B; // 2
0393  305B  	MOVLW 0x5B
0394  00A1  	MOVWF gbl_tm1638Data+D'1'

                    //tm1638Data[2] = 0x3F; // O
                    tm1638Data[3] = 0x54; // n
0395  3054  	MOVLW 0x54
0396  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
0397  3005  	MOVLW 0x05
0398  00C9  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
0399  3004  	MOVLW 0x04
039A  00EE  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlue2OnHour); // Display hour in digits 4 and 5 (dot on 5)
039B  085D  	MOVF gbl_gBcdBlue2OnHour, W
039C  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
039D  2255  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlue2OnMinute); // Display minute in digits 6 and 7 (no dot)
039E  085C  	MOVF gbl_gBcdBlue2OnMinute, W
039F  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03A0  2255  	CALL bcdTo7Seg_00000

                    break;
03A1  2C51  	GOTO	label85

                case 10:
031E  3A03  	XORLW 0x03
031F  1903  	BTFSC STATUS,Z
0320  2BA2  	GOTO	label68
03A2        label68

                    // 2nd Blue LED on minute, shows as 'b2On' followed by hh:mm with 8th digit flashing
                    iDigitToFlash = 7;
03A2  3007  	MOVLW 0x07
03A3  00C9  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
03A4  3006  	MOVLW 0x06
03A5  00EE  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlue2OnMinute); // Display minute in digits 6 and 7 (no dot)
03A6  085C  	MOVF gbl_gBcdBlue2OnMinute, W
03A7  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03A8  2255  	CALL bcdTo7Seg_00000

                    break;
03A9  2C51  	GOTO	label85

                case 11:
0321  3A01  	XORLW 0x01
0322  1903  	BTFSC STATUS,Z
0323  2BAA  	GOTO	label69
03AA        label69

                    // 2nd Blue LED off hour, shows as 'b2OF' followed by hh:mm with 6th digit flashing
                    tm1638Data[3] = 0x71; // F
03AA  3071  	MOVLW 0x71
03AB  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
03AC  3005  	MOVLW 0x05
03AD  00C9  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
03AE  3004  	MOVLW 0x04
03AF  00EE  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlue2OffHour); // Display hour in digits 4 and 5 (dot on 5)
03B0  085F  	MOVF gbl_gBcdBlue2OffHour, W
03B1  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03B2  2255  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlue2OffMinute); // Display minute in digits 6 and 7 (no dot)
03B3  085E  	MOVF gbl_gBcdBlue2OffMinute, W
03B4  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03B5  2255  	CALL bcdTo7Seg_00000

                    break;
03B6  2C51  	GOTO	label85

                case 12:
0324  3A07  	XORLW 0x07
0325  1903  	BTFSC STATUS,Z
0326  2BB7  	GOTO	label70
03B7        label70

                    // 2nd Blue LED off minute, shows as 'b2OF' followed by hh:mm with 8th digit flashing
                    iDigitToFlash = 7;
03B7  3007  	MOVLW 0x07
03B8  00C9  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
03B9  3006  	MOVLW 0x06
03BA  00EE  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlue2OffMinute); // Display minute in digits 6 and 7 (no dot)
03BB  085E  	MOVF gbl_gBcdBlue2OffMinute, W
03BC  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03BD  2255  	CALL bcdTo7Seg_00000

                    break;
03BE  2C51  	GOTO	label85

                case 13:
0327  3A01  	XORLW 0x01
0328  1903  	BTFSC STATUS,Z
0329  2BBF  	GOTO	label71
03BF        label71

                    // Fan on temperature, shows as 'Fan On' followed by nn (temperature in degrees C) with 8th digit flashing
                    tm1638Data[0] = 0x71; // F
03BF  3071  	MOVLW 0x71
03C0  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x5F; // a
03C1  305F  	MOVLW 0x5F
03C2  00A1  	MOVWF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x54; // n
03C3  3054  	MOVLW 0x54
03C4  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x00; // space
03C5  01A3  	CLRF gbl_tm1638Data+D'3'

                    tm1638Data[4] = 0x3F; // O
03C6  303F  	MOVLW 0x3F
03C7  00A4  	MOVWF gbl_tm1638Data+D'4'

                    tm1638Data[5] = 0x54; // n
03C8  3054  	MOVLW 0x54
03C9  00A5  	MOVWF gbl_tm1638Data+D'5'

                    iDigitToFlash = 7;
03CA  3007  	MOVLW 0x07
03CB  00C9  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
03CC  3006  	MOVLW 0x06
03CD  00EE  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdFanOnTemp); // Display celsius in digits 6 and 7 (no dot)
03CE  0860  	MOVF gbl_gBcdFanOnTemp, W
03CF  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03D0  2255  	CALL bcdTo7Seg_00000

                    break;
03D1  2C51  	GOTO	label85

                case 14:
032A  3A03  	XORLW 0x03
032B  1903  	BTFSC STATUS,Z
032C  2BD2  	GOTO	label72
03D2        label72

                    // Fan off temperature, shows as 'Fan OF' followed by nn (temperature in degrees C) with 8th digit flashing
                    tm1638Data[5] = 0x71; // F
03D2  3071  	MOVLW 0x71
03D3  00A5  	MOVWF gbl_tm1638Data+D'5'

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
03D4  3006  	MOVLW 0x06
03D5  00EE  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdFanOffTemp); // Display celsius in digits 6 and 7 (no dot)
03D6  0861  	MOVF gbl_gBcdFanOffTemp, W
03D7  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03D8  2255  	CALL bcdTo7Seg_00000

                    break;
03D9  2C51  	GOTO	label85

                case 15:
032D  3A01  	XORLW 0x01
032E  1903  	BTFSC STATUS,Z
032F  2BDA  	GOTO	label73
03DA        label73

                    // Heater on temperature, shows as 'HeatOn' followed by nn (temperature in degrees C) with 8th digit flashing
                    tm1638Data[0] = 0x76; // H
03DA  3076  	MOVLW 0x76
03DB  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x7B; // e
03DC  307B  	MOVLW 0x7B
03DD  00A1  	MOVWF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x5F; // a
03DE  305F  	MOVLW 0x5F
03DF  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x78; // t
03E0  3078  	MOVLW 0x78
03E1  00A3  	MOVWF gbl_tm1638Data+D'3'

                    tm1638Data[4] = 0x3F; // O
03E2  303F  	MOVLW 0x3F
03E3  00A4  	MOVWF gbl_tm1638Data+D'4'

                    tm1638Data[5] = 0x54; // n
03E4  3054  	MOVLW 0x54
03E5  00A5  	MOVWF gbl_tm1638Data+D'5'

                    iDigitToFlash = 7;
03E6  3007  	MOVLW 0x07
03E7  00C9  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
03E8  3006  	MOVLW 0x06
03E9  00EE  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdHeaterOnTemp); // Display celsius in digits 6 and 7 (no dot)
03EA  0862  	MOVF gbl_gBcdHeaterOnTemp, W
03EB  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03EC  2255  	CALL bcdTo7Seg_00000

                    break;
03ED  2C51  	GOTO	label85

                case 16:
0330  3A1F  	XORLW 0x1F
0331  1903  	BTFSC STATUS,Z
0332  2BEE  	GOTO	label74
03EE        label74

                    // Heater off temperature, shows as 'HeatOF' followed by nn (temperature in degrees C) with 8th digit flashing
                    tm1638Data[5] = 0x71; // f
03EE  3071  	MOVLW 0x71
03EF  00A5  	MOVWF gbl_tm1638Data+D'5'

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
03F0  3006  	MOVLW 0x06
03F1  00EE  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdHeaterOffTemp); // Display celsius in digits 6 and 7 (no dot)
03F2  0863  	MOVF gbl_gBcdHeaterOffTemp, W
03F3  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03F4  2255  	CALL bcdTo7Seg_00000

                    break;
            }
        } else {
03F5  2C51  	GOTO	label85

            // If in set mode, set the relevant digit to flash
            switch (gcSetMode) {
0412        label81

                case 2:
03F6  0851  	MOVF gbl_gcSetMode, W
03F7  3A02  	XORLW 0x02
03F8  1903  	BTFSC STATUS,Z
03F9  2C04  	GOTO	label76
0404        label76

                    // Month
                    iDigitToFlash = 3;
0404  3003  	MOVLW 0x03
0405  00C9  	MOVWF gbl_iDigitToFlash

                    break;
0406  2C12  	GOTO	label81

                case 3:
03FA  3A01  	XORLW 0x01
03FB  1903  	BTFSC STATUS,Z
03FC  2C07  	GOTO	label77
0407        label77

                    // Day of month
                    iDigitToFlash = 1;
0407  3001  	MOVLW 0x01
0408  00C9  	MOVWF gbl_iDigitToFlash

                    break;
0409  2C12  	GOTO	label81

                case 6:
03FD  3A05  	XORLW 0x05
03FE  1903  	BTFSC STATUS,Z
03FF  2C0A  	GOTO	label78
040A        label78

                    // Clock Hour
                    iDigitToFlash = 5;
040A  3005  	MOVLW 0x05
040B  00C9  	MOVWF gbl_iDigitToFlash

                    break;
040C  2C12  	GOTO	label81

                case 7:
0400  3A01  	XORLW 0x01
0401  1903  	BTFSC STATUS,Z
0402  2C0D  	GOTO	label79
040D        label79

                    // Clock Minute
                    iDigitToFlash = 7;
040D  3007  	MOVLW 0x07
040E  00C9  	MOVWF gbl_iDigitToFlash

                    break;
040F  2C12  	GOTO	label81

                default:
0403  2C10  	GOTO	label80
0410        label80

                    iDigitToFlash = 8; // digit no flashing
0410  3008  	MOVLW 0x08
0411  00C9  	MOVWF gbl_iDigitToFlash

            }
            // Display date in DD.MM format when in set mode or gcDisplayMode = 2
            iPrintStartDigit = 0;
0412  01EE  	CLRF gbl_iPrintStartDigit

            iPrintDotDigit = 1;
0413  3001  	MOVLW 0x01
0414  00EF  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(gBcdDayOfMonth); // Display day of month in digits 0 and 1 (+dot on 1)
0415  0839  	MOVF gbl_gBcdDayOfMonth, W
0416  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0417  2255  	CALL bcdTo7Seg_00000

            zeroToBlank(0); // left fill zero with blank
0418  01F9  	CLRF zeroToBlan_00021_arg_iDigit
0419  215F  	CALL zeroToBlan_00021


            iPrintDotDigit = 3;
041A  3003  	MOVLW 0x03
041B  00EF  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(gBcdMonth); // Display month in digits 2 and 3 (+dot on 3)
041C  083A  	MOVF gbl_gBcdMonth, W
041D  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
041E  2255  	CALL bcdTo7Seg_00000

            zeroToBlank(2); // left fill zero with blank
041F  3002  	MOVLW 0x02
0420  00F9  	MOVWF zeroToBlan_00021_arg_iDigit
0421  215F  	CALL zeroToBlan_00021

        }
    } else {
0422  2C51  	GOTO	label85

        iDigitToFlash = 8; // No flashing digit in normal mode
0423  3008  	MOVLW 0x08
0424  00C9  	MOVWF gbl_iDigitToFlash

        // translate DS3231 temperature to digit values
        iPrintDotDigit = 1;
0425  3001  	MOVLW 0x01
0426  00EF  	MOVWF gbl_iPrintDotDigit

        if (gcDisplayMode == 1) // no dot on the first two digits for fahrenheit
0427  0350  	DECF gbl_gcDisplayMode, W
0428  1D03  	BTFSS STATUS,Z
0429  2C2C  	GOTO	label83
042C        label83

			iPrintDotDigit = 2;
042A  3002  	MOVLW 0x02
042B  00EF  	MOVWF gbl_iPrintDotDigit

        // For -10 or below, shift digits right
        if (gbDS3231IsMinus && (giDS3231ValueBCD & 0xF000)) {
042C  08CD  	MOVF gbl_gbDS3231IsMinus, F
042D  1903  	BTFSC STATUS,Z
042E  2C41  	GOTO	label84
042F  30F0  	MOVLW 0xF0
0430  0534  	ANDWF gbl_giDS3231ValueBCD+D'1', W
0431  1903  	BTFSC STATUS,Z
0432  2C41  	GOTO	label84
0441        label84

            giDS3231ValueBCD >>= 4;
0433  0D34  	RLF gbl_giDS3231ValueBCD+D'1', W
0434  0CB4  	RRF gbl_giDS3231ValueBCD+D'1', F
0435  0CB3  	RRF gbl_giDS3231ValueBCD, F
0436  0D34  	RLF gbl_giDS3231ValueBCD+D'1', W
0437  0CB4  	RRF gbl_giDS3231ValueBCD+D'1', F
0438  0CB3  	RRF gbl_giDS3231ValueBCD, F
0439  0D34  	RLF gbl_giDS3231ValueBCD+D'1', W
043A  0CB4  	RRF gbl_giDS3231ValueBCD+D'1', F
043B  0CB3  	RRF gbl_giDS3231ValueBCD, F
043C  0D34  	RLF gbl_giDS3231ValueBCD+D'1', W
043D  0CB4  	RRF gbl_giDS3231ValueBCD+D'1', F
043E  0CB3  	RRF gbl_giDS3231ValueBCD, F

            iPrintDotDigit = 2;
043F  3002  	MOVLW 0x02
0440  00EF  	MOVWF gbl_iPrintDotDigit

        }
        // Display current temperature in digits 0 to 3 (+dot on digit 1 and 3)
        iPrintStartDigit = 0;
0441  01EE  	CLRF gbl_iPrintStartDigit

        bcdTo7Seg(giDS3231ValueBCD >> 8);
0442  0834  	MOVF gbl_giDS3231ValueBCD+D'1', W
0443  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0444  2255  	CALL bcdTo7Seg_00000

        bcdTo7Seg(giDS3231ValueBCD);
0445  0833  	MOVF gbl_giDS3231ValueBCD, W
0446  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0447  2255  	CALL bcdTo7Seg_00000

        // Also display dot on 4th digit (always)
		tm1638Data[3] |= tm1638Dot;
0448  0866  	MOVF gbl_tm1638Dot, W
0449  04A3  	IORWF gbl_tm1638Data+D'3', F

        // left fill zero with blank (1st digit)
        zeroToBlank(0);
044A  01F9  	CLRF zeroToBlan_00021_arg_iDigit
044B  215F  	CALL zeroToBlan_00021

        // If minus, overwrite left most digit with minus sign
        if (gbDS3231IsMinus)
044C  08CD  	MOVF gbl_gbDS3231IsMinus, F
044D  1903  	BTFSC STATUS,Z
044E  2C51  	GOTO	label85
0451        label85

            tm1638Data[0] = 0x40;
044F  3040  	MOVLW 0x40
0450  00A0  	MOVWF gbl_tm1638Data

    }

    // Display clock HH.MM in last 4 digits of TM1638 (unless in trigger mode)
    if (!gcTriggerMode) {
0451  08D3  	MOVF gbl_gcTriggerMode, F
0452  1D03  	BTFSS STATUS,Z
0453  2C8B  	GOTO	label91
048B        label91

        // Flash dot every second
        if (gBcdSecond.0)
0454  1C35  	BTFSS gbl_gBcdSecond,0
0455  2C59  	GOTO	label86
0459        label86

			iPrintDotDigit = 5;
0456  3005  	MOVLW 0x05
0457  00EF  	MOVWF gbl_iPrintDotDigit

		else
0458  2C5B  	GOTO	label87
045B        label87

			iPrintDotDigit = 8;
0459  3008  	MOVLW 0x08
045A  00EF  	MOVWF gbl_iPrintDotDigit


        char cBcdHourDisp = gBcdHour;
045B  0837  	MOVF gbl_gBcdHour, W
045C  00F8  	MOVWF tm1638Upda_00022_198_cBcdH_00024

        // 12h clock handling - convert from 24h
        if (gcHourMode && (gBcdHour > 0x12)) {
045D  08D2  	MOVF gbl_gcHourMode, F
045E  1903  	BTFSC STATUS,Z
045F  2C6F  	GOTO	label88
0460  0837  	MOVF gbl_gBcdHour, W
0461  3C12  	SUBLW 0x12
0462  1803  	BTFSC STATUS,C
0463  2C6F  	GOTO	label88

			// convert to 12h
			cBcdHourDisp -= 0x12;
0464  3012  	MOVLW 0x12
0465  02F8  	SUBWF tm1638Upda_00022_198_cBcdH_00024, F

			// For 8 and 9pm, take off another 6
			if ((cBcdHourDisp & 0x0F) > 7)
0466  300F  	MOVLW 0x0F
0467  0578  	ANDWF tm1638Upda_00022_198_cBcdH_00024, W
0468  00F9  	MOVWF CompTempVar599
0469  0879  	MOVF CompTempVar599, W
046A  3C07  	SUBLW 0x07
046B  1803  	BTFSC STATUS,C
046C  2C6F  	GOTO	label88
046F        label88

                cBcdHourDisp -= 6;
046D  3006  	MOVLW 0x06
046E  02F8  	SUBWF tm1638Upda_00022_198_cBcdH_00024, F

        }
        if (gcHourMode && gBcdHour == 0) {
046F  08D2  	MOVF gbl_gcHourMode, F
0470  1903  	BTFSC STATUS,Z
0471  2C77  	GOTO	label89
0472  08B7  	MOVF gbl_gBcdHour, F
0473  1D03  	BTFSS STATUS,Z
0474  2C77  	GOTO	label89
0477        label89

			cBcdHourDisp = 0x12; // 12am
0475  3012  	MOVLW 0x12
0476  00F8  	MOVWF tm1638Upda_00022_198_cBcdH_00024

        }
        iPrintStartDigit = 4;
0477  3004  	MOVLW 0x04
0478  00EE  	MOVWF gbl_iPrintStartDigit

        bcdTo7Seg(cBcdHourDisp); // Display hour in digits 4 and 5 (dot on 5)
0479  0878  	MOVF tm1638Upda_00022_198_cBcdH_00024, W
047A  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
047B  2255  	CALL bcdTo7Seg_00000

        // left fill zero with blank (for 5th digit)
        zeroToBlank(4);
047C  3004  	MOVLW 0x04
047D  00F9  	MOVWF zeroToBlan_00021_arg_iDigit
047E  215F  	CALL zeroToBlan_00021

        if (gcHourMode && (gBcdHour > 0x11)) {
047F  08D2  	MOVF gbl_gcHourMode, F
0480  1903  	BTFSC STATUS,Z
0481  2C88  	GOTO	label90
0482  0837  	MOVF gbl_gBcdHour, W
0483  3C11  	SUBLW 0x11
0484  1803  	BTFSC STATUS,C
0485  2C88  	GOTO	label90
0488        label90

			// PM dot
			iPrintDotDigit = 7;
0486  3007  	MOVLW 0x07
0487  00EF  	MOVWF gbl_iPrintDotDigit

        }
        bcdTo7Seg(gBcdMinute); // Display minute in digits 6 and 7 (no dot)
0488  0836  	MOVF gbl_gBcdMinute, W
0489  00F9  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
048A  2255  	CALL bcdTo7Seg_00000

    }

    // Light LED for set mode
    char cCompareSetMode = gcSetMode;
048B  0851  	MOVF gbl_gcSetMode, W
048C  00F5  	MOVWF tm1638Upda_00022_1_cCompar_00023

    for (char i = 2; i < 8; i++) {
048D  3002  	MOVLW 0x02
048E  00F7  	MOVWF tm1638Upda_00022_3_i
048F        label92
048F  3008  	MOVLW 0x08
0490  0277  	SUBWF tm1638Upda_00022_3_i, W
0491  1803  	BTFSC STATUS,C
0492  2CA8  	GOTO	label95
04A6  0AF7  	INCF tm1638Upda_00022_3_i, F
04A7  2C8F  	GOTO	label92
04A8        label95

        if (i == cCompareSetMode)
0493  0875  	MOVF tm1638Upda_00022_1_cCompar_00023, W
0494  0677  	XORWF tm1638Upda_00022_3_i, W
0495  1D03  	BTFSS STATUS,Z
0496  2C9F  	GOTO	label93
049F        label93

            tm1638LEDs[i] = 1;
0497  1383  	BCF	STATUS,IRP
0498  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
0499  0084  	MOVWF FSR
049A  0877  	MOVF tm1638Upda_00022_3_i, W
049B  0784  	ADDWF FSR, F
049C  3001  	MOVLW 0x01
049D  0080  	MOVWF INDF

        else
049E  2CA6  	GOTO	label94
04A6        label94

            tm1638LEDs[i] = 0;
049F  1383  	BCF	STATUS,IRP
04A0  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
04A1  0084  	MOVWF FSR
04A2  0877  	MOVF tm1638Upda_00022_3_i, W
04A3  0784  	ADDWF FSR, F
04A4  3000  	MOVLW 0x00
04A5  0080  	MOVWF INDF

    }
    tm1638LEDs[0] = HEATER; // Light 1st LED if the heater is on
04A8  01A8  	CLRF gbl_tm1638LEDs
04A9  1805  	BTFSC gbl_porta,0
04AA  0AA8  	INCF gbl_tm1638LEDs, F

    tm1638LEDs[1] = FAN; // Light 2nd LED if the fans are on
04AB  01A9  	CLRF gbl_tm1638LEDs+D'1'
04AC  1885  	BTFSC gbl_porta,1
04AD  0AA9  	INCF gbl_tm1638LEDs+D'1', F


    // Now we have the data for the LED 7-segment display and LEDs, push these to the TM1638

    // Write 0x40 [01000000] (table 5.1) to indicate command to display data - [Write data to display register]
    tm1638strobe = 0;
04AE  1186  	BCF gbl_portb,3

    tm1638ByteWrite(tm1638ByteSetData);
04AF  0868  	MOVF gbl_tm1638ByteSetData, W
04B0  00F7  	MOVWF tm1638Byte_0001E_arg_bWrite
04B1  2170  	CALL tm1638Byte_0001E

    tm1638strobe = 1;
04B2  1586  	BSF gbl_portb,3


    // Specify the display address 0xC0 [11000000] (table 5.2) [Display address 00H] then write out all 16 bytes
    tm1638strobe = 0;
04B3  1186  	BCF gbl_portb,3

    tm1638ByteWrite(tm1638ByteSetAddr);
04B4  086A  	MOVF gbl_tm1638ByteSetAddr, W
04B5  00F7  	MOVWF tm1638Byte_0001E_arg_bWrite
04B6  2170  	CALL tm1638Byte_0001E

    for (char i = 0; i < tm1638MaxDigits; i++) {
04B7  01F6  	CLRF tm1638Upda_00022_2_i
04B8        label96
04B8  0864  	MOVF gbl_tm1638MaxDigits, W
04B9  0276  	SUBWF tm1638Upda_00022_2_i, W
04BA  1803  	BTFSC STATUS,C
04BB  2CD7  	GOTO	label99
04D5  0AF6  	INCF tm1638Upda_00022_2_i, F
04D6  2CB8  	GOTO	label96
04D7        label99

        // display 7-segment digit first
        // If flashing the digit, alternate a blank output
        if (iFlashDigitOff.0 && (i == iDigitToFlash))
04BC  1C48  	BTFSS gbl_iFlashDigitOff,0
04BD  2CC5  	GOTO	label97
04BE  0849  	MOVF gbl_iDigitToFlash, W
04BF  0676  	XORWF tm1638Upda_00022_2_i, W
04C0  1D03  	BTFSS STATUS,Z
04C1  2CC5  	GOTO	label97
04C5        label97

            tm1638ByteWrite(0);
04C2  01F7  	CLRF tm1638Byte_0001E_arg_bWrite
04C3  2170  	CALL tm1638Byte_0001E

        else
04C4  2CCD  	GOTO	label98
04CD        label98

            tm1638ByteWrite(tm1638Data[i]);
04C5  1383  	BCF	STATUS,IRP
04C6  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
04C7  0084  	MOVWF FSR
04C8  0876  	MOVF tm1638Upda_00022_2_i, W
04C9  0784  	ADDWF FSR, F
04CA  0800  	MOVF INDF, W
04CB  00F7  	MOVWF tm1638Byte_0001E_arg_bWrite
04CC  2170  	CALL tm1638Byte_0001E

        // then LED
        tm1638ByteWrite(tm1638LEDs[i]);
04CD  1383  	BCF	STATUS,IRP
04CE  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
04CF  0084  	MOVWF FSR
04D0  0876  	MOVF tm1638Upda_00022_2_i, W
04D1  0784  	ADDWF FSR, F
04D2  0800  	MOVF INDF, W
04D3  00F7  	MOVWF tm1638Byte_0001E_arg_bWrite
04D4  2170  	CALL tm1638Byte_0001E

    }
    tm1638strobe = 1;
04D7  1586  	BSF gbl_portb,3

}
04D8  0008  	RETURN


/*********************************************************************************************
  void tm1638ReadKeys()
  Reads the keys status into tm1638Keys
  from http://www.piclearning.net/280/pic-and-tm1638-ledkey-module.php
*********************************************************************************************/
void tm1638ReadKeys() {

    // Write 0x42 [01000010] to indicate command to read data
    tm1638strobe = 0;
07E9  1283  	BCF STATUS, RP0
07EA  1303  	BCF STATUS, RP1
07EB  1186  	BCF gbl_portb,3

    tm1638ByteWrite(tm1638ByteReadData);
07EC  0869  	MOVF gbl_tm1638ByteReadData, W
07ED  00F7  	MOVWF tm1638Byte_0001E_arg_bWrite
07EE  2170  	CALL tm1638Byte_0001E


    tm1638dioTris = 1; // Set data pin to input
07EF  1683  	BSF STATUS, RP0
07F0  1486  	BSF gbl_trisb,1

    char tm1638KeysTemp = 32;
07F1  3020  	MOVLW 0x20
07F2  1283  	BCF STATUS, RP0
07F3  00F4  	MOVWF tm1638Read_00025_1_tm1638K_00026

    // Read 4 bytes
    for (char i = 0; i < 32; i++) {
07F4  01F5  	CLRF tm1638Read_00025_2_i
07F5        label137
07F5  3020  	MOVLW 0x20
07F6  0275  	SUBWF tm1638Read_00025_2_i, W
07F7  158A  	BSF PCLATH,3
07F8  1803  	BTFSC STATUS,C
07F9  2805  	GOTO	label139
0802  0AF5  	INCF tm1638Read_00025_2_i, F
0803  118A  	BCF PCLATH,3
0804  2FF5  	GOTO	label137
0805        label139

        tm1638KeysTemp--;
07FA  03F4  	DECF tm1638Read_00025_1_tm1638K_00026, F

        tm1638clk = 0;
07FB  1106  	BCF gbl_portb,2

        //delay_us(1);
        nop();
07FC  0000  	NOP

        if(tm1638dio)
07FD  1C86  	BTFSS gbl_portb,1
07FE  2801  	GOTO	label138
0801        label138

            tm1638KeysTemp <<= 1;
07FF  1003  	BCF STATUS,C
0800  0DF4  	RLF tm1638Read_00025_1_tm1638K_00026, F

        tm1638clk = 1;
0801  1506  	BSF gbl_portb,2

    }
    tm1638dioTris = 0; // Set data pin to output
0805  1683  	BSF STATUS, RP0
0806  1086  	BCF gbl_trisb,1

    tm1638strobe = 1;
0807  1283  	BCF STATUS, RP0
0808  1586  	BSF gbl_portb,3


    tm1638Keys = tm1638KeysTemp;
0809  0874  	MOVF tm1638Read_00025_1_tm1638K_00026, W
080A  00EC  	MOVWF gbl_tm1638Keys

    /*
    1F = 0001 1111
	17 = 0001 0111
	0F = 0000 1111
	07 = 0000 0111
	1B = 0001 1011
	13 = 0001 0011
	0B = 0000 1011
	03 = 0000 0111
	*/
}
080B  0008  	RETURN


/*********************************************************************************************
  int intToBcd(int iValue)
  Used to split the 16 bit integer into bcd parts (max 9999)
*********************************************************************************************/
int intToBcd(int iValue) {

    int iBcdOut = 0;
019F  1683  	BSF STATUS, RP0
01A0  01A0  	CLRF intToBcd_00000_1_iBcdOut
01A1  01A1  	CLRF intToBcd_00000_1_iBcdOut+D'1'

    // Split via loops = less program memory needed, may be slower executing
    // https://electronics.stackexchange.com/questions/158563/how-to-split-a-floating-point-number-into-individual-digits
    iBcdOut = 0;
01A2  01A0  	CLRF intToBcd_00000_1_iBcdOut
01A3  01A1  	CLRF intToBcd_00000_1_iBcdOut+D'1'


    // incrementing variables for each digit
    // determine to thousands digit
    while (iValue >= 1000) {
01A4        label28
01A4  3003  	MOVLW 0x03
01A5  1283  	BCF STATUS, RP0
01A6  027D  	SUBWF intToBcd_00000_arg_iValue+D'1', W
01A7  1D03  	BTFSS STATUS,Z
01A8  29AB  	GOTO	label29
01A9  30E8  	MOVLW 0xE8
01AA  027C  	SUBWF intToBcd_00000_arg_iValue, W
01AB        label29
01AB  1C03  	BTFSS STATUS,C
01AC  29B9  	GOTO	label30
01AD  1BFD  	BTFSC intToBcd_00000_arg_iValue+D'1',7
01AE  29B9  	GOTO	label30
01B8  29A4  	GOTO	label28
01B9        label30

        iValue -= 1000;
01AF  30E8  	MOVLW 0xE8
01B0  02FC  	SUBWF intToBcd_00000_arg_iValue, F
01B1  3003  	MOVLW 0x03
01B2  1C03  	BTFSS STATUS,C
01B3  03FD  	DECF intToBcd_00000_arg_iValue+D'1', F
01B4  02FD  	SUBWF intToBcd_00000_arg_iValue+D'1', F

        // each time we take off 1000, the digit is incremented
        iBcdOut += 0x1000;
01B5  3010  	MOVLW 0x10
01B6  1683  	BSF STATUS, RP0
01B7  07A1  	ADDWF intToBcd_00000_1_iBcdOut+D'1', F

    }

    // determine to hundreds digit
    while (iValue >= 100) {
01B9  1283  	BCF STATUS, RP0
01BA  087D  	MOVF intToBcd_00000_arg_iValue+D'1', W
01BB  3A80  	XORLW 0x80
01BC  1683  	BSF STATUS, RP0
01BD  00A2  	MOVWF CompTempVar639
01BE  3080  	MOVLW 0x80
01BF  0222  	SUBWF CompTempVar639, W
01C0  1D03  	BTFSS STATUS,Z
01C1  29C5  	GOTO	label31
01C2  3064  	MOVLW 0x64
01C3  1283  	BCF STATUS, RP0
01C4  027C  	SUBWF intToBcd_00000_arg_iValue, W
01C5        label31
01C5  1C03  	BTFSS STATUS,C
01C6  29CF  	GOTO	label32
01CE  29B9  	GOTO	label30
01CF        label32

        iValue -= 100;
01C7  3064  	MOVLW 0x64
01C8  1283  	BCF STATUS, RP0
01C9  02FC  	SUBWF intToBcd_00000_arg_iValue, F
01CA  1C03  	BTFSS STATUS,C
01CB  03FD  	DECF intToBcd_00000_arg_iValue+D'1', F

        // each time we take off 100, the digit is incremented
        iBcdOut += 0x100;
01CC  1683  	BSF STATUS, RP0
01CD  0AA1  	INCF intToBcd_00000_1_iBcdOut+D'1', F

    }

    // determine to tens digit
    while (iValue >= 10) {
01CF  1283  	BCF STATUS, RP0
01D0  087D  	MOVF intToBcd_00000_arg_iValue+D'1', W
01D1  3A80  	XORLW 0x80
01D2  1683  	BSF STATUS, RP0
01D3  00A2  	MOVWF CompTempVar640
01D4  3080  	MOVLW 0x80
01D5  0222  	SUBWF CompTempVar640, W
01D6  1D03  	BTFSS STATUS,Z
01D7  29DB  	GOTO	label33
01D8  300A  	MOVLW 0x0A
01D9  1283  	BCF STATUS, RP0
01DA  027C  	SUBWF intToBcd_00000_arg_iValue, W
01DB        label33
01DB  1C03  	BTFSS STATUS,C
01DC  29E8  	GOTO	label34
01E7  29CF  	GOTO	label32
01E8        label34

        iValue -= 10;
01DD  300A  	MOVLW 0x0A
01DE  1283  	BCF STATUS, RP0
01DF  02FC  	SUBWF intToBcd_00000_arg_iValue, F
01E0  1C03  	BTFSS STATUS,C
01E1  03FD  	DECF intToBcd_00000_arg_iValue+D'1', F

        // each time we take off 10, the left most digit is incremented
        iBcdOut += 0x10;
01E2  3010  	MOVLW 0x10
01E3  1683  	BSF STATUS, RP0
01E4  07A0  	ADDWF intToBcd_00000_1_iBcdOut, F
01E5  1803  	BTFSC STATUS,C
01E6  0AA1  	INCF intToBcd_00000_1_iBcdOut+D'1', F

    }

    // the last digit is what's left on iValue
    iBcdOut += iValue;
01E8  1283  	BCF STATUS, RP0
01E9  087C  	MOVF intToBcd_00000_arg_iValue, W
01EA  1683  	BSF STATUS, RP0
01EB  07A0  	ADDWF intToBcd_00000_1_iBcdOut, F
01EC  1283  	BCF STATUS, RP0
01ED  087D  	MOVF intToBcd_00000_arg_iValue+D'1', W
01EE  1C03  	BTFSS STATUS,C
01EF  29F2  	GOTO	label35
01F0  1683  	BSF STATUS, RP0
01F1  0AA1  	INCF intToBcd_00000_1_iBcdOut+D'1', F
01F2  1683  	BSF STATUS, RP0
01F3  07A1  	ADDWF intToBcd_00000_1_iBcdOut+D'1', F

}
01F4  0008  	RETURN


/*********************************************************************************************
  void convertTemp()
  Used to convert the ds18b20 temperature to display values
*********************************************************************************************/
void convertTemp() {

    // convert both bytes to a 16bit int - e.g. 0000 0001 0100 0110 (1 and 70, gives 326)
    signed int iTemp = (cTempH << 8) | cTempL;
0555  1283  	BCF STATUS, RP0
0556  1303  	BCF STATUS, RP1
0557  01F4  	CLRF convertTem_00027_1_iTemp
0558  084A  	MOVF gbl_cTempH, W
0559  00F5  	MOVWF convertTem_00027_1_iTemp+D'1'
055A  084B  	MOVF gbl_cTempL, W
055B  04F4  	IORWF convertTem_00027_1_iTemp, F

    signed int iTemp2 = iTemp;
055C  0874  	MOVF convertTem_00027_1_iTemp, W
055D  00F6  	MOVWF convertTem_00027_1_iTemp2
055E  0875  	MOVF convertTem_00027_1_iTemp+D'1', W
055F  00F7  	MOVWF convertTem_00027_1_iTemp2+D'1'

    // Compare to previous and ignore erroneous readings
    // Ignore startup reading (85 degrees - 1360) or anything greater
    if (iTemp > 1359)
0560  3C05  	SUBLW 0x05
0561  1D03  	BTFSS STATUS,Z
0562  2D65  	GOTO	label102
0563  0874  	MOVF convertTem_00027_1_iTemp, W
0564  3C4F  	SUBLW 0x4F
0565        label102
0565  1803  	BTFSC STATUS,C
0566  2D6A  	GOTO	label103
0567  1BF5  	BTFSC convertTem_00027_1_iTemp+D'1',7
0568  2D6A  	GOTO	label103
056A        label103

        return;

    // this gets celsius * 100 - https://www.phanderson.com/PIC/PICC/sourceboost/ds18b20_1.html
    // celsius value is always required for triggering
	gbDS3231IsMinus = (iTemp2 < 0);
056A  01CD  	CLRF gbl_gbDS3231IsMinus
056B  1BF7  	BTFSC convertTem_00027_1_iTemp2+D'1',7
056C  0ACD  	INCF gbl_gbDS3231IsMinus, F

	if (gbDS3231IsMinus) {
056D  08CD  	MOVF gbl_gbDS3231IsMinus, F
056E  1903  	BTFSC STATUS,Z
056F  2D75  	GOTO	label104

		iTemp2 = ~iTemp2 + 1;
0570  09F6  	COMF convertTem_00027_1_iTemp2, F
0571  09F7  	COMF convertTem_00027_1_iTemp2+D'1', F
0572  0AF6  	INCF convertTem_00027_1_iTemp2, F
0573  1903  	BTFSC STATUS,Z
0574  0AF7  	INCF convertTem_00027_1_iTemp2+D'1', F
0575        label104

	}
    int iValueC = (6 * iTemp2) + (iTemp2 / 4);
0575  3006  	MOVLW 0x06
0576  00FC  	MOVWF __mul_16s__0000F_arg_a
0577  01FD  	CLRF __mul_16s__0000F_arg_a+D'1'
0578  0876  	MOVF convertTem_00027_1_iTemp2, W
0579  1683  	BSF STATUS, RP0
057A  00A0  	MOVWF __mul_16s__0000F_arg_b
057B  1283  	BCF STATUS, RP0
057C  0877  	MOVF convertTem_00027_1_iTemp2+D'1', W
057D  1683  	BSF STATUS, RP0
057E  00A1  	MOVWF __mul_16s__0000F_arg_b+D'1'
057F  2287  	CALL __mul_16s__0000F
0580  0825  	MOVF CompTempVarRet387, W
0581  1283  	BCF STATUS, RP0
0582  00F8  	MOVWF convertTem_00027_1_iValueC
0583  1683  	BSF STATUS, RP0
0584  0826  	MOVF CompTempVarRet387+D'1', W
0585  1283  	BCF STATUS, RP0
0586  00FB  	MOVWF CompTempVar617
0587  0876  	MOVF convertTem_00027_1_iTemp2, W
0588  00FA  	MOVWF CompTempVar614
0589  0877  	MOVF convertTem_00027_1_iTemp2+D'1', W
058A  00F9  	MOVWF convertTem_00027_1_iValueC+D'1'
058B  0D77  	RLF convertTem_00027_1_iTemp2+D'1', W
058C  0CF9  	RRF convertTem_00027_1_iValueC+D'1', F
058D  0CFA  	RRF CompTempVar614, F
058E  0D77  	RLF convertTem_00027_1_iTemp2+D'1', W
058F  0CF9  	RRF convertTem_00027_1_iValueC+D'1', F
0590  0CFA  	RRF CompTempVar614, F
0591  087A  	MOVF CompTempVar614, W
0592  07F8  	ADDWF convertTem_00027_1_iValueC, F
0593  087B  	MOVF CompTempVar617, W
0594  1803  	BTFSC STATUS,C
0595  0AF9  	INCF convertTem_00027_1_iValueC+D'1', F
0596  07F9  	ADDWF convertTem_00027_1_iValueC+D'1', F

    // Split the temperature reading into digits
    giDS3231ValueBCD = intToBcd(iValueC);
0597  0878  	MOVF convertTem_00027_1_iValueC, W
0598  00FC  	MOVWF intToBcd_00000_arg_iValue
0599  0879  	MOVF convertTem_00027_1_iValueC+D'1', W
059A  00FD  	MOVWF intToBcd_00000_arg_iValue+D'1'
059B  219F  	CALL intToBcd_00000
059C  0820  	MOVF CompTempVarRet638, W
059D  1283  	BCF STATUS, RP0
059E  00B3  	MOVWF gbl_giDS3231ValueBCD
059F  1683  	BSF STATUS, RP0
05A0  0821  	MOVF CompTempVarRet638+D'1', W
05A1  1283  	BCF STATUS, RP0
05A2  00B4  	MOVWF gbl_giDS3231ValueBCD+D'1'

    // Truncated value for triggering heater/fans
    giDS3231ValueTruncCBCD = giDS3231ValueBCD >> 8;
05A3  0834  	MOVF gbl_giDS3231ValueBCD+D'1', W
05A4  00CC  	MOVWF gbl_giDS3231ValueTruncCBCD


    if (gcDisplayMode == 1) {
05A5  0350  	DECF gbl_gcDisplayMode, W
05A6  1D03  	BTFSS STATUS,Z

		// -17.8125 (-285/65251) results in minus fahrenheit (-0.125), -17.75 (-284/65250) results in positive fahrenheit (1)
        // this gets Fahrenheit * 10 - https://www.electro-tech-online.com/threads/temperature-sensor-ds18b20-display-fahrenhiet.117377/
        iTemp2 = ((iTemp + 4) / 8) + iTemp + 320;
05A8  3004  	MOVLW 0x04
05A9  0774  	ADDWF convertTem_00027_1_iTemp, W
05AA  00FD  	MOVWF CompTempVar629
05AB  0875  	MOVF convertTem_00027_1_iTemp+D'1', W
05AC  1683  	BSF STATUS, RP0
05AD  00A0  	MOVWF CompTempVar632
05AE  1803  	BTFSC STATUS,C
05AF  0AA0  	INCF CompTempVar632, F
05B0  0820  	MOVF CompTempVar632, W
05B1  1283  	BCF STATUS, RP0
05B2  00FC  	MOVWF CompTempVar626
05B3  1683  	BSF STATUS, RP0
05B4  0D20  	RLF CompTempVar632, W
05B5  1283  	BCF STATUS, RP0
05B6  0CFC  	RRF CompTempVar626, F
05B7  0CFD  	RRF CompTempVar629, F
05B8  1683  	BSF STATUS, RP0
05B9  0D20  	RLF CompTempVar632, W
05BA  1283  	BCF STATUS, RP0
05BB  0CFC  	RRF CompTempVar626, F
05BC  0CFD  	RRF CompTempVar629, F
05BD  1683  	BSF STATUS, RP0
05BE  0D20  	RLF CompTempVar632, W
05BF  1283  	BCF STATUS, RP0
05C0  0CFC  	RRF CompTempVar626, F
05C1  0CFD  	RRF CompTempVar629, F
05C2  0874  	MOVF convertTem_00027_1_iTemp, W
05C3  07FD  	ADDWF CompTempVar629, F
05C4  0875  	MOVF convertTem_00027_1_iTemp+D'1', W
05C5  00FE  	MOVWF CompTempVar630
05C6  087C  	MOVF CompTempVar626, W
05C7  1803  	BTFSC STATUS,C
05C8  0AFE  	INCF CompTempVar630, F
05C9  07FE  	ADDWF CompTempVar630, F
05CA  3040  	MOVLW 0x40
05CB  07FD  	ADDWF CompTempVar629, F
05CC  3001  	MOVLW 0x01
05CD  1803  	BTFSC STATUS,C
05CE  0AFE  	INCF CompTempVar630, F
05CF  07FE  	ADDWF CompTempVar630, F
05D0  087D  	MOVF CompTempVar629, W
05D1  00F6  	MOVWF convertTem_00027_1_iTemp2
05D2  087E  	MOVF CompTempVar630, W
05D3  00F7  	MOVWF convertTem_00027_1_iTemp2+D'1'

        // convert to absolute value
        gbDS3231IsMinus = (iTemp2 < 0);
05D4  01CD  	CLRF gbl_gbDS3231IsMinus
05D5  1BF7  	BTFSC convertTem_00027_1_iTemp2+D'1',7
05D6  0ACD  	INCF gbl_gbDS3231IsMinus, F

        if (gbDS3231IsMinus) {
05D7  08CD  	MOVF gbl_gbDS3231IsMinus, F
05D8  1903  	BTFSC STATUS,Z
05D9  2DDF  	GOTO	label105

            iTemp2 = ~iTemp2 + 1;
05DA  09F6  	COMF convertTem_00027_1_iTemp2, F
05DB  09F7  	COMF convertTem_00027_1_iTemp2+D'1', F
05DC  0AF6  	INCF convertTem_00027_1_iTemp2, F
05DD  1903  	BTFSC STATUS,Z
05DE  0AF7  	INCF convertTem_00027_1_iTemp2+D'1', F
05DF        label105

        }
        // Split the temperature reading into digits
        giDS3231ValueBCD = intToBcd(iTemp2);
05DF  0876  	MOVF convertTem_00027_1_iTemp2, W
05E0  00FC  	MOVWF intToBcd_00000_arg_iValue
05E1  0877  	MOVF convertTem_00027_1_iTemp2+D'1', W
05E2  00FD  	MOVWF intToBcd_00000_arg_iValue+D'1'
05E3  219F  	CALL intToBcd_00000
05E4  0820  	MOVF CompTempVarRet638, W
05E5  1283  	BCF STATUS, RP0
05E6  00B3  	MOVWF gbl_giDS3231ValueBCD
05E7  1683  	BSF STATUS, RP0
05E8  0821  	MOVF CompTempVarRet638+D'1', W
05E9  1283  	BCF STATUS, RP0
05EA  00B4  	MOVWF gbl_giDS3231ValueBCD+D'1'

	}
}
0569  0008  	RETURN
05A7  0008  	RETURN
05EB  0008  	RETURN


/*********************************************************************************************
  void startTemp()
  Sends the Convert T [44h] function command to the ds18b20
*********************************************************************************************/
void startTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // 44 is the convert function
    oneWireTxBytes(0xCC, 0x44);
080C  30CC  	MOVLW 0xCC
080D  1283  	BCF STATUS, RP0
080E  1303  	BCF STATUS, RP1
080F  00F3  	MOVWF oneWireTxB_00016_arg_cData
0810  3044  	MOVLW 0x44
0811  00F4  	MOVWF oneWireTxB_00016_arg_cData2
0812  118A  	BCF PCLATH,3
0813  24E1  	CALL oneWireTxB_00016

}
0814  0008  	RETURN


/*********************************************************************************************
  void readTemp()
  Sends the Read Scratchpad [BEh] function command to the ds18b20
*********************************************************************************************/
void readTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // BE indicates to read scratchpad
    oneWireTxBytes(0xCC, 0xBE);
0815  30CC  	MOVLW 0xCC
0816  1283  	BCF STATUS, RP0
0817  1303  	BCF STATUS, RP1
0818  00F3  	MOVWF oneWireTxB_00016_arg_cData
0819  30BE  	MOVLW 0xBE
081A  00F4  	MOVWF oneWireTxB_00016_arg_cData2
081B  118A  	BCF PCLATH,3
081C  24E1  	CALL oneWireTxB_00016

    // Now get the temperature from the scratchpad
    // This is in the first two bytes - so get those only and ignore the rest
    cTempL = oneWireRxByte();
081D  24E8  	CALL oneWireRxB_00017
081E  0874  	MOVF CompTempVarRet549, W
081F  00CB  	MOVWF gbl_cTempL

    cTempH = oneWireRxByte();
0820  24E8  	CALL oneWireRxB_00017
0821  0874  	MOVF CompTempVarRet549, W
0822  00CA  	MOVWF gbl_cTempH

}
0823  0008  	RETURN


/*********************************************************************************************
  char bcdAdjust(char bcd, char bcdMax, char bcdMin)
  Increment or Decrement a BCD variable for sending to the DS3231, within a given range
  Must set iBcdAdjustment (up/down increment) first
*********************************************************************************************/
char bcdAdjust(char bcd, char bcdMax, char bcdMin) {

    if (iBcdAdjustment == 1) {
025D  0370  	DECF gbl_iBcdAdjustment, W
025E  1D03  	BTFSS STATUS,Z
025F  2A73  	GOTO	label47
0273        label47

        // Increment
        // if at maximum, reset to minimum
        if (bcd == bcdMax)
0260  0877  	MOVF bcdAdjust_00000_arg_bcdMax, W
0261  0676  	XORWF bcdAdjust_00000_arg_bcd, W
0262  1D03  	BTFSS STATUS,Z
0263  2A67  	GOTO	label45
0267        label45

            bcd = bcdMin;
0264  0878  	MOVF bcdAdjust_00000_arg_bcdMin, W
0265  00F6  	MOVWF bcdAdjust_00000_arg_bcd

        else if ((bcd & 0x0F) == 9)
0266  2A84  	GOTO	label50
0267  300F  	MOVLW 0x0F
0268  0576  	ANDWF bcdAdjust_00000_arg_bcd, W
0269  00F9  	MOVWF CompTempVar642
026A  0879  	MOVF CompTempVar642, W
026B  3A09  	XORLW 0x09
026C  1D03  	BTFSS STATUS,Z
026D  2A71  	GOTO	label46
0271        label46

            bcd += 0x07; // add 0x10 (16), minus 9
026E  3007  	MOVLW 0x07
026F  07F6  	ADDWF bcdAdjust_00000_arg_bcd, F

        else
0270  2A84  	GOTO	label50

            bcd++;
0271  0AF6  	INCF bcdAdjust_00000_arg_bcd, F

    } else {
0272  2A84  	GOTO	label50

        // Decrement
        // if at minimum, reset to maximum
        if (bcd == bcdMin)
0273  0878  	MOVF bcdAdjust_00000_arg_bcdMin, W
0274  0676  	XORWF bcdAdjust_00000_arg_bcd, W
0275  1D03  	BTFSS STATUS,Z
0276  2A7A  	GOTO	label48
027A        label48

            bcd = bcdMax;
0277  0877  	MOVF bcdAdjust_00000_arg_bcdMax, W
0278  00F6  	MOVWF bcdAdjust_00000_arg_bcd

        else if ((bcd & 0x0F) == 0)
0279  2A84  	GOTO	label50
027A  300F  	MOVLW 0x0F
027B  0576  	ANDWF bcdAdjust_00000_arg_bcd, W
027C  00F9  	MOVWF CompTempVar643
027D  08F9  	MOVF CompTempVar643, F
027E  1D03  	BTFSS STATUS,Z
027F  2A83  	GOTO	label49
0283        label49

            bcd -= 0x07; // minus 0x10 (16), add 9
0280  3007  	MOVLW 0x07
0281  02F6  	SUBWF bcdAdjust_00000_arg_bcd, F

        else
0282  2A84  	GOTO	label50
0284        label50

            bcd--;
0283  03F6  	DECF bcdAdjust_00000_arg_bcd, F

    }
    return bcd;
0284  0876  	MOVF bcdAdjust_00000_arg_bcd, W
0285  00F9  	MOVWF CompTempVarRet641

}
0286  0008  	RETURN


/*********************************************************************************************
  void adjustDateTime()
  Increment or Decrement a BCD variable for sending to the DS3231, within a given range
  Must set iBcdAdjustment (up/down increment) first
*********************************************************************************************/
void adjustDateTime() {

    switch (gcSetMode) {

        case 1:
0762  1283  	BCF STATUS, RP0
0763  1303  	BCF STATUS, RP1
0764  0851  	MOVF gbl_gcSetMode, W
0765  3A01  	XORLW 0x01
0766  1903  	BTFSC STATUS,Z
0767  2F7B  	GOTO	label126
077B        label126

            // Setting year - from 00 to 99
            gBcdYear = bcdAdjust(gBcdYear, 0x99, 0x00);
077B  083B  	MOVF gbl_gBcdYear, W
077C  00F6  	MOVWF bcdAdjust_00000_arg_bcd
077D  3099  	MOVLW 0x99
077E  00F7  	MOVWF bcdAdjust_00000_arg_bcdMax
077F  01F8  	CLRF bcdAdjust_00000_arg_bcdMin
0780  225D  	CALL bcdAdjust_00000
0781  0879  	MOVF CompTempVarRet641, W
0782  00BB  	MOVWF gbl_gBcdYear

            break;
        case 2:
0768  3A03  	XORLW 0x03
0769  1903  	BTFSC STATUS,Z
076A  2F84  	GOTO	label127
0784        label127

            // Setting month - from 1 to 12
            gBcdMonth = bcdAdjust(gBcdMonth, 0x12, 0x01);
0784  083A  	MOVF gbl_gBcdMonth, W
0785  00F6  	MOVWF bcdAdjust_00000_arg_bcd
0786  3012  	MOVLW 0x12
0787  00F7  	MOVWF bcdAdjust_00000_arg_bcdMax
0788  3001  	MOVLW 0x01
0789  00F8  	MOVWF bcdAdjust_00000_arg_bcdMin
078A  225D  	CALL bcdAdjust_00000
078B  0879  	MOVF CompTempVarRet641, W
078C  00BA  	MOVWF gbl_gBcdMonth

            break;
        case 3:
076B  3A01  	XORLW 0x01
076C  1903  	BTFSC STATUS,Z
076D  2F8E  	GOTO	label128
078E        label128

            // Setting day of month - from 1 to max days in month (i.e. 31, 30 or 28/29)
            char iMonth = gBcdMonth;
078E  083A  	MOVF gbl_gBcdMonth, W
078F  00F4  	MOVWF adjustDate_00028_1_iMonth

            if (iMonth & 0xF0)
0790  30F0  	MOVLW 0xF0
0791  0574  	ANDWF adjustDate_00028_1_iMonth, W
0792  1903  	BTFSC STATUS,Z
0793  2F99  	GOTO	label129
0799        label129

                iMonth += (gBcdMonth >> 4);
0794  0E3A  	SWAPF gbl_gBcdMonth, W
0795  390F  	ANDLW 0x0F
0796  00F6  	MOVWF CompTempVar644
0797  0876  	MOVF CompTempVar644, W
0798  07F4  	ADDWF adjustDate_00028_1_iMonth, F

            iMonth--; // Make 0 to 11 index based
0799  03F4  	DECF adjustDate_00028_1_iMonth, F

            char bcdMaxDay = gDaysInMonth[iMonth];
079A  083C  	MOVF gbl_gDaysInMonth, W
079B  00FC  	MOVWF __rom_get_00000_arg_objNumb
079C  0874  	MOVF adjustDate_00028_1_iMonth, W
079D  00FD  	MOVWF __rom_get_00000_arg_idx
079E  201A  	CALL __rom_get_00000
079F  1283  	BCF STATUS, RP0
07A0  00F5  	MOVWF adjustDate_00028_1_bcdMaxDay

            // If February(1), adjust max days for leap years
            if (iMonth == 1) {
07A1  0374  	DECF adjustDate_00028_1_iMonth, W
07A2  118A  	BCF PCLATH,3
07A3  120A  	BCF PCLATH,4
07A4  1D03  	BTFSS STATUS,Z
07A5  2FBD  	GOTO	label132

                // See if the 24 leap years since 2000 match the current year
                for (char i = 0; i < 24; i++) {
07A6  01F6  	CLRF adjustDate_00028_16_i
07A7        label130
07A7  3018  	MOVLW 0x18
07A8  0276  	SUBWF adjustDate_00028_16_i, W
07A9  1803  	BTFSC STATUS,C
07AA  2FBD  	GOTO	label132
07BB  0AF6  	INCF adjustDate_00028_16_i, F
07BC  2FA7  	GOTO	label130
07BD        label132

                    if (gLeapYears[i] == gBcdYear) {
07AB  083D  	MOVF gbl_gLeapYears, W
07AC  00FC  	MOVWF __rom_get_00000_arg_objNumb
07AD  0876  	MOVF adjustDate_00028_16_i, W
07AE  00FD  	MOVWF __rom_get_00000_arg_idx
07AF  201A  	CALL __rom_get_00000
07B0  1283  	BCF STATUS, RP0
07B1  00F7  	MOVWF CompTempVar645
07B2  083B  	MOVF gbl_gBcdYear, W
07B3  0677  	XORWF CompTempVar645, W
07B4  118A  	BCF PCLATH,3
07B5  120A  	BCF PCLATH,4
07B6  1D03  	BTFSS STATUS,Z
07B7  2FBB  	GOTO	label131
07BB        label131

                        bcdMaxDay = 0x29;
07B8  3029  	MOVLW 0x29
07B9  00F5  	MOVWF adjustDate_00028_1_bcdMaxDay

                        break;
07BA  2FBD  	GOTO	label132

                    }
                }
            }
            gBcdDayOfMonth = bcdAdjust(gBcdDayOfMonth, bcdMaxDay, 0x01);
07BD  0839  	MOVF gbl_gBcdDayOfMonth, W
07BE  00F6  	MOVWF bcdAdjust_00000_arg_bcd
07BF  0875  	MOVF adjustDate_00028_1_bcdMaxDay, W
07C0  00F7  	MOVWF bcdAdjust_00000_arg_bcdMax
07C1  3001  	MOVLW 0x01
07C2  00F8  	MOVWF bcdAdjust_00000_arg_bcdMin
07C3  225D  	CALL bcdAdjust_00000
07C4  0879  	MOVF CompTempVarRet641, W
07C5  00B9  	MOVWF gbl_gBcdDayOfMonth

            break;
        case 4:
076E  3A07  	XORLW 0x07
076F  1903  	BTFSC STATUS,Z
0770  2FC7  	GOTO	label133
07C7        label133

            // Setting day of week - from 1 to 7
            gDayOfWeek = bcdAdjust(gDayOfWeek, 0x07, 0x01);
07C7  0838  	MOVF gbl_gDayOfWeek, W
07C8  00F6  	MOVWF bcdAdjust_00000_arg_bcd
07C9  3007  	MOVLW 0x07
07CA  00F7  	MOVWF bcdAdjust_00000_arg_bcdMax
07CB  3001  	MOVLW 0x01
07CC  00F8  	MOVWF bcdAdjust_00000_arg_bcdMin
07CD  225D  	CALL bcdAdjust_00000
07CE  0879  	MOVF CompTempVarRet641, W
07CF  00B8  	MOVWF gbl_gDayOfWeek

            break;
        case 5:
0771  3A01  	XORLW 0x01
0772  1903  	BTFSC STATUS,Z
0773  2FD1  	GOTO	label134
07D1        label134

            // Setting 12h/24h
            gcHourMode++;
07D1  0AD2  	INCF gbl_gcHourMode, F

            if (gcHourMode > 2)
07D2  0852  	MOVF gbl_gcHourMode, W
07D3  3C02  	SUBLW 0x02
07D4  1C03  	BTFSS STATUS,C

				gcHourMode = 0;
07D5  01D2  	CLRF gbl_gcHourMode

            break;
        case 6:
0774  3A03  	XORLW 0x03
0775  1903  	BTFSC STATUS,Z
0776  2FD7  	GOTO	label135
07D7        label135

            // Setting hour - from 0 to 23
            gBcdHour = bcdAdjust(gBcdHour, 0x23, 0x00);
07D7  0837  	MOVF gbl_gBcdHour, W
07D8  00F6  	MOVWF bcdAdjust_00000_arg_bcd
07D9  3023  	MOVLW 0x23
07DA  00F7  	MOVWF bcdAdjust_00000_arg_bcdMax
07DB  01F8  	CLRF bcdAdjust_00000_arg_bcdMin
07DC  225D  	CALL bcdAdjust_00000
07DD  0879  	MOVF CompTempVarRet641, W
07DE  00B7  	MOVWF gbl_gBcdHour

            break;
        case 7:
0777  3A01  	XORLW 0x01
0778  1903  	BTFSC STATUS,Z
0779  2FE0  	GOTO	label136
07E0        label136

            // Setting minute - from 0 to 59
            gBcdMinute = bcdAdjust(gBcdMinute, 0x59, 0x00);
07E0  0836  	MOVF gbl_gBcdMinute, W
07E1  00F6  	MOVWF bcdAdjust_00000_arg_bcd
07E2  3059  	MOVLW 0x59
07E3  00F7  	MOVWF bcdAdjust_00000_arg_bcdMax
07E4  01F8  	CLRF bcdAdjust_00000_arg_bcdMin
07E5  225D  	CALL bcdAdjust_00000
07E6  0879  	MOVF CompTempVarRet641, W
07E7  00B6  	MOVWF gbl_gBcdMinute

            break;
    }
}
077A  0008  	RETURN
0783  0008  	RETURN
078D  0008  	RETURN
07C6  0008  	RETURN
07D0  0008  	RETURN
07D6  0008  	RETURN
07DF  0008  	RETURN
07E8  0008  	RETURN


/*********************************************************************************************
  void adjustTrigger()
  Increment or Decrement a trigger time or temperate
  Must set iBcdAdjustment first
*********************************************************************************************/
void adjustTrigger() {

    switch (gcTriggerMode) {

        case 1:
068F  1283  	BCF STATUS, RP0
0690  1303  	BCF STATUS, RP1
0691  0853  	MOVF gbl_gcTriggerMode, W
0692  3A01  	XORLW 0x01
0693  1903  	BTFSC STATUS,Z
0694  2EC3  	GOTO	label108
06C3        label108

            // White LED on hour - from 0 to 23
            gBcdWhiteOnHour = bcdAdjust(gBcdWhiteOnHour, 0x23, 0x00);
06C3  0855  	MOVF gbl_gBcdWhiteOnHour, W
06C4  00F6  	MOVWF bcdAdjust_00000_arg_bcd
06C5  3023  	MOVLW 0x23
06C6  00F7  	MOVWF bcdAdjust_00000_arg_bcdMax
06C7  01F8  	CLRF bcdAdjust_00000_arg_bcdMin
06C8  225D  	CALL bcdAdjust_00000
06C9  0879  	MOVF CompTempVarRet641, W
06CA  00D5  	MOVWF gbl_gBcdWhiteOnHour

            break;
        case 2:
0695  3A03  	XORLW 0x03
0696  1903  	BTFSC STATUS,Z
0697  2ECC  	GOTO	label109
06CC        label109

            // White LED on minute - from 0 to 59
            gBcdWhiteOnMinute = bcdAdjust(gBcdWhiteOnMinute, 0x59, 0x00);
06CC  0854  	MOVF gbl_gBcdWhiteOnMinute, W
06CD  00F6  	MOVWF bcdAdjust_00000_arg_bcd
06CE  3059  	MOVLW 0x59
06CF  00F7  	MOVWF bcdAdjust_00000_arg_bcdMax
06D0  01F8  	CLRF bcdAdjust_00000_arg_bcdMin
06D1  225D  	CALL bcdAdjust_00000
06D2  0879  	MOVF CompTempVarRet641, W
06D3  00D4  	MOVWF gbl_gBcdWhiteOnMinute

            break;
        case 3:
0698  3A01  	XORLW 0x01
0699  1903  	BTFSC STATUS,Z
069A  2ED5  	GOTO	label110
06D5        label110

            // White LED off hour - from 0 to 23
            gBcdWhiteOffHour = bcdAdjust(gBcdWhiteOffHour, 0x23, 0x00);
06D5  0857  	MOVF gbl_gBcdWhiteOffHour, W
06D6  00F6  	MOVWF bcdAdjust_00000_arg_bcd
06D7  3023  	MOVLW 0x23
06D8  00F7  	MOVWF bcdAdjust_00000_arg_bcdMax
06D9  01F8  	CLRF bcdAdjust_00000_arg_bcdMin
06DA  225D  	CALL bcdAdjust_00000
06DB  0879  	MOVF CompTempVarRet641, W
06DC  00D7  	MOVWF gbl_gBcdWhiteOffHour

            break;
        case 4:
069B  3A07  	XORLW 0x07
069C  1903  	BTFSC STATUS,Z
069D  2EDE  	GOTO	label111
06DE        label111

            // White LED off minute - from 0 to 59
            gBcdWhiteOffMinute = bcdAdjust(gBcdWhiteOffMinute, 0x59, 0x00);
06DE  0856  	MOVF gbl_gBcdWhiteOffMinute, W
06DF  00F6  	MOVWF bcdAdjust_00000_arg_bcd
06E0  3059  	MOVLW 0x59
06E1  00F7  	MOVWF bcdAdjust_00000_arg_bcdMax
06E2  01F8  	CLRF bcdAdjust_00000_arg_bcdMin
06E3  225D  	CALL bcdAdjust_00000
06E4  0879  	MOVF CompTempVarRet641, W
06E5  00D6  	MOVWF gbl_gBcdWhiteOffMinute

            break;
        case 5:
069E  3A01  	XORLW 0x01
069F  1903  	BTFSC STATUS,Z
06A0  2EE7  	GOTO	label112
06E7        label112

            // 1st Blue LED on hour - from 0 to 23
            gBcdBlueOnHour = bcdAdjust(gBcdBlueOnHour, 0x23, 0x00);
06E7  0859  	MOVF gbl_gBcdBlueOnHour, W
06E8  00F6  	MOVWF bcdAdjust_00000_arg_bcd
06E9  3023  	MOVLW 0x23
06EA  00F7  	MOVWF bcdAdjust_00000_arg_bcdMax
06EB  01F8  	CLRF bcdAdjust_00000_arg_bcdMin
06EC  225D  	CALL bcdAdjust_00000
06ED  0879  	MOVF CompTempVarRet641, W
06EE  00D9  	MOVWF gbl_gBcdBlueOnHour

            break;
        case 6:
06A1  3A03  	XORLW 0x03
06A2  1903  	BTFSC STATUS,Z
06A3  2EF0  	GOTO	label113
06F0        label113

            // 1st Blue LED on minute - from 0 to 59
            gBcdBlueOnMinute = bcdAdjust(gBcdBlueOnMinute, 0x59, 0x00);
06F0  0858  	MOVF gbl_gBcdBlueOnMinute, W
06F1  00F6  	MOVWF bcdAdjust_00000_arg_bcd
06F2  3059  	MOVLW 0x59
06F3  00F7  	MOVWF bcdAdjust_00000_arg_bcdMax
06F4  01F8  	CLRF bcdAdjust_00000_arg_bcdMin
06F5  225D  	CALL bcdAdjust_00000
06F6  0879  	MOVF CompTempVarRet641, W
06F7  00D8  	MOVWF gbl_gBcdBlueOnMinute

            break;
        case 7:
06A4  3A01  	XORLW 0x01
06A5  1903  	BTFSC STATUS,Z
06A6  2EF9  	GOTO	label114
06F9        label114

            // 1st Blue LED off hour - from 0 to 23
            gBcdBlueOffHour = bcdAdjust(gBcdBlueOffHour, 0x23, 0x00);
06F9  085B  	MOVF gbl_gBcdBlueOffHour, W
06FA  00F6  	MOVWF bcdAdjust_00000_arg_bcd
06FB  3023  	MOVLW 0x23
06FC  00F7  	MOVWF bcdAdjust_00000_arg_bcdMax
06FD  01F8  	CLRF bcdAdjust_00000_arg_bcdMin
06FE  225D  	CALL bcdAdjust_00000
06FF  0879  	MOVF CompTempVarRet641, W
0700  00DB  	MOVWF gbl_gBcdBlueOffHour

            break;
        case 8:
06A7  3A0F  	XORLW 0x0F
06A8  1903  	BTFSC STATUS,Z
06A9  2F02  	GOTO	label115
0702        label115

            // 1st Blue LED off minute - from 0 to 59
            gBcdBlueOffMinute = bcdAdjust(gBcdBlueOffMinute, 0x59, 0x00);
0702  085A  	MOVF gbl_gBcdBlueOffMinute, W
0703  00F6  	MOVWF bcdAdjust_00000_arg_bcd
0704  3059  	MOVLW 0x59
0705  00F7  	MOVWF bcdAdjust_00000_arg_bcdMax
0706  01F8  	CLRF bcdAdjust_00000_arg_bcdMin
0707  225D  	CALL bcdAdjust_00000
0708  0879  	MOVF CompTempVarRet641, W
0709  00DA  	MOVWF gbl_gBcdBlueOffMinute

            break;
        case 9:
06AA  3A01  	XORLW 0x01
06AB  1903  	BTFSC STATUS,Z
06AC  2F0B  	GOTO	label116
070B        label116

            // 2nd Blue LED on hour - from 0 to 23
            gBcdBlue2OnHour = bcdAdjust(gBcdBlue2OnHour, 0x23, 0x00);
070B  085D  	MOVF gbl_gBcdBlue2OnHour, W
070C  00F6  	MOVWF bcdAdjust_00000_arg_bcd
070D  3023  	MOVLW 0x23
070E  00F7  	MOVWF bcdAdjust_00000_arg_bcdMax
070F  01F8  	CLRF bcdAdjust_00000_arg_bcdMin
0710  225D  	CALL bcdAdjust_00000
0711  0879  	MOVF CompTempVarRet641, W
0712  00DD  	MOVWF gbl_gBcdBlue2OnHour

            break;
        case 10:
06AD  3A03  	XORLW 0x03
06AE  1903  	BTFSC STATUS,Z
06AF  2F14  	GOTO	label117
0714        label117

            // 2nd Blue LED on minute - from 0 to 59
            gBcdBlue2OnMinute = bcdAdjust(gBcdBlue2OnMinute, 0x59, 0x00);
0714  085C  	MOVF gbl_gBcdBlue2OnMinute, W
0715  00F6  	MOVWF bcdAdjust_00000_arg_bcd
0716  3059  	MOVLW 0x59
0717  00F7  	MOVWF bcdAdjust_00000_arg_bcdMax
0718  01F8  	CLRF bcdAdjust_00000_arg_bcdMin
0719  225D  	CALL bcdAdjust_00000
071A  0879  	MOVF CompTempVarRet641, W
071B  00DC  	MOVWF gbl_gBcdBlue2OnMinute

            break;
        case 11:
06B0  3A01  	XORLW 0x01
06B1  1903  	BTFSC STATUS,Z
06B2  2F1D  	GOTO	label118
071D        label118

            // 2nd Blue LED off hour - from 0 to 23
            gBcdBlue2OffHour = bcdAdjust(gBcdBlue2OffHour, 0x23, 0x00);
071D  085F  	MOVF gbl_gBcdBlue2OffHour, W
071E  00F6  	MOVWF bcdAdjust_00000_arg_bcd
071F  3023  	MOVLW 0x23
0720  00F7  	MOVWF bcdAdjust_00000_arg_bcdMax
0721  01F8  	CLRF bcdAdjust_00000_arg_bcdMin
0722  225D  	CALL bcdAdjust_00000
0723  0879  	MOVF CompTempVarRet641, W
0724  00DF  	MOVWF gbl_gBcdBlue2OffHour

            break;
        case 12:
06B3  3A07  	XORLW 0x07
06B4  1903  	BTFSC STATUS,Z
06B5  2F26  	GOTO	label119
0726        label119

            // 2nd Blue LED off minute - from 0 to 59
            gBcdBlue2OffMinute = bcdAdjust(gBcdBlue2OffMinute, 0x59, 0x00);
0726  085E  	MOVF gbl_gBcdBlue2OffMinute, W
0727  00F6  	MOVWF bcdAdjust_00000_arg_bcd
0728  3059  	MOVLW 0x59
0729  00F7  	MOVWF bcdAdjust_00000_arg_bcdMax
072A  01F8  	CLRF bcdAdjust_00000_arg_bcdMin
072B  225D  	CALL bcdAdjust_00000
072C  0879  	MOVF CompTempVarRet641, W
072D  00DE  	MOVWF gbl_gBcdBlue2OffMinute

            break;
        case 13:
06B6  3A01  	XORLW 0x01
06B7  1903  	BTFSC STATUS,Z
06B8  2F2F  	GOTO	label120
072F        label120

            // Fan on temp - between 20 and 40 degrees C
            gBcdFanOnTemp = bcdAdjust(gBcdFanOnTemp, 0x40, 0x20);
072F  0860  	MOVF gbl_gBcdFanOnTemp, W
0730  00F6  	MOVWF bcdAdjust_00000_arg_bcd
0731  3040  	MOVLW 0x40
0732  00F7  	MOVWF bcdAdjust_00000_arg_bcdMax
0733  3020  	MOVLW 0x20
0734  00F8  	MOVWF bcdAdjust_00000_arg_bcdMin
0735  225D  	CALL bcdAdjust_00000
0736  0879  	MOVF CompTempVarRet641, W
0737  00E0  	MOVWF gbl_gBcdFanOnTemp

            break;
        case 14:
06B9  3A03  	XORLW 0x03
06BA  1903  	BTFSC STATUS,Z
06BB  2F39  	GOTO	label121
0739        label121

            // Fan off temp - off must be lower than on, min 20 degrees C
            if (gBcdFanOffTemp > gBcdFanOnTemp)
0739  0861  	MOVF gbl_gBcdFanOffTemp, W
073A  0260  	SUBWF gbl_gBcdFanOnTemp, W
073B  1803  	BTFSC STATUS,C
073C  2F3F  	GOTO	label122
073F        label122

				gBcdFanOffTemp = gBcdFanOnTemp;
073D  0860  	MOVF gbl_gBcdFanOnTemp, W
073E  00E1  	MOVWF gbl_gBcdFanOffTemp

            gBcdFanOffTemp = bcdAdjust(gBcdFanOffTemp, gBcdFanOnTemp, 0x20);
073F  0861  	MOVF gbl_gBcdFanOffTemp, W
0740  00F6  	MOVWF bcdAdjust_00000_arg_bcd
0741  0860  	MOVF gbl_gBcdFanOnTemp, W
0742  00F7  	MOVWF bcdAdjust_00000_arg_bcdMax
0743  3020  	MOVLW 0x20
0744  00F8  	MOVWF bcdAdjust_00000_arg_bcdMin
0745  225D  	CALL bcdAdjust_00000
0746  0879  	MOVF CompTempVarRet641, W
0747  00E1  	MOVWF gbl_gBcdFanOffTemp

            break;
        case 15:
06BC  3A01  	XORLW 0x01
06BD  1903  	BTFSC STATUS,Z
06BE  2F49  	GOTO	label123
0749        label123

            // Heater on temp - between 0 and 40 degrees C
            gBcdHeaterOnTemp = bcdAdjust(gBcdHeaterOnTemp, 0x40, 0);
0749  0862  	MOVF gbl_gBcdHeaterOnTemp, W
074A  00F6  	MOVWF bcdAdjust_00000_arg_bcd
074B  3040  	MOVLW 0x40
074C  00F7  	MOVWF bcdAdjust_00000_arg_bcdMax
074D  01F8  	CLRF bcdAdjust_00000_arg_bcdMin
074E  225D  	CALL bcdAdjust_00000
074F  0879  	MOVF CompTempVarRet641, W
0750  00E2  	MOVWF gbl_gBcdHeaterOnTemp

            break;
        case 16:
06BF  3A1F  	XORLW 0x1F
06C0  1903  	BTFSC STATUS,Z
06C1  2F52  	GOTO	label124
0752        label124

            // Heater off temp - off must be equal or higher than on - max 40 degrees C
            if (gBcdHeaterOffTemp < gBcdHeaterOnTemp)
0752  0862  	MOVF gbl_gBcdHeaterOnTemp, W
0753  0263  	SUBWF gbl_gBcdHeaterOffTemp, W
0754  1803  	BTFSC STATUS,C
0755  2F58  	GOTO	label125
0758        label125

				gBcdHeaterOffTemp = gBcdHeaterOnTemp;
0756  0862  	MOVF gbl_gBcdHeaterOnTemp, W
0757  00E3  	MOVWF gbl_gBcdHeaterOffTemp

            gBcdHeaterOffTemp = bcdAdjust(gBcdHeaterOffTemp, 0x40, gBcdHeaterOnTemp);
0758  0863  	MOVF gbl_gBcdHeaterOffTemp, W
0759  00F6  	MOVWF bcdAdjust_00000_arg_bcd
075A  3040  	MOVLW 0x40
075B  00F7  	MOVWF bcdAdjust_00000_arg_bcdMax
075C  0862  	MOVF gbl_gBcdHeaterOnTemp, W
075D  00F8  	MOVWF bcdAdjust_00000_arg_bcdMin
075E  225D  	CALL bcdAdjust_00000
075F  0879  	MOVF CompTempVarRet641, W
0760  00E3  	MOVWF gbl_gBcdHeaterOffTemp

            break;
    }
}
06C2  0008  	RETURN
06CB  0008  	RETURN
06D4  0008  	RETURN
06DD  0008  	RETURN
06E6  0008  	RETURN
06EF  0008  	RETURN
06F8  0008  	RETURN
0701  0008  	RETURN
070A  0008  	RETURN
0713  0008  	RETURN
071C  0008  	RETURN
0725  0008  	RETURN
072E  0008  	RETURN
0738  0008  	RETURN
0748  0008  	RETURN
0751  0008  	RETURN
0761  0008  	RETURN


/*********************************************************************************************
  void processKeys()
  Action a key press
*********************************************************************************************/
void processKeys() {

    // Key hex codes based on result from tm1638ReadKeys, from http://www.piclearning.net/280/pic-and-tm1638-ledkey-module.php
    switch (tm1638Keys) {

        case 0x1F:
0824  1283  	BCF STATUS, RP0
0825  1303  	BCF STATUS, RP1
0826  086C  	MOVF gbl_tm1638Keys, W
0827  3A1F  	XORLW 0x1F
0828  1903  	BTFSC STATUS,Z
0829  2840  	GOTO	label140
0840        label140

            // Toggle white light on/off
            WHITE_LED = !WHITE_LED;
0840  01F4  	CLRF CompTempVar646
0841  1C87  	BTFSS gbl_portc,1
0842  0AF4  	INCF CompTempVar646, F
0843  1874  	BTFSC CompTempVar646,0
0844  1487  	BSF gbl_portc,1
0845  1C74  	BTFSS CompTempVar646,0
0846  1087  	BCF gbl_portc,1

            break;
        case 0x17:
082A  3A08  	XORLW 0x08
082B  1903  	BTFSC STATUS,Z
082C  2848  	GOTO	label141
0848        label141

            // Toggle blue light on/off
            BLUE_LED = !BLUE_LED;
0848  01F4  	CLRF CompTempVar647
0849  1D07  	BTFSS gbl_portc,2
084A  0AF4  	INCF CompTempVar647, F
084B  1874  	BTFSC CompTempVar647,0
084C  1507  	BSF gbl_portc,2
084D  1C74  	BTFSS CompTempVar647,0
084E  1107  	BCF gbl_portc,2

            break;
        case 0x0F:
082D  3A18  	XORLW 0x18
082E  1903  	BTFSC STATUS,Z
082F  2850  	GOTO	label142
0850        label142

            // Toggle fan on/off
            gbFanOn = !gbFanOn;
0850  01F4  	CLRF CompTempVar648
0851  1C4F  	BTFSS gbl_gbFanOn,0
0852  0AF4  	INCF CompTempVar648, F
0853  104F  	BCF gbl_gbFanOn,0
0854  0874  	MOVF CompTempVar648, W
0855  1D03  	BTFSS STATUS,Z
0856  144F  	BSF gbl_gbFanOn,0

            break;
        case 0x07:
0830  3A08  	XORLW 0x08
0831  1903  	BTFSC STATUS,Z
0832  2858  	GOTO	label143
0858        label143

            // Exit other modes
            if (gcTriggerMode)
0858  08D3  	MOVF gbl_gcTriggerMode, F
085A  1D03  	BTFSS STATUS,Z

                at24c32WriteAll(); // Exiting trigger mode, save the new triggers to EEPROM chip
0859  118A  	BCF PCLATH,3
085B  25EC  	CALL at24c32Wri_00018

            gcSetMode = 0;
085C  01D1  	CLRF gbl_gcSetMode

            gcTriggerMode = 0;
085D  01D3  	CLRF gbl_gcTriggerMode

            // Display temp C/temp F/date
            gcDisplayMode++;
085E  0AD0  	INCF gbl_gcDisplayMode, F

            if (gcDisplayMode > 3)
085F  0850  	MOVF gbl_gcDisplayMode, W
0860  3C03  	SUBLW 0x03
0861  1C03  	BTFSS STATUS,C

                gcDisplayMode = 0;
0862  01D0  	CLRF gbl_gcDisplayMode

            convertTemp(); // force conversion (no read)
0863  2555  	CALL convertTem_00027

            break;
        case 0x1B:
0833  3A1C  	XORLW 0x1C
0834  1903  	BTFSC STATUS,Z
0835  2865  	GOTO	label144
0865        label144

            // Exit other modes
            gcTriggerMode = 0;
0865  01D3  	CLRF gbl_gcTriggerMode

            // Adjust set mode
            gcSetMode++;
0866  0AD1  	INCF gbl_gcSetMode, F

            if (gcSetMode > 7) {
0867  0851  	MOVF gbl_gcSetMode, W
0868  3C07  	SUBLW 0x07
0869  1803  	BTFSC STATUS,C

                ds3231WriteDateTime();
086B  118A  	BCF PCLATH,3
086C  2519  	CALL ds3231Writ_0001B

                gcSetMode = 0;
086D  01D1  	CLRF gbl_gcSetMode

            }
            break;
        case 0x13:
0836  3A08  	XORLW 0x08
0837  1903  	BTFSC STATUS,Z
0838  286F  	GOTO	label145
086F        label145

            // Adjust down
            iBcdAdjustment = 0;
086F  01F0  	CLRF gbl_iBcdAdjustment

            if (gcSetMode) {
0870  08D1  	MOVF gbl_gcSetMode, F
0871  1903  	BTFSC STATUS,Z
0872  2876  	GOTO	label146
0876        label146

                adjustDateTime();
0873  118A  	BCF PCLATH,3
0874  2762  	CALL adjustDate_00028

            } else if (gcTriggerMode) {
0876  08D3  	MOVF gbl_gcTriggerMode, F
0878  1D03  	BTFSS STATUS,Z

                adjustTrigger();
0877  118A  	BCF PCLATH,3
0879  268F  	CALL adjustTrig_00029

            }
            break;
        case 0x0B:
0839  3A18  	XORLW 0x18
083A  1903  	BTFSC STATUS,Z
083B  287B  	GOTO	label147
087B        label147

            iBcdAdjustment = 1;
087B  3001  	MOVLW 0x01
087C  00F0  	MOVWF gbl_iBcdAdjustment

            // Adjust up
            if (gcSetMode) {
087D  08D1  	MOVF gbl_gcSetMode, F
087E  1903  	BTFSC STATUS,Z
087F  2883  	GOTO	label148
0883        label148

                adjustDateTime();
0880  118A  	BCF PCLATH,3
0881  2762  	CALL adjustDate_00028

            } else if (gcTriggerMode) {
0883  08D3  	MOVF gbl_gcTriggerMode, F
0885  1D03  	BTFSS STATUS,Z

                adjustTrigger();
0884  118A  	BCF PCLATH,3
0886  268F  	CALL adjustTrig_00029

            }
            break;
        case 0x03:
083C  3A08  	XORLW 0x08
083D  1903  	BTFSC STATUS,Z
083E  2888  	GOTO	label149
0888        label149

            // Exit set mode
            gcSetMode = 0;
0888  01D1  	CLRF gbl_gcSetMode

            // Adjust timer mode
            gcTriggerMode++;
0889  0AD3  	INCF gbl_gcTriggerMode, F

            if (gcTriggerMode > 16) {
088A  0853  	MOVF gbl_gcTriggerMode, W
088B  3C10  	SUBLW 0x10
088C  1803  	BTFSC STATUS,C

                at24c32WriteAll(); // Exiting trigger mode, save the new triggers to EEPROM chip
088E  118A  	BCF PCLATH,3
088F  25EC  	CALL at24c32Wri_00018

                gcTriggerMode = 0;
0890  01D3  	CLRF gbl_gcTriggerMode

            }
            break;
    }
}
083F  0008  	RETURN
0847  0008  	RETURN
084F  0008  	RETURN
0857  0008  	RETURN
0864  0008  	RETURN
086A  0008  	RETURN
086E  0008  	RETURN
0875  0008  	RETURN
087A  0008  	RETURN
0882  0008  	RETURN
0887  0008  	RETURN
088D  0008  	RETURN
0891  0008  	RETURN


/*********************************************************************************************
  void interrupt()
  Interrupt handler
*********************************************************************************************/
void interrupt() {

    // Interrupt on timer0 - flash digit delay
    if (intcon.T0IF) {
0A65  1D0B  	BTFSS gbl_intcon,2
0A66  2A6D  	GOTO	label178
0A6D        label178

        tmr0 = TMR0PRELOAD;
0A67  303D  	MOVLW 0x3D
0A68  1283  	BCF STATUS, RP0
0A69  1303  	BCF STATUS, RP1
0A6A  0081  	MOVWF gbl_tmr0

        cTask.TASK_TIMER0 = 1;
0A6B  14CE  	BSF gbl_cTask,1

        // Clear interrupt flag
        intcon.T0IF = 0;
0A6C  110B  	BCF gbl_intcon,2

    }
    // Handle timer1 interrupt - delay counter from DS3231
    if (pir1.TMR1IF) {
0A6D  1283  	BCF STATUS, RP0
0A6E  1303  	BCF STATUS, RP1
0A6F  1C0C  	BTFSS gbl_pir1,0
0A70  2A76  	GOTO	label179
0A76        label179

        tmr1h = TMR1HV;      // preset for timer1 MSB register
0A71  30FF  	MOVLW 0xFF
0A72  008F  	MOVWF gbl_tmr1h

        tmr1l = TMR1LV;      // preset for timer1 LSB register
0A73  008E  	MOVWF gbl_tmr1l


        pir1.TMR1IF = 0;     // Clear interrupt flag
0A74  100C  	BCF gbl_pir1,0

        cTask.TASK_TIMER1 = 1;
0A75  154E  	BSF gbl_cTask,2

    }
}
0A76  0E32  	SWAPF Int1BContext+D'2', W
0A77  0084  	MOVWF FSR
0A78  0E31  	SWAPF Int1BContext+D'1', W
0A79  008A  	MOVWF PCLATH
0A7A  0E30  	SWAPF Int1BContext, W
0A7B  0083  	MOVWF STATUS
0A7C  0EFF  	SWAPF Int1Context, F
0A7D  0E7F  	SWAPF Int1Context, W
0A7E  0009  	RETFIE


/*********************************************************************************************
  void initialise()
  Function called once only to initialise variables and
  setup the PIC registers
*********************************************************************************************/
void initialise() {

    //PIC16F73 doesn't have an internal oscillator
    //pcon.OSCF = 1; // 4MHz internal osc

    // Configure port A
    /*
    RA7     Doesn't exist
    RA6     Doesn't exist
    RA5
    RA4
    RA3
    RA2
    RA1     OUT FANS
    RA0     OUT HEATER
    */
    trisa = 0x00; // all outputs
08AB  1683  	BSF STATUS, RP0
08AC  1303  	BCF STATUS, RP1
08AD  0185  	CLRF gbl_trisa

    porta = 0x00; // All off
08AE  1283  	BCF STATUS, RP0
08AF  0185  	CLRF gbl_porta


    // Configure port B
    /*
    RB7     ICSP PGD
    RB6     ICSP PGC
    RB5
    RB4
    RB3     OUT TM1638 STB
    RB2     OUT TM1638 CLK
    RB1     IN/OUT TM1638 DIO
    RB0
    */
    trisb = 0x00; // all outputs by default
08B0  1683  	BSF STATUS, RP0
08B1  0186  	CLRF gbl_trisb

    portb = 0x0E; // default TM1638 pins high
08B2  300E  	MOVLW 0x0E
08B3  1283  	BCF STATUS, RP0
08B4  0086  	MOVWF gbl_portb


    // Configure port C
    /*
    RC7
    RC6
    RC5     IN/OUT DS18B20
    RC4     IN/OUT DS3231M I2C SDA
    RC3     IN/OUT DS3231M I2C CLK
    RC2     OUT BLUE LIGHT PWM
    RC1     OUT WHITE LIGHT PWM
    RC0     IN SQW DS3231M
    */
    trisc = 0x21; // RC0 and RC5 inputs
08B5  3021  	MOVLW 0x21
08B6  1683  	BSF STATUS, RP0
08B7  0087  	MOVWF gbl_trisc

    portc = 0x38; // default DS18B20 and DS3231 pins high
08B8  3038  	MOVLW 0x38
08B9  1283  	BCF STATUS, RP0
08BA  0087  	MOVWF gbl_portc


    option_reg = 0;
08BB  1683  	BSF STATUS, RP0
08BC  0181  	CLRF gbl_option_reg

    option_reg.NOT_RBPU = 1; // disable port b pull ups
08BD  1781  	BSF gbl_option_reg,7


    // ADC setup
    // PIC16F73 doesn't have comparators, setting cmcon may be needed for some PICs
    //cmcon = 7; // disable all comparators so port a is usable as digital io
    adcon1 = 7; // Set RA0,RA1,RA2,RA5,RA3 all to digital I/O
08BE  3007  	MOVLW 0x07
08BF  009F  	MOVWF gbl_adcon1



    // Setup timer 0, used for flashing display
    // Timer calculator: http://eng-serve.com/pic/pic_timer.html
    // Timer0 Registers Prescaler= 256 - TMR0 Preset = 61 - Freq = 20.03 Hz - Period = 0.049920 seconds
    //option_reg.T0CS = 0; // bit 5  TMR0 Clock Source Select bit...0 = Internal Clock (CLKO) 1 = Transition on T0CKI pin
    //option_reg.T0SE = 0; // bit 4 TMR0 Source Edge Select bit 0 = low/high 1 = high/low
    //option_reg.PSA = 0; // bit 3  Prescaler Assignment bit...0 = Prescaler is assigned to the Timer0
    option_reg.PS2 = 1; // bits 2-0  PS2:PS0: Prescaler Rate Select bits
08C0  1501  	BSF gbl_option_reg,2

    option_reg.PS1 = 1;
08C1  1481  	BSF gbl_option_reg,1

    option_reg.PS0 = 1;
08C2  1401  	BSF gbl_option_reg,0

    tmr0 = TMR0PRELOAD; // preset for timer register (61)
08C3  303D  	MOVLW 0x3D
08C4  1283  	BCF STATUS, RP0
08C5  0081  	MOVWF gbl_tmr0

    intcon.T0IF = 0; // Clear timer 1 interrupt flag bit
08C6  110B  	BCF gbl_intcon,2

    intcon.T0IE = 1; // Timer 1 interrupt enabled
08C7  168B  	BSF gbl_intcon,5


    // Setup timer 1, used to update clock display and periodically ask for a temperature reading
    // Timer 1 setup - interrupt on DS3231 SQW 1Hz
    // Timer1 Registers Prescaler= 1 - TMR1 Preset = 65535 - Freq = 1 Hz
    // Bits 5-4 T1CKPS1:T1CKPS0 = 00: Prescaler Rate Select bits, 00 = 1:1 prescaler
    // Bit 3 T1OSCEN = 0: Timer1 LP Oscillator Enable Control bit, 0 = off
    // Bit 2 NOT_T1SYNC = 1: Timer1 External Clock Input Synchronization Control bit, 1 = Do not synchronize external clock input
    // Bit 1 TMR1CS = 1: Timer1 Clock Source Select bit, 1 = External clock from T1OSO/T1CKI pin (on the rising edge)
    // Bit 0 TMR1ON = 0: Timer1 On Bit, 0 = off
    t1con = 0b00000111;
08C8  3007  	MOVLW 0x07
08C9  0090  	MOVWF gbl_t1con

    tmr1h = TMR1HV;      // preset for timer1 MSB register
08CA  30FF  	MOVLW 0xFF
08CB  008F  	MOVWF gbl_tmr1h

    tmr1l = TMR1LV;      // preset for timer1 LSB register
08CC  008E  	MOVWF gbl_tmr1l

    pie1.TMR1IE = 1;     // Timer 1 interrupt
08CD  1683  	BSF STATUS, RP0
08CE  140C  	BSF gbl_pie1,0


    // No task at initialisation
    cTask = 0;
08CF  1283  	BCF STATUS, RP0
08D0  01CE  	CLRF gbl_cTask


	// I2C Bus initialisation - baud rate divisor not applicable for software implementation
	i2c_init(1);
08D1  3001  	MOVLW 0x01
08D2  00F4  	MOVWF i2c_INIT_00000_arg_i2c_divisor
08D3  118A  	BCF PCLATH,3
08D4  2506  	CALL i2c_INIT_00000


	// Startup delay
	delay_ms(500);
08D5  30F4  	MOVLW 0xF4
08D6  00F4  	MOVWF delay_ms_00000_arg_del
08D7  2084  	CALL delay_ms_00000


    // Read in variables from EEPROM
    at24c32ReadAll();
08D8  262F  	CALL at24c32Rea_00019


    // Check if the DS3231 needs initilising
    char cStatus = ds3231ReadRegister(0x0F); // Read the status register
08D9  300F  	MOVLW 0x0F
08DA  00F4  	MOVWF ds3231Read_0001D_arg_cRegAddress
08DB  2535  	CALL ds3231Read_0001D
08DC  0876  	MOVF CompTempVarRet552, W
08DD  00F3  	MOVWF initialise_00000_1_cStatus

    // If the oscillator (OSF bit in status register) has stopped, then init and write a default date/time
    // This is only expected first time, or backup battery not present/empty in DS3231M module
    if (cStatus.7) {
08DE  158A  	BSF PCLATH,3
08DF  1FF3  	BTFSS initialise_00000_1_cStatus,7
08E0  28E4  	GOTO	label150
08E4        label150

        ds3231Init();
08E1  118A  	BCF PCLATH,3
08E2  254A  	CALL ds3231Init_00000

        ds3231WriteDateTime();
08E3  2519  	CALL ds3231Writ_0001B

    }

	tm1638DisplayOn();
08E4  118A  	BCF PCLATH,3
08E5  24D9  	CALL tm1638Disp_0001F

    tm1638UpdateDisplay();
08E6  22B4  	CALL tm1638Upda_00022


    // Enable interrupts
    intcon.GIE = 1;
08E7  178B  	BSF gbl_intcon,7

    intcon.PEIE = 1;
08E8  170B  	BSF gbl_intcon,6

}
08E9  0008  	RETURN


/*********************************************************************************************
  void main()
  Entry method. Loops infinitely with a simple task scheduler.
*********************************************************************************************/
void main() {

    initialise();
0915  20AB  	CALL initialise_00000


    // Endless loop
    while(1) {
0916        label151

        // Task scheduler
        // If there are tasks to be performed, find out the
        // most recent task from the array and execute it
        while (cTask > 0) {
0916  084E  	MOVF gbl_cTask, W
0917  3C00  	SUBLW 0x00
0918  158A  	BSF PCLATH,3
0919  1803  	BTFSC STATUS,C
091A  2916  	GOTO	label151

            if (cTask.TASK_TIMER1) {
091B  1D4E  	BTFSS gbl_cTask,2
091C  29CE  	GOTO	label171
09CE        label171

                if (!gcSetMode) {
091D  08D1  	MOVF gbl_gcSetMode, F
091E  1D03  	BTFSS STATUS,Z
091F  295C  	GOTO	label157

                    // Don't read date/time when in set mode
                    ds3231ReadDateTime();
0920  20EA  	CALL ds3231Read_0001C

                    if ((gBcdSecond == 0x29) || (gBcdSecond == 0x59)) {
0921  0835  	MOVF gbl_gBcdSecond, W
0922  3A29  	XORLW 0x29
0923  158A  	BSF PCLATH,3
0924  1903  	BTFSC STATUS,Z
0925  292A  	GOTO	label152
0926  0835  	MOVF gbl_gBcdSecond, W
0927  3A59  	XORLW 0x59
0928  1D03  	BTFSS STATUS,Z
0929  292F  	GOTO	label153
092A        label152
092F        label153

                        // Ask to convert for temperature reading at 29 seconds or 59 seconds past the minute
                        oneWireBusReset();
092A  2092  	CALL oneWireBus_00014

                        startTemp();
092B  158A  	BSF PCLATH,3
092C  200C  	CALL startTemp_00000

                    } else if ((gBcdSecond == 0) || (gBcdSecond == 0x30)) {
092D  158A  	BSF PCLATH,3
092E  293A  	GOTO	label155
092F  08B5  	MOVF gbl_gBcdSecond, F
0930  1903  	BTFSC STATUS,Z
0931  2936  	GOTO	label154
0932  0835  	MOVF gbl_gBcdSecond, W
0933  3A30  	XORLW 0x30
0934  1D03  	BTFSS STATUS,Z
0935  293A  	GOTO	label155
0936        label154
093A        label155
09FE  158A  	BSF PCLATH,3
09FF  2916  	GOTO	label151

                        // 1 second later, read the converted temperature
                        oneWireBusReset();
0936  2092  	CALL oneWireBus_00014

                        readTemp();
0937  158A  	BSF PCLATH,3
0938  2015  	CALL readTemp_00000

                        // store it in the array, next display refresh will pick it up
                        convertTemp();
0939  2555  	CALL convertTem_00027

                    }
                    // daylight savings time handling (UK/europe) - last sunday of March or October (this can fall between the 25th and the 31st)
                    if ((gBcdSecond == 0) && (gDayOfWeek == 7) && (gBcdDayOfMonth > 0x24)) {
093A  08B5  	MOVF gbl_gBcdSecond, F
093B  158A  	BSF PCLATH,3
093C  1D03  	BTFSS STATUS,Z
093D  295C  	GOTO	label157
093E  0838  	MOVF gbl_gDayOfWeek, W
093F  3A07  	XORLW 0x07
0940  1D03  	BTFSS STATUS,Z
0941  295C  	GOTO	label157
0942  0839  	MOVF gbl_gBcdDayOfMonth, W
0943  3C24  	SUBLW 0x24
0944  1803  	BTFSC STATUS,C
0945  295C  	GOTO	label157

						// In March, at 1AM, apply daylight savings time if appropriate
						if ((gBcdHour == 1) && (gBcdMonth == 3)) {
0946  0337  	DECF gbl_gBcdHour, W
0947  1D03  	BTFSS STATUS,Z
0948  2950  	GOTO	label156
0949  083A  	MOVF gbl_gBcdMonth, W
094A  3A03  	XORLW 0x03
094B  1D03  	BTFSS STATUS,Z
094C  2950  	GOTO	label156
0950        label156

							gBcdHour++; // one hour forwards
094D  0AB7  	INCF gbl_gBcdHour, F

							ds3231WriteDateTime();
094E  118A  	BCF PCLATH,3
094F  2519  	CALL ds3231Writ_0001B

						}
						// In October, at 2AM, remove daylight savings time if appropriate (UK/europe) daylight savings time if appropriate (UK/europe) - last sunday of October
						if ((gBcdHour == 2) && (gBcdMonth == 0x10)) {
0950  0837  	MOVF gbl_gBcdHour, W
0951  3A02  	XORLW 0x02
0952  158A  	BSF PCLATH,3
0953  1D03  	BTFSS STATUS,Z
0954  295C  	GOTO	label157
0955  083A  	MOVF gbl_gBcdMonth, W
0956  3A10  	XORLW 0x10
0957  1D03  	BTFSS STATUS,Z
0958  295C  	GOTO	label157
095C        label157

							gBcdHour--; // one hour back
0959  03B7  	DECF gbl_gBcdHour, F

							ds3231WriteDateTime();
095A  118A  	BCF PCLATH,3
095B  2519  	CALL ds3231Writ_0001B

						}
					}
                }
                if (!gcTriggerMode) {
095C  08D3  	MOVF gbl_gcTriggerMode, F
095D  158A  	BSF PCLATH,3
095E  1D03  	BTFSS STATUS,Z
095F  29C5  	GOTO	label169

					// Don't activate triggers when in trigger set mode
					// Trigger white led
					// Don't activate/deactivate if on and off set hour/min are the same
					if ((gBcdWhiteOnHour != gBcdWhiteOffHour) || (gBcdWhiteOnMinute != gBcdWhiteOffMinute)) {
0960  0857  	MOVF gbl_gBcdWhiteOffHour, W
0961  0655  	XORWF gbl_gBcdWhiteOnHour, W
0962  1D03  	BTFSS STATUS,Z
0963  2968  	GOTO	label158
0964  0856  	MOVF gbl_gBcdWhiteOffMinute, W
0965  0654  	XORWF gbl_gBcdWhiteOnMinute, W
0966  1903  	BTFSC STATUS,Z
0967  2978  	GOTO	label160
0968        label158

						if ((gBcdHour == gBcdWhiteOnHour) && (gBcdMinute == gBcdWhiteOnMinute)) {
0968  0855  	MOVF gbl_gBcdWhiteOnHour, W
0969  0637  	XORWF gbl_gBcdHour, W
096A  1D03  	BTFSS STATUS,Z
096B  2970  	GOTO	label159
096C  0854  	MOVF gbl_gBcdWhiteOnMinute, W
096D  0636  	XORWF gbl_gBcdMinute, W
096E  1903  	BTFSC STATUS,Z

							WHITE_LED = 1;
096F  1487  	BSF gbl_portc,1
0970        label159

						}
						if ((gBcdHour == gBcdWhiteOffHour) && (gBcdMinute == gBcdWhiteOffMinute)) {
0970  0857  	MOVF gbl_gBcdWhiteOffHour, W
0971  0637  	XORWF gbl_gBcdHour, W
0972  1D03  	BTFSS STATUS,Z
0973  2978  	GOTO	label160
0974  0856  	MOVF gbl_gBcdWhiteOffMinute, W
0975  0636  	XORWF gbl_gBcdMinute, W
0976  1903  	BTFSC STATUS,Z

							WHITE_LED = 0;
0977  1087  	BCF gbl_portc,1
0978        label160

						}
					}
					// Trigger blue led
					// Don't activate/deactivate if on and off set hour/min are the same
					if ((gBcdBlueOnHour != gBcdBlueOffHour) || (gBcdBlueOnMinute != gBcdBlueOffMinute)) {
0978  085B  	MOVF gbl_gBcdBlueOffHour, W
0979  0659  	XORWF gbl_gBcdBlueOnHour, W
097A  1D03  	BTFSS STATUS,Z
097B  2980  	GOTO	label161
097C  085A  	MOVF gbl_gBcdBlueOffMinute, W
097D  0658  	XORWF gbl_gBcdBlueOnMinute, W
097E  1903  	BTFSC STATUS,Z
097F  2990  	GOTO	label163
0980        label161

						if ((gBcdHour == gBcdBlueOnHour) && (gBcdMinute == gBcdBlueOnMinute)) {
0980  0859  	MOVF gbl_gBcdBlueOnHour, W
0981  0637  	XORWF gbl_gBcdHour, W
0982  1D03  	BTFSS STATUS,Z
0983  2988  	GOTO	label162
0984  0858  	MOVF gbl_gBcdBlueOnMinute, W
0985  0636  	XORWF gbl_gBcdMinute, W
0986  1903  	BTFSC STATUS,Z

							BLUE_LED = 1;
0987  1507  	BSF gbl_portc,2
0988        label162

						}
						if ((gBcdHour == gBcdBlueOffHour) && (gBcdMinute == gBcdBlueOffMinute)) {
0988  085B  	MOVF gbl_gBcdBlueOffHour, W
0989  0637  	XORWF gbl_gBcdHour, W
098A  1D03  	BTFSS STATUS,Z
098B  2990  	GOTO	label163
098C  085A  	MOVF gbl_gBcdBlueOffMinute, W
098D  0636  	XORWF gbl_gBcdMinute, W
098E  1903  	BTFSC STATUS,Z

							BLUE_LED = 0;
098F  1107  	BCF gbl_portc,2
0990        label163

						}
					}
					// 2nd Trigger blue led
					// Don't activate/deactivate if on and off set hour/min are the same
					if ((gBcdBlue2OnHour != gBcdBlue2OffHour) || (gBcdBlue2OnMinute != gBcdBlue2OffMinute)) {
0990  085F  	MOVF gbl_gBcdBlue2OffHour, W
0991  065D  	XORWF gbl_gBcdBlue2OnHour, W
0992  1D03  	BTFSS STATUS,Z
0993  2998  	GOTO	label164
0994  085E  	MOVF gbl_gBcdBlue2OffMinute, W
0995  065C  	XORWF gbl_gBcdBlue2OnMinute, W
0996  1903  	BTFSC STATUS,Z
0997  29A8  	GOTO	label166
0998        label164

						if ((gBcdHour == gBcdBlue2OnHour) && (gBcdMinute == gBcdBlue2OnMinute)) {
0998  085D  	MOVF gbl_gBcdBlue2OnHour, W
0999  0637  	XORWF gbl_gBcdHour, W
099A  1D03  	BTFSS STATUS,Z
099B  29A0  	GOTO	label165
099C  085C  	MOVF gbl_gBcdBlue2OnMinute, W
099D  0636  	XORWF gbl_gBcdMinute, W
099E  1903  	BTFSC STATUS,Z

							BLUE_LED = 1;
099F  1507  	BSF gbl_portc,2
09A0        label165

						}
						if ((gBcdHour == gBcdBlue2OffHour) && (gBcdMinute == gBcdBlue2OffMinute)) {
09A0  085F  	MOVF gbl_gBcdBlue2OffHour, W
09A1  0637  	XORWF gbl_gBcdHour, W
09A2  1D03  	BTFSS STATUS,Z
09A3  29A8  	GOTO	label166
09A4  085E  	MOVF gbl_gBcdBlue2OffMinute, W
09A5  0636  	XORWF gbl_gBcdMinute, W
09A6  1903  	BTFSC STATUS,Z

							BLUE_LED = 0;
09A7  1107  	BCF gbl_portc,2
09A8        label166

						}
					}
					// Trigger fan
					// Don't activate/deactivate if on and off temperature are the same
					if (gBcdFanOnTemp != gBcdFanOffTemp) {
09A8  0861  	MOVF gbl_gBcdFanOffTemp, W
09A9  0660  	XORWF gbl_gBcdFanOnTemp, W
09AA  1903  	BTFSC STATUS,Z
09AB  29B4  	GOTO	label167

						if (giDS3231ValueTruncCBCD >= gBcdFanOnTemp) {
09AC  0860  	MOVF gbl_gBcdFanOnTemp, W
09AD  024C  	SUBWF gbl_giDS3231ValueTruncCBCD, W
09AE  1803  	BTFSC STATUS,C

							FAN = 1;
09AF  1485  	BSF gbl_porta,1

						}
						if (giDS3231ValueTruncCBCD <= gBcdFanOffTemp) {
09B0  084C  	MOVF gbl_giDS3231ValueTruncCBCD, W
09B1  0261  	SUBWF gbl_gBcdFanOffTemp, W
09B2  1803  	BTFSC STATUS,C

							FAN = 0;
09B3  1085  	BCF gbl_porta,1
09B4        label167

						}
					}
					// Forced on
					if (gbFanOn)
09B4  184F  	BTFSC gbl_gbFanOn,0

						FAN = 1;
09B5  1485  	BSF gbl_porta,1

					// Trigger heater
					// Don't activate/deactivate if on and off temperature are the same
					if (gBcdHeaterOnTemp != gBcdHeaterOffTemp) {
09B6  0863  	MOVF gbl_gBcdHeaterOffTemp, W
09B7  0662  	XORWF gbl_gBcdHeaterOnTemp, W
09B8  1903  	BTFSC STATUS,Z
09B9  29C2  	GOTO	label168

						if (giDS3231ValueTruncCBCD <= gBcdHeaterOnTemp) {
09BA  084C  	MOVF gbl_giDS3231ValueTruncCBCD, W
09BB  0262  	SUBWF gbl_gBcdHeaterOnTemp, W
09BC  1803  	BTFSC STATUS,C

							HEATER = 1;
09BD  1405  	BSF gbl_porta,0

						}
						if (giDS3231ValueTruncCBCD >= gBcdHeaterOffTemp) {
09BE  0863  	MOVF gbl_gBcdHeaterOffTemp, W
09BF  024C  	SUBWF gbl_giDS3231ValueTruncCBCD, W
09C0  1803  	BTFSC STATUS,C

							HEATER = 0;
09C1  1005  	BCF gbl_porta,0
09C2        label168

						}
					}
					// If temperature is minus, always trigger heater
					if (gbDS3231IsMinus)
09C2  08CD  	MOVF gbl_gbDS3231IsMinus, F
09C3  1D03  	BTFSS STATUS,Z

						HEATER = 1;
09C4  1405  	BSF gbl_porta,0
09C5        label169

				}
				// Display time and temperature or date on TM1638 after clock tick
				if (!gcTriggerMode && !gcSetMode) {
09C5  08D3  	MOVF gbl_gcTriggerMode, F
09C6  1D03  	BTFSS STATUS,Z
09C7  29CD  	GOTO	label170
09C8  08D1  	MOVF gbl_gcSetMode, F
09C9  1D03  	BTFSS STATUS,Z
09CA  29CD  	GOTO	label170
09CD        label170

					tm1638UpdateDisplay();
09CB  118A  	BCF PCLATH,3
09CC  22B4  	CALL tm1638Upda_00022

                }

                cTask.TASK_TIMER1 = 0;
09CD  114E  	BCF gbl_cTask,2

            }
            if (cTask.TASK_TIMER0) {
09CE  158A  	BSF PCLATH,3
09CF  1CCE  	BTFSS gbl_cTask,1
09D0  2916  	GOTO	label151

				// Task should happen about every 50ms
                // Digit flashing - see if 10 counts has happened for an ~half second count
                iTimer0FlashCounts++;
09D1  0ABE  	INCF gbl_iTimer0FlashCounts, F

				if (iTimer0FlashCounts > 9) {
09D2  083E  	MOVF gbl_iTimer0FlashCounts, W
09D3  3C09  	SUBLW 0x09
09D4  1803  	BTFSC STATUS,C
09D5  29E0  	GOTO	label173

					iFlashDigitOff++;
09D6  0AC8  	INCF gbl_iFlashDigitOff, F

					iTimer0FlashCounts = 0;
09D7  01BE  	CLRF gbl_iTimer0FlashCounts

					// If in set or trigger mode, update the display every ~half second to flash a digit
					if (gcSetMode || gcTriggerMode)
09D8  08D1  	MOVF gbl_gcSetMode, F
09D9  1D03  	BTFSS STATUS,Z
09DA  29DE  	GOTO	label172
09DB  08D3  	MOVF gbl_gcTriggerMode, F
09DC  1903  	BTFSC STATUS,Z
09DD  29E0  	GOTO	label173
09DE        label172

						tm1638UpdateDisplay();
09DE  118A  	BCF PCLATH,3
09DF  22B4  	CALL tm1638Upda_00022

				}
				// Poll keys
				tm1638ReadKeys();
09E0  118A  	BCF PCLATH,3
09E1  27E9  	CALL tm1638Read_00025

				// Button state changed
                char processKeys = 0;
09E2  01F3  	CLRF main_104_processKeys

                if (tm1638Keys != tm1638KeysOld) {
09E3  086D  	MOVF gbl_tm1638KeysOld, W
09E4  066C  	XORWF gbl_tm1638Keys, W
09E5  1903  	BTFSC STATUS,Z
09E6  29EA  	GOTO	label174
09EA        label174

                    processKeys = 1;
09E7  3001  	MOVLW 0x01
09E8  00F3  	MOVWF main_104_processKeys

                } else if (tm1638Keys != 0) {
09E9  29F4  	GOTO	label175
09EA  08EC  	MOVF gbl_tm1638Keys, F
09EB  1903  	BTFSC STATUS,Z
09EC  29F4  	GOTO	label175

                    // Button held
                    iTimer0KeyCounts++;
09ED  0ABF  	INCF gbl_iTimer0KeyCounts, F

                    // If button held more than 250ms
                    if (iTimer0KeyCounts > 4) {
09EE  083F  	MOVF gbl_iTimer0KeyCounts, W
09EF  3C04  	SUBLW 0x04
09F0  1803  	BTFSC STATUS,C
09F1  29F4  	GOTO	label175
09F4        label175

                        processKeys = 1;
09F2  3001  	MOVLW 0x01
09F3  00F3  	MOVWF main_104_processKeys

                    }
                }
                if (processKeys) {
09F4  08F3  	MOVF main_104_processKeys, F
09F5  1903  	BTFSC STATUS,Z
09F6  29FD  	GOTO	label176
09FD        label176

					processKeys();
09F7  2024  	CALL processKey_0002A

					tm1638UpdateDisplay();
09F8  118A  	BCF PCLATH,3
09F9  22B4  	CALL tm1638Upda_00022

					tm1638KeysOld = tm1638Keys;
09FA  086C  	MOVF gbl_tm1638Keys, W
09FB  00ED  	MOVWF gbl_tm1638KeysOld

                    iTimer0KeyCounts = 0;
09FC  01BF  	CLRF gbl_iTimer0KeyCounts

                }
                cTask.TASK_TIMER0 = 0;
09FD  10CE  	BCF gbl_cTask,1

            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
// I2C Communications Library for I2C MASTER
////////////////////////////////////////////////////////////////////////////
// Author(s): Andrew Smallridge
// Date 15 November 2004
//
// Copyright(C) 2004-2006 Andrew Smallridge
// Copyright(C) 2004-2010 Pavel Baranov
// Copyright(C) 2004-2010 David Hobday
// Existing constants predefined for i2c hardware driver and i2s software
// emulation for the PIC 18F2xx and 18F4xx processors. For hardware support
// on other PICs the constants must be mapped to the corresponding register
// map of the target device
////////////////////////////////////////////////////////////////////////////

/*
////////////////////////////////////////////////////////////////////////////
//	The following three sections should be copied to the user's program:
//		i2c master hardware / software mode definition
//		i2c software implementation template arguments and variables
// 		i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////
// i2c master hardware / software mode definition
//
// For i2c hardware support comment out the #define use_ic2_SW line
////////////////////////////////////////////////////////////////////////////
//#define use_i2c_SW

#if defined use_i2c_SW
////////////////////////////////////////////////////////////////////////////
// i2c software implementation template arguments and variables
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)

// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and software emalated i2c RAM locations. These constants are
// then used by the templated functions. When changing the address of an emulated
// register the corresponding constant mapping must also be changed.
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3					

#else
////////////////////////////////////////////////////////////////////////////
// i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP |i2c_HW)

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and PIC's i2c register locations. These constants are
// then used by the templated functions. 
#define PORTC		0x0f82
#define TRISC		0x0f94
#define e_SSPCON1	0xfc6
#define e_SSPCON2	0xfc5
#define e_SSPSTAT	0xfc7
#define e_SSPADD	0xfc8
#define e_SSPBUF	0xfc9
#define e_SSPIF_PIR	0xf9e
#define e_BCLIF_PIR	0xfa1
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3

#endif

*/


////////////////////////////////////////////////////////////////////////////
// Define the common i2c template structure
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL	template <unsigned char T_SCL_BIT, unsigned short T_SCL_PORT,	\
					unsigned short T_SCL_TRIS, unsigned char T_SDA_BIT, 			\
					unsigned short T_SDA_PORT, unsigned short T_SDA_TRIS,			\
					unsigned short T_i2c_SSPCON1, unsigned short T_i2c_SSPCON2, 	\
					unsigned short T_i2c_SSPSTAT, unsigned short T_i2c_SSPBUF, 		\
					unsigned char T_i2c_SSPIF_BIT, unsigned short T_i2c_SSPIF_PIR,	\
					unsigned char T_i2c_BCLIF_BIT, unsigned short T_i2c_BCLIF_PIR,	\
					unsigned char T_i2c_SMP_BIT, unsigned short T_i2c_SSPADD, 		\
					unsigned char T_MODE>

////////////////////////////////////////////////////////////////////////////
// Define the common i2c template parameters
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL_ARGS	T_SCL_BIT, T_SCL_PORT, T_SCL_TRIS, T_SDA_BIT, 			\
						T_SDA_PORT, T_SDA_TRIS, T_i2c_SSPCON1, T_i2c_SSPCON2, 	\
						T_i2c_SSPSTAT, T_i2c_SSPBUF, T_i2c_SSPIF_BIT, 			\
						T_i2c_SSPIF_PIR, T_i2c_BCLIF_BIT, T_i2c_BCLIF_PIR,		\
						T_i2c_SMP_BIT, T_i2c_SSPADD, T_MODE

////////////////////////////////////////////////////////////////////////////
// Helpers that hide template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_init	i2c_INIT<i2c_ARGS>
#define i2c_start	i2c_START<i2c_ARGS>
#define i2c_restart	i2c_RESTART<i2c_ARGS>
#define i2c_stop	i2c_STOP<i2c_ARGS>
#define i2c_read	i2c_READ<i2c_ARGS>
#define i2c_write	i2c_WRITE<i2c_ARGS>


////////////////////////////////////////////////////////////////////////////
// I2C Control Status Bits - Emulates the PIC18F hardware I2C implementation
////////////////////////////////////////////////////////////////////////////
// define I2C i2C_SSPCON1 control bits
#define	i2c_WCOL	7
#define	i2c_SSPOV	6
#define	i2c_SSPEN	5
#define	i2c_CKP		4
#define	i2c_SSPM3	3
#define	i2c_SSPM2	2
#define	i2c_SSPM1	1
#define	i2c_SSPM0	0

// define I2C SSPCON2 control bits
#define	i2c_GCEN 	7
#define	i2c_ACKSTAT	6
#define	i2c_ACKDT	5
#define	i2c_ACKEN	4
#define	i2c_RCEN	3
#define	i2c_PEN		2
#define	i2c_RSEN	1
#define	i2c_SEN		0

// define I2C SSPSTAT status bits
#define	i2c_DA		5
#define	i2c_P		4
#define	i2c_S		3
#define	i2c_RW		2
#define	i2c_UA		1
#define	i2c_BF		0


////////////////////////////////////////////////////////////////////////////
// I2C Control Flag Bits
////////////////////////////////////////////////////////////////////////////
// define I2C Mode bits
#define	i2c_HW			0x01
#define	i2c_400KHz		0x02	// 100KHz or 400KHz I2C clock (set = 400KHz)
#define	i2c_reset_wdt	0x04
#define i2c_SMP			0x80	


////////////////////////////////////////////////////////////////////////////
// I2C software constants
////////////////////////////////////////////////////////////////////////////
#define	dly 10	// number of 1us delay increments



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Start Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL 
void i2c_START(void)

{
	// Initiate the I2C START condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	delay_us(dly);
012A  300A  	MOVLW 0x0A
012B  1283  	BCF STATUS, RP0
012C  1303  	BCF STATUS, RP1
012D  00F9  	MOVWF delay_us_00000_arg_del
012E  2010  	CALL delay_us_00000

	l_bclif = 0; // initialise the collision flag for this command
012F  11C6  	BCF i2c_START_00000_1_l_bclif,3

	l_sspif = 0;
0130  11C5  	BCF i2c_START_00000_1_l_sspif,3

		
	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
			
		l_sen = 1; // initiate START condition	

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation			
		l_sen = 1; // initiate START condition
0131  1441  	BSF i2c_START_00000_1_l_sen,0

		l_scl_tris = 1; // ensure the SCL line is high
0132  1683  	BSF STATUS, RP0
0133  1587  	BSF i2c_START_00000_1_l_scl_tris,3

		l_sda_tris = 1; // ensure the SDA line is high	
0134  1607  	BSF i2c_START_00000_1_l_sda_tris,4

		l_scl = 0; // prepare to set SCL line low
0135  1283  	BCF STATUS, RP0
0136  1187  	BCF i2c_START_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low
0137  1207  	BCF i2c_START_00000_1_l_sda,4

		
		if (l_scl && l_sda)
0138  1D87  	BTFSS i2c_START_00000_1_l_scl,3
0139  2957  	GOTO	label24
013A  1E07  	BTFSS i2c_START_00000_1_l_sda,4
013B  2957  	GOTO	label24
0157        label24

		{
			// good sign - no collision detected
			delay_us(dly);
013C  300A  	MOVLW 0x0A
013D  00F9  	MOVWF delay_us_00000_arg_del
013E  2010  	CALL delay_us_00000

			
			if (!l_scl) // ensure the clock is still high
013F  1987  	BTFSC i2c_START_00000_1_l_scl,3
0140  2945  	GOTO	label23
0145        label23

			{
				l_bclif = 1;
0141  15C6  	BSF i2c_START_00000_1_l_bclif,3

				l_s = 1;
0142  15C2  	BSF i2c_START_00000_1_l_s,3

				l_sen = 0;
0143  1041  	BCF i2c_START_00000_1_l_sen,0

				return;
			}
					
			l_sda = 0; // prepare to set SDA line low
0145  1207  	BCF i2c_START_00000_1_l_sda,4

			l_sda_tris = 0; // SDA to output (driven low)
0146  1683  	BSF STATUS, RP0
0147  1207  	BCF i2c_START_00000_1_l_sda_tris,4


			delay_us(dly);					
0148  300A  	MOVLW 0x0A
0149  1283  	BCF STATUS, RP0
014A  00F9  	MOVWF delay_us_00000_arg_del
014B  2010  	CALL delay_us_00000

			l_scl = 0; // prepare to set SCL line low
014C  1187  	BCF i2c_START_00000_1_l_scl,3

			l_scl_tris = 0; // SCL to output (driven low)
014D  1683  	BSF STATUS, RP0
014E  1187  	BCF i2c_START_00000_1_l_scl_tris,3


			delay_us(dly);					
014F  300A  	MOVLW 0x0A
0150  1283  	BCF STATUS, RP0
0151  00F9  	MOVWF delay_us_00000_arg_del
0152  2010  	CALL delay_us_00000

			l_s = 1; // set 'S' bit flag (start bit detected)
0153  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0; // clear flag
0154  1041  	BCF i2c_START_00000_1_l_sen,0

			l_sspif = 1; // flag end of start condition interrupt	
0155  15C5  	BSF i2c_START_00000_1_l_sspif,3

		}
		else
		{
			// here is SDA or SCL are low at the start - indicates a bus collision
			l_bclif = 1;
0157  15C6  	BSF i2c_START_00000_1_l_bclif,3

			l_s = 1; // set 'S' bit flag (start bit detected)
0158  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0;
0159  1041  	BCF i2c_START_00000_1_l_sen,0

			l_rsen = 0;
015A  10C1  	BCF i2c_START_00000_1_l_rsen,1

			l_pen = 0;
015B  1141  	BCF i2c_START_00000_1_l_pen,2

			l_rcen = 0;								
015C  11C1  	BCF i2c_START_00000_1_l_rcen,3

			l_acken = 0;			
015D  1241  	BCF i2c_START_00000_1_l_acken,4

		}
	}
}
0144  0008  	RETURN
0156  0008  	RETURN
015E  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Restart Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_RESTART(void)
{
	// Initiate the I2C RESTART condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
			
	delay_us(dly);
	l_bclif = 0; // initialise the collision flag for this command
	l_sspif = 0;

	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_rsen = 1; // initiate RESTART condition
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation	
		l_rsen = 1;
		l_scl = 0;
		l_sda = 0;
		
		if (!l_scl)
		{
			// good sign - no other I2C activity in progress
			l_sda_tris = 1; // float SDA line high	(should already be in this condition)	
			delay_us(dly);
		
			// about to float the clock line
			// ensure the data line is still high
			if (!l_sda)
			{
				// problem - SDA is low, a bus collision has occurred				
				l_bclif = 1; // set the bus collision flag	
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_scl_tris = 1; // float SCL line (high)	
				return;
			}
												
			l_scl_tris = 1; // float SCL line (high)

			// wait until any clock stretching has finished
			while (!l_scl)
				if (T_MODE & i2c_reset_wdt)
					clear_wdt();	
			delay_us(dly);
			
			// here we are about to drive SDA low
			// first ensure SCL is still high
			if (!l_scl)
			{
				// problem - SCL is low, a bus collision has occurred
				l_bclif = 1; // set the bus collision flag
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_sda_tris = 1; // float SDA line (high)
				return;
			}
				
			l_sda_tris = 0; // drive SDA low
			l_s = 1; // set 'S' bit flag (start bit detected)

			delay_us(dly);
			l_scl_tris = 0; // drive SCL low
			l_rsen = 0;
			l_pen = 0;
			l_sen = 0;			
			l_rcen = 0;								
			l_acken = 0;			
			l_sspif = 1; // flag end of start condition interrupt
		}
		else
		{
			// SCL is high at the start
			// some other I2C activity in progress		
			l_rsen = 0; // clear flag
			// exit without further action
		}
	}
}



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Stop Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_STOP(void)

{ 
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_p@T_i2c_SSPSTAT.i2c_P; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;

	l_bclif = 0; // initialise the collision flag for this command
00FA  1283  	BCF STATUS, RP0
00FB  1303  	BCF STATUS, RP1
00FC  11C6  	BCF i2c_STOP_00000_1_l_bclif,3

	l_sspif = 0;
00FD  11C5  	BCF i2c_STOP_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_pen = 1; // initiate STOP condition on the I2C bus	
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
		
	}
	else
	{
		//	Software I2C implementation
		l_pen = 1; // initiate STOP condition on the I2C bus
00FE  1541  	BSF i2c_STOP_00000_1_l_pen,2

		delay_us(dly);
00FF  300A  	MOVLW 0x0A
0100  00F9  	MOVWF delay_us_00000_arg_del
0101  2010  	CALL delay_us_00000

		
		l_scl = 0; // prepare to set SCL line low
0102  1187  	BCF i2c_STOP_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low
0103  1207  	BCF i2c_STOP_00000_1_l_sda,4

		l_scl_tris = 0; // drive SCL line low (should already be low)
0104  1683  	BSF STATUS, RP0
0105  1187  	BCF i2c_STOP_00000_1_l_scl_tris,3

		l_sda_tris = 0; // drive SDA line low
0106  1207  	BCF i2c_STOP_00000_1_l_sda_tris,4


		delay_us(dly);		
0107  300A  	MOVLW 0x0A
0108  1283  	BCF STATUS, RP0
0109  00F9  	MOVWF delay_us_00000_arg_del
010A  2010  	CALL delay_us_00000

		l_scl_tris = 1; // float SCL line (high)
010B  1683  	BSF STATUS, RP0
010C  1587  	BSF i2c_STOP_00000_1_l_scl_tris,3

		
		// wait until any clock stretching has finished
		while (!l_scl)
010D        label19
010D  1283  	BCF STATUS, RP0
010E  1987  	BTFSC i2c_STOP_00000_1_l_scl,3
010F  2912  	GOTO	label20
0111  290D  	GOTO	label19
0112        label20

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
0110  0064  	CLRWDT

						
		delay_us(dly);
0112  300A  	MOVLW 0x0A
0113  00F9  	MOVWF delay_us_00000_arg_del
0114  2010  	CALL delay_us_00000

		l_sda_tris = 1; // float SDA line
0115  1683  	BSF STATUS, RP0
0116  1607  	BSF i2c_STOP_00000_1_l_sda_tris,4

		delay_us(dly);		
0117  300A  	MOVLW 0x0A
0118  1283  	BCF STATUS, RP0
0119  00F9  	MOVWF delay_us_00000_arg_del
011A  2010  	CALL delay_us_00000

		
		// here the SDA line should be high - if not a collision has occurred				
		if (!l_sda || !l_scl)
011B  1E07  	BTFSS i2c_STOP_00000_1_l_sda,4
011C  291F  	GOTO	label21
011D  1987  	BTFSC i2c_STOP_00000_1_l_scl,3
011E  2923  	GOTO	label22
011F        label21
0123        label22

		{
			// problem - SDA or SCL is low, a bus collision has occurred
			l_bclif = 1; // set the bus collision flag	
011F  15C6  	BSF i2c_STOP_00000_1_l_bclif,3

			l_s = 0; // clear 'S' bit flag
0120  11C2  	BCF i2c_STOP_00000_1_l_s,3

			l_pen = 0; // clear flag
0121  1141  	BCF i2c_STOP_00000_1_l_pen,2

		}
		else
		{		
			l_p = 1;
0123  1642  	BSF i2c_STOP_00000_1_l_p,4

			l_pen = 0;
0124  1141  	BCF i2c_STOP_00000_1_l_pen,2

			l_sen = 0;
0125  1041  	BCF i2c_STOP_00000_1_l_sen,0

			l_rsen = 0;			
0126  10C1  	BCF i2c_STOP_00000_1_l_rsen,1

			l_rcen = 0;								
0127  11C1  	BCF i2c_STOP_00000_1_l_rcen,3

			l_acken = 0;
0128  1241  	BCF i2c_STOP_00000_1_l_acken,4

		}
	}
}
0122  0008  	RETURN
0129  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Write Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_WRITE(unsigned char i2c_data)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;	
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
	
	char BitMask;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
00A9  11C6  	BCF i2c_WRITE_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
00AA  11C5  	BCF i2c_WRITE_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
				
		l_wcol = 0; // clear write collision flag	
		i2c_SSPBUF = i2c_data;

		// test if a write collision occurred
		if (l_wcol)
			return (1); // error exit	

		// wait until MSSP Tx register is empty
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
								
		return (0); // successful exit
	}

	// here for i2c software driver
	l_wcol = 0; // clear write collision flag	
00AB  13C0  	BCF i2c_WRITE_00000_1_l_wcol,7

	i2c_SSPBUF = i2c_data;
00AC  0876  	MOVF i2c_WRITE_00000_arg_i2c_data, W
00AD  00C4  	MOVWF i2c_WRITE_00000_1_i2c_SSPBUF

	
	l_scl = 0; // prepare to set SCL line low
00AE  1187  	BCF i2c_WRITE_00000_1_l_scl,3

	l_sda = 0; // prepare to set SDA line low
00AF  1207  	BCF i2c_WRITE_00000_1_l_sda,4

	l_rw = 0; // signal we are doing a write
00B0  1142  	BCF i2c_WRITE_00000_1_l_rw,2


	for (BitMask = 0x80; BitMask; BitMask>>=1)
00B1  3080  	MOVLW 0x80
00B2  00F7  	MOVWF i2c_WRITE_00000_1_BitMask
00B3        label11
00B3  08F7  	MOVF i2c_WRITE_00000_1_BitMask, F
00B4  1903  	BTFSC STATUS,Z
00B5  28D6  	GOTO	label16
00D3  1003  	BCF STATUS,C
00D4  0CF7  	RRF i2c_WRITE_00000_1_BitMask, F
00D5  28B3  	GOTO	label11
00D6        label16

	{
		if (i2c_data & BitMask)
00B6  0877  	MOVF i2c_WRITE_00000_1_BitMask, W
00B7  0576  	ANDWF i2c_WRITE_00000_arg_i2c_data, W
00B8  1903  	BTFSC STATUS,Z
00B9  28BD  	GOTO	label12
00BD        label12

			l_sda_tris = 1; // float SDA high	
00BA  1683  	BSF STATUS, RP0
00BB  1607  	BSF i2c_WRITE_00000_1_l_sda_tris,4

		else
00BC  28BF  	GOTO	label13
00BF        label13

			l_sda_tris = 0; // drive SDA low
00BD  1683  	BSF STATUS, RP0
00BE  1207  	BCF i2c_WRITE_00000_1_l_sda_tris,4

		delay_us(dly);
00BF  300A  	MOVLW 0x0A
00C0  1283  	BCF STATUS, RP0
00C1  00F9  	MOVWF delay_us_00000_arg_del
00C2  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
00C3  1683  	BSF STATUS, RP0
00C4  1587  	BSF i2c_WRITE_00000_1_l_scl_tris,3


		// wait until any clock stretching has finished
		while (!l_scl)
00C5        label14
00C5  1283  	BCF STATUS, RP0
00C6  1987  	BTFSC i2c_WRITE_00000_1_l_scl,3
00C7  28CA  	GOTO	label15
00C9  28C5  	GOTO	label14
00CA        label15

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
00C8  0064  	CLRWDT

		delay_us(dly);
00CA  300A  	MOVLW 0x0A
00CB  00F9  	MOVWF delay_us_00000_arg_del
00CC  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low	
00CD  1683  	BSF STATUS, RP0
00CE  1187  	BCF i2c_WRITE_00000_1_l_scl_tris,3

		delay_us(dly);
00CF  300A  	MOVLW 0x0A
00D0  1283  	BCF STATUS, RP0
00D1  00F9  	MOVWF delay_us_00000_arg_del
00D2  2010  	CALL delay_us_00000

	}
	// serialized out the data
	// now get the status		
	// set SSPIF
	l_sspif = 1;
00D6  15C5  	BSF i2c_WRITE_00000_1_l_sspif,3

	l_acken = 1;
00D7  1641  	BSF i2c_WRITE_00000_1_l_acken,4

	l_ackdt = 0;
00D8  12C1  	BCF i2c_WRITE_00000_1_l_ackdt,5

	l_sda_tris = 1; // float SDA high
00D9  1683  	BSF STATUS, RP0
00DA  1607  	BSF i2c_WRITE_00000_1_l_sda_tris,4

	
	delay_us(dly);
00DB  300A  	MOVLW 0x0A
00DC  1283  	BCF STATUS, RP0
00DD  00F9  	MOVWF delay_us_00000_arg_del
00DE  2010  	CALL delay_us_00000

	
	l_scl_tris = 1; // float SCL high
00DF  1683  	BSF STATUS, RP0
00E0  1587  	BSF i2c_WRITE_00000_1_l_scl_tris,3

	
	// wait until any clock stretching has finished
	while (!l_scl)
00E1        label17
00E1  1283  	BCF STATUS, RP0
00E2  1987  	BTFSC i2c_WRITE_00000_1_l_scl,3
00E3  28E6  	GOTO	label18
00E5  28E1  	GOTO	label17
00E6        label18

		if (T_MODE & i2c_reset_wdt)
			clear_wdt();	
00E4  0064  	CLRWDT

	delay_us(dly);
00E6  300A  	MOVLW 0x0A
00E7  00F9  	MOVWF delay_us_00000_arg_del
00E8  2010  	CALL delay_us_00000


	// get the status bit
	local_ack = l_sda;
00E9  1078  	BCF i2c_WRITE_00000_1_local_ack,0
00EA  1A07  	BTFSC i2c_WRITE_00000_1_l_sda,4
00EB  1478  	BSF i2c_WRITE_00000_1_local_ack,0

	delay_us(dly);
00EC  300A  	MOVLW 0x0A
00ED  00F9  	MOVWF delay_us_00000_arg_del
00EE  2010  	CALL delay_us_00000


	l_scl_tris = 0; // drive SCL low	
00EF  1683  	BSF STATUS, RP0
00F0  1187  	BCF i2c_WRITE_00000_1_l_scl_tris,3

	l_acken = 0;
00F1  1283  	BCF STATUS, RP0
00F2  1241  	BCF i2c_WRITE_00000_1_l_acken,4

	delay_us(dly);
00F3  300A  	MOVLW 0x0A
00F4  00F9  	MOVWF delay_us_00000_arg_del
00F5  2010  	CALL delay_us_00000

	return(local_ack);
00F6  01F9  	CLRF CompTempVarRet550
00F7  1878  	BTFSC i2c_WRITE_00000_1_local_ack,0
00F8  0AF9  	INCF CompTempVarRet550, F

}
00F9  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Read Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_READ(char ack_status)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	char BitMask;
	char i2c_data;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
01F5  11C6  	BCF i2c_READ_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
01F6  11C5  	BCF i2c_READ_00000_1_l_sspif,3

	l_wcol = 0; // clear write collision flag	
01F7  13C0  	BCF i2c_READ_00000_1_l_wcol,7


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// enable master for 1 byte reception	
		l_rcen = 1;

		// wait until byte received
		while(!l_sspif || !l_bf)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// read the byte from the Rx register
		i2c_data = i2c_SSPBUF;			
			
		// wait until the bus is idle		
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		if (ack_status)
			l_ackdt = 1; // preset ack bit
		else
			l_ackdt = 0; // preset ack bit

		l_sspif = 0;
		l_acken = 1; // acknowledge sequence enable

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();								
	}
	else
	{
		// here for i2c software driver
		l_rcen = 1;
01F8  15C1  	BSF i2c_READ_00000_1_l_rcen,3

		l_ackdt = ack_status;
01F9  1876  	BTFSC i2c_READ_00000_arg_ack_status,0
01FA  16C1  	BSF i2c_READ_00000_1_l_ackdt,5
01FB  1C76  	BTFSS i2c_READ_00000_arg_ack_status,0
01FC  12C1  	BCF i2c_READ_00000_1_l_ackdt,5

		l_rw = 1;
01FD  1542  	BSF i2c_READ_00000_1_l_rw,2

		l_scl = 0; // prepare to set SCL line low
01FE  1187  	BCF i2c_READ_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low	
01FF  1207  	BCF i2c_READ_00000_1_l_sda,4


		// prepare to serialize in the byte
		l_sda_tris = 1; // float SDA
0200  1683  	BSF STATUS, RP0
0201  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

		delay_us(dly);
0202  300A  	MOVLW 0x0A
0203  1283  	BCF STATUS, RP0
0204  00F9  	MOVWF delay_us_00000_arg_del
0205  2010  	CALL delay_us_00000

		i2c_data = 0;
0206  01F8  	CLRF i2c_READ_00000_1_i2c_data

		for (BitMask = 0x80; BitMask; BitMask>>=1)
0207  3080  	MOVLW 0x80
0208  00F7  	MOVWF i2c_READ_00000_1_BitMask
0209        label36
0209  08F7  	MOVF i2c_READ_00000_1_BitMask, F
020A  1903  	BTFSC STATUS,Z
020B  2A26  	GOTO	label40
0223  1003  	BCF STATUS,C
0224  0CF7  	RRF i2c_READ_00000_1_BitMask, F
0225  2A09  	GOTO	label36
0226        label40

		{
			l_scl_tris = 1; // float SCL high
020C  1683  	BSF STATUS, RP0
020D  1587  	BSF i2c_READ_00000_1_l_scl_tris,3

			// wait until any clock stretching has finished
			while (!l_scl)
020E        label37
020E  1283  	BCF STATUS, RP0
020F  1987  	BTFSC i2c_READ_00000_1_l_scl,3
0210  2A13  	GOTO	label38
0212  2A0E  	GOTO	label37
0213        label38

				if (T_MODE & i2c_reset_wdt)
					clear_wdt();		
0211  0064  	CLRWDT

			delay_us(dly);
0213  300A  	MOVLW 0x0A
0214  00F9  	MOVWF delay_us_00000_arg_del
0215  2010  	CALL delay_us_00000


			// read the current bit
			l_sda_tris = 1; // float SDA
0216  1683  	BSF STATUS, RP0
0217  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

			if (l_sda)
0218  1283  	BCF STATUS, RP0
0219  1E07  	BTFSS i2c_READ_00000_1_l_sda,4
021A  2A1D  	GOTO	label39
021D        label39

				i2c_data |= BitMask;
021B  0877  	MOVF i2c_READ_00000_1_BitMask, W
021C  04F8  	IORWF i2c_READ_00000_1_i2c_data, F

			l_scl_tris = 0; // drive SCL low
021D  1683  	BSF STATUS, RP0
021E  1187  	BCF i2c_READ_00000_1_l_scl_tris,3

			delay_us(dly);
021F  300A  	MOVLW 0x0A
0220  1283  	BCF STATUS, RP0
0221  00F9  	MOVWF delay_us_00000_arg_del
0222  2010  	CALL delay_us_00000

		}
		// flag receive complete			
		l_sspif = 1;
0226  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		l_rcen = 0;
0227  11C1  	BCF i2c_READ_00000_1_l_rcen,3

		
		// set the ACK state
		if (ack_status)	
0228  08F6  	MOVF i2c_READ_00000_arg_ack_status, F
0229  1903  	BTFSC STATUS,Z
022A  2A2E  	GOTO	label41
022E        label41

			l_sda_tris = 1; // float SDA high
022B  1683  	BSF STATUS, RP0
022C  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

		else
022D  2A30  	GOTO	label42
0230        label42

			l_sda_tris = 0; // drive SDA low
022E  1683  	BSF STATUS, RP0
022F  1207  	BCF i2c_READ_00000_1_l_sda_tris,4

		delay_us(dly);
0230  300A  	MOVLW 0x0A
0231  1283  	BCF STATUS, RP0
0232  00F9  	MOVWF delay_us_00000_arg_del
0233  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
0234  1683  	BSF STATUS, RP0
0235  1587  	BSF i2c_READ_00000_1_l_scl_tris,3


		// wait until any clock stretching has finished
		while (!l_scl)
0236        label43
0236  1283  	BCF STATUS, RP0
0237  1987  	BTFSC i2c_READ_00000_1_l_scl,3
0238  2A3B  	GOTO	label44
023A  2A36  	GOTO	label43
023B        label44

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
0239  0064  	CLRWDT

	
		l_sspif = 0; // clear SSPIF
023B  11C5  	BCF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
023C  300A  	MOVLW 0x0A
023D  00F9  	MOVWF delay_us_00000_arg_del
023E  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low		
023F  1683  	BSF STATUS, RP0
0240  1187  	BCF i2c_READ_00000_1_l_scl_tris,3

		l_sspif = 1;
0241  1283  	BCF STATUS, RP0
0242  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
0243  300A  	MOVLW 0x0A
0244  00F9  	MOVWF delay_us_00000_arg_del
0245  2010  	CALL delay_us_00000

	}
	return(i2c_data);
0246  0878  	MOVF i2c_READ_00000_1_i2c_data, W
0247  00F9  	MOVWF CompTempVarRet551

}
0248  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Initialization
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_INIT(unsigned char i2c_divisor)

{
	volatile unsigned char i2c_SSPADD@T_i2c_SSPADD, i2c_SSPSTAT@T_i2c_SSPSTAT;
	volatile unsigned char i2c_SSPCON1@T_i2c_SSPCON1,i2c_SSPCON2@T_i2c_SSPCON2;

	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_sspen@T_i2c_SSPCON1.i2c_SSPEN, l_smp@T_i2c_SSPSTAT.T_i2c_SMP_BIT;

	l_sda_tris = 1;
0506  1683  	BSF STATUS, RP0
0507  1607  	BSF i2c_INIT_00000_1_l_sda_tris,4

	l_scl_tris = 1;
0508  1587  	BSF i2c_INIT_00000_1_l_scl_tris,3

	
	i2c_SSPCON1 = 0x00; // initialise the I2C control register (mirrors HW SSPCON1)	
0509  1283  	BCF STATUS, RP0
050A  01C0  	CLRF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPADD = i2c_divisor; // get the I2C baud rate divisor
050B  0874  	MOVF i2c_INIT_00000_arg_i2c_divisor, W
050C  00C3  	MOVWF i2c_INIT_00000_1_i2c_SSPADD

	i2c_SSPCON1 = 0x08; // initialise the I2C control register (mirrors HW SSPCON1)	
050D  3008  	MOVLW 0x08
050E  00C0  	MOVWF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPCON2 = 0x00; // initialise the I2C control register (mirrors HW SSPCON2)	
050F  01C1  	CLRF i2c_INIT_00000_1_i2c_SSPCON2

	
	i2c_SSPSTAT = 0x00; // initialise the I2C status register (mirrors HW SSPSTAT)
0510  01C2  	CLRF i2c_INIT_00000_1_i2c_SSPSTAT

	
	if (T_MODE & i2c_SMP)
		l_smp = 1;
0511  17C2  	BSF i2c_INIT_00000_1_l_smp,7


	l_sspif = 0; // initialise the I2C SSP interrupt status
0512  11C5  	BCF i2c_INIT_00000_1_l_sspif,3

	l_bclif = 0; // initialise the I2C BCL interrupt status
0513  11C6  	BCF i2c_INIT_00000_1_l_bclif,3

	l_sda = 0;
0514  1207  	BCF i2c_INIT_00000_1_l_sda,4

	l_scl = 0;
0515  1187  	BCF i2c_INIT_00000_1_l_scl,3

	l_sspen = 1; // enable I2C
0516  16C0  	BSF i2c_INIT_00000_1_l_sspen,5

	
	i2c_STOP<_I2C_TEMPL_ARGS>();
0517  20FA  	CALL i2c_STOP_00000

}
0518  0008  	RETURN







////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  158A  	BSF PCLATH,3
0001  2A00  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B0  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00B1  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00B2  	MOVWF Int1BContext+D'2'
000D  158A  	BSF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2A65  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010  3003  	MOVLW 0x03
0011  07F9  	ADDWF delay_us_00000_arg_del, F
0012  0CF9  	RRF delay_us_00000_arg_del, F
0013  0CF9  	RRF delay_us_00000_arg_del, F
0014  307F  	MOVLW 0x7F
0015  05F9  	ANDWF delay_us_00000_arg_del, F
0016        label1
0016  0000  	NOP
0017  0BF9  	DECFSZ delay_us_00000_arg_del, F
0018  2816  	GOTO	label1
0019  0008  	RETURN
001A        ; } delay_us function end

001A        __rom_get_00000
001A        ; { __rom_get ; function begin
001A  087C  	MOVF __rom_get_00000_arg_objNumb, W
001B  1683  	BSF STATUS, RP0
001C  00A1  	MOVWF __rom_get_00000_1_romAddr+D'1'
001D  01A0  	CLRF __rom_get_00000_1_romAddr
001E  1003  	BCF STATUS,C
001F  0DA1  	RLF __rom_get_00000_1_romAddr+D'1', F
0020  0DA0  	RLF __rom_get_00000_1_romAddr, F
0021  0DA1  	RLF __rom_get_00000_1_romAddr+D'1', F
0022  0DA0  	RLF __rom_get_00000_1_romAddr, F
0023  07A1  	ADDWF __rom_get_00000_1_romAddr+D'1', F
0024  1803  	BTFSC STATUS,C
0025  0AA0  	INCF __rom_get_00000_1_romAddr, F
0026  07A1  	ADDWF __rom_get_00000_1_romAddr+D'1', F
0027  1803  	BTFSC STATUS,C
0028  0AA0  	INCF __rom_get_00000_1_romAddr, F
0029  3036  	MOVLW	LOW( label2 )
002A  07A1  	ADDWF __rom_get_00000_1_romAddr+D'1', F
002B  1803  	BTFSC STATUS,C
002C  0AA0  	INCF __rom_get_00000_1_romAddr, F
002D  3000  	MOVLW	HIGH( label2 )
002E  0720  	ADDWF __rom_get_00000_1_romAddr, W
002F  008A  	MOVWF PCLATH
0030  1283  	BCF STATUS, RP0
0031  087D  	MOVF __rom_get_00000_arg_idx, W
0032  1683  	BSF STATUS, RP0
0033  00A0  	MOVWF __rom_get_00000_1_romAddr
0034  0821  	MOVF __rom_get_00000_1_romAddr+D'1', W
0035  0082  	MOVWF PCL
0036        label2
0036  3000  	MOVLW	HIGH( label3 )
0037  008A  	MOVWF PCLATH
0038  3000  	MOVLW	HIGH( label4 )
0039  00A1  	MOVWF __rom_get_00000_1_romAddr+D'1'
003A  304C  	MOVLW	LOW( label4 )
003B  2845  	GOTO	label3
003C  3000  	MOVLW	HIGH( label3 )
003D  008A  	MOVWF PCLATH
003E  3000  	MOVLW	HIGH( label5 )
003F  00A1  	MOVWF __rom_get_00000_1_romAddr+D'1'
0040  3058  	MOVLW	LOW( label5 )
0041  2845  	GOTO	label3
0042  3000  	MOVLW	HIGH( label6 )
0043  00A1  	MOVWF __rom_get_00000_1_romAddr+D'1'
0044  3070  	MOVLW	LOW( label6 )
0045        label3
0045  07A0  	ADDWF __rom_get_00000_1_romAddr, F
0046  1803  	BTFSC STATUS,C
0047  0AA1  	INCF __rom_get_00000_1_romAddr+D'1', F
0048  0821  	MOVF __rom_get_00000_1_romAddr+D'1', W
0049  008A  	MOVWF PCLATH
004A  0820  	MOVF __rom_get_00000_1_romAddr, W
004B  0082  	MOVWF PCL
004C        label4
004C  3431  	RETLW 0x31
004D  3428  	RETLW 0x28
004E  3431  	RETLW 0x31
004F  3430  	RETLW 0x30
0050  3431  	RETLW 0x31
0051  3430  	RETLW 0x30
0052  3431  	RETLW 0x31
0053  3431  	RETLW 0x31
0054  3430  	RETLW 0x30
0055  3431  	RETLW 0x31
0056  3430  	RETLW 0x30
0057  3431  	RETLW 0x31
0058        label5
0058  3404  	RETLW 0x04
0059  3408  	RETLW 0x08
005A  3412  	RETLW 0x12
005B  3416  	RETLW 0x16
005C  3420  	RETLW 0x20
005D  3424  	RETLW 0x24
005E  3428  	RETLW 0x28
005F  3432  	RETLW 0x32
0060  3436  	RETLW 0x36
0061  3440  	RETLW 0x40
0062  3444  	RETLW 0x44
0063  3448  	RETLW 0x48
0064  3452  	RETLW 0x52
0065  3456  	RETLW 0x56
0066  3460  	RETLW 0x60
0067  3464  	RETLW 0x64
0068  3468  	RETLW 0x68
0069  3472  	RETLW 0x72
006A  3476  	RETLW 0x76
006B  3480  	RETLW 0x80
006C  3484  	RETLW 0x84
006D  3488  	RETLW 0x88
006E  3492  	RETLW 0x92
006F  3496  	RETLW 0x96
0070        label6
0070  343F  	RETLW 0x3F
0071  3406  	RETLW 0x06
0072  345B  	RETLW 0x5B
0073  344F  	RETLW 0x4F
0074  3466  	RETLW 0x66
0075  346D  	RETLW 0x6D
0076  347D  	RETLW 0x7D
0077  3407  	RETLW 0x07
0078  347F  	RETLW 0x7F
0079  346F  	RETLW 0x6F
007A        ; } __rom_get function end

007A        delay_10us_00000
007A        ; { delay_10us ; function begin
007A        label7
007A  0000  	NOP
007B  0000  	NOP
007C  0000  	NOP
007D  0000  	NOP
007E  0000  	NOP
007F  0000  	NOP
0080  0000  	NOP
0081  0BF8  	DECFSZ delay_10us_00000_arg_del, F
0082  287A  	GOTO	label7
0083  0008  	RETURN
0084        ; } delay_10us function end

0084        delay_ms_00000
0084        ; { delay_ms ; function begin
0084  08F4  	MOVF delay_ms_00000_arg_del, F
0085  1D03  	BTFSS STATUS,Z
0086  2888  	GOTO	label8
0087  0008  	RETURN
0088        label8
0088  30F9  	MOVLW 0xF9
0089        label9
0089  3EFF  	ADDLW 0xFF
008A  1D03  	BTFSS STATUS,Z
008B  2889  	GOTO	label9
008C  0000  	NOP
008D  0BF4  	DECFSZ delay_ms_00000_arg_del, F
008E  2888  	GOTO	label8
008F  0008  	RETURN
0090        ; } delay_ms function end











0287        __mul_16s__0000F
0287        ; { __mul_16s_16s__16 ; function begin
0287  01A2  	CLRF __mul_16s__0000F_1_i
0288  01A5  	CLRF CompTempVarRet387
0289  01A6  	CLRF CompTempVarRet387+D'1'
028A  1283  	BCF STATUS, RP0
028B  087C  	MOVF __mul_16s__0000F_arg_a, W
028C  1683  	BSF STATUS, RP0
028D  00A3  	MOVWF __mul_16s__0000F_1_t
028E  1283  	BCF STATUS, RP0
028F  087D  	MOVF __mul_16s__0000F_arg_a+D'1', W
0290  1683  	BSF STATUS, RP0
0291  00A4  	MOVWF __mul_16s__0000F_1_t+D'1'
0292  1FA1  	BTFSS __mul_16s__0000F_arg_b+D'1',7
0293  2A9A  	GOTO	label51
0294  17A2  	BSF __mul_16s__0000F_1_i,7
0295  09A0  	COMF __mul_16s__0000F_arg_b, F
0296  09A1  	COMF __mul_16s__0000F_arg_b+D'1', F
0297  0AA0  	INCF __mul_16s__0000F_arg_b, F
0298  1903  	BTFSC gbl_status,2
0299  0AA1  	INCF __mul_16s__0000F_arg_b+D'1', F
029A        label51
029A  1A22  	BTFSC __mul_16s__0000F_1_i,4
029B  2AAC  	GOTO	label53
029C  1C20  	BTFSS __mul_16s__0000F_arg_b,0
029D  2AA4  	GOTO	label52
029E  0823  	MOVF __mul_16s__0000F_1_t, W
029F  07A5  	ADDWF CompTempVarRet387, F
02A0  0824  	MOVF __mul_16s__0000F_1_t+D'1', W
02A1  1803  	BTFSC gbl_status,0
02A2  0F24  	INCFSZ __mul_16s__0000F_1_t+D'1', W
02A3  07A6  	ADDWF CompTempVarRet387+D'1', F
02A4        label52
02A4  1003  	BCF gbl_status,0
02A5  0CA1  	RRF __mul_16s__0000F_arg_b+D'1', F
02A6  0CA0  	RRF __mul_16s__0000F_arg_b, F
02A7  1003  	BCF gbl_status,0
02A8  0DA3  	RLF __mul_16s__0000F_1_t, F
02A9  0DA4  	RLF __mul_16s__0000F_1_t+D'1', F
02AA  0AA2  	INCF __mul_16s__0000F_1_i, F
02AB  2A9A  	GOTO	label51
02AC        label53
02AC  1FA2  	BTFSS __mul_16s__0000F_1_i,7
02AD  0008  	RETURN
02AE  09A5  	COMF CompTempVarRet387, F
02AF  09A6  	COMF CompTempVarRet387+D'1', F
02B0  0AA5  	INCF CompTempVarRet387, F
02B1  1903  	BTFSC gbl_status,2
02B2  0AA6  	INCF CompTempVarRet387+D'1', F
02B3  0008  	RETURN
02B4        ; } __mul_16s_16s__16 function end





































0A00        _startup

0A62  158A  	BSF PCLATH,3
0A63  120A  	BCF PCLATH,4
0A64  2915  	GOTO	main

2007  3FB1  	DW 0x3FB1
