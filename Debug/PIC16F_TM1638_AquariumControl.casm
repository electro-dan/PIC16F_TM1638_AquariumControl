;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 8.01
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

#ifndef _PIC16F_TM1638_AquariumControl_H_
#define _PIC16F_TM1638_AquariumControl_H_

#define TASK_TIMER1 2
#define TASK_TIMER1_START 3
#define TASK_TIMER1_READ 4
#define TASK_TIMER2 5

#define oneWireBus (porta.6)
#define oneWireTris (trisa.6)
#define tm1638dio (porta.1)
#define tm1638clk (porta.0)
#define tm1638dioTris (trisa.1)
#define tm1638strobe (porta.7)
#define WHITE_LED (portb.5)
#define BLUE_LED (portb.4)
#define FAN (portb.3)
#define HEATER (portb.2)

// This means timer 1 will overflow when 1 cycle completes, generating the interrupt
#define TMR1HV 0xFF
#define TMR1LV 0xFF

// i2c options
#define use_i2c_SW
// clock SCL on GP0, data SDA on GP1
#define i2c_ARGS	2, PORTA, TRISA, 3, PORTA, TRISA, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)
// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3

#define ds3231_addr 0xD0

// Time and date variables
char gBcdSeconds = 0; // 0 to 59
061A  1283  	BCF STATUS, RP0
061B  1303  	BCF STATUS, RP1
061C  01B5  	CLRF gbl_gBcdSeconds

char gBcdMinute = 0; // 0 to 59
061D  01B6  	CLRF gbl_gBcdMinute

char gBcdHour = 0; // 0 to 23 or 1 to 12. Also contains 12/24 setting at bit 6. If 12 hour, AM/PM uses bit 5
061E  01B7  	CLRF gbl_gBcdHour

char gDayOfWeek = 1; // 1 to 7
061F  3001  	MOVLW 0x01
0620  00B8  	MOVWF gbl_gDayOfWeek

char gBcdDayOfMonth = 1; // 1 to 31
0621  3001  	MOVLW 0x01
0622  00B9  	MOVWF gbl_gBcdDayOfMonth

char gBcdMonth = 1; // 1 to 12 + century at bit 7
0623  3001  	MOVLW 0x01
0624  00BA  	MOVWF gbl_gBcdMonth

char gBcdYear = 0x23; // Init to 0x23
0625  3023  	MOVLW 0x23
0626  00BB  	MOVWF gbl_gBcdYear

rom char *gDaysInMonth = {0x31, 0x28, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31}; // Days in each month
0627  3000  	MOVLW 0x00
0628  00BC  	MOVWF gbl_gDaysInMonth

rom char *gLeapYears = {0x04, 0x08, 0x12, 0x16, 0x20, 0x24, 0x28, 0x32, 0x36, 0x40, 0x44, 0x48, 0x52, 0x56, 0x60, 0x64, 0x68, 0x72, 0x76, 0x80, 0x84, 0x88, 0x92, 0x96}; // List of leap years
0629  3001  	MOVLW 0x01
062A  00BD  	MOVWF gbl_gLeapYears


// Timer variables
char iTimer2Counts = 0;
062B  01BE  	CLRF gbl_iTimer2Counts

char iFlashDigitOff = 0;
062C  01BF  	CLRF gbl_iFlashDigitOff

char iDigitToFlash = 8; // 8 = no digit to flash
062D  3008  	MOVLW 0x08
062E  00C8  	MOVWF gbl_iDigitToFlash


// Hold the upper and lower bytes from the ds18b0x
char cTempH = 0;
062F  01C9  	CLRF gbl_cTempH

char cTempL = 0;
0630  01CA  	CLRF gbl_cTempL

char iDecimalPosition = 2;
0631  3002  	MOVLW 0x02
0632  00CB  	MOVWF gbl_iDecimalPosition


int giDS3231ValueBCD = 0;
0633  01B3  	CLRF gbl_giDS3231ValueBCD
0634  01B4  	CLRF gbl_giDS3231ValueBCD+D'1'

char gbDS3231IsMinus = 0;
0635  01CC  	CLRF gbl_gbDS3231IsMinus


char cTask = 0; // Used for task scheduler
0636  01CD  	CLRF gbl_cTask

bool gbWhiteOn = 0;
0637  104E  	BCF gbl_gbWhiteOn,0

bool gbBlueOn = 0;
0638  10CE  	BCF gbl_gbBlueOn,1

bool gbFanOn = 0;
0639  114E  	BCF gbl_gbFanOn,2

bool gbHeaterOn = 0;
063A  11CE  	BCF gbl_gbHeaterOn,3

bool gbFlashOff = 0;
063B  124E  	BCF gbl_gbFlashOff,4

char gcDisplayMode = 0;
063C  01CF  	CLRF gbl_gcDisplayMode

char gcSetMode = 0;
063D  01D0  	CLRF gbl_gcSetMode


char gBcdWhiteOnMinute = 0; // 0 to 59
063E  01D1  	CLRF gbl_gBcdWhiteOnMinute

char gBcdWhiteOnHour = 0; // 0 to 23
063F  01D2  	CLRF gbl_gBcdWhiteOnHour

char gBcdWhiteOffMinute = 0; // 0 to 59
0640  01D3  	CLRF gbl_gBcdWhiteOffMinute

char gBcdWhiteOffHour = 0; // 0 to 23
0641  01D4  	CLRF gbl_gBcdWhiteOffHour


char gBcdBlueOnMinute = 0; // 0 to 59
0642  01D5  	CLRF gbl_gBcdBlueOnMinute

char gBcdBlueOnHour = 0; // 0 to 23
0643  01D6  	CLRF gbl_gBcdBlueOnHour

char gBcdBlueOffMinute = 0; // 0 to 59
0644  01D7  	CLRF gbl_gBcdBlueOffMinute

char gBcdBlueOffHour = 0; // 0 to 23
0645  01D8  	CLRF gbl_gBcdBlueOffHour


char gFanOnTemp = 28; // Degrees C
0646  301C  	MOVLW 0x1C
0647  00D9  	MOVWF gbl_gFanOnTemp

char gFanOffTemp = 27; // Degrees C
0648  301B  	MOVLW 0x1B
0649  00DA  	MOVWF gbl_gFanOffTemp


char gHeaterOnTemp = 24; // Degrees C
064A  3018  	MOVLW 0x18
064B  00DB  	MOVWF gbl_gHeaterOnTemp

char gHeaterOffTemp = 25; // Degrees C
064C  3019  	MOVLW 0x19
064D  00DC  	MOVWF gbl_gHeaterOffTemp


// Used to output the segments from numbers
char tm1638MaxDigits = 8;
064E  3008  	MOVLW 0x08
064F  00DD  	MOVWF gbl_tm1638MaxDigits

rom char *tm1638DisplayNumtoSeg = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f};
0650  3002  	MOVLW 0x02
0651  00DE  	MOVWF gbl_tm1638DisplayNumtoSeg

char tm1638Dot = 0x80;
0652  3080  	MOVLW 0x80
0653  00DF  	MOVWF gbl_tm1638Dot

char tm1638Brightness = 7; // 0 to 7
0654  3007  	MOVLW 0x07
0655  00E0  	MOVWF gbl_tm1638Brightness

// 0x40 [01000000] = indicate command to display data
char tm1638ByteSetData = 0x40;
0656  3040  	MOVLW 0x40
0657  00E1  	MOVWF gbl_tm1638ByteSetData

// 0x42 [01000010] = indicate command to read data
char tm1638ByteReadData = 0x42;
0658  3042  	MOVLW 0x42
0659  00E2  	MOVWF gbl_tm1638ByteReadData

// 0xC0 [11000000] = write out all bytes
char tm1638ByteSetAddr = 0xC0;
065A  30C0  	MOVLW 0xC0
065B  00E3  	MOVWF gbl_tm1638ByteSetAddr

// 0x88 [10001000] - Display ON, plus brightness
char tm1638ByteSetOn = 0x88;
065C  3088  	MOVLW 0x88
065D  00E4  	MOVWF gbl_tm1638ByteSetOn


// Copy of the data to write / on the display
char tm1638Data[] = {0, 0, 0, 0, 0, 0, 0, 0};
065E  01A0  	CLRF gbl_tm1638Data
065F  01A1  	CLRF gbl_tm1638Data+D'1'
0660  01A2  	CLRF gbl_tm1638Data+D'2'
0661  01A3  	CLRF gbl_tm1638Data+D'3'
0662  01A4  	CLRF gbl_tm1638Data+D'4'
0663  01A5  	CLRF gbl_tm1638Data+D'5'
0664  01A6  	CLRF gbl_tm1638Data+D'6'
0665  01A7  	CLRF gbl_tm1638Data+D'7'

// Copy of the LED status
char tm1638LEDs[] = {0, 0, 0, 0, 0, 0, 0, 0};
0666  01A8  	CLRF gbl_tm1638LEDs
0667  01A9  	CLRF gbl_tm1638LEDs+D'1'
0668  01AA  	CLRF gbl_tm1638LEDs+D'2'
0669  01AB  	CLRF gbl_tm1638LEDs+D'3'
066A  01AC  	CLRF gbl_tm1638LEDs+D'4'
066B  01AD  	CLRF gbl_tm1638LEDs+D'5'
066C  01AE  	CLRF gbl_tm1638LEDs+D'6'
066D  01AF  	CLRF gbl_tm1638LEDs+D'7'

// Copy of the keys
char tm1638Keys = 0;
066E  01E5  	CLRF gbl_tm1638Keys


// DS18B20 functions
char oneWireIsPresent = 0;
066F  01E6  	CLRF gbl_oneWireIsPresent

char oneWireResetStage = 0;
0670  01E7  	CLRF gbl_oneWireResetStage

void oneWireBusReset();
void oneWireTxByte(char data);
void oneWireTxBytes(char data, char data2);
char oneWireRxByte();

// EEPROM functions
void eepromWriteAll();
char eepromWrite(char address, char data);
void eepromReadAll();
char eepromRead(char address);

// DS3231 functions
void ds3231Write(char ds3231Reg, char bWrite);
void ds3231Init();
void ds3231Start();
void ds3231Stop();
void ds3231WriteDateTime();
void ds3231ReadDateTime();

// TM1638 functions
void tm1638ByteWrite(char bWrite);
void bcdTo7Seg(char iBcdIn, char iOffsetFromLeft, char iDotPosition);
void tm1638UpdateDisplay();
void tm1638ReadKeys();

// General functions
int binToBcd(int iBin);
void startTemp();
void readTemp();

char bcdAdjust(char bcd, char bcdMax, char bcdMin, char iAdjustment);
void adjustDateTime(char iAdjustment);
void processKeys();

#endif

#include <system.h>
#include <i2c_driver.h>
#include "PIC16F_TM1638_AquariumControl.h"

//Target PIC16F628A configuration word
#pragma DATA _CONFIG, _PWRTE_OFF & _WDT_OFF & _INTRC_OSC_NOCLKOUT & _CP_OFF & _LVP_OFF & _BODEN_OFF & _MCLRE_OFF

//Set clock frequency
#pragma CLOCK_FREQ	4000000

/***********************************************************************************
  EEPROM read and write methods
************************************************************************************/
void eepromWriteAll() {
    char didWrite = 0;
    // only write value if it is different
    didWrite += eepromWrite(1, gBcdWhiteOnMinute);
    didWrite += eepromWrite(2, gBcdWhiteOnHour);
    didWrite += eepromWrite(3, gBcdWhiteOffMinute);
    didWrite += eepromWrite(4, gBcdWhiteOffHour);
    didWrite += eepromWrite(5, gBcdBlueOnMinute);
    didWrite += eepromWrite(6, gBcdBlueOnHour);
    didWrite += eepromWrite(7, gBcdBlueOffMinute);
    didWrite += eepromWrite(8, gBcdBlueOffHour);
    didWrite += eepromWrite(9, gFanOnTemp);
    didWrite += eepromWrite(10, gFanOffTemp);
    didWrite += eepromWrite(11, gHeaterOnTemp);
    didWrite += eepromWrite(12, gHeaterOffTemp);
    
    if (didWrite)
        eepromWrite(0, 10); // To indicate EEPROM has been saved
}

char eepromWrite(char address, char data) {
    char didWrite = 0;
    if (eepromRead(address) != data) {
        char intconsave = intcon;
        
        // Load address and data
        eeadr = address;
        eedata = data;
    
        eecon1.WREN = 1; // Enable writes
        
        // Required write sequence
        intcon = 0;
        eecon2 = 0x55; // Write 55h
        eecon2 = 0xAA; // Write 0AAh
        eecon1.WR = 1; // Set WR bit to begin write
        intcon = intconsave;
        eecon1.WREN = 0; // Disable writes on write complete (EEIF set)
        while(!pir1.EEIF); // Wait for the interrupt bit EEIF to be set
        pir1.EEIF = 0; // Clear EEIF
        didWrite = 1;
    }
    return didWrite;
}

/******************************************************
  Function to read the current variables from ROM
*******************************************************/
void eepromReadAll() {

    // Read initial values from EEPROM
    // Do not read other variables if the EEPROM has not been saved before
    // as all default will be 0xFF
    if (eepromRead(0) == 10) {
0228  1283  	BCF STATUS, RP0
0229  1303  	BCF STATUS, RP1
022A  01E8  	CLRF eepromRead_00000_arg_address
022B  2149  	CALL eepromRead_00000
022C  0869  	MOVF CompTempVarRet550, W
022D  3A0A  	XORLW 0x0A
022E  1D03  	BTFSS STATUS,Z

        gBcdWhiteOnMinute = eepromRead(1);
0230  3001  	MOVLW 0x01
0231  00E8  	MOVWF eepromRead_00000_arg_address
0232  2149  	CALL eepromRead_00000
0233  0869  	MOVF CompTempVarRet550, W
0234  00D1  	MOVWF gbl_gBcdWhiteOnMinute

        gBcdWhiteOnHour = eepromRead(2);
0235  3002  	MOVLW 0x02
0236  00E8  	MOVWF eepromRead_00000_arg_address
0237  2149  	CALL eepromRead_00000
0238  0869  	MOVF CompTempVarRet550, W
0239  00D2  	MOVWF gbl_gBcdWhiteOnHour

        gBcdWhiteOffMinute = eepromRead(3);
023A  3003  	MOVLW 0x03
023B  00E8  	MOVWF eepromRead_00000_arg_address
023C  2149  	CALL eepromRead_00000
023D  0869  	MOVF CompTempVarRet550, W
023E  00D3  	MOVWF gbl_gBcdWhiteOffMinute

        gBcdWhiteOffHour = eepromRead(4);
023F  3004  	MOVLW 0x04
0240  00E8  	MOVWF eepromRead_00000_arg_address
0241  2149  	CALL eepromRead_00000
0242  0869  	MOVF CompTempVarRet550, W
0243  00D4  	MOVWF gbl_gBcdWhiteOffHour

        gBcdBlueOnMinute = eepromRead(5);
0244  3005  	MOVLW 0x05
0245  00E8  	MOVWF eepromRead_00000_arg_address
0246  2149  	CALL eepromRead_00000
0247  0869  	MOVF CompTempVarRet550, W
0248  00D5  	MOVWF gbl_gBcdBlueOnMinute

        gBcdBlueOnHour = eepromRead(6);
0249  3006  	MOVLW 0x06
024A  00E8  	MOVWF eepromRead_00000_arg_address
024B  2149  	CALL eepromRead_00000
024C  0869  	MOVF CompTempVarRet550, W
024D  00D6  	MOVWF gbl_gBcdBlueOnHour

        gBcdBlueOffMinute = eepromRead(7);
024E  3007  	MOVLW 0x07
024F  00E8  	MOVWF eepromRead_00000_arg_address
0250  2149  	CALL eepromRead_00000
0251  0869  	MOVF CompTempVarRet550, W
0252  00D7  	MOVWF gbl_gBcdBlueOffMinute

        gBcdBlueOffHour = eepromRead(8);
0253  3008  	MOVLW 0x08
0254  00E8  	MOVWF eepromRead_00000_arg_address
0255  2149  	CALL eepromRead_00000
0256  0869  	MOVF CompTempVarRet550, W
0257  00D8  	MOVWF gbl_gBcdBlueOffHour

        gFanOnTemp = eepromRead(9);
0258  3009  	MOVLW 0x09
0259  00E8  	MOVWF eepromRead_00000_arg_address
025A  2149  	CALL eepromRead_00000
025B  0869  	MOVF CompTempVarRet550, W
025C  00D9  	MOVWF gbl_gFanOnTemp

        gFanOffTemp = eepromRead(10);
025D  300A  	MOVLW 0x0A
025E  00E8  	MOVWF eepromRead_00000_arg_address
025F  2149  	CALL eepromRead_00000
0260  0869  	MOVF CompTempVarRet550, W
0261  00DA  	MOVWF gbl_gFanOffTemp

        gHeaterOnTemp = eepromRead(11);
0262  300B  	MOVLW 0x0B
0263  00E8  	MOVWF eepromRead_00000_arg_address
0264  2149  	CALL eepromRead_00000
0265  0869  	MOVF CompTempVarRet550, W
0266  00DB  	MOVWF gbl_gHeaterOnTemp

        gHeaterOffTemp = eepromRead(12);
0267  300C  	MOVLW 0x0C
0268  00E8  	MOVWF eepromRead_00000_arg_address
0269  2149  	CALL eepromRead_00000
026A  0869  	MOVF CompTempVarRet550, W
026B  00DC  	MOVWF gbl_gHeaterOffTemp

    }
}
022F  0008  	RETURN
026C  0008  	RETURN


char eepromRead(char address) {

    // Load address
    eeadr = address;
0149  0868  	MOVF eepromRead_00000_arg_address, W
014A  1683  	BSF STATUS, RP0
014B  009B  	MOVWF gbl_eeadr


    // Read, data is available in eedata the next cycle.
    eecon1.RD = 1;
014C  141C  	BSF gbl_eecon1,0

    
    // Return value
    return eedata;
014D  081A  	MOVF gbl_eedata, W
014E  1283  	BCF STATUS, RP0
014F  00E9  	MOVWF CompTempVarRet550

}
0150  0008  	RETURN

    
/*********************************************************************************************
  oneWireBusReset()
  First part of the reset routine - drive the bus low for 500us
*********************************************************************************************/
void oneWireBusReset() {

    char isPresent;
    oneWireTris = 1; // start with high
0545  1683  	BSF STATUS, RP0
0546  1303  	BCF STATUS, RP1
0547  1705  	BSF gbl_trisa,6

    isPresent = 0;
0548  1283  	BCF STATUS, RP0
0549  01E8  	CLRF oneWireBus_00013_1_isPresent

    // Send the reset pulse - drive low for 500us
    oneWireBus = 0;      
054A  1305  	BCF gbl_porta,6

    oneWireTris = 0;
054B  1683  	BSF STATUS, RP0
054C  1305  	BCF gbl_trisa,6

    delay_10us(50);
054D  3032  	MOVLW 0x32
054E  1283  	BCF STATUS, RP0
054F  00ED  	MOVWF delay_10us_00000_arg_del
0550  201A  	CALL delay_10us_00000

    // Release line and wait 70us for PD Pulse
    oneWireTris = 1;
0551  1683  	BSF STATUS, RP0
0552  1705  	BSF gbl_trisa,6

    delay_10us(7);
0553  3007  	MOVLW 0x07
0554  1283  	BCF STATUS, RP0
0555  00ED  	MOVWF delay_10us_00000_arg_del
0556  201A  	CALL delay_10us_00000

    // Now sample, if there is a sensor on the bus, the line should be low
    if (oneWireBus) {
0557  1B05  	BTFSC gbl_porta,6

        oneWireIsPresent = 0; // no devices
0558  01E6  	CLRF gbl_oneWireIsPresent

    }
    delay_10us(50);
0559  3032  	MOVLW 0x32
055A  00ED  	MOVWF delay_10us_00000_arg_del
055B  201A  	CALL delay_10us_00000

}
055C  0008  	RETURN


/*********************************************************************************************
  oneWireTxByte(char data)
  Transmits a single byte from the bus
*********************************************************************************************/
void oneWireTxByte(char cData) {

    char cTemp = 1;
012D  3001  	MOVLW 0x01
012E  00EB  	MOVWF oneWireTxB_00014_1_cTemp

    // Loop through the eight bits in the byte
    for (char i = 0; i < 8; i++) {
012F  01EC  	CLRF oneWireTxB_00014_2_i
0130        label22
0130  3008  	MOVLW 0x08
0131  026C  	SUBWF oneWireTxB_00014_2_i, W
0132  1803  	BTFSC STATUS,C
0147  0AEC  	INCF oneWireTxB_00014_2_i, F
0148  2930  	GOTO	label22

        // Send the LSB first

        // Drive the line low initially for 3us
        oneWireTris = 0;
0134  1683  	BSF STATUS, RP0
0135  1305  	BCF gbl_trisa,6

        oneWireBus = 0;
0136  1283  	BCF STATUS, RP0
0137  1305  	BCF gbl_porta,6


        // Delay not needed for 4MHz PIC
        //delay_us(3); // Delay 3us
        
        if (cData & cTemp) {
0138  086B  	MOVF oneWireTxB_00014_1_cTemp, W
0139  056A  	ANDWF oneWireTxB_00014_arg_cData, W
013A  1903  	BTFSC STATUS,Z
013B  293E  	GOTO	label23

            oneWireTris = 1; // Release the bus
013C  1683  	BSF STATUS, RP0
013D  1705  	BSF gbl_trisa,6

        }
        
        delay_10us(5); // Delay 60us - 50us works fine with code delays
013E  3005  	MOVLW 0x05
013F  1283  	BCF STATUS, RP0
0140  00ED  	MOVWF delay_10us_00000_arg_del
0141  201A  	CALL delay_10us_00000

        oneWireTris = 1; // Release the bus
0142  1683  	BSF STATUS, RP0
0143  1705  	BSF gbl_trisa,6

        
        // move the test bit
        cTemp <<= 1;
0144  1003  	BCF STATUS,C
0145  1283  	BCF STATUS, RP0
0146  0DEB  	RLF oneWireTxB_00014_1_cTemp, F

    }
}
0133  0008  	RETURN


/*********************************************************************************************
  oneWireTxBytes(char data, char data2)
  Transmits a 2 bytes from the bus
*********************************************************************************************/
void oneWireTxBytes(char cData, char cData2) {

    // Reset first - done in main
    //oneWireBusReset();
    // Send first byte
    oneWireTxByte(cData);
019C  0868  	MOVF oneWireTxB_00015_arg_cData, W
019D  00EA  	MOVWF oneWireTxB_00014_arg_cData
019E  212D  	CALL oneWireTxB_00014

    // Send second byte
    oneWireTxByte(cData2);
019F  0869  	MOVF oneWireTxB_00015_arg_cData2, W
01A0  00EA  	MOVWF oneWireTxB_00014_arg_cData
01A1  212D  	CALL oneWireTxB_00014

}
01A2  0008  	RETURN


/*********************************************************************************************
  oneWireRxByte()
  Receives a single byte from the bus
*********************************************************************************************/
char oneWireRxByte() {

    char cDataIn = 0;
01A3  1283  	BCF STATUS, RP0
01A4  1303  	BCF STATUS, RP1
01A5  01E8  	CLRF oneWireRxB_00016_1_cDataIn

    // Loop through the eight bits in the byte
    for(char i = 0; i < 8; i++) {
01A6  01E9  	CLRF oneWireRxB_00016_2_i
01A7        label32
01A7  3008  	MOVLW 0x08
01A8  0269  	SUBWF oneWireRxB_00016_2_i, W
01A9  1803  	BTFSC STATUS,C
01AA  29BE  	GOTO	label33
01BC  0AE9  	INCF oneWireRxB_00016_2_i, F
01BD  29A7  	GOTO	label32
01BE        label33

        // Bring bus low for 15us
        oneWireTris = 0;
01AB  1683  	BSF STATUS, RP0
01AC  1305  	BCF gbl_trisa,6

        oneWireBus = 0;
01AD  1283  	BCF STATUS, RP0
01AE  1305  	BCF gbl_porta,6


        // Delay not needed for 4MHz PIC
        //delay_us(15); // Delay 15us

        // Release bus for 6us, this is enough time for the slave to respond
        oneWireTris = 1;
01AF  1683  	BSF STATUS, RP0
01B0  1705  	BSF gbl_trisa,6

        delay_us(6); // Delay 6us
01B1  3006  	MOVLW 0x06
01B2  1283  	BCF STATUS, RP0
01B3  00ED  	MOVWF delay_us_00000_arg_del
01B4  2010  	CALL delay_us_00000

        
        // Shift data already received left
        cDataIn >>= 1;
01B5  1003  	BCF STATUS,C
01B6  0CE8  	RRF oneWireRxB_00016_1_cDataIn, F

        // Check the value of the onewire bus - set the MSB of cDataIn if so
        if (oneWireBus)
01B7  1B05  	BTFSC gbl_porta,6

            cDataIn.7 = 1;
01B8  17E8  	BSF oneWireRxB_00016_1_cDataIn,7


        // To finish time slot
        delay_10us(6); // 60us
01B9  3006  	MOVLW 0x06
01BA  00ED  	MOVWF delay_10us_00000_arg_del
01BB  201A  	CALL delay_10us_00000

    } 
    
    return cDataIn;
01BE  0868  	MOVF oneWireRxB_00016_1_cDataIn, W
01BF  00E9  	MOVWF CompTempVarRet548

}
01C0  0008  	RETURN


/*********************************************************************************************
 ds3231Write(char ds3231Reg, char bWrite)
 Write one byte
*********************************************************************************************/
void ds3231Write(char ds3231Reg, char bWrite) {

	i2c_start();
0151  20F8  	CALL i2c_START_00000

	i2c_write(ds3231_addr); // address + write
0152  30D0  	MOVLW 0xD0
0153  00EA  	MOVWF i2c_WRITE_00000_arg_i2c_data
0154  2077  	CALL i2c_WRITE_00000

	i2c_write(ds3231Reg); // start at address
0155  0868  	MOVF ds3231Writ_0001A_arg_ds3231Reg, W
0156  00EA  	MOVWF i2c_WRITE_00000_arg_i2c_data
0157  2077  	CALL i2c_WRITE_00000

	i2c_write(bWrite); // start at address
0158  0869  	MOVF ds3231Writ_0001A_arg_bWrite, W
0159  00EA  	MOVWF i2c_WRITE_00000_arg_i2c_data
015A  2077  	CALL i2c_WRITE_00000

	i2c_stop();
015B  20C8  	CALL i2c_STOP_00000

}
015C  0008  	RETURN


/*********************************************************************************************
 ds3231Init()
 Initialise the DS3231
*********************************************************************************************/
void ds3231Init() {

	/* control register 0Eh
    bit7 EOSC   Enable Oscillator (1 if oscillator must be stopped when on battery)
    bit6 BBSQW  Battery Backed Square Wave
    bit5 CONV   Convert temperature (1 forces a conversion NOW)
    bit4 RS2    Rate select - frequency of square wave output
    bit3 RS1    Rate select
    bit2 INTCN  Interrupt control (1 for use of the alarms and to disable square wave)
    bit1 A2IE   Alarm2 interrupt enable (1 to enable)
    bit0 A1IE   Alarm1 interrupt enable (1 to enable)
    */
	ds3231Write(0x0E, 0x80);
0290  300E  	MOVLW 0x0E
0291  1283  	BCF STATUS, RP0
0292  1303  	BCF STATUS, RP1
0293  00E8  	MOVWF ds3231Writ_0001A_arg_ds3231Reg
0294  3080  	MOVLW 0x80
0295  00E9  	MOVWF ds3231Writ_0001A_arg_bWrite
0296  2151  	CALL ds3231Writ_0001A

	/* Status Register 0Fh
    bit7 OSF     Oscillator Stop Flag
    bit3 EN32kHz Enable 32kHz Output
    bit2 BSY     Busy
    bit1 A2F     Alarm 2 Flag
    bit0 A1F     Alarm 1 Flag
    */
	ds3231Write(0x0F, 0x80);
0297  300F  	MOVLW 0x0F
0298  00E8  	MOVWF ds3231Writ_0001A_arg_ds3231Reg
0299  3080  	MOVLW 0x80
029A  00E9  	MOVWF ds3231Writ_0001A_arg_bWrite
029B  2151  	CALL ds3231Writ_0001A

}
029C  0008  	RETURN


/*********************************************************************************************
 ds3231Start()
 Start the DS3231
*********************************************************************************************/
void ds3231Start() {

	ds3231Write(0x0F, 0x00);
0289  300F  	MOVLW 0x0F
028A  1283  	BCF STATUS, RP0
028B  1303  	BCF STATUS, RP1
028C  00E8  	MOVWF ds3231Writ_0001A_arg_ds3231Reg
028D  01E9  	CLRF ds3231Writ_0001A_arg_bWrite
028E  2151  	CALL ds3231Writ_0001A

}
028F  0008  	RETURN


/*********************************************************************************************
 ds3231Stop()
 Stop the DS3231
*********************************************************************************************/
void ds3231Stop() {
	ds3231Write(0x0F, 0x80);
}

/*********************************************************************************************
 ds3231WriteDateTime()
 Write the date to the DS3231
*********************************************************************************************/
void ds3231WriteDateTime() {

	i2c_start();
026D  20F8  	CALL i2c_START_00000

	i2c_write(ds3231_addr); // address + write
026E  30D0  	MOVLW 0xD0
026F  00EA  	MOVWF i2c_WRITE_00000_arg_i2c_data
0270  2077  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
0271  01EA  	CLRF i2c_WRITE_00000_arg_i2c_data
0272  2077  	CALL i2c_WRITE_00000

	i2c_write(0); // seconds
0273  01EA  	CLRF i2c_WRITE_00000_arg_i2c_data
0274  2077  	CALL i2c_WRITE_00000

	i2c_write(gBcdMinute); // minutes
0275  0836  	MOVF gbl_gBcdMinute, W
0276  00EA  	MOVWF i2c_WRITE_00000_arg_i2c_data
0277  2077  	CALL i2c_WRITE_00000

	i2c_write(gBcdHour); // hours
0278  0837  	MOVF gbl_gBcdHour, W
0279  00EA  	MOVWF i2c_WRITE_00000_arg_i2c_data
027A  2077  	CALL i2c_WRITE_00000

	i2c_write(gDayOfWeek); // day of week
027B  0838  	MOVF gbl_gDayOfWeek, W
027C  00EA  	MOVWF i2c_WRITE_00000_arg_i2c_data
027D  2077  	CALL i2c_WRITE_00000

	i2c_write(gBcdDayOfMonth); // day of month
027E  0839  	MOVF gbl_gBcdDayOfMonth, W
027F  00EA  	MOVWF i2c_WRITE_00000_arg_i2c_data
0280  2077  	CALL i2c_WRITE_00000

	i2c_write(gBcdMonth); // month + century
0281  083A  	MOVF gbl_gBcdMonth, W
0282  00EA  	MOVWF i2c_WRITE_00000_arg_i2c_data
0283  2077  	CALL i2c_WRITE_00000

	i2c_write(gBcdYear); // year
0284  083B  	MOVF gbl_gBcdYear, W
0285  00EA  	MOVWF i2c_WRITE_00000_arg_i2c_data
0286  2077  	CALL i2c_WRITE_00000

	i2c_stop();
0287  20C8  	CALL i2c_STOP_00000

}
0288  0008  	RETURN


/*********************************************************************************************
 ds3231ReadDateTime()
 Write the date to the DS3231
*********************************************************************************************/
void ds3231ReadDateTime() {

	i2c_start();
0589  20F8  	CALL i2c_START_00000

	i2c_write(ds3231_addr); // address + read
058A  30D0  	MOVLW 0xD0
058B  00EA  	MOVWF i2c_WRITE_00000_arg_i2c_data
058C  2077  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
058D  01EA  	CLRF i2c_WRITE_00000_arg_i2c_data
058E  2077  	CALL i2c_WRITE_00000

	i2c_stop();
058F  20C8  	CALL i2c_STOP_00000

	
	i2c_start();
0590  20F8  	CALL i2c_START_00000

	i2c_write(ds3231_addr + 1); // address + read
0591  30D1  	MOVLW 0xD1
0592  00EA  	MOVWF i2c_WRITE_00000_arg_i2c_data
0593  2077  	CALL i2c_WRITE_00000

	gBcdSeconds = i2c_read(0); // ack
0594  01E8  	CLRF i2c_READ_00000_arg_ack_status
0595  21C1  	CALL i2c_READ_00000
0596  086B  	MOVF CompTempVarRet552, W
0597  00B5  	MOVWF gbl_gBcdSeconds

	gBcdMinute = i2c_read(0); // ack
0598  01E8  	CLRF i2c_READ_00000_arg_ack_status
0599  21C1  	CALL i2c_READ_00000
059A  086B  	MOVF CompTempVarRet552, W
059B  00B6  	MOVWF gbl_gBcdMinute

	gBcdHour = i2c_read(0); // ack
059C  01E8  	CLRF i2c_READ_00000_arg_ack_status
059D  21C1  	CALL i2c_READ_00000
059E  086B  	MOVF CompTempVarRet552, W
059F  00B7  	MOVWF gbl_gBcdHour

	gDayOfWeek = i2c_read(0); // ack
05A0  01E8  	CLRF i2c_READ_00000_arg_ack_status
05A1  21C1  	CALL i2c_READ_00000
05A2  086B  	MOVF CompTempVarRet552, W
05A3  00B8  	MOVWF gbl_gDayOfWeek

	gBcdDayOfMonth = i2c_read(0); // ack
05A4  01E8  	CLRF i2c_READ_00000_arg_ack_status
05A5  21C1  	CALL i2c_READ_00000
05A6  086B  	MOVF CompTempVarRet552, W
05A7  00B9  	MOVWF gbl_gBcdDayOfMonth

	gBcdMonth = i2c_read(0); // ack
05A8  01E8  	CLRF i2c_READ_00000_arg_ack_status
05A9  21C1  	CALL i2c_READ_00000
05AA  086B  	MOVF CompTempVarRet552, W
05AB  00BA  	MOVWF gbl_gBcdMonth

	gBcdYear = i2c_read(1); // nack
05AC  3001  	MOVLW 0x01
05AD  00E8  	MOVWF i2c_READ_00000_arg_ack_status
05AE  21C1  	CALL i2c_READ_00000
05AF  086B  	MOVF CompTempVarRet552, W
05B0  00BB  	MOVWF gbl_gBcdYear

	i2c_stop();
05B1  20C8  	CALL i2c_STOP_00000

}
05B2  0008  	RETURN


/*********************************************************************************************
 tm1638ByteWrite(char bWrite)
 Write one byte
*********************************************************************************************/
void tm1638ByteWrite(char bWrite) {

    for (char i = 0; i < 8; i++) {
0189  01EB  	CLRF tm1638Byte_0001E_2_i
018A        label31
018A  3008  	MOVLW 0x08
018B  026B  	SUBWF tm1638Byte_0001E_2_i, W
018C  1803  	BTFSC STATUS,C
019A  0AEB  	INCF tm1638Byte_0001E_2_i, F
019B  298A  	GOTO	label31

        tm1638dio = (bWrite & 0x01);
018E  3001  	MOVLW 0x01
018F  056A  	ANDWF tm1638Byte_0001E_arg_bWrite, W
0190  00EC  	MOVWF CompTempVar553
0191  186C  	BTFSC CompTempVar553,0
0192  1485  	BSF gbl_porta,1
0193  1C6C  	BTFSS CompTempVar553,0
0194  1085  	BCF gbl_porta,1

        tm1638clk = 0;
0195  1005  	BCF gbl_porta,0

        bWrite = (bWrite >> 1);
0196  08EA  	MOVF tm1638Byte_0001E_arg_bWrite, F
0197  1003  	BCF STATUS,C
0198  0CEA  	RRF tm1638Byte_0001E_arg_bWrite, F

        tm1638clk = 1;
0199  1405  	BSF gbl_porta,0

    }
}
018D  0008  	RETURN


void bcdTo7Seg(char iBcdIn, char iOffsetFromLeft, char iDotPosition) {

    char s7SegDisplay = 0;
0301  01EE  	CLRF bcdTo7Seg_00000_1_s7SegDisplay

    char sDigit = iOffsetFromLeft++;
0302  086C  	MOVF bcdTo7Seg_00000_arg_iOffse_0001F, W
0303  00EF  	MOVWF bcdTo7Seg_00000_1_sDigit
0304  0AEC  	INCF bcdTo7Seg_00000_arg_iOffse_0001F, F

    for (sDigit; sDigit == iOffsetFromLeft; sDigit--) {
0305        label53
0305  086C  	MOVF bcdTo7Seg_00000_arg_iOffse_0001F, W
0306  066F  	XORWF bcdTo7Seg_00000_1_sDigit, W
0307  1D03  	BTFSS STATUS,Z
0322  03EF  	DECF bcdTo7Seg_00000_1_sDigit, F
0323  2B05  	GOTO	label53

        s7SegDisplay = tm1638DisplayNumtoSeg[iBcdIn & 0x0F];
0309  085E  	MOVF gbl_tm1638DisplayNumtoSeg, W
030A  00F0  	MOVWF __rom_get_00000_arg_objNumb
030B  300F  	MOVLW 0x0F
030C  056B  	ANDWF bcdTo7Seg_00000_arg_iBcdIn, W
030D  00F1  	MOVWF __rom_get_00000_arg_idx
030E  2024  	CALL __rom_get_00000
030F  00EE  	MOVWF bcdTo7Seg_00000_1_s7SegDisplay

        if (sDigit == iDotPosition)
0310  086D  	MOVF bcdTo7Seg_00000_arg_iDotPosition, W
0311  066F  	XORWF bcdTo7Seg_00000_1_sDigit, W
0312  118A  	BCF PCLATH,3
0313  120A  	BCF PCLATH,4
0314  1D03  	BTFSS STATUS,Z
0315  2B18  	GOTO	label54
0318        label54

            s7SegDisplay += tm1638Dot;
0316  085F  	MOVF gbl_tm1638Dot, W
0317  07EE  	ADDWF bcdTo7Seg_00000_1_s7SegDisplay, F

        tm1638Data[sDigit] = s7SegDisplay;
0318  1383  	BCF	STATUS,IRP
0319  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
031A  0084  	MOVWF FSR
031B  086F  	MOVF bcdTo7Seg_00000_1_sDigit, W
031C  0784  	ADDWF FSR, F
031D  086E  	MOVF bcdTo7Seg_00000_1_s7SegDisplay, W
031E  0080  	MOVWF INDF

        iBcdIn >>= 4;
031F  0EEB  	SWAPF bcdTo7Seg_00000_arg_iBcdIn, F
0320  300F  	MOVLW 0x0F
0321  05EB  	ANDWF bcdTo7Seg_00000_arg_iBcdIn, F

    }
}
0308  0008  	RETURN



/*********************************************************************************************
 tm1638UpdateDisplay()
 Publish the tm1638Data and tm1638LEDs arrays to the display
*********************************************************************************************/
void tm1638UpdateDisplay() {

    
    if (!gcDisplayMode && !gcSetMode) {
03D3  1283  	BCF STATUS, RP0
03D4  1303  	BCF STATUS, RP1
03D5  08CF  	MOVF gbl_gcDisplayMode, F
03D6  1D03  	BTFSS STATUS,Z
03D7  2C09  	GOTO	label69
03D8  08D0  	MOVF gbl_gcSetMode, F
03D9  1D03  	BTFSS STATUS,Z
03DA  2C09  	GOTO	label69
0409        label69

        // translate DS3231 temperature to digit values
        char iDotPosition = 1;
03DB  3001  	MOVLW 0x01
03DC  00EA  	MOVWF tm1638Upda_00020_4_iDotPosition

        if (gbDS3231IsMinus && (giDS3231ValueBCD & 0xF000)) {
03DD  08CC  	MOVF gbl_gbDS3231IsMinus, F
03DE  1903  	BTFSC STATUS,Z
03DF  2BF2  	GOTO	label68
03E0  30F0  	MOVLW 0xF0
03E1  0534  	ANDWF gbl_giDS3231ValueBCD+D'1', W
03E2  1903  	BTFSC STATUS,Z
03E3  2BF2  	GOTO	label68
03F2        label68

            // If minus and value less than or equal -10 (checked as >1000), shift the digits right
            giDS3231ValueBCD >>= 4;
03E4  0D34  	RLF gbl_giDS3231ValueBCD+D'1', W
03E5  0CB4  	RRF gbl_giDS3231ValueBCD+D'1', F
03E6  0CB3  	RRF gbl_giDS3231ValueBCD, F
03E7  0D34  	RLF gbl_giDS3231ValueBCD+D'1', W
03E8  0CB4  	RRF gbl_giDS3231ValueBCD+D'1', F
03E9  0CB3  	RRF gbl_giDS3231ValueBCD, F
03EA  0D34  	RLF gbl_giDS3231ValueBCD+D'1', W
03EB  0CB4  	RRF gbl_giDS3231ValueBCD+D'1', F
03EC  0CB3  	RRF gbl_giDS3231ValueBCD, F
03ED  0D34  	RLF gbl_giDS3231ValueBCD+D'1', W
03EE  0CB4  	RRF gbl_giDS3231ValueBCD+D'1', F
03EF  0CB3  	RRF gbl_giDS3231ValueBCD, F

            iDotPosition = 2;
03F0  3002  	MOVLW 0x02
03F1  00EA  	MOVWF tm1638Upda_00020_4_iDotPosition

        }
        bcdTo7Seg(giDS3231ValueBCD, 2, 3);
03F2  0833  	MOVF gbl_giDS3231ValueBCD, W
03F3  00EB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03F4  3002  	MOVLW 0x02
03F5  00EC  	MOVWF bcdTo7Seg_00000_arg_iOffse_0001F
03F6  3003  	MOVLW 0x03
03F7  00ED  	MOVWF bcdTo7Seg_00000_arg_iDotPosition
03F8  2301  	CALL bcdTo7Seg_00000

        bcdTo7Seg(giDS3231ValueBCD >> 8, 0, iDotPosition);
03F9  0834  	MOVF gbl_giDS3231ValueBCD+D'1', W
03FA  00EB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03FB  01EC  	CLRF bcdTo7Seg_00000_arg_iOffse_0001F
03FC  086A  	MOVF tm1638Upda_00020_4_iDotPosition, W
03FD  00ED  	MOVWF bcdTo7Seg_00000_arg_iDotPosition
03FE  2301  	CALL bcdTo7Seg_00000


        // left fill zeroes with blanks up to the digit before the decimal place
        if (tm1638Data[0] == 0x3f)
03FF  0820  	MOVF gbl_tm1638Data, W
0400  3A3F  	XORLW 0x3F
0401  1903  	BTFSC STATUS,Z

            tm1638Data[0] = 0;
0402  01A0  	CLRF gbl_tm1638Data

        // If minus, overwrite left most digit with minus sign
        if (gbDS3231IsMinus)
0403  08CC  	MOVF gbl_gbDS3231IsMinus, F
0404  1903  	BTFSC STATUS,Z
0405  2C58  	GOTO	label78

            tm1638Data[0] = 0x40;
0406  3040  	MOVLW 0x40
0407  00A0  	MOVWF gbl_tm1638Data

    } else {
0408  2C58  	GOTO	label78

        if (gcSetMode == 1) {
0409  0350  	DECF gbl_gcSetMode, W
040A  1D03  	BTFSS STATUS,Z
040B  2C1C  	GOTO	label70
041C        label70

            iDigitToFlash = 3;
040C  3003  	MOVLW 0x03
040D  00C8  	MOVWF gbl_iDigitToFlash

            // Display year
            bcdTo7Seg(0x20, 0, 1); // Display 20 in digits 0 and 1 (+dot on 1)
040E  3020  	MOVLW 0x20
040F  00EB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0410  01EC  	CLRF bcdTo7Seg_00000_arg_iOffse_0001F
0411  3001  	MOVLW 0x01
0412  00ED  	MOVWF bcdTo7Seg_00000_arg_iDotPosition
0413  2301  	CALL bcdTo7Seg_00000

            bcdTo7Seg(gBcdYear, 2, 3); // Display year in digits 2 and 3 (+dot on 3)
0414  083B  	MOVF gbl_gBcdYear, W
0415  00EB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0416  3002  	MOVLW 0x02
0417  00EC  	MOVWF bcdTo7Seg_00000_arg_iOffse_0001F
0418  3003  	MOVLW 0x03
0419  00ED  	MOVWF bcdTo7Seg_00000_arg_iDotPosition
041A  2301  	CALL bcdTo7Seg_00000

        } else if (gcSetMode == 4) {
041B  2C58  	GOTO	label78
041C  0850  	MOVF gbl_gcSetMode, W
041D  3A04  	XORLW 0x04
041E  1D03  	BTFSS STATUS,Z
041F  2C2F  	GOTO	label71
042F        label71

            iDigitToFlash = 3;
0420  3003  	MOVLW 0x03
0421  00C8  	MOVWF gbl_iDigitToFlash

            // Display day of week
            tm1638Data[0] = 0;
0422  01A0  	CLRF gbl_tm1638Data

            tm1638Data[1] = 0;
0423  01A1  	CLRF gbl_tm1638Data+D'1'

            tm1638Data[2] = 0;
0424  01A2  	CLRF gbl_tm1638Data+D'2'

            tm1638Data[3] = tm1638DisplayNumtoSeg[gDayOfWeek] + tm1638Dot;
0425  085E  	MOVF gbl_tm1638DisplayNumtoSeg, W
0426  00F0  	MOVWF __rom_get_00000_arg_objNumb
0427  0838  	MOVF gbl_gDayOfWeek, W
0428  00F1  	MOVWF __rom_get_00000_arg_idx
0429  2024  	CALL __rom_get_00000
042A  075F  	ADDWF gbl_tm1638Dot, W
042B  00A3  	MOVWF gbl_tm1638Data+D'3'

        } else {
042C  118A  	BCF PCLATH,3
042D  120A  	BCF PCLATH,4
042E  2C58  	GOTO	label78
0458        label78

            switch (gcSetMode) {
044B        label77

                case 2:
042F  0850  	MOVF gbl_gcSetMode, W
0430  3A02  	XORLW 0x02
0431  1903  	BTFSC STATUS,Z
0432  2C3D  	GOTO	label72
043D        label72

                    iDigitToFlash = 3;
043D  3003  	MOVLW 0x03
043E  00C8  	MOVWF gbl_iDigitToFlash

                    break;
043F  2C4B  	GOTO	label77

                case 3:
0433  3A01  	XORLW 0x01
0434  1903  	BTFSC STATUS,Z
0435  2C40  	GOTO	label73
0440        label73

                    iDigitToFlash = 1;
0440  3001  	MOVLW 0x01
0441  00C8  	MOVWF gbl_iDigitToFlash

                    break;
0442  2C4B  	GOTO	label77

                case 5:
0436  3A06  	XORLW 0x06
0437  1903  	BTFSC STATUS,Z
0438  2C43  	GOTO	label74
0443        label74

                    iDigitToFlash = 5;
0443  3005  	MOVLW 0x05
0444  00C8  	MOVWF gbl_iDigitToFlash

                    break;
0445  2C4B  	GOTO	label77

                case 6:
0439  3A03  	XORLW 0x03
043A  1903  	BTFSC STATUS,Z
043B  2C46  	GOTO	label75
0446        label75

                    iDigitToFlash = 7;
0446  3007  	MOVLW 0x07
0447  00C8  	MOVWF gbl_iDigitToFlash

                    break;
0448  2C4B  	GOTO	label77

                default:
043C  2C49  	GOTO	label76
0449        label76

                    iDigitToFlash = 8;
0449  3008  	MOVLW 0x08
044A  00C8  	MOVWF gbl_iDigitToFlash

            }
            // Display date DD.MM
            bcdTo7Seg(gBcdDayOfMonth, 0, 1); // Display day of month in digits 0 and 1 (+dot on 1)
044B  0839  	MOVF gbl_gBcdDayOfMonth, W
044C  00EB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
044D  01EC  	CLRF bcdTo7Seg_00000_arg_iOffse_0001F
044E  3001  	MOVLW 0x01
044F  00ED  	MOVWF bcdTo7Seg_00000_arg_iDotPosition
0450  2301  	CALL bcdTo7Seg_00000

            bcdTo7Seg(gBcdMonth, 2, 3); // Display month in digits 2 and 3 (+dot on 3)
0451  083A  	MOVF gbl_gBcdMonth, W
0452  00EB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0453  3002  	MOVLW 0x02
0454  00EC  	MOVWF bcdTo7Seg_00000_arg_iOffse_0001F
0455  3003  	MOVLW 0x03
0456  00ED  	MOVWF bcdTo7Seg_00000_arg_iDotPosition
0457  2301  	CALL bcdTo7Seg_00000

        }
    }

    // HH.MM in last 4 digits of TM1638
    bcdTo7Seg(gBcdHour, 4, 5); // Display day of month in digits 4 and 5 (dot on 5)
0458  0837  	MOVF gbl_gBcdHour, W
0459  00EB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
045A  3004  	MOVLW 0x04
045B  00EC  	MOVWF bcdTo7Seg_00000_arg_iOffse_0001F
045C  3005  	MOVLW 0x05
045D  00ED  	MOVWF bcdTo7Seg_00000_arg_iDotPosition
045E  2301  	CALL bcdTo7Seg_00000

    bcdTo7Seg(gBcdMinute, 6, 8); // Display month in digits 6 and 7 (no dot)
045F  0836  	MOVF gbl_gBcdMinute, W
0460  00EB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0461  3006  	MOVLW 0x06
0462  00EC  	MOVWF bcdTo7Seg_00000_arg_iOffse_0001F
0463  3008  	MOVLW 0x08
0464  00ED  	MOVWF bcdTo7Seg_00000_arg_iDotPosition
0465  2301  	CALL bcdTo7Seg_00000


    // Light LED for set mode
    for (char i = 2; i < 8; i++) {
0466  3002  	MOVLW 0x02
0467  00E9  	MOVWF tm1638Upda_00020_3_i
0468        label79
0468  3008  	MOVLW 0x08
0469  0269  	SUBWF tm1638Upda_00020_3_i, W
046A  1803  	BTFSC STATUS,C
046B  2C89  	GOTO	label82
0487  0AE9  	INCF tm1638Upda_00020_3_i, F
0488  2C68  	GOTO	label79
0489        label82

        if (i == (gcSetMode + 2))
046C  01EB  	CLRF CompTempVar564
046D  3002  	MOVLW 0x02
046E  0750  	ADDWF gbl_gcSetMode, W
046F  00EA  	MOVWF CompTempVar563
0470  1803  	BTFSC STATUS,C
0471  0AEB  	INCF CompTempVar564, F
0472  0869  	MOVF tm1638Upda_00020_3_i, W
0473  066A  	XORWF CompTempVar563, W
0474  1903  	BTFSC STATUS,Z
0475  086B  	MOVF CompTempVar564, W
0476  1D03  	BTFSS STATUS,Z
0477  2C80  	GOTO	label80
0480        label80

            tm1638LEDs[i] = 1;
0478  1383  	BCF	STATUS,IRP
0479  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
047A  0084  	MOVWF FSR
047B  0869  	MOVF tm1638Upda_00020_3_i, W
047C  0784  	ADDWF FSR, F
047D  3001  	MOVLW 0x01
047E  0080  	MOVWF INDF

        else
047F  2C87  	GOTO	label81
0487        label81

            tm1638LEDs[i] = 0;
0480  1383  	BCF	STATUS,IRP
0481  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
0482  0084  	MOVWF FSR
0483  0869  	MOVF tm1638Upda_00020_3_i, W
0484  0784  	ADDWF FSR, F
0485  3000  	MOVLW 0x00
0486  0080  	MOVWF INDF

    }
    tm1638LEDs[0] = gbHeaterOn;
0489  01A8  	CLRF gbl_tm1638LEDs
048A  19CE  	BTFSC gbl_gbHeaterOn,3
048B  0AA8  	INCF gbl_tm1638LEDs, F

    tm1638LEDs[1] = gbFanOn;
048C  01A9  	CLRF gbl_tm1638LEDs+D'1'
048D  194E  	BTFSC gbl_gbFanOn,2
048E  0AA9  	INCF gbl_tm1638LEDs+D'1', F


    // Write 0x40 [01000000] to indicate command to display data - [Write data to display register]
    tm1638strobe = 0;
048F  1385  	BCF gbl_porta,7

    tm1638ByteWrite(tm1638ByteSetData);
0490  0861  	MOVF gbl_tm1638ByteSetData, W
0491  00EA  	MOVWF tm1638Byte_0001E_arg_bWrite
0492  2189  	CALL tm1638Byte_0001E

    tm1638strobe = 1;
0493  1785  	BSF gbl_porta,7

    
    tm1638strobe = 0;
0494  1385  	BCF gbl_porta,7

    // Specify the display address 0xC0 [11000000] then write out all 8 bytes
    tm1638ByteWrite(tm1638ByteSetAddr);
0495  0863  	MOVF gbl_tm1638ByteSetAddr, W
0496  00EA  	MOVWF tm1638Byte_0001E_arg_bWrite
0497  2189  	CALL tm1638Byte_0001E

    for (char i = 0; i < tm1638MaxDigits; i++) {
0498  01E8  	CLRF tm1638Upda_00020_2_i
0499        label83
0499  085D  	MOVF gbl_tm1638MaxDigits, W
049A  0268  	SUBWF tm1638Upda_00020_2_i, W
049B  1803  	BTFSC STATUS,C
049C  2CB8  	GOTO	label86
04B6  0AE8  	INCF tm1638Upda_00020_2_i, F
04B7  2C99  	GOTO	label83
04B8        label86

        if (iFlashDigitOff.0 && (i == iDigitToFlash))
049D  1C3F  	BTFSS gbl_iFlashDigitOff,0
049E  2CA6  	GOTO	label84
049F  0848  	MOVF gbl_iDigitToFlash, W
04A0  0668  	XORWF tm1638Upda_00020_2_i, W
04A1  1D03  	BTFSS STATUS,Z
04A2  2CA6  	GOTO	label84
04A6        label84

            tm1638ByteWrite(0);
04A3  01EA  	CLRF tm1638Byte_0001E_arg_bWrite
04A4  2189  	CALL tm1638Byte_0001E

        else
04A5  2CAE  	GOTO	label85
04AE        label85

            tm1638ByteWrite(tm1638Data[i]);
04A6  1383  	BCF	STATUS,IRP
04A7  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
04A8  0084  	MOVWF FSR
04A9  0868  	MOVF tm1638Upda_00020_2_i, W
04AA  0784  	ADDWF FSR, F
04AB  0800  	MOVF INDF, W
04AC  00EA  	MOVWF tm1638Byte_0001E_arg_bWrite
04AD  2189  	CALL tm1638Byte_0001E

        tm1638ByteWrite(tm1638LEDs[i]);
04AE  1383  	BCF	STATUS,IRP
04AF  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
04B0  0084  	MOVWF FSR
04B1  0868  	MOVF tm1638Upda_00020_2_i, W
04B2  0784  	ADDWF FSR, F
04B3  0800  	MOVF INDF, W
04B4  00EA  	MOVWF tm1638Byte_0001E_arg_bWrite
04B5  2189  	CALL tm1638Byte_0001E

    }
    tm1638strobe = 1;
04B8  1785  	BSF gbl_porta,7

}
04B9  0008  	RETURN


/*********************************************************************************************
 tm1638ReadKeys()
 Reads the keys status into tm1638Keys
*********************************************************************************************/
void tm1638ReadKeys() {

    // Write 0x42 [01000010] to indicate command to read data
    tm1638strobe = 0;
04BA  1283  	BCF STATUS, RP0
04BB  1303  	BCF STATUS, RP1
04BC  1385  	BCF gbl_porta,7

    tm1638ByteWrite(tm1638ByteReadData);
04BD  0862  	MOVF gbl_tm1638ByteReadData, W
04BE  00EA  	MOVWF tm1638Byte_0001E_arg_bWrite
04BF  2189  	CALL tm1638Byte_0001E

    
    tm1638dioTris = 1; // Set data pin to input
04C0  1683  	BSF STATUS, RP0
04C1  1485  	BSF gbl_trisa,1

    char tm1638KeysTemp = 32;
04C2  3020  	MOVLW 0x20
04C3  1283  	BCF STATUS, RP0
04C4  00E8  	MOVWF tm1638Read_00021_1_tm1638K_00022

    // Read 4 bytes
    for (char i = 0; i < 32; i++) {
04C5  01E9  	CLRF tm1638Read_00021_2_i
04C6        label87
04C6  3020  	MOVLW 0x20
04C7  0269  	SUBWF tm1638Read_00021_2_i, W
04C8  1803  	BTFSC STATUS,C
04C9  2CD7  	GOTO	label89
04D5  0AE9  	INCF tm1638Read_00021_2_i, F
04D6  2CC6  	GOTO	label87
04D7        label89

        tm1638KeysTemp--;
04CA  03E8  	DECF tm1638Read_00021_1_tm1638K_00022, F

        tm1638clk = 0;
04CB  1005  	BCF gbl_porta,0

        delay_us(1);
04CC  3001  	MOVLW 0x01
04CD  00ED  	MOVWF delay_us_00000_arg_del
04CE  2010  	CALL delay_us_00000

        if(tm1638dio)
04CF  1C85  	BTFSS gbl_porta,1
04D0  2CD4  	GOTO	label88
04D4        label88

            tm1638KeysTemp = (tm1638KeysTemp << 1);
04D1  08E8  	MOVF tm1638Read_00021_1_tm1638K_00022, F
04D2  1003  	BCF STATUS,C
04D3  0DE8  	RLF tm1638Read_00021_1_tm1638K_00022, F

        tm1638clk = 1;
04D4  1405  	BSF gbl_porta,0

    }
    tm1638dioTris = 0; // Set data pin to output
04D7  1683  	BSF STATUS, RP0
04D8  1085  	BCF gbl_trisa,1

    tm1638strobe = 1;
04D9  1283  	BCF STATUS, RP0
04DA  1785  	BSF gbl_porta,7


    tm1638Keys = tm1638KeysTemp;
04DB  0868  	MOVF tm1638Read_00021_1_tm1638K_00022, W
04DC  00E5  	MOVWF gbl_tm1638Keys

}
04DD  0008  	RETURN


/*********************************************************************************************
  Function called once only to initialise variables and
  setup the PIC registers
*********************************************************************************************/
void initialise() {

    pcon.OSCF = 1; // 4MHz internal osc
055D  1683  	BSF STATUS, RP0
055E  1303  	BCF STATUS, RP1
055F  158E  	BSF gbl_pcon,3


    // Configure port A
    /*
    RA7     OUT TM1638 STB
    RA6     IN/OUT DS18B20
    RA5     
    RA4     ICSP VPP
    RA3     IN/OUT DS3231M I2C SDA
    RA2     IN/OUT DS3231M I2C CLK
    RA1     IN/OUT TM1638 DIO
    RA0     OUT TM1638 CLK
    */
    trisa = 0x0C;
0560  300C  	MOVLW 0x0C
0561  0085  	MOVWF gbl_trisa

    porta = 0x00; // 
0562  1283  	BCF STATUS, RP0
0563  0185  	CLRF gbl_porta

    
    // Configure port B
    /*      
    RB7     ICSP PGD
    RB6     IN SQW DS3231M + ICSP PGC
    RB5     OUT WHITE LIGHT PWM
    RB4     OUT BLUE LIGHT PWM
    RB3     OUT FANS
    RB2     OUT HEATER
    RB1     
    RB0     
    */
    trisb = 0x00; // all outputs
0564  1683  	BSF STATUS, RP0
0565  0186  	CLRF gbl_trisb

    portb = 0x00; // all off by default
0566  1283  	BCF STATUS, RP0
0567  0186  	CLRF gbl_portb


    option_reg = 0;
0568  1683  	BSF STATUS, RP0
0569  0181  	CLRF gbl_option_reg

    option_reg.NOT_RBPU = 1; // disable port b pull ups
056A  1781  	BSF gbl_option_reg,7


    // ADC setup
    cmcon = 7; // disable all comparators so port a is usable as digital io
056B  3007  	MOVLW 0x07
056C  1283  	BCF STATUS, RP0
056D  009F  	MOVWF gbl_cmcon



    // Setup timer 0, used for PWM
    // https://labprojectsbd.com/2021/03/31/pwm-pulse-generation-using-pic12f675-micro-controller/
    // Timer calculator: http://eng-serve.com/pic/pic_timer.html
    // Timer0 Registers Prescaler= 16 - TMR0 Preset = 0 - Freq = 244.14 Hz - Period = 0.004096 seconds
    //option_reg.T0CS = 0; // bit 5  TMR0 Clock Source Select bit...0 = Internal Clock (CLKO) 1 = Transition on T0CKI pin
    //option_reg.T0SE = 0; // bit 4 TMR0 Source Edge Select bit 0 = low/high 1 = high/low
    //option_reg.PSA = 0; // bit 3  Prescaler Assignment bit...0 = Prescaler is assigned to the Timer0
    //option_reg.PS2 = 0; // bits 2-0  PS2:PS0: Prescaler Rate Select bits
    /*option_reg.PS1 = 1;
    option_reg.PS0 = 1;
    tmr0 = 0; // preset for timer register
    intcon.T0IF = 0; // Clear timer 1 interrupt flag bit
    intcon.T0IE = 1; // Timer 1 interrupt enabled*/

    // Setup timer 1, used to update clock display and periodically ask for a temperature reading
    // Timer 1 setup - interrupt on DS3231 SQW 1Hz
    // Timer1 Registers Prescaler= 1 - TMR1 Preset = 65535 - Freq = 1 Hz
    // Bits 5-4 T1CKPS1:T1CKPS0 = 00: Prescaler Rate Select bits, 00 = 1:1 prescaler
    // Bit 3 T1OSCEN = 0: Timer1 LP Oscillator Enable Control bit, 0 = off
    // Bit 2 NOT_T1SYNC = 1: Timer1 External Clock Input Synchronization Control bit, 1 = Do not synchronize external clock input
    // Bit 1 TMR1CS = 1: Timer1 Clock Source Select bit, 1 = External clock from T1OSO/T1CKI pin (on the rising edge)
    // Bit 0 TMR1ON = 0: Timer1 On Bit, 0 = off
    t1con = 0b00000110;
056E  3006  	MOVLW 0x06
056F  0090  	MOVWF gbl_t1con

    tmr1h = TMR1HV;      // preset for timer1 MSB register
0570  30FF  	MOVLW 0xFF
0571  008F  	MOVWF gbl_tmr1h

    tmr1l = TMR1LV;      // preset for timer1 LSB register
0572  008E  	MOVWF gbl_tmr1l

    pie1.TMR1IE = 1;     // Timer 1 interrupt
0573  1683  	BSF STATUS, RP0
0574  140C  	BSF gbl_pie1,0

    
    // Setup timer 2, used for flashing display
    // Timer calculator: http://eng-serve.com/pic/pic_timer.html
    //Timer2 Registers Prescaler= 16 - TMR2 PostScaler = 16 - PR2 = 195 - Freq = 20.03 Hz - Period = 0.049920 seconds
    t2con |= 120; // bits 6-3 Post scaler 1:1 thru 1:16
0575  3078  	MOVLW 0x78
0576  1283  	BCF STATUS, RP0
0577  0492  	IORWF gbl_t2con, F

    t2con.TMR2ON = 1; // bit 2 turn timer2 on;
0578  1512  	BSF gbl_t2con,2

    t2con.T2CKPS1 = 1; // bits 1-0  Prescaler Rate Select bits
0579  1492  	BSF gbl_t2con,1

    //t2con.T2CKPS0 = 0;
    pr2 = 195; // PR2 (Timer2 Match value)
057A  30C3  	MOVLW 0xC3
057B  1683  	BSF STATUS, RP0
057C  0092  	MOVWF gbl_pr2


    // No task at initialisation
    cTask = 0;
057D  1283  	BCF STATUS, RP0
057E  01CD  	CLRF gbl_cTask

    
    // Enable interrupts
    intcon.GIE = 1;
057F  178B  	BSF gbl_intcon,7

    intcon.PEIE = 1;
0580  170B  	BSF gbl_intcon,6


    // Read in variables from EEPROM
    eepromReadAll(); 
0581  2228  	CALL eepromRead_00019


	i2c_init(1); 
0582  3001  	MOVLW 0x01
0583  00E8  	MOVWF i2c_INIT_00000_arg_i2c_divisor
0584  2215  	CALL i2c_INIT_00000

	ds3231Init();
0585  2290  	CALL ds3231Init_00000

	ds3231WriteDateTime();
0586  226D  	CALL ds3231Writ_0001C

	ds3231Start();
0587  2289  	CALL ds3231Star_0001B

}
0588  0008  	RETURN



/*********************************************************************************************
  interrupt()
  Interrupt handler
*********************************************************************************************/
void interrupt() {

    // Handle timer1 interrupt - delay counter from DS3231
    if (pir1.TMR1IF) {
0674  1283  	BCF STATUS, RP0
0675  1303  	BCF STATUS, RP1
0676  1C0C  	BTFSS gbl_pir1,0
0677  2E7D  	GOTO	label107
067D        label107

        tmr1h = TMR1HV;      // preset for timer1 MSB register
0678  30FF  	MOVLW 0xFF
0679  008F  	MOVWF gbl_tmr1h

        tmr1l = TMR1LV;      // preset for timer1 LSB register
067A  008E  	MOVWF gbl_tmr1l


        pir1.TMR1IF = 0;     // Clear interrupt flag
067B  100C  	BCF gbl_pir1,0

        cTask.TASK_TIMER1 = 1;
067C  154D  	BSF gbl_cTask,2

    }
    
    // Interrupt on timer2 - flash digit delay
    if (pir1.TMR2IF) {
067D  1C8C  	BTFSS gbl_pir1,1
067E  2E88  	GOTO	label109
0688        label109

        iTimer2Counts++;
067F  0ABE  	INCF gbl_iTimer2Counts, F

        if (iTimer2Counts > 9) {
0680  083E  	MOVF gbl_iTimer2Counts, W
0681  3C09  	SUBLW 0x09
0682  1803  	BTFSC STATUS,C
0683  2E87  	GOTO	label108
0687        label108

            iFlashDigitOff++;
0684  0ABF  	INCF gbl_iFlashDigitOff, F

            iTimer2Counts = 0;
0685  01BE  	CLRF gbl_iTimer2Counts

            cTask.TASK_TIMER2 = 1;
0686  16CD  	BSF gbl_cTask,5

        }
        // Clear interrupt flag
        pir1.TMR2IF = 0; 
0687  108C  	BCF gbl_pir1,1

    }
}
0688  0E32  	SWAPF Int1BContext+D'2', W
0689  0084  	MOVWF FSR
068A  0E31  	SWAPF Int1BContext+D'1', W
068B  008A  	MOVWF PCLATH
068C  0E30  	SWAPF Int1BContext, W
068D  0083  	MOVWF STATUS
068E  0EFF  	SWAPF Int1Context, F
068F  0E7F  	SWAPF Int1Context, W
0690  0009  	RETFIE


int binToBcd(int iBin) {

    int iBcd = 0; // 16-bit BCD value - only supporting up to 9999
029D  01F0  	CLRF binToBcd_00000_1_iBcd
029E  01F1  	CLRF binToBcd_00000_1_iBcd+D'1'

    int iTest = 32768; // Start testing from MSB
029F  01F2  	CLRF binToBcd_00000_1_iTest
02A0  3080  	MOVLW 0x80
02A1  00F3  	MOVWF binToBcd_00000_1_iTest+D'1'

    // Loop through the 16 bits in the two bytes
    for (char i = 0; i < 16; i++) {
02A2  01F4  	CLRF binToBcd_00000_2_i
02A3        label43
02A3  3010  	MOVLW 0x10
02A4  0274  	SUBWF binToBcd_00000_2_i, W
02A5  1803  	BTFSC STATUS,C
02A6  2AFC  	GOTO	label52
02FA  0AF4  	INCF binToBcd_00000_2_i, F
02FB  2AA3  	GOTO	label43
02FC        label52

        // Shift one
        iBcd <<= 1;
02A7  1003  	BCF STATUS,C
02A8  0DF0  	RLF binToBcd_00000_1_iBcd, F
02A9  0DF1  	RLF binToBcd_00000_1_iBcd+D'1', F

        // If the bit is set, add one
        if (iBin & iTest)
02AA  0872  	MOVF binToBcd_00000_1_iTest, W
02AB  056E  	ANDWF binToBcd_00000_arg_iBin, W
02AC  1D03  	BTFSS STATUS,Z
02AD  2AB2  	GOTO	label44
02AE  0873  	MOVF binToBcd_00000_1_iTest+D'1', W
02AF  056F  	ANDWF binToBcd_00000_arg_iBin+D'1', W
02B0  1903  	BTFSC STATUS,Z
02B1  2AB5  	GOTO	label45
02B2        label44

            iBcd++;
02B2  0AF0  	INCF binToBcd_00000_1_iBcd, F
02B3  1903  	BTFSC STATUS,Z
02B4  0AF1  	INCF binToBcd_00000_1_iBcd+D'1', F
02B5        label45

        
        // Add 3 to any BCD column 5 or greater
        if ((iBcd & 0x0F) > 0x04)
02B5  300F  	MOVLW 0x0F
02B6  0570  	ANDWF binToBcd_00000_1_iBcd, W
02B7  00F5  	MOVWF CompTempVar577
02B8  01F6  	CLRF CompTempVar578
02B9  0875  	MOVF CompTempVar577, W
02BA  3C04  	SUBLW 0x04
02BB  0876  	MOVF CompTempVar578, W
02BC  1803  	BTFSC STATUS,C
02BD  1D03  	BTFSS STATUS,Z
02BE  1BF6  	BTFSC CompTempVar578,7
02BF  2AC4  	GOTO	label46

            iBcd += 3;
02C0  3003  	MOVLW 0x03
02C1  07F0  	ADDWF binToBcd_00000_1_iBcd, F
02C2  1803  	BTFSC STATUS,C
02C3  0AF1  	INCF binToBcd_00000_1_iBcd+D'1', F
02C4        label46

        if ((iBcd & 0xF0) > 0x49)
02C4  30F0  	MOVLW 0xF0
02C5  0570  	ANDWF binToBcd_00000_1_iBcd, W
02C6  00F7  	MOVWF CompTempVar579
02C7  01F8  	CLRF CompTempVar580
02C8  0877  	MOVF CompTempVar579, W
02C9  3C49  	SUBLW 0x49
02CA  0878  	MOVF CompTempVar580, W
02CB  1803  	BTFSC STATUS,C
02CC  1D03  	BTFSS STATUS,Z
02CD  1BF8  	BTFSC CompTempVar580,7
02CE  2AD3  	GOTO	label47

            iBcd += 0x30;
02CF  3030  	MOVLW 0x30
02D0  07F0  	ADDWF binToBcd_00000_1_iBcd, F
02D1  1803  	BTFSC STATUS,C
02D2  0AF1  	INCF binToBcd_00000_1_iBcd+D'1', F
02D3        label47

        if ((iBcd & 0xF00) > 0x499)
02D3  3000  	MOVLW 0x00
02D4  0570  	ANDWF binToBcd_00000_1_iBcd, W
02D5  00F9  	MOVWF CompTempVar581
02D6  0871  	MOVF binToBcd_00000_1_iBcd+D'1', W
02D7  390F  	ANDLW 0x0F
02D8  00FA  	MOVWF CompTempVar582
02D9  087A  	MOVF CompTempVar582, W
02DA  3C04  	SUBLW 0x04
02DB  1D03  	BTFSS STATUS,Z
02DC  2ADF  	GOTO	label48
02DD  0879  	MOVF CompTempVar581, W
02DE  3C99  	SUBLW 0x99
02DF        label48
02DF  1803  	BTFSC STATUS,C
02E0  2AE5  	GOTO	label49
02E1  1BFA  	BTFSC CompTempVar582,7
02E2  2AE5  	GOTO	label49
02E5        label49

            iBcd += 0x300;
02E3  3003  	MOVLW 0x03
02E4  07F1  	ADDWF binToBcd_00000_1_iBcd+D'1', F

        if ((iBcd & 0xF000) > 0x4999)
02E5  3000  	MOVLW 0x00
02E6  0570  	ANDWF binToBcd_00000_1_iBcd, W
02E7  00FB  	MOVWF CompTempVar583
02E8  0871  	MOVF binToBcd_00000_1_iBcd+D'1', W
02E9  39F0  	ANDLW 0xF0
02EA  00FC  	MOVWF CompTempVar584
02EB  087C  	MOVF CompTempVar584, W
02EC  3C49  	SUBLW 0x49
02ED  1D03  	BTFSS STATUS,Z
02EE  2AF1  	GOTO	label50
02EF  087B  	MOVF CompTempVar583, W
02F0  3C99  	SUBLW 0x99
02F1        label50
02F1  1803  	BTFSC STATUS,C
02F2  2AF7  	GOTO	label51
02F3  1BFC  	BTFSC CompTempVar584,7
02F4  2AF7  	GOTO	label51
02F7        label51

            iBcd += 0x3000;
02F5  3030  	MOVLW 0x30
02F6  07F1  	ADDWF binToBcd_00000_1_iBcd+D'1', F

        
        // move the test bit
        iTest >>= 1;
02F7  0D73  	RLF binToBcd_00000_1_iTest+D'1', W
02F8  0CF3  	RRF binToBcd_00000_1_iTest+D'1', F
02F9  0CF2  	RRF binToBcd_00000_1_iTest, F

    }

    return iBcd;
02FC  0870  	MOVF binToBcd_00000_1_iBcd, W
02FD  00F4  	MOVWF CompTempVarRet576
02FE  0871  	MOVF binToBcd_00000_1_iBcd+D'1', W
02FF  00F5  	MOVWF CompTempVarRet576+D'1'

}
0300  0008  	RETURN



/*********************************************************************************************
  displayTemp()
  Used to split the 16 bit integer returned from the ds18b20 into parts for display
  cTempH - upper 8 bits
  cTempL - lower 8 bits
*********************************************************************************************/
void convertTemp() {

    // convert both bytes to a 16bit int - e.g. 0000 0001 0100 0110 (1 and 70, gives 326)
    
    signed int iTemp = (cTempH << 8) | cTempL;
05B3  1283  	BCF STATUS, RP0
05B4  1303  	BCF STATUS, RP1
05B5  01E8  	CLRF convertTem_00025_1_iTemp
05B6  0849  	MOVF gbl_cTempH, W
05B7  00E9  	MOVWF convertTem_00025_1_iTemp+D'1'
05B8  084A  	MOVF gbl_cTempL, W
05B9  04E8  	IORWF convertTem_00025_1_iTemp, F

    
    // Celcius
    gbDS3231IsMinus = (iTemp < 0);
05BA  01CC  	CLRF gbl_gbDS3231IsMinus
05BB  1BE9  	BTFSC convertTem_00025_1_iTemp+D'1',7
05BC  0ACC  	INCF gbl_gbDS3231IsMinus, F

    if (gbDS3231IsMinus) {
05BD  08CC  	MOVF gbl_gbDS3231IsMinus, F
05BE  1903  	BTFSC STATUS,Z
05BF  2DC5  	GOTO	label97

        iTemp = ~iTemp + 1;
05C0  09E8  	COMF convertTem_00025_1_iTemp, F
05C1  09E9  	COMF convertTem_00025_1_iTemp+D'1', F
05C2  0AE8  	INCF convertTem_00025_1_iTemp, F
05C3  1903  	BTFSC STATUS,Z
05C4  0AE9  	INCF convertTem_00025_1_iTemp+D'1', F
05C5        label97

    }
    // this gets celcius * 100 - https://www.phanderson.com/PIC/PICC/sourceboost/ds18b20_1.html
    int iValue = (6 * iTemp) + (iTemp / 4);
05C5  3006  	MOVLW 0x06
05C6  00EE  	MOVWF __mul_16s__0000F_arg_a
05C7  01EF  	CLRF __mul_16s__0000F_arg_a+D'1'
05C8  0868  	MOVF convertTem_00025_1_iTemp, W
05C9  00F0  	MOVWF __mul_16s__0000F_arg_b
05CA  0869  	MOVF convertTem_00025_1_iTemp+D'1', W
05CB  00F1  	MOVWF __mul_16s__0000F_arg_b+D'1'
05CC  23A8  	CALL __mul_16s__0000F
05CD  0875  	MOVF CompTempVarRet386, W
05CE  00EA  	MOVWF convertTem_00025_1_iValue
05CF  0876  	MOVF CompTempVarRet386+D'1', W
05D0  00ED  	MOVWF CompTempVar600
05D1  0868  	MOVF convertTem_00025_1_iTemp, W
05D2  00EC  	MOVWF CompTempVar597
05D3  0869  	MOVF convertTem_00025_1_iTemp+D'1', W
05D4  00EB  	MOVWF convertTem_00025_1_iValue+D'1'
05D5  0D69  	RLF convertTem_00025_1_iTemp+D'1', W
05D6  0CEB  	RRF convertTem_00025_1_iValue+D'1', F
05D7  0CEC  	RRF CompTempVar597, F
05D8  0D69  	RLF convertTem_00025_1_iTemp+D'1', W
05D9  0CEB  	RRF convertTem_00025_1_iValue+D'1', F
05DA  0CEC  	RRF CompTempVar597, F
05DB  086C  	MOVF CompTempVar597, W
05DC  07EA  	ADDWF convertTem_00025_1_iValue, F
05DD  086D  	MOVF CompTempVar600, W
05DE  1803  	BTFSC STATUS,C
05DF  0AEB  	INCF convertTem_00025_1_iValue+D'1', F
05E0  07EB  	ADDWF convertTem_00025_1_iValue+D'1', F


    // Split the temperature reading into digits
    
    // simple way, but more program memory needed for PIC12 or PIC16 (more than 100 words more)
    //giDS3231ValueBCD = iValue / 1000;
    //giDS3231ValueBCD += (iValue / 100) % 10;
    //giDS3231ValueBCD += (iValue / 10) % 10;
    //giDS3231ValueBCD += iValue % 10;
    
    // Double Dabble
    giDS3231ValueBCD = binToBcd(iValue);
05E1  086A  	MOVF convertTem_00025_1_iValue, W
05E2  00EE  	MOVWF binToBcd_00000_arg_iBin
05E3  086B  	MOVF convertTem_00025_1_iValue+D'1', W
05E4  00EF  	MOVWF binToBcd_00000_arg_iBin+D'1'
05E5  229D  	CALL binToBcd_00000
05E6  0874  	MOVF CompTempVarRet576, W
05E7  00B3  	MOVWF gbl_giDS3231ValueBCD
05E8  0875  	MOVF CompTempVarRet576+D'1', W
05E9  00B4  	MOVWF gbl_giDS3231ValueBCD+D'1'

    
    // less program memory needed - may be slower executing
    // https://electronics.stackexchange.com/questions/158563/how-to-split-a-floating-point-number-into-individual-digits
    /*giDS3231ValueBCD = 0;

    // incrementing variables for each digit
    // determine to thousands digit
    while (iValue >= 1000) {
        iValue = iValue - 1000;
        // each time we take off 1000, the digit is incremented
        giDS3231ValueBCD += 0x1000;
    }

    // determine to hundreds digit
    while (iValue >= 100) {
        iValue = iValue - 100;
        // each time we take off 100, the digit is incremented
        giDS3231ValueBCD += 0x100;
    }

    // determine to tens digit
    while (iValue >= 10) {
        iValue = iValue - 10;
        // each time we take off 10, the left most digit is incremented
        giDS3231ValueBCD += 0x10;
    }

    // the last digit is what's left on iValue
    giDS3231ValueBCD += iValue;*/
}
05EA  0008  	RETURN


/*********************************************************************************************
  startTemp()
  Sends the Convert T [44h] function command to the ds18b20
*********************************************************************************************/
void startTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // 44 is the convert function
    oneWireTxBytes(0xCC, 0x44);
04DE  30CC  	MOVLW 0xCC
04DF  1283  	BCF STATUS, RP0
04E0  1303  	BCF STATUS, RP1
04E1  00E8  	MOVWF oneWireTxB_00015_arg_cData
04E2  3044  	MOVLW 0x44
04E3  00E9  	MOVWF oneWireTxB_00015_arg_cData2
04E4  219C  	CALL oneWireTxB_00015

}
04E5  0008  	RETURN


/*********************************************************************************************
  startTemp()
  Sends the Read Scratchpad [BEh] function command to the ds18b20
*********************************************************************************************/
void readTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // BE indicates to read scratchpad
    oneWireTxBytes(0xCC, 0xBE);
04E6  30CC  	MOVLW 0xCC
04E7  1283  	BCF STATUS, RP0
04E8  1303  	BCF STATUS, RP1
04E9  00E8  	MOVWF oneWireTxB_00015_arg_cData
04EA  30BE  	MOVLW 0xBE
04EB  00E9  	MOVWF oneWireTxB_00015_arg_cData2
04EC  219C  	CALL oneWireTxB_00015

    // Now get the temperature from the scratchpad
    // This is in the first two bytes - so get those only and ignore the rest
    cTempL = oneWireRxByte();
04ED  21A3  	CALL oneWireRxB_00016
04EE  0869  	MOVF CompTempVarRet548, W
04EF  00CA  	MOVWF gbl_cTempL

    cTempH = oneWireRxByte();
04F0  21A3  	CALL oneWireRxB_00016
04F1  0869  	MOVF CompTempVarRet548, W
04F2  00C9  	MOVWF gbl_cTempH

}
04F3  0008  	RETURN


/*********************************************************************************************
  char bcdAdjust(char bcd, char bcdMax, char bcdMin, char iAdjustment)
  Increment or Decrement a BCD variable for sending to the DS3231, within a given range
*********************************************************************************************/
char bcdAdjust(char bcd, char bcdMax, char bcdMin, char iAdjustment) {

    if (iAdjustment == 1) {
015D  036E  	DECF bcdAdjust_00000_arg_iAdjustment, W
015E  1D03  	BTFSS STATUS,Z
015F  2975  	GOTO	label27
0175        label27

        // Increment
        // if at maximum, reset to minimum
        if (bcd == bcdMax)
0160  086C  	MOVF bcdAdjust_00000_arg_bcdMax, W
0161  066B  	XORWF bcdAdjust_00000_arg_bcd, W
0162  1D03  	BTFSS STATUS,Z
0163  2967  	GOTO	label24
0167        label24

            bcd = bcdMin;
0164  086D  	MOVF bcdAdjust_00000_arg_bcdMin, W
0165  00EB  	MOVWF bcdAdjust_00000_arg_bcd

        else if ((bcd & 0x0F) == 9)
0166  2972  	GOTO	label26
0167  300F  	MOVLW 0x0F
0168  056B  	ANDWF bcdAdjust_00000_arg_bcd, W
0169  00EF  	MOVWF CompTempVar586
016A  086F  	MOVF CompTempVar586, W
016B  3A09  	XORLW 0x09
016C  1D03  	BTFSS STATUS,Z
016D  2971  	GOTO	label25
0171        label25

            bcd += 0x10;
016E  3010  	MOVLW 0x10
016F  07EB  	ADDWF bcdAdjust_00000_arg_bcd, F

        else
0170  2972  	GOTO	label26
0172        label26

            bcd++;
0171  0AEB  	INCF bcdAdjust_00000_arg_bcd, F

        return bcd;
0172  086B  	MOVF bcdAdjust_00000_arg_bcd, W
0173  00F2  	MOVWF CompTempVarRet585

    } else {
        // Decrement
        // if at minimum, reset to maximum
        if (bcd == bcdMin)
0175  086D  	MOVF bcdAdjust_00000_arg_bcdMin, W
0176  066B  	XORWF bcdAdjust_00000_arg_bcd, W
0177  1D03  	BTFSS STATUS,Z
0178  297C  	GOTO	label28
017C        label28

            bcd = bcdMax;
0179  086C  	MOVF bcdAdjust_00000_arg_bcdMax, W
017A  00EB  	MOVWF bcdAdjust_00000_arg_bcd

        else if ((bcd & 0x0F) == 0)
017B  2986  	GOTO	label30
017C  300F  	MOVLW 0x0F
017D  056B  	ANDWF bcdAdjust_00000_arg_bcd, W
017E  00EF  	MOVWF CompTempVar587
017F  08EF  	MOVF CompTempVar587, F
0180  1D03  	BTFSS STATUS,Z
0181  2985  	GOTO	label29
0185        label29

            bcd -= 0x10;
0182  3010  	MOVLW 0x10
0183  02EB  	SUBWF bcdAdjust_00000_arg_bcd, F

        else
0184  2986  	GOTO	label30
0186        label30

            bcd--;
0185  03EB  	DECF bcdAdjust_00000_arg_bcd, F

        return bcd;
0186  086B  	MOVF bcdAdjust_00000_arg_bcd, W
0187  00F2  	MOVWF CompTempVarRet585

    }
}
0174  0008  	RETURN
0188  0008  	RETURN


/*********************************************************************************************
  adjustDateTime(char iAdjustment)
  Increment or Decrement a BCD variable for sending to the DS3231, within a given range
*********************************************************************************************/
void adjustDateTime(char iAdjustment) {

    switch (gcSetMode) {

        case 1:
0324  0850  	MOVF gbl_gcSetMode, W
0325  3A01  	XORLW 0x01
0326  1903  	BTFSC STATUS,Z
0327  2B38  	GOTO	label55
0338        label55

            // Setting year
            gBcdYear = bcdAdjust(gBcdYear, 0x99, 0x00, iAdjustment);
0338  083B  	MOVF gbl_gBcdYear, W
0339  00EB  	MOVWF bcdAdjust_00000_arg_bcd
033A  3099  	MOVLW 0x99
033B  00EC  	MOVWF bcdAdjust_00000_arg_bcdMax
033C  01ED  	CLRF bcdAdjust_00000_arg_bcdMin
033D  0868  	MOVF adjustDate_00023_arg_iAdjustment, W
033E  00EE  	MOVWF bcdAdjust_00000_arg_iAdjustment
033F  215D  	CALL bcdAdjust_00000
0340  0872  	MOVF CompTempVarRet585, W
0341  00BB  	MOVWF gbl_gBcdYear

            break;
        case 2:
0328  3A03  	XORLW 0x03
0329  1903  	BTFSC STATUS,Z
032A  2B43  	GOTO	label56
0343        label56

            // Setting month
            gBcdMonth = bcdAdjust(gBcdMonth, 0x12, 0x01, iAdjustment);
0343  083A  	MOVF gbl_gBcdMonth, W
0344  00EB  	MOVWF bcdAdjust_00000_arg_bcd
0345  3012  	MOVLW 0x12
0346  00EC  	MOVWF bcdAdjust_00000_arg_bcdMax
0347  3001  	MOVLW 0x01
0348  00ED  	MOVWF bcdAdjust_00000_arg_bcdMin
0349  0868  	MOVF adjustDate_00023_arg_iAdjustment, W
034A  00EE  	MOVWF bcdAdjust_00000_arg_iAdjustment
034B  215D  	CALL bcdAdjust_00000
034C  0872  	MOVF CompTempVarRet585, W
034D  00BA  	MOVWF gbl_gBcdMonth

            break;
        case 3:
032B  3A01  	XORLW 0x01
032C  1903  	BTFSC STATUS,Z
032D  2B4F  	GOTO	label57
034F        label57

            // Setting day of month
            char iMonth = gBcdDayOfMonth;
034F  0839  	MOVF gbl_gBcdDayOfMonth, W
0350  00E9  	MOVWF adjustDate_00023_1_iMonth

            if (iMonth & 0xF0)
0351  30F0  	MOVLW 0xF0
0352  0569  	ANDWF adjustDate_00023_1_iMonth, W
0353  1903  	BTFSC STATUS,Z
0354  2B5A  	GOTO	label58
035A        label58

                iMonth += (gBcdDayOfMonth >> 4);
0355  0E39  	SWAPF gbl_gBcdDayOfMonth, W
0356  390F  	ANDLW 0x0F
0357  00EB  	MOVWF CompTempVar588
0358  086B  	MOVF CompTempVar588, W
0359  07E9  	ADDWF adjustDate_00023_1_iMonth, F

            iMonth--; // Make 0 to 11 index based
035A  03E9  	DECF adjustDate_00023_1_iMonth, F

            char bcdMaxDay = gDaysInMonth[iMonth]; 
035B  083C  	MOVF gbl_gDaysInMonth, W
035C  00F0  	MOVWF __rom_get_00000_arg_objNumb
035D  0869  	MOVF adjustDate_00023_1_iMonth, W
035E  00F1  	MOVWF __rom_get_00000_arg_idx
035F  2024  	CALL __rom_get_00000
0360  00EA  	MOVWF adjustDate_00023_1_bcdMaxDay

            // If February, adjust max days for leap years
            if (iMonth == 1) {
0361  0369  	DECF adjustDate_00023_1_iMonth, W
0362  118A  	BCF PCLATH,3
0363  120A  	BCF PCLATH,4
0364  1D03  	BTFSS STATUS,Z
0365  2B7C  	GOTO	label61

                for (char i = 0; i < 24; i++) {
0366  01EB  	CLRF adjustDate_00023_18_i
0367        label59
0367  3018  	MOVLW 0x18
0368  026B  	SUBWF adjustDate_00023_18_i, W
0369  1803  	BTFSC STATUS,C
036A  2B7C  	GOTO	label61
037A  0AEB  	INCF adjustDate_00023_18_i, F
037B  2B67  	GOTO	label59
037C        label61

                    if (gLeapYears[i] == gBcdYear) {
036B  083D  	MOVF gbl_gLeapYears, W
036C  00F0  	MOVWF __rom_get_00000_arg_objNumb
036D  086B  	MOVF adjustDate_00023_18_i, W
036E  00F1  	MOVWF __rom_get_00000_arg_idx
036F  2024  	CALL __rom_get_00000
0370  00EC  	MOVWF CompTempVar589
0371  083B  	MOVF gbl_gBcdYear, W
0372  066C  	XORWF CompTempVar589, W
0373  118A  	BCF PCLATH,3
0374  120A  	BCF PCLATH,4
0375  1D03  	BTFSS STATUS,Z
0376  2B7A  	GOTO	label60
037A        label60

                        bcdMaxDay = 0x29;
0377  3029  	MOVLW 0x29
0378  00EA  	MOVWF adjustDate_00023_1_bcdMaxDay

                        break;
0379  2B7C  	GOTO	label61

                    }
                }
            }
            gBcdDayOfMonth = bcdAdjust(gBcdDayOfMonth, bcdMaxDay, 0x01, iAdjustment);
037C  0839  	MOVF gbl_gBcdDayOfMonth, W
037D  00EB  	MOVWF bcdAdjust_00000_arg_bcd
037E  086A  	MOVF adjustDate_00023_1_bcdMaxDay, W
037F  00EC  	MOVWF bcdAdjust_00000_arg_bcdMax
0380  3001  	MOVLW 0x01
0381  00ED  	MOVWF bcdAdjust_00000_arg_bcdMin
0382  0868  	MOVF adjustDate_00023_arg_iAdjustment, W
0383  00EE  	MOVWF bcdAdjust_00000_arg_iAdjustment
0384  215D  	CALL bcdAdjust_00000
0385  0872  	MOVF CompTempVarRet585, W
0386  00B9  	MOVWF gbl_gBcdDayOfMonth

            break;
        case 4:
032E  3A07  	XORLW 0x07
032F  1903  	BTFSC STATUS,Z
0330  2B88  	GOTO	label62
0388        label62

            // Setting day of week
            gDayOfWeek = bcdAdjust(gDayOfWeek, 0x07, 0x01, iAdjustment);
0388  0838  	MOVF gbl_gDayOfWeek, W
0389  00EB  	MOVWF bcdAdjust_00000_arg_bcd
038A  3007  	MOVLW 0x07
038B  00EC  	MOVWF bcdAdjust_00000_arg_bcdMax
038C  3001  	MOVLW 0x01
038D  00ED  	MOVWF bcdAdjust_00000_arg_bcdMin
038E  0868  	MOVF adjustDate_00023_arg_iAdjustment, W
038F  00EE  	MOVWF bcdAdjust_00000_arg_iAdjustment
0390  215D  	CALL bcdAdjust_00000
0391  0872  	MOVF CompTempVarRet585, W
0392  00B8  	MOVWF gbl_gDayOfWeek

        case 5:
0331  3A01  	XORLW 0x01
0332  1903  	BTFSC STATUS,Z
0333  2B93  	GOTO	label63
0393        label63

            // Setting hour
            gBcdHour = bcdAdjust(gBcdHour, 0x23, 0x00, iAdjustment);
0393  0837  	MOVF gbl_gBcdHour, W
0394  00EB  	MOVWF bcdAdjust_00000_arg_bcd
0395  3023  	MOVLW 0x23
0396  00EC  	MOVWF bcdAdjust_00000_arg_bcdMax
0397  01ED  	CLRF bcdAdjust_00000_arg_bcdMin
0398  0868  	MOVF adjustDate_00023_arg_iAdjustment, W
0399  00EE  	MOVWF bcdAdjust_00000_arg_iAdjustment
039A  215D  	CALL bcdAdjust_00000
039B  0872  	MOVF CompTempVarRet585, W
039C  00B7  	MOVWF gbl_gBcdHour

        case 6:
0334  3A03  	XORLW 0x03
0335  1903  	BTFSC STATUS,Z
0336  2B9D  	GOTO	label64
039D        label64

            // Setting minute
            gBcdMinute = bcdAdjust(gBcdMinute, 0x59, 0x00, iAdjustment);
039D  0836  	MOVF gbl_gBcdMinute, W
039E  00EB  	MOVWF bcdAdjust_00000_arg_bcd
039F  3059  	MOVLW 0x59
03A0  00EC  	MOVWF bcdAdjust_00000_arg_bcdMax
03A1  01ED  	CLRF bcdAdjust_00000_arg_bcdMin
03A2  0868  	MOVF adjustDate_00023_arg_iAdjustment, W
03A3  00EE  	MOVWF bcdAdjust_00000_arg_iAdjustment
03A4  215D  	CALL bcdAdjust_00000
03A5  0872  	MOVF CompTempVarRet585, W
03A6  00B6  	MOVWF gbl_gBcdMinute

    }
}
0337  0008  	RETURN
0342  0008  	RETURN
034E  0008  	RETURN
0387  0008  	RETURN
03A7  0008  	RETURN


void processKeys() {

    switch (tm1638Keys) {

        case 1:
04F4  1283  	BCF STATUS, RP0
04F5  1303  	BCF STATUS, RP1
04F6  0865  	MOVF gbl_tm1638Keys, W
04F7  3A01  	XORLW 0x01
04F8  1903  	BTFSC STATUS,Z
04F9  2D10  	GOTO	label90
0510        label90

            // Toggle white light on/off
            gbWhiteOn = !gbWhiteOn;
0510  01E8  	CLRF CompTempVar590
0511  1C4E  	BTFSS gbl_gbWhiteOn,0
0512  0AE8  	INCF CompTempVar590, F
0513  104E  	BCF gbl_gbWhiteOn,0
0514  0868  	MOVF CompTempVar590, W
0515  1D03  	BTFSS STATUS,Z
0516  144E  	BSF gbl_gbWhiteOn,0

            break;
        case 2:
04FA  3A03  	XORLW 0x03
04FB  1903  	BTFSC STATUS,Z
04FC  2D18  	GOTO	label91
0518        label91

            // Toggle blue light on/off
            gbBlueOn = !gbBlueOn;
0518  01E8  	CLRF CompTempVar591
0519  1CCE  	BTFSS gbl_gbBlueOn,1
051A  0AE8  	INCF CompTempVar591, F
051B  10CE  	BCF gbl_gbBlueOn,1
051C  0868  	MOVF CompTempVar591, W
051D  1D03  	BTFSS STATUS,Z
051E  14CE  	BSF gbl_gbBlueOn,1

            break;
        case 3:
04FD  3A01  	XORLW 0x01
04FE  1903  	BTFSC STATUS,Z
04FF  2D20  	GOTO	label92
0520        label92

            // Toggle fan on/off
            gbFanOn = !gbFanOn;
0520  01E8  	CLRF CompTempVar592
0521  1D4E  	BTFSS gbl_gbFanOn,2
0522  0AE8  	INCF CompTempVar592, F
0523  114E  	BCF gbl_gbFanOn,2
0524  0868  	MOVF CompTempVar592, W
0525  1D03  	BTFSS STATUS,Z
0526  154E  	BSF gbl_gbFanOn,2

            break;
        case 4:
0500  3A07  	XORLW 0x07
0501  1903  	BTFSC STATUS,Z
0502  2D28  	GOTO	label93
0528        label93

            // Display temp C/temp F/date
            gcDisplayMode++;
0528  0ACF  	INCF gbl_gcDisplayMode, F

            if (gcDisplayMode > 2)
0529  084F  	MOVF gbl_gcDisplayMode, W
052A  3C02  	SUBLW 0x02
052B  1C03  	BTFSS STATUS,C

                gcDisplayMode = 0;
052C  01CF  	CLRF gbl_gcDisplayMode

            break;
        case 5:
0503  3A01  	XORLW 0x01
0504  1903  	BTFSC STATUS,Z
0505  2D2E  	GOTO	label94
052E        label94

            // Set
            gcSetMode++;
052E  0AD0  	INCF gbl_gcSetMode, F

            if (gcSetMode > 6) {
052F  0850  	MOVF gbl_gcSetMode, W
0530  3C06  	SUBLW 0x06
0531  1803  	BTFSC STATUS,C

                ds3231WriteDateTime();
0533  226D  	CALL ds3231Writ_0001C

                gcSetMode = 0;
0534  01D0  	CLRF gbl_gcSetMode

            }
            break;
        case 6:
0506  3A03  	XORLW 0x03
0507  1903  	BTFSC STATUS,Z
0508  2D36  	GOTO	label95
0536        label95

            // Adjust down
            if (gcSetMode > 0) {
0536  0850  	MOVF gbl_gcSetMode, W
0537  3C00  	SUBLW 0x00
0538  1803  	BTFSC STATUS,C

                adjustDateTime(0);
053A  01E8  	CLRF adjustDate_00023_arg_iAdjustment
053B  2324  	CALL adjustDate_00023

            }
            break;
        case 7:
0509  3A01  	XORLW 0x01
050A  1903  	BTFSC STATUS,Z
050B  2D3D  	GOTO	label96
053D        label96

            // Adjust up
            if (gcSetMode > 0) {
053D  0850  	MOVF gbl_gcSetMode, W
053E  3C00  	SUBLW 0x00
053F  1803  	BTFSC STATUS,C

                adjustDateTime(1);
0541  3001  	MOVLW 0x01
0542  00E8  	MOVWF adjustDate_00023_arg_iAdjustment
0543  2324  	CALL adjustDate_00023

            }
            break;
        case 8:
050C  3A0F  	XORLW 0x0F
050D  1903  	BTFSC STATUS,Z

            // Timer
            break;
    }
}
050E  0008  	RETURN
050F  0008  	RETURN
0517  0008  	RETURN
051F  0008  	RETURN
0527  0008  	RETURN
052D  0008  	RETURN
0532  0008  	RETURN
0535  0008  	RETURN
0539  0008  	RETURN
053C  0008  	RETURN
0540  0008  	RETURN
0544  0008  	RETURN


void main() {

    initialise();
05EB  255D  	CALL initialise_00000

    //convertTemp();
    tm1638UpdateDisplay();
05EC  23D3  	CALL tm1638Upda_00020


    // Endless loop
    while(1) {
05ED        label98

        // Task scheduler
        // If there are tasks to be performed, find out the
        // most recent task from the array and execute it
        while (cTask > 0) {
05ED  084D  	MOVF gbl_cTask, W
05EE  3C00  	SUBLW 0x00
05EF  1803  	BTFSC STATUS,C
05F0  2DED  	GOTO	label98

            if (cTask.TASK_TIMER1) {
05F1  1D4D  	BTFSS gbl_cTask,2
05F2  2E0E  	GOTO	label104
060E        label104

                if (gcSetMode == 0) {
05F3  08D0  	MOVF gbl_gcSetMode, F
05F4  1D03  	BTFSS STATUS,Z
05F5  2E0D  	GOTO	label103
060D        label103

                    ds3231ReadDateTime();
05F6  2589  	CALL ds3231Read_0001D

                    if ((gBcdSeconds == 0x29) || (gBcdSeconds == 0x59)) {
05F7  0835  	MOVF gbl_gBcdSeconds, W
05F8  3A29  	XORLW 0x29
05F9  1903  	BTFSC STATUS,Z
05FA  2DFF  	GOTO	label99
05FB  0835  	MOVF gbl_gBcdSeconds, W
05FC  3A59  	XORLW 0x59
05FD  1D03  	BTFSS STATUS,Z
05FE  2E02  	GOTO	label100
05FF        label99
0602        label100

                        // Ask to convert for temperature reading at 29 seconds or 59 seconds past the minute
                        oneWireBusReset();
05FF  2545  	CALL oneWireBus_00013

                        startTemp();
0600  24DE  	CALL startTemp_00000

                    } else if ((gBcdSeconds == 0) || (gBcdSeconds == 0x30)) {
0601  2E0C  	GOTO	label102
0602  08B5  	MOVF gbl_gBcdSeconds, F
0603  1903  	BTFSC STATUS,Z
0604  2E09  	GOTO	label101
0605  0835  	MOVF gbl_gBcdSeconds, W
0606  3A30  	XORLW 0x30
0607  1D03  	BTFSS STATUS,Z
0608  2E0C  	GOTO	label102
0609        label101
060C        label102
0619  2DED  	GOTO	label98

                        // 1 second later, read the converted temperature
                        oneWireBusReset();
0609  2545  	CALL oneWireBus_00013

                        readTemp(); 
060A  24E6  	CALL readTemp_00000

                        // store it in the array, next display refresh will pick it up
                        convertTemp();
060B  25B3  	CALL convertTem_00025

                    }
                    // Display time and temp or date on TM1638
                    tm1638UpdateDisplay();
060C  23D3  	CALL tm1638Upda_00020

                }
                
                cTask.TASK_TIMER1 = 0;
060D  114D  	BCF gbl_cTask,2

            }
            if (cTask.TASK_TIMER2) {
060E  1ECD  	BTFSS gbl_cTask,5
060F  2E15  	GOTO	label105
0615        label105

                // If in set mode, update the display every ~half second to flash a digit
                if (gcSetMode > 0)
0610  0850  	MOVF gbl_gcSetMode, W
0611  3C00  	SUBLW 0x00
0612  1C03  	BTFSS STATUS,C

                    tm1638UpdateDisplay();
0613  23D3  	CALL tm1638Upda_00020

                cTask.TASK_TIMER2 = 0;
0614  12CD  	BCF gbl_cTask,5

            }
            // Poll keys
            tm1638ReadKeys();
0615  24BA  	CALL tm1638Read_00021

            if (tm1638Keys != 0) {
0616  08E5  	MOVF gbl_tm1638Keys, F
0617  1D03  	BTFSS STATUS,Z

                processKeys();
0618  24F4  	CALL processKey_00024

            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
// I2C Communications Library for I2C MASTER
////////////////////////////////////////////////////////////////////////////
// Author(s): Andrew Smallridge
// Date 15 November 2004
//
// Copyright(C) 2004-2006 Andrew Smallridge
// Copyright(C) 2004-2010 Pavel Baranov
// Copyright(C) 2004-2010 David Hobday
// Existing constants predefined for i2c hardware driver and i2s software
// emulation for the PIC 18F2xx and 18F4xx processors. For hardware support
// on other PICs the constants must be mapped to the corresponding register
// map of the target device
////////////////////////////////////////////////////////////////////////////

/*
////////////////////////////////////////////////////////////////////////////
//	The following three sections should be copied to the user's program:
//		i2c master hardware / software mode definition
//		i2c software implementation template arguments and variables
// 		i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////
// i2c master hardware / software mode definition
//
// For i2c hardware support comment out the #define use_ic2_SW line
////////////////////////////////////////////////////////////////////////////
//#define use_i2c_SW

#if defined use_i2c_SW
////////////////////////////////////////////////////////////////////////////
// i2c software implementation template arguments and variables
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)

// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and software emalated i2c RAM locations. These constants are
// then used by the templated functions. When changing the address of an emulated
// register the corresponding constant mapping must also be changed.
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3					

#else
////////////////////////////////////////////////////////////////////////////
// i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP |i2c_HW)

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and PIC's i2c register locations. These constants are
// then used by the templated functions. 
#define PORTC		0x0f82
#define TRISC		0x0f94
#define e_SSPCON1	0xfc6
#define e_SSPCON2	0xfc5
#define e_SSPSTAT	0xfc7
#define e_SSPADD	0xfc8
#define e_SSPBUF	0xfc9
#define e_SSPIF_PIR	0xf9e
#define e_BCLIF_PIR	0xfa1
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3

#endif

*/


////////////////////////////////////////////////////////////////////////////
// Define the common i2c template structure
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL	template <unsigned char T_SCL_BIT, unsigned short T_SCL_PORT,	\
					unsigned short T_SCL_TRIS, unsigned char T_SDA_BIT, 			\
					unsigned short T_SDA_PORT, unsigned short T_SDA_TRIS,			\
					unsigned short T_i2c_SSPCON1, unsigned short T_i2c_SSPCON2, 	\
					unsigned short T_i2c_SSPSTAT, unsigned short T_i2c_SSPBUF, 		\
					unsigned char T_i2c_SSPIF_BIT, unsigned short T_i2c_SSPIF_PIR,	\
					unsigned char T_i2c_BCLIF_BIT, unsigned short T_i2c_BCLIF_PIR,	\
					unsigned char T_i2c_SMP_BIT, unsigned short T_i2c_SSPADD, 		\
					unsigned char T_MODE>

////////////////////////////////////////////////////////////////////////////
// Define the common i2c template parameters
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL_ARGS	T_SCL_BIT, T_SCL_PORT, T_SCL_TRIS, T_SDA_BIT, 			\
						T_SDA_PORT, T_SDA_TRIS, T_i2c_SSPCON1, T_i2c_SSPCON2, 	\
						T_i2c_SSPSTAT, T_i2c_SSPBUF, T_i2c_SSPIF_BIT, 			\
						T_i2c_SSPIF_PIR, T_i2c_BCLIF_BIT, T_i2c_BCLIF_PIR,		\
						T_i2c_SMP_BIT, T_i2c_SSPADD, T_MODE

////////////////////////////////////////////////////////////////////////////
// Helpers that hide template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_init	i2c_INIT<i2c_ARGS>
#define i2c_start	i2c_START<i2c_ARGS>
#define i2c_restart	i2c_RESTART<i2c_ARGS>
#define i2c_stop	i2c_STOP<i2c_ARGS>
#define i2c_read	i2c_READ<i2c_ARGS>
#define i2c_write	i2c_WRITE<i2c_ARGS>


////////////////////////////////////////////////////////////////////////////
// I2C Control Status Bits - Emulates the PIC18F hardware I2C implementation
////////////////////////////////////////////////////////////////////////////
// define I2C i2C_SSPCON1 control bits
#define	i2c_WCOL	7
#define	i2c_SSPOV	6
#define	i2c_SSPEN	5
#define	i2c_CKP		4
#define	i2c_SSPM3	3
#define	i2c_SSPM2	2
#define	i2c_SSPM1	1
#define	i2c_SSPM0	0

// define I2C SSPCON2 control bits
#define	i2c_GCEN 	7
#define	i2c_ACKSTAT	6
#define	i2c_ACKDT	5
#define	i2c_ACKEN	4
#define	i2c_RCEN	3
#define	i2c_PEN		2
#define	i2c_RSEN	1
#define	i2c_SEN		0

// define I2C SSPSTAT status bits
#define	i2c_DA		5
#define	i2c_P		4
#define	i2c_S		3
#define	i2c_RW		2
#define	i2c_UA		1
#define	i2c_BF		0


////////////////////////////////////////////////////////////////////////////
// I2C Control Flag Bits
////////////////////////////////////////////////////////////////////////////
// define I2C Mode bits
#define	i2c_HW			0x01
#define	i2c_400KHz		0x02	// 100KHz or 400KHz I2C clock (set = 400KHz)
#define	i2c_reset_wdt	0x04
#define i2c_SMP			0x80	


////////////////////////////////////////////////////////////////////////////
// I2C software constants
////////////////////////////////////////////////////////////////////////////
#define	dly 10	// number of 1us delay increments



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Start Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL 
void i2c_START(void)

{
	// Initiate the I2C START condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	delay_us(dly);
00F8  300A  	MOVLW 0x0A
00F9  1283  	BCF STATUS, RP0
00FA  1303  	BCF STATUS, RP1
00FB  00ED  	MOVWF delay_us_00000_arg_del
00FC  2010  	CALL delay_us_00000

	l_bclif = 0; // initialise the collision flag for this command
00FD  11C6  	BCF i2c_START_00000_1_l_bclif,3

	l_sspif = 0;
00FE  11C5  	BCF i2c_START_00000_1_l_sspif,3

		
	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
			
		l_sen = 1; // initiate START condition	

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation			
		l_sen = 1; // initiate START condition
00FF  1441  	BSF i2c_START_00000_1_l_sen,0

		l_scl_tris = 1; // ensure the SCL line is high
0100  1683  	BSF STATUS, RP0
0101  1505  	BSF i2c_START_00000_1_l_scl_tris,2

		l_sda_tris = 1; // ensure the SDA line is high	
0102  1585  	BSF i2c_START_00000_1_l_sda_tris,3

		l_scl = 0; // prepare to set SCL line low
0103  1283  	BCF STATUS, RP0
0104  1105  	BCF i2c_START_00000_1_l_scl,2

		l_sda = 0; // prepare to set SDA line low
0105  1185  	BCF i2c_START_00000_1_l_sda,3

		
		if (l_scl && l_sda)
0106  1D05  	BTFSS i2c_START_00000_1_l_scl,2
0107  2925  	GOTO	label21
0108  1D85  	BTFSS i2c_START_00000_1_l_sda,3
0109  2925  	GOTO	label21
0125        label21

		{
			// good sign - no collision detected
			delay_us(dly);
010A  300A  	MOVLW 0x0A
010B  00ED  	MOVWF delay_us_00000_arg_del
010C  2010  	CALL delay_us_00000

			
			if (!l_scl) // ensure the clock is still high
010D  1905  	BTFSC i2c_START_00000_1_l_scl,2
010E  2913  	GOTO	label20
0113        label20

			{
				l_bclif = 1;
010F  15C6  	BSF i2c_START_00000_1_l_bclif,3

				l_s = 1;
0110  15C2  	BSF i2c_START_00000_1_l_s,3

				l_sen = 0;
0111  1041  	BCF i2c_START_00000_1_l_sen,0

				return;
			}
					
			l_sda = 0; // prepare to set SDA line low
0113  1185  	BCF i2c_START_00000_1_l_sda,3

			l_sda_tris = 0; // SDA to output (driven low)
0114  1683  	BSF STATUS, RP0
0115  1185  	BCF i2c_START_00000_1_l_sda_tris,3


			delay_us(dly);					
0116  300A  	MOVLW 0x0A
0117  1283  	BCF STATUS, RP0
0118  00ED  	MOVWF delay_us_00000_arg_del
0119  2010  	CALL delay_us_00000

			l_scl = 0; // prepare to set SCL line low
011A  1105  	BCF i2c_START_00000_1_l_scl,2

			l_scl_tris = 0; // SCL to output (driven low)
011B  1683  	BSF STATUS, RP0
011C  1105  	BCF i2c_START_00000_1_l_scl_tris,2


			delay_us(dly);					
011D  300A  	MOVLW 0x0A
011E  1283  	BCF STATUS, RP0
011F  00ED  	MOVWF delay_us_00000_arg_del
0120  2010  	CALL delay_us_00000

			l_s = 1; // set 'S' bit flag (start bit detected)
0121  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0; // clear flag
0122  1041  	BCF i2c_START_00000_1_l_sen,0

			l_sspif = 1; // flag end of start condition interrupt	
0123  15C5  	BSF i2c_START_00000_1_l_sspif,3

		}
		else
		{
			// here is SDA or SCL are low at the start - indicates a bus collision
			l_bclif = 1;
0125  15C6  	BSF i2c_START_00000_1_l_bclif,3

			l_s = 1; // set 'S' bit flag (start bit detected)
0126  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0;
0127  1041  	BCF i2c_START_00000_1_l_sen,0

			l_rsen = 0;
0128  10C1  	BCF i2c_START_00000_1_l_rsen,1

			l_pen = 0;
0129  1141  	BCF i2c_START_00000_1_l_pen,2

			l_rcen = 0;								
012A  11C1  	BCF i2c_START_00000_1_l_rcen,3

			l_acken = 0;			
012B  1241  	BCF i2c_START_00000_1_l_acken,4

		}
	}
}
0112  0008  	RETURN
0124  0008  	RETURN
012C  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Restart Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_RESTART(void)
{
	// Initiate the I2C RESTART condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
			
	delay_us(dly);
	l_bclif = 0; // initialise the collision flag for this command
	l_sspif = 0;

	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_rsen = 1; // initiate RESTART condition
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation	
		l_rsen = 1;
		l_scl = 0;
		l_sda = 0;
		
		if (!l_scl)
		{
			// good sign - no other I2C activity in progress
			l_sda_tris = 1; // float SDA line high	(should already be in this condition)	
			delay_us(dly);
		
			// about to float the clock line
			// ensure the data line is still high
			if (!l_sda)
			{
				// problem - SDA is low, a bus collision has occurred				
				l_bclif = 1; // set the bus collision flag	
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_scl_tris = 1; // float SCL line (high)	
				return;
			}
												
			l_scl_tris = 1; // float SCL line (high)

			// wait until any clock stretching has finished
			while (!l_scl)
				if (T_MODE & i2c_reset_wdt)
					clear_wdt();	
			delay_us(dly);
			
			// here we are about to drive SDA low
			// first ensure SCL is still high
			if (!l_scl)
			{
				// problem - SCL is low, a bus collision has occurred
				l_bclif = 1; // set the bus collision flag
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_sda_tris = 1; // float SDA line (high)
				return;
			}
				
			l_sda_tris = 0; // drive SDA low
			l_s = 1; // set 'S' bit flag (start bit detected)

			delay_us(dly);
			l_scl_tris = 0; // drive SCL low
			l_rsen = 0;
			l_pen = 0;
			l_sen = 0;			
			l_rcen = 0;								
			l_acken = 0;			
			l_sspif = 1; // flag end of start condition interrupt
		}
		else
		{
			// SCL is high at the start
			// some other I2C activity in progress		
			l_rsen = 0; // clear flag
			// exit without further action
		}
	}
}



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Stop Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_STOP(void)

{ 
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_p@T_i2c_SSPSTAT.i2c_P; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;

	l_bclif = 0; // initialise the collision flag for this command
00C8  1283  	BCF STATUS, RP0
00C9  1303  	BCF STATUS, RP1
00CA  11C6  	BCF i2c_STOP_00000_1_l_bclif,3

	l_sspif = 0;
00CB  11C5  	BCF i2c_STOP_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_pen = 1; // initiate STOP condition on the I2C bus	
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
		
	}
	else
	{
		//	Software I2C implementation
		l_pen = 1; // initiate STOP condition on the I2C bus
00CC  1541  	BSF i2c_STOP_00000_1_l_pen,2

		delay_us(dly);
00CD  300A  	MOVLW 0x0A
00CE  00ED  	MOVWF delay_us_00000_arg_del
00CF  2010  	CALL delay_us_00000

		
		l_scl = 0; // prepare to set SCL line low
00D0  1105  	BCF i2c_STOP_00000_1_l_scl,2

		l_sda = 0; // prepare to set SDA line low
00D1  1185  	BCF i2c_STOP_00000_1_l_sda,3

		l_scl_tris = 0; // drive SCL line low (should already be low)
00D2  1683  	BSF STATUS, RP0
00D3  1105  	BCF i2c_STOP_00000_1_l_scl_tris,2

		l_sda_tris = 0; // drive SDA line low
00D4  1185  	BCF i2c_STOP_00000_1_l_sda_tris,3


		delay_us(dly);		
00D5  300A  	MOVLW 0x0A
00D6  1283  	BCF STATUS, RP0
00D7  00ED  	MOVWF delay_us_00000_arg_del
00D8  2010  	CALL delay_us_00000

		l_scl_tris = 1; // float SCL line (high)
00D9  1683  	BSF STATUS, RP0
00DA  1505  	BSF i2c_STOP_00000_1_l_scl_tris,2

		
		// wait until any clock stretching has finished
		while (!l_scl)
00DB        label16
00DB  1283  	BCF STATUS, RP0
00DC  1905  	BTFSC i2c_STOP_00000_1_l_scl,2
00DD  28E0  	GOTO	label17
00DF  28DB  	GOTO	label16
00E0        label17

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
00DE  0064  	CLRWDT

						
		delay_us(dly);
00E0  300A  	MOVLW 0x0A
00E1  00ED  	MOVWF delay_us_00000_arg_del
00E2  2010  	CALL delay_us_00000

		l_sda_tris = 1; // float SDA line
00E3  1683  	BSF STATUS, RP0
00E4  1585  	BSF i2c_STOP_00000_1_l_sda_tris,3

		delay_us(dly);		
00E5  300A  	MOVLW 0x0A
00E6  1283  	BCF STATUS, RP0
00E7  00ED  	MOVWF delay_us_00000_arg_del
00E8  2010  	CALL delay_us_00000

		
		// here the SDA line should be high - if not a collision has occurred				
		if (!l_sda || !l_scl)
00E9  1D85  	BTFSS i2c_STOP_00000_1_l_sda,3
00EA  28ED  	GOTO	label18
00EB  1905  	BTFSC i2c_STOP_00000_1_l_scl,2
00EC  28F1  	GOTO	label19
00ED        label18
00F1        label19

		{
			// problem - SDA or SCL is low, a bus collision has occurred
			l_bclif = 1; // set the bus collision flag	
00ED  15C6  	BSF i2c_STOP_00000_1_l_bclif,3

			l_s = 0; // clear 'S' bit flag
00EE  11C2  	BCF i2c_STOP_00000_1_l_s,3

			l_pen = 0; // clear flag
00EF  1141  	BCF i2c_STOP_00000_1_l_pen,2

		}
		else
		{		
			l_p = 1;
00F1  1642  	BSF i2c_STOP_00000_1_l_p,4

			l_pen = 0;
00F2  1141  	BCF i2c_STOP_00000_1_l_pen,2

			l_sen = 0;
00F3  1041  	BCF i2c_STOP_00000_1_l_sen,0

			l_rsen = 0;			
00F4  10C1  	BCF i2c_STOP_00000_1_l_rsen,1

			l_rcen = 0;								
00F5  11C1  	BCF i2c_STOP_00000_1_l_rcen,3

			l_acken = 0;
00F6  1241  	BCF i2c_STOP_00000_1_l_acken,4

		}
	}
}
00F0  0008  	RETURN
00F7  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Write Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_WRITE(unsigned char i2c_data)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;	
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
	
	char BitMask;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
0077  11C6  	BCF i2c_WRITE_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
0078  11C5  	BCF i2c_WRITE_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
				
		l_wcol = 0; // clear write collision flag	
		i2c_SSPBUF = i2c_data;

		// test if a write collision occurred
		if (l_wcol)
			return (1); // error exit	

		// wait until MSSP Tx register is empty
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
								
		return (0); // successful exit
	}

	// here for i2c software driver
	l_wcol = 0; // clear write collision flag	
0079  13C0  	BCF i2c_WRITE_00000_1_l_wcol,7

	i2c_SSPBUF = i2c_data;
007A  086A  	MOVF i2c_WRITE_00000_arg_i2c_data, W
007B  00C4  	MOVWF i2c_WRITE_00000_1_i2c_SSPBUF

	
	l_scl = 0; // prepare to set SCL line low
007C  1105  	BCF i2c_WRITE_00000_1_l_scl,2

	l_sda = 0; // prepare to set SDA line low
007D  1185  	BCF i2c_WRITE_00000_1_l_sda,3

	l_rw = 0; // signal we are doing a write
007E  1142  	BCF i2c_WRITE_00000_1_l_rw,2


	for (BitMask = 0x80; BitMask; BitMask>>=1)
007F  3080  	MOVLW 0x80
0080  00EB  	MOVWF i2c_WRITE_00000_1_BitMask
0081        label8
0081  08EB  	MOVF i2c_WRITE_00000_1_BitMask, F
0082  1903  	BTFSC STATUS,Z
0083  28A4  	GOTO	label13
00A1  1003  	BCF STATUS,C
00A2  0CEB  	RRF i2c_WRITE_00000_1_BitMask, F
00A3  2881  	GOTO	label8
00A4        label13

	{
		if (i2c_data & BitMask)
0084  086B  	MOVF i2c_WRITE_00000_1_BitMask, W
0085  056A  	ANDWF i2c_WRITE_00000_arg_i2c_data, W
0086  1903  	BTFSC STATUS,Z
0087  288B  	GOTO	label9
008B        label9

			l_sda_tris = 1; // float SDA high	
0088  1683  	BSF STATUS, RP0
0089  1585  	BSF i2c_WRITE_00000_1_l_sda_tris,3

		else
008A  288D  	GOTO	label10
008D        label10

			l_sda_tris = 0; // drive SDA low
008B  1683  	BSF STATUS, RP0
008C  1185  	BCF i2c_WRITE_00000_1_l_sda_tris,3

		delay_us(dly);
008D  300A  	MOVLW 0x0A
008E  1283  	BCF STATUS, RP0
008F  00ED  	MOVWF delay_us_00000_arg_del
0090  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
0091  1683  	BSF STATUS, RP0
0092  1505  	BSF i2c_WRITE_00000_1_l_scl_tris,2


		// wait until any clock stretching has finished
		while (!l_scl)
0093        label11
0093  1283  	BCF STATUS, RP0
0094  1905  	BTFSC i2c_WRITE_00000_1_l_scl,2
0095  2898  	GOTO	label12
0097  2893  	GOTO	label11
0098        label12

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
0096  0064  	CLRWDT

		delay_us(dly);
0098  300A  	MOVLW 0x0A
0099  00ED  	MOVWF delay_us_00000_arg_del
009A  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low	
009B  1683  	BSF STATUS, RP0
009C  1105  	BCF i2c_WRITE_00000_1_l_scl_tris,2

		delay_us(dly);
009D  300A  	MOVLW 0x0A
009E  1283  	BCF STATUS, RP0
009F  00ED  	MOVWF delay_us_00000_arg_del
00A0  2010  	CALL delay_us_00000

	}
	// serialized out the data
	// now get the status		
	// set SSPIF
	l_sspif = 1;
00A4  15C5  	BSF i2c_WRITE_00000_1_l_sspif,3

	l_acken = 1;
00A5  1641  	BSF i2c_WRITE_00000_1_l_acken,4

	l_ackdt = 0;
00A6  12C1  	BCF i2c_WRITE_00000_1_l_ackdt,5

	l_sda_tris = 1; // float SDA high
00A7  1683  	BSF STATUS, RP0
00A8  1585  	BSF i2c_WRITE_00000_1_l_sda_tris,3

	
	delay_us(dly);
00A9  300A  	MOVLW 0x0A
00AA  1283  	BCF STATUS, RP0
00AB  00ED  	MOVWF delay_us_00000_arg_del
00AC  2010  	CALL delay_us_00000

	
	l_scl_tris = 1; // float SCL high
00AD  1683  	BSF STATUS, RP0
00AE  1505  	BSF i2c_WRITE_00000_1_l_scl_tris,2

	
	// wait until any clock stretching has finished
	while (!l_scl)
00AF        label14
00AF  1283  	BCF STATUS, RP0
00B0  1905  	BTFSC i2c_WRITE_00000_1_l_scl,2
00B1  28B4  	GOTO	label15
00B3  28AF  	GOTO	label14
00B4        label15

		if (T_MODE & i2c_reset_wdt)
			clear_wdt();	
00B2  0064  	CLRWDT

	delay_us(dly);
00B4  300A  	MOVLW 0x0A
00B5  00ED  	MOVWF delay_us_00000_arg_del
00B6  2010  	CALL delay_us_00000


	// get the status bit
	local_ack = l_sda;
00B7  106C  	BCF i2c_WRITE_00000_1_local_ack,0
00B8  1985  	BTFSC i2c_WRITE_00000_1_l_sda,3
00B9  146C  	BSF i2c_WRITE_00000_1_local_ack,0

	delay_us(dly);
00BA  300A  	MOVLW 0x0A
00BB  00ED  	MOVWF delay_us_00000_arg_del
00BC  2010  	CALL delay_us_00000


	l_scl_tris = 0; // drive SCL low	
00BD  1683  	BSF STATUS, RP0
00BE  1105  	BCF i2c_WRITE_00000_1_l_scl_tris,2

	l_acken = 0;
00BF  1283  	BCF STATUS, RP0
00C0  1241  	BCF i2c_WRITE_00000_1_l_acken,4

	delay_us(dly);
00C1  300A  	MOVLW 0x0A
00C2  00ED  	MOVWF delay_us_00000_arg_del
00C3  2010  	CALL delay_us_00000

	return(local_ack);
00C4  01ED  	CLRF CompTempVarRet551
00C5  186C  	BTFSC i2c_WRITE_00000_1_local_ack,0
00C6  0AED  	INCF CompTempVarRet551, F

}
00C7  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Read Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_READ(char ack_status)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	char BitMask;
	char i2c_data;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
01C1  11C6  	BCF i2c_READ_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
01C2  11C5  	BCF i2c_READ_00000_1_l_sspif,3

	l_wcol = 0; // clear write collision flag	
01C3  13C0  	BCF i2c_READ_00000_1_l_wcol,7


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// enable master for 1 byte reception	
		l_rcen = 1;

		// wait until byte received
		while(!l_sspif || !l_bf)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// read the byte from the Rx register
		i2c_data = i2c_SSPBUF;			
			
		// wait until the bus is idle		
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		if (ack_status)
			l_ackdt = 1; // preset ack bit
		else
			l_ackdt = 0; // preset ack bit

		l_sspif = 0;
		l_acken = 1; // acknowledge sequence enable

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();								
	}
	else
	{
		// here for i2c software driver
		l_rcen = 1;
01C4  15C1  	BSF i2c_READ_00000_1_l_rcen,3

		l_ackdt = ack_status;
01C5  1868  	BTFSC i2c_READ_00000_arg_ack_status,0
01C6  16C1  	BSF i2c_READ_00000_1_l_ackdt,5
01C7  1C68  	BTFSS i2c_READ_00000_arg_ack_status,0
01C8  12C1  	BCF i2c_READ_00000_1_l_ackdt,5

		l_rw = 1;
01C9  1542  	BSF i2c_READ_00000_1_l_rw,2

		l_scl = 0; // prepare to set SCL line low
01CA  1105  	BCF i2c_READ_00000_1_l_scl,2

		l_sda = 0; // prepare to set SDA line low	
01CB  1185  	BCF i2c_READ_00000_1_l_sda,3


		// prepare to serialize in the byte
		l_sda_tris = 1; // float SDA
01CC  1683  	BSF STATUS, RP0
01CD  1585  	BSF i2c_READ_00000_1_l_sda_tris,3

		delay_us(dly);
01CE  300A  	MOVLW 0x0A
01CF  1283  	BCF STATUS, RP0
01D0  00ED  	MOVWF delay_us_00000_arg_del
01D1  2010  	CALL delay_us_00000

		i2c_data = 0;
01D2  01EA  	CLRF i2c_READ_00000_1_i2c_data

		for (BitMask = 0x80; BitMask; BitMask>>=1)
01D3  3080  	MOVLW 0x80
01D4  00E9  	MOVWF i2c_READ_00000_1_BitMask
01D5        label34
01D5  08E9  	MOVF i2c_READ_00000_1_BitMask, F
01D6  1903  	BTFSC STATUS,Z
01D7  29F2  	GOTO	label38
01EF  1003  	BCF STATUS,C
01F0  0CE9  	RRF i2c_READ_00000_1_BitMask, F
01F1  29D5  	GOTO	label34
01F2        label38

		{
			l_scl_tris = 1; // float SCL high
01D8  1683  	BSF STATUS, RP0
01D9  1505  	BSF i2c_READ_00000_1_l_scl_tris,2

			// wait until any clock stretching has finished
			while (!l_scl)
01DA        label35
01DA  1283  	BCF STATUS, RP0
01DB  1905  	BTFSC i2c_READ_00000_1_l_scl,2
01DC  29DF  	GOTO	label36
01DE  29DA  	GOTO	label35
01DF        label36

				if (T_MODE & i2c_reset_wdt)
					clear_wdt();		
01DD  0064  	CLRWDT

			delay_us(dly);
01DF  300A  	MOVLW 0x0A
01E0  00ED  	MOVWF delay_us_00000_arg_del
01E1  2010  	CALL delay_us_00000


			// read the current bit
			l_sda_tris = 1; // float SDA
01E2  1683  	BSF STATUS, RP0
01E3  1585  	BSF i2c_READ_00000_1_l_sda_tris,3

			if (l_sda)
01E4  1283  	BCF STATUS, RP0
01E5  1D85  	BTFSS i2c_READ_00000_1_l_sda,3
01E6  29E9  	GOTO	label37
01E9        label37

				i2c_data |= BitMask;
01E7  0869  	MOVF i2c_READ_00000_1_BitMask, W
01E8  04EA  	IORWF i2c_READ_00000_1_i2c_data, F

			l_scl_tris = 0; // drive SCL low
01E9  1683  	BSF STATUS, RP0
01EA  1105  	BCF i2c_READ_00000_1_l_scl_tris,2

			delay_us(dly);
01EB  300A  	MOVLW 0x0A
01EC  1283  	BCF STATUS, RP0
01ED  00ED  	MOVWF delay_us_00000_arg_del
01EE  2010  	CALL delay_us_00000

		}
		// flag receive complete			
		l_sspif = 1;
01F2  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		l_rcen = 0;
01F3  11C1  	BCF i2c_READ_00000_1_l_rcen,3

		
		// set the ACK state
		if (ack_status)	
01F4  08E8  	MOVF i2c_READ_00000_arg_ack_status, F
01F5  1903  	BTFSC STATUS,Z
01F6  29FA  	GOTO	label39
01FA        label39

			l_sda_tris = 1; // float SDA high
01F7  1683  	BSF STATUS, RP0
01F8  1585  	BSF i2c_READ_00000_1_l_sda_tris,3

		else
01F9  29FC  	GOTO	label40
01FC        label40

			l_sda_tris = 0; // drive SDA low
01FA  1683  	BSF STATUS, RP0
01FB  1185  	BCF i2c_READ_00000_1_l_sda_tris,3

		delay_us(dly);
01FC  300A  	MOVLW 0x0A
01FD  1283  	BCF STATUS, RP0
01FE  00ED  	MOVWF delay_us_00000_arg_del
01FF  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
0200  1683  	BSF STATUS, RP0
0201  1505  	BSF i2c_READ_00000_1_l_scl_tris,2


		// wait until any clock stretching has finished
		while (!l_scl)
0202        label41
0202  1283  	BCF STATUS, RP0
0203  1905  	BTFSC i2c_READ_00000_1_l_scl,2
0204  2A07  	GOTO	label42
0206  2A02  	GOTO	label41
0207        label42

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
0205  0064  	CLRWDT

	
		l_sspif = 0; // clear SSPIF
0207  11C5  	BCF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
0208  300A  	MOVLW 0x0A
0209  00ED  	MOVWF delay_us_00000_arg_del
020A  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low		
020B  1683  	BSF STATUS, RP0
020C  1105  	BCF i2c_READ_00000_1_l_scl_tris,2

		l_sspif = 1;
020D  1283  	BCF STATUS, RP0
020E  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
020F  300A  	MOVLW 0x0A
0210  00ED  	MOVWF delay_us_00000_arg_del
0211  2010  	CALL delay_us_00000

	}
	return(i2c_data);
0212  086A  	MOVF i2c_READ_00000_1_i2c_data, W
0213  00EB  	MOVWF CompTempVarRet552

}
0214  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Initialization
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_INIT(unsigned char i2c_divisor)

{
	volatile unsigned char i2c_SSPADD@T_i2c_SSPADD, i2c_SSPSTAT@T_i2c_SSPSTAT;
	volatile unsigned char i2c_SSPCON1@T_i2c_SSPCON1,i2c_SSPCON2@T_i2c_SSPCON2;

	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_sspen@T_i2c_SSPCON1.i2c_SSPEN, l_smp@T_i2c_SSPSTAT.T_i2c_SMP_BIT;

	l_sda_tris = 1;
0215  1683  	BSF STATUS, RP0
0216  1585  	BSF i2c_INIT_00000_1_l_sda_tris,3

	l_scl_tris = 1;
0217  1505  	BSF i2c_INIT_00000_1_l_scl_tris,2

	
	i2c_SSPCON1 = 0x00; // initialise the I2C control register (mirrors HW SSPCON1)	
0218  1283  	BCF STATUS, RP0
0219  01C0  	CLRF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPADD = i2c_divisor; // get the I2C baud rate divisor
021A  0868  	MOVF i2c_INIT_00000_arg_i2c_divisor, W
021B  00C3  	MOVWF i2c_INIT_00000_1_i2c_SSPADD

	i2c_SSPCON1 = 0x08; // initialise the I2C control register (mirrors HW SSPCON1)	
021C  3008  	MOVLW 0x08
021D  00C0  	MOVWF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPCON2 = 0x00; // initialise the I2C control register (mirrors HW SSPCON2)	
021E  01C1  	CLRF i2c_INIT_00000_1_i2c_SSPCON2

	
	i2c_SSPSTAT = 0x00; // initialise the I2C status register (mirrors HW SSPSTAT)
021F  01C2  	CLRF i2c_INIT_00000_1_i2c_SSPSTAT

	
	if (T_MODE & i2c_SMP)
		l_smp = 1;
0220  17C2  	BSF i2c_INIT_00000_1_l_smp,7


	l_sspif = 0; // initialise the I2C SSP interrupt status
0221  11C5  	BCF i2c_INIT_00000_1_l_sspif,3

	l_bclif = 0; // initialise the I2C BCL interrupt status
0222  11C6  	BCF i2c_INIT_00000_1_l_bclif,3

	l_sda = 0;
0223  1185  	BCF i2c_INIT_00000_1_l_sda,3

	l_scl = 0;
0224  1105  	BCF i2c_INIT_00000_1_l_scl,2

	l_sspen = 1; // enable I2C
0225  16C0  	BSF i2c_INIT_00000_1_l_sspen,5

	
	i2c_STOP<_I2C_TEMPL_ARGS>();
0226  20C8  	CALL i2c_STOP_00000

}
0227  0008  	RETURN







////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  2E1A  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B0  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00B1  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00B2  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2E74  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010  3003  	MOVLW 0x03
0011  07ED  	ADDWF delay_us_00000_arg_del, F
0012  0CED  	RRF delay_us_00000_arg_del, F
0013  0CED  	RRF delay_us_00000_arg_del, F
0014  307F  	MOVLW 0x7F
0015  05ED  	ANDWF delay_us_00000_arg_del, F
0016        label1
0016  0000  	NOP
0017  0BED  	DECFSZ delay_us_00000_arg_del, F
0018  2816  	GOTO	label1
0019  0008  	RETURN
001A        ; } delay_us function end

001A        delay_10us_00000
001A        ; { delay_10us ; function begin
001A        label2
001A  0000  	NOP
001B  0000  	NOP
001C  0000  	NOP
001D  0000  	NOP
001E  0000  	NOP
001F  0000  	NOP
0020  0000  	NOP
0021  0BED  	DECFSZ delay_10us_00000_arg_del, F
0022  281A  	GOTO	label2
0023  0008  	RETURN
0024        ; } delay_10us function end

0024        __rom_get_00000
0024        ; { __rom_get ; function begin
0024  0870  	MOVF __rom_get_00000_arg_objNumb, W
0025  00F3  	MOVWF __rom_get_00000_1_romAddr+D'1'
0026  01F2  	CLRF __rom_get_00000_1_romAddr
0027  1003  	BCF STATUS,C
0028  0DF3  	RLF __rom_get_00000_1_romAddr+D'1', F
0029  0DF2  	RLF __rom_get_00000_1_romAddr, F
002A  0DF3  	RLF __rom_get_00000_1_romAddr+D'1', F
002B  0DF2  	RLF __rom_get_00000_1_romAddr, F
002C  3037  	MOVLW	LOW( label3 )
002D  07F3  	ADDWF __rom_get_00000_1_romAddr+D'1', F
002E  1803  	BTFSC STATUS,C
002F  0AF2  	INCF __rom_get_00000_1_romAddr, F
0030  3000  	MOVLW	HIGH( label3 )
0031  0772  	ADDWF __rom_get_00000_1_romAddr, W
0032  008A  	MOVWF PCLATH
0033  0871  	MOVF __rom_get_00000_arg_idx, W
0034  00F2  	MOVWF __rom_get_00000_1_romAddr
0035  0873  	MOVF __rom_get_00000_1_romAddr+D'1', W
0036  0082  	MOVWF PCL
0037        label3
0037  3000  	MOVLW	HIGH( label5 )
0038  00F3  	MOVWF __rom_get_00000_1_romAddr+D'1'
0039  3049  	MOVLW	LOW( label5 )
003A  2842  	GOTO	label4
003B  3000  	MOVLW	HIGH( label6 )
003C  00F3  	MOVWF __rom_get_00000_1_romAddr+D'1'
003D  3055  	MOVLW	LOW( label6 )
003E  2842  	GOTO	label4
003F  3000  	MOVLW	HIGH( label7 )
0040  00F3  	MOVWF __rom_get_00000_1_romAddr+D'1'
0041  306D  	MOVLW	LOW( label7 )
0042        label4
0042  07F2  	ADDWF __rom_get_00000_1_romAddr, F
0043  1803  	BTFSC STATUS,C
0044  0AF3  	INCF __rom_get_00000_1_romAddr+D'1', F
0045  0873  	MOVF __rom_get_00000_1_romAddr+D'1', W
0046  008A  	MOVWF PCLATH
0047  0872  	MOVF __rom_get_00000_1_romAddr, W
0048  0082  	MOVWF PCL
0049        label5
0049  3431  	RETLW 0x31
004A  3428  	RETLW 0x28
004B  3431  	RETLW 0x31
004C  3430  	RETLW 0x30
004D  3431  	RETLW 0x31
004E  3430  	RETLW 0x30
004F  3431  	RETLW 0x31
0050  3431  	RETLW 0x31
0051  3430  	RETLW 0x30
0052  3431  	RETLW 0x31
0053  3430  	RETLW 0x30
0054  3431  	RETLW 0x31
0055        label6
0055  3404  	RETLW 0x04
0056  3408  	RETLW 0x08
0057  3412  	RETLW 0x12
0058  3416  	RETLW 0x16
0059  3420  	RETLW 0x20
005A  3424  	RETLW 0x24
005B  3428  	RETLW 0x28
005C  3432  	RETLW 0x32
005D  3436  	RETLW 0x36
005E  3440  	RETLW 0x40
005F  3444  	RETLW 0x44
0060  3448  	RETLW 0x48
0061  3452  	RETLW 0x52
0062  3456  	RETLW 0x56
0063  3460  	RETLW 0x60
0064  3464  	RETLW 0x64
0065  3468  	RETLW 0x68
0066  3472  	RETLW 0x72
0067  3476  	RETLW 0x76
0068  3480  	RETLW 0x80
0069  3484  	RETLW 0x84
006A  3488  	RETLW 0x88
006B  3492  	RETLW 0x92
006C  3496  	RETLW 0x96
006D        label7
006D  343F  	RETLW 0x3F
006E  3406  	RETLW 0x06
006F  345B  	RETLW 0x5B
0070  344F  	RETLW 0x4F
0071  3466  	RETLW 0x66
0072  346D  	RETLW 0x6D
0073  347D  	RETLW 0x7D
0074  3407  	RETLW 0x07
0075  347F  	RETLW 0x7F
0076  346F  	RETLW 0x6F
0077        ; } __rom_get function end














03A8        __mul_16s__0000F
03A8        ; { __mul_16s_16s__16 ; function begin
03A8  01F2  	CLRF __mul_16s__0000F_1_i
03A9  01F5  	CLRF CompTempVarRet386
03AA  01F6  	CLRF CompTempVarRet386+D'1'
03AB  1283  	BCF STATUS, RP0
03AC  1303  	BCF STATUS, RP1
03AD  086E  	MOVF __mul_16s__0000F_arg_a, W
03AE  00F3  	MOVWF __mul_16s__0000F_1_t
03AF  086F  	MOVF __mul_16s__0000F_arg_a+D'1', W
03B0  00F4  	MOVWF __mul_16s__0000F_1_t+D'1'
03B1  1FF1  	BTFSS __mul_16s__0000F_arg_b+D'1',7
03B2  2BB9  	GOTO	label65
03B3  17F2  	BSF __mul_16s__0000F_1_i,7
03B4  09F0  	COMF __mul_16s__0000F_arg_b, F
03B5  09F1  	COMF __mul_16s__0000F_arg_b+D'1', F
03B6  0AF0  	INCF __mul_16s__0000F_arg_b, F
03B7  1903  	BTFSC gbl_status,2
03B8  0AF1  	INCF __mul_16s__0000F_arg_b+D'1', F
03B9        label65
03B9  1A72  	BTFSC __mul_16s__0000F_1_i,4
03BA  2BCB  	GOTO	label67
03BB  1C70  	BTFSS __mul_16s__0000F_arg_b,0
03BC  2BC3  	GOTO	label66
03BD  0873  	MOVF __mul_16s__0000F_1_t, W
03BE  07F5  	ADDWF CompTempVarRet386, F
03BF  0874  	MOVF __mul_16s__0000F_1_t+D'1', W
03C0  1803  	BTFSC gbl_status,0
03C1  0F74  	INCFSZ __mul_16s__0000F_1_t+D'1', W
03C2  07F6  	ADDWF CompTempVarRet386+D'1', F
03C3        label66
03C3  1003  	BCF gbl_status,0
03C4  0CF1  	RRF __mul_16s__0000F_arg_b+D'1', F
03C5  0CF0  	RRF __mul_16s__0000F_arg_b, F
03C6  1003  	BCF gbl_status,0
03C7  0DF3  	RLF __mul_16s__0000F_1_t, F
03C8  0DF4  	RLF __mul_16s__0000F_1_t+D'1', F
03C9  0AF2  	INCF __mul_16s__0000F_1_i, F
03CA  2BB9  	GOTO	label65
03CB        label67
03CB  1FF2  	BTFSS __mul_16s__0000F_1_i,7
03CC  0008  	RETURN
03CD  09F5  	COMF CompTempVarRet386, F
03CE  09F6  	COMF CompTempVarRet386+D'1', F
03CF  0AF5  	INCF CompTempVarRet386, F
03D0  1903  	BTFSC gbl_status,2
03D1  0AF6  	INCF CompTempVarRet386+D'1', F
03D2  0008  	RETURN
03D3        ; } __mul_16s_16s__16 function end














061A        _startup

0671  118A  	BCF PCLATH,3
0672  120A  	BCF PCLATH,4
0673  2DEB  	GOTO	main

2007  3F18  	DW 0x3F18
