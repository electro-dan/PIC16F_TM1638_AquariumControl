;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 8.01
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

#ifndef _PIC16F_TM1638_AquariumControl_H_
#define _PIC16F_TM1638_AquariumControl_H_

#define TASK_TIMER1 2
#define TASK_TIMER1_START 3
#define TASK_TIMER1_READ 4
#define oneWireBus (porta.6)
#define oneWireTris (trisa.6)
#define tm1638dio (porta.1)
#define tm1638clk (porta.0)
#define tm1638dioTris (trisa.1)
#define tm1638strobe (porta.7)

// This means timer 1 will overflow when 1 cycle completes, generating the interrupt
#define TMR1HV 0xFF
#define TMR1LV 0xFF

// i2c options
#define use_i2c_SW
// clock SCL on GP0, data SDA on GP1
#define i2c_ARGS	2, PORTA, TRISA, 3, PORTA, TRISA, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)
// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3

#define ds3231_addr 0xD0

// Time and date variables
char gBcdSeconds = 0; // 0 to 59
037E  1283  	BCF STATUS, RP0
037F  1303  	BCF STATUS, RP1
0380  01BD  	CLRF gbl_gBcdSeconds

char gBcdMinute = 0; // 0 to 59
0381  01BE  	CLRF gbl_gBcdMinute

char gBcdHour = 0; // 0 to 23 or 1 to 12. Also contains 12/24 setting at bit 6. If 12 hour, AM/PM uses bit 5
0382  01BF  	CLRF gbl_gBcdHour

char gDayOfWeek = 1; // 1 to 7
0383  3001  	MOVLW 0x01
0384  00C8  	MOVWF gbl_gDayOfWeek

char gBcdDayOfMonth = 1; // 1 to 31
0385  3001  	MOVLW 0x01
0386  00C9  	MOVWF gbl_gBcdDayOfMonth

char gBcdMonth = 1; // 1 to 12 + century at bit 7
0387  3001  	MOVLW 0x01
0388  00CA  	MOVWF gbl_gBcdMonth

char gBcdYear = 0x23; // Init to 2023
0389  3023  	MOVLW 0x23
038A  00CB  	MOVWF gbl_gBcdYear


// Hold the upper and lower bytes from the ds18b20
char cTempH = 0;
038B  01CC  	CLRF gbl_cTempH

char cTempL = 0;
038C  01CD  	CLRF gbl_cTempL

char iDecimalPosition = 2;
038D  3002  	MOVLW 0x02
038E  00CE  	MOVWF gbl_iDecimalPosition


char oneWireIsPresent = 0;
038F  01CF  	CLRF gbl_oneWireIsPresent

char oneWireResetStage = 0;
0390  01D0  	CLRF gbl_oneWireResetStage

void oneWireBusReset();
void oneWireTxByte(char data);
void oneWireTxBytes(char data, char data2);
char oneWireRxByte();

void ds3231Write(char ds3231Reg, char bWrite);
void ds3231Init();
void ds3231Start();
void ds3231Stop();
void ds3231WriteDateTime();
void ds3231ReadDateTime();


char cTask = 0; // Used for task scheduler
0391  01D1  	CLRF gbl_cTask


// Used to output the segments from numbers
char tm1638MaxDigits = 8;
0392  3008  	MOVLW 0x08
0393  00D2  	MOVWF gbl_tm1638MaxDigits

char tm1638DisplayNumtoSeg[] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f};
0394  303F  	MOVLW 0x3F
0395  00A0  	MOVWF gbl_tm1638DisplayNumtoSeg
0396  3006  	MOVLW 0x06
0397  00A1  	MOVWF gbl_tm1638DisplayNumtoSeg+D'1'
0398  305B  	MOVLW 0x5B
0399  00A2  	MOVWF gbl_tm1638DisplayNumtoSeg+D'2'
039A  304F  	MOVLW 0x4F
039B  00A3  	MOVWF gbl_tm1638DisplayNumtoSeg+D'3'
039C  3066  	MOVLW 0x66
039D  00A4  	MOVWF gbl_tm1638DisplayNumtoSeg+D'4'
039E  306D  	MOVLW 0x6D
039F  00A5  	MOVWF gbl_tm1638DisplayNumtoSeg+D'5'
03A0  307D  	MOVLW 0x7D
03A1  00A6  	MOVWF gbl_tm1638DisplayNumtoSeg+D'6'
03A2  3007  	MOVLW 0x07
03A3  00A7  	MOVWF gbl_tm1638DisplayNumtoSeg+D'7'
03A4  307F  	MOVLW 0x7F
03A5  00A8  	MOVWF gbl_tm1638DisplayNumtoSeg+D'8'
03A6  306F  	MOVLW 0x6F
03A7  00A9  	MOVWF gbl_tm1638DisplayNumtoSeg+D'9'

char tm1638Dot = 0x80;
03A8  3080  	MOVLW 0x80
03A9  00D3  	MOVWF gbl_tm1638Dot

char tm1638Brightness = 7; // 0 to 7
03AA  3007  	MOVLW 0x07
03AB  00D4  	MOVWF gbl_tm1638Brightness

// 0x40 [01000000] = indicate command to display data
char tm1638ByteSetData = 0x40;
03AC  3040  	MOVLW 0x40
03AD  00D5  	MOVWF gbl_tm1638ByteSetData

// 0x42 [01000010] = indicate command to read data
char tm1638ByteReadData = 0x42;
03AE  3042  	MOVLW 0x42
03AF  00D6  	MOVWF gbl_tm1638ByteReadData

// 0xC0 [11000000] = write out all bytes
char tm1638ByteSetAddr = 0xC0;
03B0  30C0  	MOVLW 0xC0
03B1  00D7  	MOVWF gbl_tm1638ByteSetAddr

// 0x88 [10001000] - Display ON, plus brightness
char tm1638ByteSetOn = 0x88;
03B2  3088  	MOVLW 0x88
03B3  00D8  	MOVWF gbl_tm1638ByteSetOn


// Copy of the data to write / on the display
char tm1638Data[] = {0, 0, 0, 0, 0, 0, 0, 0};
03B4  01AA  	CLRF gbl_tm1638Data
03B5  01AB  	CLRF gbl_tm1638Data+D'1'
03B6  01AC  	CLRF gbl_tm1638Data+D'2'
03B7  01AD  	CLRF gbl_tm1638Data+D'3'
03B8  01AE  	CLRF gbl_tm1638Data+D'4'
03B9  01AF  	CLRF gbl_tm1638Data+D'5'
03BA  01B0  	CLRF gbl_tm1638Data+D'6'
03BB  01B1  	CLRF gbl_tm1638Data+D'7'

// Copy of the LED status
char tm1638LEDs[] = {0, 0, 0, 0, 0, 0, 0, 0};
03BC  01B2  	CLRF gbl_tm1638LEDs
03BD  01B3  	CLRF gbl_tm1638LEDs+D'1'
03BE  01B4  	CLRF gbl_tm1638LEDs+D'2'
03BF  01B5  	CLRF gbl_tm1638LEDs+D'3'
03C0  01B6  	CLRF gbl_tm1638LEDs+D'4'
03C1  01B7  	CLRF gbl_tm1638LEDs+D'5'
03C2  01B8  	CLRF gbl_tm1638LEDs+D'6'
03C3  01B9  	CLRF gbl_tm1638LEDs+D'7'

// Copy of the keys
char tm1638Keys = 0;
03C4  01D9  	CLRF gbl_tm1638Keys


void tm1638ByteWrite(char bWrite);
void tm1638UpdateDisplay();
void tm1638ReadKeys();

void displayTemp();
void storeTempDigits4(int iValue);
void startTemp();
void readTemp();
void processKeys();

#endif

#include <system.h>
#include <i2c_driver.h>
#include "PIC16F_TM1638_AquariumControl.h"

//Target PIC16F627 configuration word
#pragma DATA _CONFIG, _PWRTE_OFF & _WDT_OFF & _INTRC_OSC_NOCLKOUT & _CP_OFF & _LVP_OFF & _BODEN_OFF & _MCLRE_OFF

//Set clock frequency
#pragma CLOCK_FREQ	4000000

/*********************************************************************************************
  oneWireBusReset()
  First part of the reset routine - drive the bus low for 500us
*********************************************************************************************/
void oneWireBusReset() {

    char isPresent;
    oneWireTris = 1; // start with high
0258  1683  	BSF STATUS, RP0
0259  1303  	BCF STATUS, RP1
025A  1705  	BSF gbl_trisa,6

    isPresent = 0;
025B  1283  	BCF STATUS, RP0
025C  01DA  	CLRF oneWireBus_00015_1_isPresent

    // Send the reset pulse - drive low for 500us
    oneWireBus = 0;      
025D  1305  	BCF gbl_porta,6

    oneWireTris = 0;
025E  1683  	BSF STATUS, RP0
025F  1305  	BCF gbl_trisa,6

    delay_10us(50);
0260  3032  	MOVLW 0x32
0261  1283  	BCF STATUS, RP0
0262  00DF  	MOVWF delay_10us_00000_arg_del
0263  201A  	CALL delay_10us_00000

    // Release line and wait 70us for PD Pulse
    oneWireTris = 1;
0264  1683  	BSF STATUS, RP0
0265  1705  	BSF gbl_trisa,6

    delay_10us(7);
0266  3007  	MOVLW 0x07
0267  1283  	BCF STATUS, RP0
0268  00DF  	MOVWF delay_10us_00000_arg_del
0269  201A  	CALL delay_10us_00000

    // Now sample, if there is a sensor on the bus, the line should be low
    if (oneWireBus) {
026A  1B05  	BTFSC gbl_porta,6

        oneWireIsPresent = 0; // no devices
026B  01CF  	CLRF gbl_oneWireIsPresent

    }
    delay_10us(50);
026C  3032  	MOVLW 0x32
026D  00DF  	MOVWF delay_10us_00000_arg_del
026E  201A  	CALL delay_10us_00000

}
026F  0008  	RETURN


/*********************************************************************************************
  oneWireTxByte(char data)
  Transmits a single byte from the bus
*********************************************************************************************/
void oneWireTxByte(char cData) {

    char cTemp = 1;
00DA  3001  	MOVLW 0x01
00DB  00DD  	MOVWF oneWireTxB_00016_1_cTemp

    // Loop through the eight bits in the byte
    for (char i = 0; i < 8; i++) {
00DC  01DE  	CLRF oneWireTxB_00016_2_i
00DD        label17
00DD  3008  	MOVLW 0x08
00DE  025E  	SUBWF oneWireTxB_00016_2_i, W
00DF  1803  	BTFSC STATUS,C
00F4  0ADE  	INCF oneWireTxB_00016_2_i, F
00F5  28DD  	GOTO	label17

        // Send the LSB first

        // Drive the line low initially for 3us
        oneWireTris = 0;
00E1  1683  	BSF STATUS, RP0
00E2  1305  	BCF gbl_trisa,6

        oneWireBus = 0;
00E3  1283  	BCF STATUS, RP0
00E4  1305  	BCF gbl_porta,6


        // Delay not needed for 4MHz PIC
        //delay_us(3); // Delay 3us
        
        if (cData & cTemp) {
00E5  085D  	MOVF oneWireTxB_00016_1_cTemp, W
00E6  055C  	ANDWF oneWireTxB_00016_arg_cData, W
00E7  1903  	BTFSC STATUS,Z
00E8  28EB  	GOTO	label18

            oneWireTris = 1; // Release the bus
00E9  1683  	BSF STATUS, RP0
00EA  1705  	BSF gbl_trisa,6

        }
        
        delay_10us(5); // Delay 60us - 50us works fine with code delays
00EB  3005  	MOVLW 0x05
00EC  1283  	BCF STATUS, RP0
00ED  00DF  	MOVWF delay_10us_00000_arg_del
00EE  201A  	CALL delay_10us_00000

        oneWireTris = 1; // Release the bus
00EF  1683  	BSF STATUS, RP0
00F0  1705  	BSF gbl_trisa,6

        
        // move the test bit
        cTemp <<= 1;
00F1  1003  	BCF STATUS,C
00F2  1283  	BCF STATUS, RP0
00F3  0DDD  	RLF oneWireTxB_00016_1_cTemp, F

    }
}
00E0  0008  	RETURN


/*********************************************************************************************
  oneWireTxBytes(char data, char data2)
  Transmits a 2 bytes from the bus
*********************************************************************************************/
void oneWireTxBytes(char cData, char cData2) {

    // Reset first - done in main
    //oneWireBusReset();
    // Send first byte
    oneWireTxByte(cData);
0115  085A  	MOVF oneWireTxB_00017_arg_cData, W
0116  00DC  	MOVWF oneWireTxB_00016_arg_cData
0117  20DA  	CALL oneWireTxB_00016

    // Send second byte
    oneWireTxByte(cData2);
0118  085B  	MOVF oneWireTxB_00017_arg_cData2, W
0119  00DC  	MOVWF oneWireTxB_00016_arg_cData
011A  20DA  	CALL oneWireTxB_00016

}
011B  0008  	RETURN


/*********************************************************************************************
  oneWireRxByte()
  Receives a single byte from the bus
*********************************************************************************************/
char oneWireRxByte() {

    char cDataIn = 0;
011C  1283  	BCF STATUS, RP0
011D  1303  	BCF STATUS, RP1
011E  01DA  	CLRF oneWireRxB_00018_1_cDataIn

    // Loop through the eight bits in the byte
    for(char i = 0; i < 8; i++) {
011F  01DB  	CLRF oneWireRxB_00018_2_i
0120        label20
0120  3008  	MOVLW 0x08
0121  025B  	SUBWF oneWireRxB_00018_2_i, W
0122  1803  	BTFSC STATUS,C
0123  2937  	GOTO	label21
0135  0ADB  	INCF oneWireRxB_00018_2_i, F
0136  2920  	GOTO	label20
0137        label21

        // Bring bus low for 15us
        oneWireTris = 0;
0124  1683  	BSF STATUS, RP0
0125  1305  	BCF gbl_trisa,6

        oneWireBus = 0;
0126  1283  	BCF STATUS, RP0
0127  1305  	BCF gbl_porta,6


        // Delay not needed for 4MHz PIC
        //delay_us(15); // Delay 15us

        // Release bus for 6us, this is enough time for the slave to respond
        oneWireTris = 1;
0128  1683  	BSF STATUS, RP0
0129  1705  	BSF gbl_trisa,6

        delay_us(6); // Delay 6us
012A  3006  	MOVLW 0x06
012B  1283  	BCF STATUS, RP0
012C  00DF  	MOVWF delay_us_00000_arg_del
012D  2010  	CALL delay_us_00000

        
        // Shift data already received left
        cDataIn >>= 1;
012E  1003  	BCF STATUS,C
012F  0CDA  	RRF oneWireRxB_00018_1_cDataIn, F

        // Check the value of the onewire bus - set the MSB of cDataIn if so
        if (oneWireBus)
0130  1B05  	BTFSC gbl_porta,6

            cDataIn.7 = 1;
0131  17DA  	BSF oneWireRxB_00018_1_cDataIn,7


        // To finish time slot
        delay_10us(6); // 60us
0132  3006  	MOVLW 0x06
0133  00DF  	MOVWF delay_10us_00000_arg_del
0134  201A  	CALL delay_10us_00000

    } 
    
    return cDataIn;
0137  085A  	MOVF oneWireRxB_00018_1_cDataIn, W
0138  00DB  	MOVWF CompTempVarRet548

}
0139  0008  	RETURN


/*********************************************************************************************
 ds3231Write(char ds3231Reg, char bWrite)
 Write one byte
*********************************************************************************************/
void ds3231Write(char ds3231Reg, char bWrite) {

	i2c_start();
00F6  20A5  	CALL i2c_START_00000

	i2c_write(ds3231_addr); // address + write
00F7  30D0  	MOVLW 0xD0
00F8  00DC  	MOVWF i2c_WRITE_00000_arg_i2c_data
00F9  2024  	CALL i2c_WRITE_00000

	i2c_write(ds3231Reg); // start at address
00FA  085A  	MOVF ds3231Writ_00019_arg_ds3231Reg, W
00FB  00DC  	MOVWF i2c_WRITE_00000_arg_i2c_data
00FC  2024  	CALL i2c_WRITE_00000

	i2c_write(bWrite); // start at address
00FD  085B  	MOVF ds3231Writ_00019_arg_bWrite, W
00FE  00DC  	MOVWF i2c_WRITE_00000_arg_i2c_data
00FF  2024  	CALL i2c_WRITE_00000

	i2c_stop();
0100  2075  	CALL i2c_STOP_00000

}
0101  0008  	RETURN


/*********************************************************************************************
 ds3231Init()
 Initialise the DS3231
*********************************************************************************************/
void ds3231Init() {

	/* control register 0Eh
    bit7 EOSC   Enable Oscillator (1 if oscillator must be stopped when on battery)
    bit6 BBSQW  Battery Backed Square Wave
    bit5 CONV   Convert temperature (1 forces a conversion NOW)
    bit4 RS2    Rate select - frequency of square wave output
    bit3 RS1    Rate select
    bit2 INTCN  Interrupt control (1 for use of the alarms and to disable square wave)
    bit1 A2IE   Alarm2 interrupt enable (1 to enable)
    bit0 A1IE   Alarm1 interrupt enable (1 to enable)
    */
	ds3231Write(0x0E, 0x80);
01BD  300E  	MOVLW 0x0E
01BE  1283  	BCF STATUS, RP0
01BF  1303  	BCF STATUS, RP1
01C0  00DA  	MOVWF ds3231Writ_00019_arg_ds3231Reg
01C1  3080  	MOVLW 0x80
01C2  00DB  	MOVWF ds3231Writ_00019_arg_bWrite
01C3  20F6  	CALL ds3231Writ_00019

	/* Status Register 0Fh
    bit7 OSF     Oscillator Stop Flag
    bit3 EN32kHz Enable 32kHz Output
    bit2 BSY     Busy
    bit1 A2F     Alarm 2 Flag
    bit0 A1F     Alarm 1 Flag
    */
	ds3231Write(0x0F, 0x80);
01C4  300F  	MOVLW 0x0F
01C5  00DA  	MOVWF ds3231Writ_00019_arg_ds3231Reg
01C6  3080  	MOVLW 0x80
01C7  00DB  	MOVWF ds3231Writ_00019_arg_bWrite
01C8  20F6  	CALL ds3231Writ_00019

}
01C9  0008  	RETURN


/*********************************************************************************************
 ds3231Start()
 Start the DS3231
*********************************************************************************************/
void ds3231Start() {
	ds3231Write(0x0F, 0x00);
}

/*********************************************************************************************
 ds3231Stop()
 Stop the DS3231
*********************************************************************************************/
void ds3231Stop() {
	ds3231Write(0x0F, 0x80);
}

/*********************************************************************************************
 ds3231WriteDateTime()
 Write the date to the DS3231
*********************************************************************************************/
void ds3231WriteDateTime() {

	i2c_start();
01A1  20A5  	CALL i2c_START_00000

	i2c_write(ds3231_addr); // address + write
01A2  30D0  	MOVLW 0xD0
01A3  00DC  	MOVWF i2c_WRITE_00000_arg_i2c_data
01A4  2024  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
01A5  01DC  	CLRF i2c_WRITE_00000_arg_i2c_data
01A6  2024  	CALL i2c_WRITE_00000

	i2c_write(0); // seconds
01A7  01DC  	CLRF i2c_WRITE_00000_arg_i2c_data
01A8  2024  	CALL i2c_WRITE_00000

	i2c_write(gBcdMinute); // minutes
01A9  083E  	MOVF gbl_gBcdMinute, W
01AA  00DC  	MOVWF i2c_WRITE_00000_arg_i2c_data
01AB  2024  	CALL i2c_WRITE_00000

	i2c_write(gBcdHour); // hours
01AC  083F  	MOVF gbl_gBcdHour, W
01AD  00DC  	MOVWF i2c_WRITE_00000_arg_i2c_data
01AE  2024  	CALL i2c_WRITE_00000

	i2c_write(gDayOfWeek); // day of week
01AF  0848  	MOVF gbl_gDayOfWeek, W
01B0  00DC  	MOVWF i2c_WRITE_00000_arg_i2c_data
01B1  2024  	CALL i2c_WRITE_00000

	i2c_write(gBcdDayOfMonth); // day of month
01B2  0849  	MOVF gbl_gBcdDayOfMonth, W
01B3  00DC  	MOVWF i2c_WRITE_00000_arg_i2c_data
01B4  2024  	CALL i2c_WRITE_00000

	i2c_write(gBcdMonth); // month + century
01B5  084A  	MOVF gbl_gBcdMonth, W
01B6  00DC  	MOVWF i2c_WRITE_00000_arg_i2c_data
01B7  2024  	CALL i2c_WRITE_00000

	i2c_write(gBcdYear); // year
01B8  084B  	MOVF gbl_gBcdYear, W
01B9  00DC  	MOVWF i2c_WRITE_00000_arg_i2c_data
01BA  2024  	CALL i2c_WRITE_00000

	i2c_stop();
01BB  2075  	CALL i2c_STOP_00000

}
01BC  0008  	RETURN


/*********************************************************************************************
 ds3231ReadDateTime()
 Write the date to the DS3231
*********************************************************************************************/
void ds3231ReadDateTime() {

	i2c_start();
0292  20A5  	CALL i2c_START_00000

	i2c_write(ds3231_addr); // address + read
0293  30D0  	MOVLW 0xD0
0294  00DC  	MOVWF i2c_WRITE_00000_arg_i2c_data
0295  2024  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
0296  01DC  	CLRF i2c_WRITE_00000_arg_i2c_data
0297  2024  	CALL i2c_WRITE_00000

	i2c_stop();
0298  2075  	CALL i2c_STOP_00000

	
	i2c_start();
0299  20A5  	CALL i2c_START_00000

	i2c_write(ds3231_addr + 1); // address + read
029A  30D1  	MOVLW 0xD1
029B  00DC  	MOVWF i2c_WRITE_00000_arg_i2c_data
029C  2024  	CALL i2c_WRITE_00000

	gBcdSeconds = i2c_read(0); // ack
029D  01DA  	CLRF i2c_READ_00000_arg_ack_status
029E  213A  	CALL i2c_READ_00000
029F  085D  	MOVF CompTempVarRet550, W
02A0  00BD  	MOVWF gbl_gBcdSeconds

	gBcdMinute = i2c_read(0); // ack
02A1  01DA  	CLRF i2c_READ_00000_arg_ack_status
02A2  213A  	CALL i2c_READ_00000
02A3  085D  	MOVF CompTempVarRet550, W
02A4  00BE  	MOVWF gbl_gBcdMinute

	gBcdHour = i2c_read(0); // ack
02A5  01DA  	CLRF i2c_READ_00000_arg_ack_status
02A6  213A  	CALL i2c_READ_00000
02A7  085D  	MOVF CompTempVarRet550, W
02A8  00BF  	MOVWF gbl_gBcdHour

	gDayOfWeek = i2c_read(0); // ack
02A9  01DA  	CLRF i2c_READ_00000_arg_ack_status
02AA  213A  	CALL i2c_READ_00000
02AB  085D  	MOVF CompTempVarRet550, W
02AC  00C8  	MOVWF gbl_gDayOfWeek

	gBcdDayOfMonth = i2c_read(0); // ack
02AD  01DA  	CLRF i2c_READ_00000_arg_ack_status
02AE  213A  	CALL i2c_READ_00000
02AF  085D  	MOVF CompTempVarRet550, W
02B0  00C9  	MOVWF gbl_gBcdDayOfMonth

	gBcdMonth = i2c_read(0); // ack
02B1  01DA  	CLRF i2c_READ_00000_arg_ack_status
02B2  213A  	CALL i2c_READ_00000
02B3  085D  	MOVF CompTempVarRet550, W
02B4  00CA  	MOVWF gbl_gBcdMonth

	gBcdYear = i2c_read(1); // nack
02B5  3001  	MOVLW 0x01
02B6  00DA  	MOVWF i2c_READ_00000_arg_ack_status
02B7  213A  	CALL i2c_READ_00000
02B8  085D  	MOVF CompTempVarRet550, W
02B9  00CB  	MOVWF gbl_gBcdYear

	i2c_stop();
02BA  2075  	CALL i2c_STOP_00000

}
02BB  0008  	RETURN


/*********************************************************************************************
 tm1638ByteWrite(char bWrite)
 Write one byte
*********************************************************************************************/
void tm1638ByteWrite(char bWrite) {

    for (char i = 0; i < 8; i++) {
0102  01DD  	CLRF tm1638Byte_0001D_2_i
0103        label19
0103  3008  	MOVLW 0x08
0104  025D  	SUBWF tm1638Byte_0001D_2_i, W
0105  1803  	BTFSC STATUS,C
0113  0ADD  	INCF tm1638Byte_0001D_2_i, F
0114  2903  	GOTO	label19

        tm1638dio = (bWrite & 0x01);
0107  3001  	MOVLW 0x01
0108  055C  	ANDWF tm1638Byte_0001D_arg_bWrite, W
0109  00DE  	MOVWF CompTempVar551
010A  185E  	BTFSC CompTempVar551,0
010B  1485  	BSF gbl_porta,1
010C  1C5E  	BTFSS CompTempVar551,0
010D  1085  	BCF gbl_porta,1

        tm1638clk = 0;
010E  1005  	BCF gbl_porta,0

        bWrite = (bWrite >> 1);
010F  08DC  	MOVF tm1638Byte_0001D_arg_bWrite, F
0110  1003  	BCF STATUS,C
0111  0CDC  	RRF tm1638Byte_0001D_arg_bWrite, F

        tm1638clk = 1;
0112  1405  	BSF gbl_porta,0

    }
}
0106  0008  	RETURN


/*********************************************************************************************
 tm1638UpdateDisplay()
 Publish the tm1638Data and tm1638LEDs arrays to the display
*********************************************************************************************/
void tm1638UpdateDisplay() {

    // Write 0x40 [01000000] to indicate command to display data - [Write data to display register]
    tm1638strobe = 0;
01F3  1283  	BCF STATUS, RP0
01F4  1303  	BCF STATUS, RP1
01F5  1385  	BCF gbl_porta,7

    tm1638ByteWrite(tm1638ByteSetData);
01F6  0855  	MOVF gbl_tm1638ByteSetData, W
01F7  00DC  	MOVWF tm1638Byte_0001D_arg_bWrite
01F8  2102  	CALL tm1638Byte_0001D

    tm1638strobe = 1;
01F9  1785  	BSF gbl_porta,7

    
    tm1638strobe = 0;
01FA  1385  	BCF gbl_porta,7

    // Specify the display address 0xC0 [11000000] then write out all 8 bytes
    tm1638ByteWrite(tm1638ByteSetAddr);
01FB  0857  	MOVF gbl_tm1638ByteSetAddr, W
01FC  00DC  	MOVWF tm1638Byte_0001D_arg_bWrite
01FD  2102  	CALL tm1638Byte_0001D

    for (char i = 0; i < tm1638MaxDigits; i++) {
01FE  01DA  	CLRF tm1638Upda_0001E_2_i
01FF        label34
01FF  0852  	MOVF gbl_tm1638MaxDigits, W
0200  025A  	SUBWF tm1638Upda_0001E_2_i, W
0201  1803  	BTFSC STATUS,C
0202  2A15  	GOTO	label35
0213  0ADA  	INCF tm1638Upda_0001E_2_i, F
0214  29FF  	GOTO	label34
0215        label35

        tm1638ByteWrite(tm1638Data[i]);
0203  1383  	BCF	STATUS,IRP
0204  302A  	MOVLW LOW(gbl_tm1638Data+D'0')
0205  0084  	MOVWF FSR
0206  085A  	MOVF tm1638Upda_0001E_2_i, W
0207  0784  	ADDWF FSR, F
0208  0800  	MOVF INDF, W
0209  00DC  	MOVWF tm1638Byte_0001D_arg_bWrite
020A  2102  	CALL tm1638Byte_0001D

        tm1638ByteWrite(tm1638LEDs[i]);
020B  1383  	BCF	STATUS,IRP
020C  3032  	MOVLW LOW(gbl_tm1638LEDs+D'0')
020D  0084  	MOVWF FSR
020E  085A  	MOVF tm1638Upda_0001E_2_i, W
020F  0784  	ADDWF FSR, F
0210  0800  	MOVF INDF, W
0211  00DC  	MOVWF tm1638Byte_0001D_arg_bWrite
0212  2102  	CALL tm1638Byte_0001D

    }
    tm1638strobe = 1;
0215  1785  	BSF gbl_porta,7

}
0216  0008  	RETURN


/*********************************************************************************************
 tm1638ReadKeys()
 Reads the keys status into tm1638Keys
*********************************************************************************************/
void tm1638ReadKeys() {

    // Write 0x42 [01000010] to indicate command to read data
    tm1638strobe = 0;
0217  1283  	BCF STATUS, RP0
0218  1303  	BCF STATUS, RP1
0219  1385  	BCF gbl_porta,7

    tm1638ByteWrite(tm1638ByteReadData);
021A  0856  	MOVF gbl_tm1638ByteReadData, W
021B  00DC  	MOVWF tm1638Byte_0001D_arg_bWrite
021C  2102  	CALL tm1638Byte_0001D

    
    tm1638dioTris = 1; // Set data pin to input
021D  1683  	BSF STATUS, RP0
021E  1485  	BSF gbl_trisa,1

    char tm1638KeysTemp = 32;
021F  3020  	MOVLW 0x20
0220  1283  	BCF STATUS, RP0
0221  00DA  	MOVWF tm1638Read_0001F_1_tm1638K_00020

    // Read 4 bytes
    for (char i = 0; i < 32; i++) {
0222  01DB  	CLRF tm1638Read_0001F_2_i
0223        label36
0223  3020  	MOVLW 0x20
0224  025B  	SUBWF tm1638Read_0001F_2_i, W
0225  1803  	BTFSC STATUS,C
0226  2A34  	GOTO	label38
0232  0ADB  	INCF tm1638Read_0001F_2_i, F
0233  2A23  	GOTO	label36
0234        label38

        tm1638KeysTemp--;
0227  03DA  	DECF tm1638Read_0001F_1_tm1638K_00020, F

        tm1638clk = 0;
0228  1005  	BCF gbl_porta,0

        delay_us(1);
0229  3001  	MOVLW 0x01
022A  00DF  	MOVWF delay_us_00000_arg_del
022B  2010  	CALL delay_us_00000

        if(tm1638dio)
022C  1C85  	BTFSS gbl_porta,1
022D  2A31  	GOTO	label37
0231        label37

            tm1638KeysTemp = (tm1638KeysTemp << 1);
022E  08DA  	MOVF tm1638Read_0001F_1_tm1638K_00020, F
022F  1003  	BCF STATUS,C
0230  0DDA  	RLF tm1638Read_0001F_1_tm1638K_00020, F

        tm1638clk = 1;
0231  1405  	BSF gbl_porta,0

    }
    tm1638dioTris = 0; // Set data pin to output
0234  1683  	BSF STATUS, RP0
0235  1085  	BCF gbl_trisa,1

    tm1638strobe = 1;
0236  1283  	BCF STATUS, RP0
0237  1785  	BSF gbl_porta,7


    tm1638Keys = tm1638KeysTemp;
0238  085A  	MOVF tm1638Read_0001F_1_tm1638K_00020, W
0239  00D9  	MOVWF gbl_tm1638Keys

}
023A  0008  	RETURN


/*********************************************************************************************
  Function called once only to initialise variables and
  setup the PIC registers
*********************************************************************************************/
void initialise() {

    pcon.OSCF = 1; // 4MHz internal osc
0270  1683  	BSF STATUS, RP0
0271  1303  	BCF STATUS, RP1
0272  158E  	BSF gbl_pcon,3


    // Configure port A
    /*
    RA7     OUT TM1638 STB
    RA6     IN/OUT DS18B20
    RA5     
    RA4     ICSP VPP
    RA3     IN/OUT DS3231M I2C SDA
    RA2     IN/OUT DS3231M I2C CLK
    RA1     IN/OUT TM1638 DIO
    RA0     OUT TM1638 CLK
    */
    trisa = 0x0C;
0273  300C  	MOVLW 0x0C
0274  0085  	MOVWF gbl_trisa

    porta = 0x00; // 
0275  1283  	BCF STATUS, RP0
0276  0185  	CLRF gbl_porta

    
    // Configure port B
    /*      
    RB7     ICSP PGD
    RB6     ICSP PGC
    RB5     OUT WHITE LIGHT PWM
    RB4     OUT BLUE LIGHT PWM
    RB3     OUT FANS
    RB2     OUT HEATER
    RB1     
    RB0     IN INT DS3231M
    */
    trisb = 0x00; // all outputs
0277  1683  	BSF STATUS, RP0
0278  0186  	CLRF gbl_trisb

    portb = 0x00; // all off by default
0279  1283  	BCF STATUS, RP0
027A  0186  	CLRF gbl_portb


    option_reg = 0;
027B  1683  	BSF STATUS, RP0
027C  0181  	CLRF gbl_option_reg

    option_reg.NOT_RBPU = 1; // disable port b pull ups
027D  1781  	BSF gbl_option_reg,7


    // ADC setup
    cmcon = 7; // disable all comparators so port a is usable as digital io
027E  3007  	MOVLW 0x07
027F  1283  	BCF STATUS, RP0
0280  009F  	MOVWF gbl_cmcon



    // Setup timer 0, used for PWM
    // https://labprojectsbd.com/2021/03/31/pwm-pulse-generation-using-pic12f675-micro-controller/
    // Timer calculator: http://eng-serve.com/pic/pic_timer.html
    // Timer0 Registers Prescaler= 16 - TMR0 Preset = 0 - Freq = 244.14 Hz - Period = 0.004096 seconds
    //option_reg.T0CS = 0; // bit 5  TMR0 Clock Source Select bit...0 = Internal Clock (CLKO) 1 = Transition on T0CKI pin
    //option_reg.T0SE = 0; // bit 4 TMR0 Source Edge Select bit 0 = low/high 1 = high/low
    //option_reg.PSA = 0; // bit 3  Prescaler Assignment bit...0 = Prescaler is assigned to the Timer0
    //option_reg.PS2 = 0; // bits 2-0  PS2:PS0: Prescaler Rate Select bits
    /*option_reg.PS1 = 1;
    option_reg.PS0 = 1;
    tmr0 = 0; // preset for timer register
    intcon.T0IF = 0; // Clear timer 1 interrupt flag bit
    intcon.T0IE = 1; // Timer 1 interrupt enabled*/

    // Setup timer 1, used to periodically ask for a temperature reading, and receive it after sending - 262ms
    // Timer calculator: http://eng-serve.com/pic/pic_timer.html
    // Timer 1 setup - interrupt every 262ms seconds 4MHz
    t1con = 0;
0281  0190  	CLRF gbl_t1con

    t1con.T1CKPS1 = 1;   // bits 5-4  Prescaler Rate Select bits
0282  1690  	BSF gbl_t1con,5

    //t1con.T1CKPS0 = 0;   // bit 4
    //t1con.T1OSCEN = 0;   // bit 3 Timer1 Oscillator Enable Control bit 1 = off - this should be cleared so we can use RB7 and RB6 as outputs
    t1con.NOT_T1SYNC = 1;    // bit 2 Timer1 External Clock Input Synchronization Control bit...1 = Do not synchronize external clock input
0283  1510  	BSF gbl_t1con,2

    //t1con.TMR1CS = 0;    // bit 1 Timer1 Clock Source Select bit...0 = Internal clock (FOSC/4)
    t1con.TMR1ON = 1;    // bit 0 enables timer
0284  1410  	BSF gbl_t1con,0

    pie1.TMR1IE = 1; // Timer 1 interrupt enable
0285  1683  	BSF STATUS, RP0
0286  140C  	BSF gbl_pie1,0

    pir1.TMR1IF = 0; // Clear timer 1 interrupt flag bit
0287  1283  	BCF STATUS, RP0
0288  100C  	BCF gbl_pir1,0

    
    // No task at initialisation
    cTask = 0;
0289  01D1  	CLRF gbl_cTask

    
    // Enable interrupts
    intcon.GIE = 1;
028A  178B  	BSF gbl_intcon,7

    intcon.PEIE = 1;
028B  170B  	BSF gbl_intcon,6


	i2c_init(1); 
028C  3001  	MOVLW 0x01
028D  00DA  	MOVWF i2c_INIT_00000_arg_i2c_divisor
028E  218E  	CALL i2c_INIT_00000

	ds3231WriteDateTime();
028F  21A1  	CALL ds3231Writ_0001B

	ds3231Init();
0290  21BD  	CALL ds3231Init_00000


}
0291  0008  	RETURN



/*********************************************************************************************
  interrupt()
  Interrupt handler
*********************************************************************************************/
void interrupt() {

    // Handle timer1 interrupt - delay counter from DS3231
    if (pir1.TMR1IF && pie1.TMR1IE) {
03C8  1283  	BCF STATUS, RP0
03C9  1303  	BCF STATUS, RP1
03CA  1C0C  	BTFSS gbl_pir1,0
03CB  2BD5  	GOTO	label56
03CC  1683  	BSF STATUS, RP0
03CD  1C0C  	BTFSS gbl_pie1,0
03CE  2BD5  	GOTO	label56
03D5        label56

        tmr1h = TMR1HV;      // preset for timer1 MSB register
03CF  30FF  	MOVLW 0xFF
03D0  1283  	BCF STATUS, RP0
03D1  008F  	MOVWF gbl_tmr1h

        tmr1l = TMR1LV;      // preset for timer1 LSB register
03D2  008E  	MOVWF gbl_tmr1l


        pir1.TMR1IF = 0;     // Clear interrupt flag
03D3  100C  	BCF gbl_pir1,0

        cTask.TASK_TIMER1 = 1;
03D4  1551  	BSF gbl_cTask,2

    }
}
03D5  1283  	BCF STATUS, RP0
03D6  0E3C  	SWAPF Int1BContext+D'2', W
03D7  0084  	MOVWF FSR
03D8  0E3B  	SWAPF Int1BContext+D'1', W
03D9  008A  	MOVWF PCLATH
03DA  0E3A  	SWAPF Int1BContext, W
03DB  0083  	MOVWF STATUS
03DC  0EFF  	SWAPF Int1Context, F
03DD  0E7F  	SWAPF Int1Context, W
03DE  0009  	RETFIE


/*********************************************************************************************
  displayTemp()
  Used to split the 16 bit integer returned from the ds18b20 into parts for display
  cTempH - upper 8 bits
  cTempL - lower 8 bits
*********************************************************************************************/
void convertTemp() {

    // convert both bytes to a 16bit int - e.g. 0000 0001 0100 0110 (1 and 70, gives 326)
    
    signed int iTemp = (cTempH << 8) | cTempL;
02BC  1283  	BCF STATUS, RP0
02BD  1303  	BCF STATUS, RP1
02BE  01DA  	CLRF convertTem_00022_1_iTemp
02BF  084C  	MOVF gbl_cTempH, W
02C0  00DB  	MOVWF convertTem_00022_1_iTemp+D'1'
02C1  084D  	MOVF gbl_cTempL, W
02C2  04DA  	IORWF convertTem_00022_1_iTemp, F

    
    // Celcius
    char isMinus = (iTemp < 0);
02C3  01DC  	CLRF convertTem_00022_1_isMinus
02C4  1BDB  	BTFSC convertTem_00022_1_iTemp+D'1',7
02C5  0ADC  	INCF convertTem_00022_1_isMinus, F

    if (isMinus) {
02C6  08DC  	MOVF convertTem_00022_1_isMinus, F
02C7  1903  	BTFSC STATUS,Z
02C8  2ACE  	GOTO	label39

        iTemp = ~iTemp + 1;
02C9  09DA  	COMF convertTem_00022_1_iTemp, F
02CA  09DB  	COMF convertTem_00022_1_iTemp+D'1', F
02CB  0ADA  	INCF convertTem_00022_1_iTemp, F
02CC  1903  	BTFSC STATUS,Z
02CD  0ADB  	INCF convertTem_00022_1_iTemp+D'1', F
02CE        label39

    }
    // this gets celcius * 100 - https://www.phanderson.com/PIC/PICC/sourceboost/ds18b20_1.html
    int iValue = (6 * iTemp) + (iTemp / 4);
02CE  3006  	MOVLW 0x06
02CF  00E5  	MOVWF __mul_16s__0000F_arg_a
02D0  01E6  	CLRF __mul_16s__0000F_arg_a+D'1'
02D1  085A  	MOVF convertTem_00022_1_iTemp, W
02D2  00E7  	MOVWF __mul_16s__0000F_arg_b
02D3  085B  	MOVF convertTem_00022_1_iTemp+D'1', W
02D4  00E8  	MOVWF __mul_16s__0000F_arg_b+D'1'
02D5  21CA  	CALL __mul_16s__0000F
02D6  086C  	MOVF CompTempVarRet386, W
02D7  00DD  	MOVWF convertTem_00022_1_iValue
02D8  086D  	MOVF CompTempVarRet386+D'1', W
02D9  00E0  	MOVWF CompTempVar568
02DA  085A  	MOVF convertTem_00022_1_iTemp, W
02DB  00DF  	MOVWF CompTempVar565
02DC  085B  	MOVF convertTem_00022_1_iTemp+D'1', W
02DD  00DE  	MOVWF convertTem_00022_1_iValue+D'1'
02DE  0D5B  	RLF convertTem_00022_1_iTemp+D'1', W
02DF  0CDE  	RRF convertTem_00022_1_iValue+D'1', F
02E0  0CDF  	RRF CompTempVar565, F
02E1  0D5B  	RLF convertTem_00022_1_iTemp+D'1', W
02E2  0CDE  	RRF convertTem_00022_1_iValue+D'1', F
02E3  0CDF  	RRF CompTempVar565, F
02E4  085F  	MOVF CompTempVar565, W
02E5  07DD  	ADDWF convertTem_00022_1_iValue, F
02E6  0860  	MOVF CompTempVar568, W
02E7  1803  	BTFSC STATUS,C
02E8  0ADE  	INCF convertTem_00022_1_iValue+D'1', F
02E9  07DE  	ADDWF convertTem_00022_1_iValue+D'1', F


    // Split the temperature reading into digits
    
    // simple way, but more program memory needed for PIC12 or PIC16 (more than 100 words more)
    //char cDig3 = iValue / 1000;
    //char cDig2 = (iValue / 100) % 10;
    //char cDig1 = (iValue / 10) % 10;
    //char cDig0 = iValue % 10;
    
    // less program memory needed - may be slower executing
    // https://electronics.stackexchange.com/questions/158563/how-to-split-a-floating-point-number-into-individual-digits
    char cDig3 = 0;
02EA  01E1  	CLRF convertTem_00022_1_cDig3

    char cDig2 = 0;
02EB  01E2  	CLRF convertTem_00022_1_cDig2

    char cDig1 = 0;
02EC  01E3  	CLRF convertTem_00022_1_cDig1

    char cDig0 = 0;
02ED  01E4  	CLRF convertTem_00022_1_cDig0

    
    // incrementing variables for each digit

    // determine to thousands digit
    while (iValue >= 1000) {
02EE        label40
02EE  3003  	MOVLW 0x03
02EF  025E  	SUBWF convertTem_00022_1_iValue+D'1', W
02F0  1D03  	BTFSS STATUS,Z
02F1  2AF4  	GOTO	label41
02F2  30E8  	MOVLW 0xE8
02F3  025D  	SUBWF convertTem_00022_1_iValue, W
02F4        label41
02F4  1C03  	BTFSS STATUS,C
02F5  2B00  	GOTO	label42
02F6  1BDE  	BTFSC convertTem_00022_1_iValue+D'1',7
02F7  2B00  	GOTO	label42
02FF  2AEE  	GOTO	label40
0300        label42

        iValue = iValue - 1000;
02F8  30E8  	MOVLW 0xE8
02F9  02DD  	SUBWF convertTem_00022_1_iValue, F
02FA  3003  	MOVLW 0x03
02FB  1C03  	BTFSS STATUS,C
02FC  3004  	MOVLW 0x04
02FD  02DE  	SUBWF convertTem_00022_1_iValue+D'1', F

        // each time we take off 1000, the digit is incremented
        cDig3++;
02FE  0AE1  	INCF convertTem_00022_1_cDig3, F

    }

    // determine to hundreds digit
    while (iValue >= 100) {
0300  085E  	MOVF convertTem_00022_1_iValue+D'1', W
0301  3A80  	XORLW 0x80
0302  00E5  	MOVWF CompTempVar577
0303  3080  	MOVLW 0x80
0304  0265  	SUBWF CompTempVar577, W
0305  1D03  	BTFSS STATUS,Z
0306  2B09  	GOTO	label43
0307  3064  	MOVLW 0x64
0308  025D  	SUBWF convertTem_00022_1_iValue, W
0309        label43
0309  1C03  	BTFSS STATUS,C
030A  2B12  	GOTO	label44
0311  2B00  	GOTO	label42
0312        label44

        iValue = iValue - 100;
030B  3064  	MOVLW 0x64
030C  02DD  	SUBWF convertTem_00022_1_iValue, F
030D  08DE  	MOVF convertTem_00022_1_iValue+D'1', F
030E  1C03  	BTFSS STATUS,C
030F  03DE  	DECF convertTem_00022_1_iValue+D'1', F

        // each time we take off 100, the digit is incremented
        cDig2++;
0310  0AE2  	INCF convertTem_00022_1_cDig2, F

    }

    // determine to tens digit
    while (iValue >= 10) {
0312  085E  	MOVF convertTem_00022_1_iValue+D'1', W
0313  3A80  	XORLW 0x80
0314  00E5  	MOVWF CompTempVar580
0315  3080  	MOVLW 0x80
0316  0265  	SUBWF CompTempVar580, W
0317  1D03  	BTFSS STATUS,Z
0318  2B1B  	GOTO	label45
0319  300A  	MOVLW 0x0A
031A  025D  	SUBWF convertTem_00022_1_iValue, W
031B        label45
031B  1C03  	BTFSS STATUS,C
031C  2B24  	GOTO	label46
0323  2B12  	GOTO	label44
0324        label46

        iValue = iValue - 10;
031D  300A  	MOVLW 0x0A
031E  02DD  	SUBWF convertTem_00022_1_iValue, F
031F  08DE  	MOVF convertTem_00022_1_iValue+D'1', F
0320  1C03  	BTFSS STATUS,C
0321  03DE  	DECF convertTem_00022_1_iValue+D'1', F

        // each time we take off 10, the left most digit is incremented
        cDig1++;
0322  0AE3  	INCF convertTem_00022_1_cDig1, F

    }

    // the last digit is what's left on iValue
    cDig0 = iValue;
0324  085D  	MOVF convertTem_00022_1_iValue, W
0325  00E4  	MOVWF convertTem_00022_1_cDig0


    // translate the numbers to digit values
    tm1638Data[0] = tm1638DisplayNumtoSeg[cDig3];
0326  1383  	BCF	STATUS,IRP
0327  3020  	MOVLW LOW(gbl_tm1638DisplayNumtoSeg+D'0')
0328  0084  	MOVWF FSR
0329  0861  	MOVF convertTem_00022_1_cDig3, W
032A  0784  	ADDWF FSR, F
032B  0800  	MOVF INDF, W
032C  00AA  	MOVWF gbl_tm1638Data

    tm1638Data[1] = tm1638DisplayNumtoSeg[cDig2] + tm1638Dot;
032D  3020  	MOVLW LOW(gbl_tm1638DisplayNumtoSeg+D'0')
032E  0084  	MOVWF FSR
032F  0862  	MOVF convertTem_00022_1_cDig2, W
0330  0784  	ADDWF FSR, F
0331  0853  	MOVF gbl_tm1638Dot, W
0332  0700  	ADDWF INDF, W
0333  00AB  	MOVWF gbl_tm1638Data+D'1'

    tm1638Data[2] = tm1638DisplayNumtoSeg[cDig1];
0334  3020  	MOVLW LOW(gbl_tm1638DisplayNumtoSeg+D'0')
0335  0084  	MOVWF FSR
0336  0863  	MOVF convertTem_00022_1_cDig1, W
0337  0784  	ADDWF FSR, F
0338  0800  	MOVF INDF, W
0339  00AC  	MOVWF gbl_tm1638Data+D'2'

    tm1638Data[3] = tm1638DisplayNumtoSeg[cDig0];
033A  3020  	MOVLW LOW(gbl_tm1638DisplayNumtoSeg+D'0')
033B  0084  	MOVWF FSR
033C  0864  	MOVF convertTem_00022_1_cDig0, W
033D  0784  	ADDWF FSR, F
033E  0800  	MOVF INDF, W
033F  00AD  	MOVWF gbl_tm1638Data+D'3'


    // left fill zeroes with blanks up to the digit before the decimal place
    if (cDig3 == 0) {
0340  08E1  	MOVF convertTem_00022_1_cDig3, F
0341  1903  	BTFSC STATUS,Z

        tm1638Data[0] = 0;
0342  01AA  	CLRF gbl_tm1638Data

    }

    if (isMinus) {
0343  08DC  	MOVF convertTem_00022_1_isMinus, F
0344  1903  	BTFSC STATUS,Z

        // If minus and value less than or equal -10 (checked as >1000), shift the digits right
        if (iValue >= 1000) {
0346  3003  	MOVLW 0x03
0347  025E  	SUBWF convertTem_00022_1_iValue+D'1', W
0348  1D03  	BTFSS STATUS,Z
0349  2B4C  	GOTO	label47
034A  30E8  	MOVLW 0xE8
034B  025D  	SUBWF convertTem_00022_1_iValue, W
034C        label47
034C  1C03  	BTFSS STATUS,C
034D  2B56  	GOTO	label48
034E  1BDE  	BTFSC convertTem_00022_1_iValue+D'1',7
034F  2B56  	GOTO	label48
0356        label48

            tm1638Data[1] = tm1638Data[0];
0350  082A  	MOVF gbl_tm1638Data, W
0351  00AB  	MOVWF gbl_tm1638Data+D'1'

            tm1638Data[2] = tm1638Data[1];
0352  082B  	MOVF gbl_tm1638Data+D'1', W
0353  00AC  	MOVWF gbl_tm1638Data+D'2'

            tm1638Data[3] = tm1638Data[2];
0354  082C  	MOVF gbl_tm1638Data+D'2', W
0355  00AD  	MOVWF gbl_tm1638Data+D'3'

        }
        // If minus, overwrite left most digit with minus sign
        tm1638Data[0] = 0x40;
0356  3040  	MOVLW 0x40
0357  00AA  	MOVWF gbl_tm1638Data

    }
}
0345  0008  	RETURN
0358  0008  	RETURN


/*********************************************************************************************
  startTemp()
  Sends the Convert T [44h] function command to the ds18b20
*********************************************************************************************/
void startTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // 44 is the convert function
    oneWireTxBytes(0xCC, 0x44);
023B  30CC  	MOVLW 0xCC
023C  1283  	BCF STATUS, RP0
023D  1303  	BCF STATUS, RP1
023E  00DA  	MOVWF oneWireTxB_00017_arg_cData
023F  3044  	MOVLW 0x44
0240  00DB  	MOVWF oneWireTxB_00017_arg_cData2
0241  2115  	CALL oneWireTxB_00017

}
0242  0008  	RETURN


/*********************************************************************************************
  startTemp()
  Sends the Read Scratchpad [BEh] function command to the ds18b20
*********************************************************************************************/
void readTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // BE indicates to read scratchpad
    oneWireTxBytes(0xCC, 0xBE);
0243  30CC  	MOVLW 0xCC
0244  1283  	BCF STATUS, RP0
0245  1303  	BCF STATUS, RP1
0246  00DA  	MOVWF oneWireTxB_00017_arg_cData
0247  30BE  	MOVLW 0xBE
0248  00DB  	MOVWF oneWireTxB_00017_arg_cData2
0249  2115  	CALL oneWireTxB_00017

    // Now get the temperature from the scratchpad
    // This is in the first two bytes - so get those only and ignore the rest
    cTempL = oneWireRxByte();
024A  211C  	CALL oneWireRxB_00018
024B  085B  	MOVF CompTempVarRet548, W
024C  00CD  	MOVWF gbl_cTempL

    cTempH = oneWireRxByte();
024D  211C  	CALL oneWireRxB_00018
024E  085B  	MOVF CompTempVarRet548, W
024F  00CC  	MOVWF gbl_cTempH

}
0250  0008  	RETURN


void processKeys() {

    switch (tm1638Keys) {
        case 1:
0251  1283  	BCF STATUS, RP0
0252  1303  	BCF STATUS, RP1
0253  0859  	MOVF gbl_tm1638Keys, W
0254  3A01  	XORLW 0x01
0255  1D03  	BTFSS STATUS,Z

            break;
    }
}
0256  0008  	RETURN
0257  0008  	RETURN


void main() {

    initialise();
0359  2270  	CALL initialise_00000

    //convertTemp();
    tm1638UpdateDisplay();
035A  21F3  	CALL tm1638Upda_0001E


    // Endless loop
    while(1) {
035B        label49

        // Task scheduler
        // If there are tasks to be performed, find out the
        // most recent task from the array and execute it
        while (cTask > 0) {
035B  0851  	MOVF gbl_cTask, W
035C  3C00  	SUBLW 0x00
035D  1803  	BTFSC STATUS,C
035E  2B5B  	GOTO	label49

            if (cTask.TASK_TIMER1) {
035F  1D51  	BTFSS gbl_cTask,2
0360  2B79  	GOTO	label54
0379        label54

                ds3231ReadDateTime();
0361  2292  	CALL ds3231Read_0001C

                if ((gBcdSeconds == 0x29) || (gBcdSeconds == 0x59)) {
0362  083D  	MOVF gbl_gBcdSeconds, W
0363  3A29  	XORLW 0x29
0364  1903  	BTFSC STATUS,Z
0365  2B6A  	GOTO	label50
0366  083D  	MOVF gbl_gBcdSeconds, W
0367  3A59  	XORLW 0x59
0368  1D03  	BTFSS STATUS,Z
0369  2B6D  	GOTO	label51
036A        label50
036D        label51

                    // Ask to convert for temperature reading at 29 seconds or 59 seconds past the minute
                    oneWireBusReset();
036A  2258  	CALL oneWireBus_00015

                    startTemp();
036B  223B  	CALL startTemp_00000

                } else if ((gBcdSeconds == 0) || (gBcdSeconds == 0x30)) {
036C  2B77  	GOTO	label53
036D  08BD  	MOVF gbl_gBcdSeconds, F
036E  1903  	BTFSC STATUS,Z
036F  2B74  	GOTO	label52
0370  083D  	MOVF gbl_gBcdSeconds, W
0371  3A30  	XORLW 0x30
0372  1D03  	BTFSS STATUS,Z
0373  2B77  	GOTO	label53
0374        label52
0377        label53
037D  2B5B  	GOTO	label49

                    // 1 second later, read the converted temperature
                    oneWireBusReset();
0374  2258  	CALL oneWireBus_00015

                    readTemp(); 
0375  2243  	CALL readTemp_00000

                    // store it in the array, next display refresh will pick it up
                    convertTemp();
0376  22BC  	CALL convertTem_00022

                }
                // Display time and temp or date on TM1638
                tm1638UpdateDisplay();
0377  21F3  	CALL tm1638Upda_0001E

                
                cTask.TASK_TIMER1 = 0;
0378  1151  	BCF gbl_cTask,2

            }
            // Poll keys
            tm1638ReadKeys();
0379  2217  	CALL tm1638Read_0001F

            if (tm1638Keys != 0) {
037A  08D9  	MOVF gbl_tm1638Keys, F
037B  1D03  	BTFSS STATUS,Z

                processKeys();
037C  2251  	CALL processKey_00021

            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
// I2C Communications Library for I2C MASTER
////////////////////////////////////////////////////////////////////////////
// Author(s): Andrew Smallridge
// Date 15 November 2004
//
// Copyright(C) 2004-2006 Andrew Smallridge
// Copyright(C) 2004-2010 Pavel Baranov
// Copyright(C) 2004-2010 David Hobday
// Existing constants predefined for i2c hardware driver and i2s software
// emulation for the PIC 18F2xx and 18F4xx processors. For hardware support
// on other PICs the constants must be mapped to the corresponding register
// map of the target device
////////////////////////////////////////////////////////////////////////////

/*
////////////////////////////////////////////////////////////////////////////
//	The following three sections should be copied to the user's program:
//		i2c master hardware / software mode definition
//		i2c software implementation template arguments and variables
// 		i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////
// i2c master hardware / software mode definition
//
// For i2c hardware support comment out the #define use_ic2_SW line
////////////////////////////////////////////////////////////////////////////
//#define use_i2c_SW

#if defined use_i2c_SW
////////////////////////////////////////////////////////////////////////////
// i2c software implementation template arguments and variables
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)

// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and software emalated i2c RAM locations. These constants are
// then used by the templated functions. When changing the address of an emulated
// register the corresponding constant mapping must also be changed.
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3					

#else
////////////////////////////////////////////////////////////////////////////
// i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP |i2c_HW)

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and PIC's i2c register locations. These constants are
// then used by the templated functions. 
#define PORTC		0x0f82
#define TRISC		0x0f94
#define e_SSPCON1	0xfc6
#define e_SSPCON2	0xfc5
#define e_SSPSTAT	0xfc7
#define e_SSPADD	0xfc8
#define e_SSPBUF	0xfc9
#define e_SSPIF_PIR	0xf9e
#define e_BCLIF_PIR	0xfa1
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3

#endif

*/


////////////////////////////////////////////////////////////////////////////
// Define the common i2c template structure
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL	template <unsigned char T_SCL_BIT, unsigned short T_SCL_PORT,	\
					unsigned short T_SCL_TRIS, unsigned char T_SDA_BIT, 			\
					unsigned short T_SDA_PORT, unsigned short T_SDA_TRIS,			\
					unsigned short T_i2c_SSPCON1, unsigned short T_i2c_SSPCON2, 	\
					unsigned short T_i2c_SSPSTAT, unsigned short T_i2c_SSPBUF, 		\
					unsigned char T_i2c_SSPIF_BIT, unsigned short T_i2c_SSPIF_PIR,	\
					unsigned char T_i2c_BCLIF_BIT, unsigned short T_i2c_BCLIF_PIR,	\
					unsigned char T_i2c_SMP_BIT, unsigned short T_i2c_SSPADD, 		\
					unsigned char T_MODE>

////////////////////////////////////////////////////////////////////////////
// Define the common i2c template parameters
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL_ARGS	T_SCL_BIT, T_SCL_PORT, T_SCL_TRIS, T_SDA_BIT, 			\
						T_SDA_PORT, T_SDA_TRIS, T_i2c_SSPCON1, T_i2c_SSPCON2, 	\
						T_i2c_SSPSTAT, T_i2c_SSPBUF, T_i2c_SSPIF_BIT, 			\
						T_i2c_SSPIF_PIR, T_i2c_BCLIF_BIT, T_i2c_BCLIF_PIR,		\
						T_i2c_SMP_BIT, T_i2c_SSPADD, T_MODE

////////////////////////////////////////////////////////////////////////////
// Helpers that hide template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_init	i2c_INIT<i2c_ARGS>
#define i2c_start	i2c_START<i2c_ARGS>
#define i2c_restart	i2c_RESTART<i2c_ARGS>
#define i2c_stop	i2c_STOP<i2c_ARGS>
#define i2c_read	i2c_READ<i2c_ARGS>
#define i2c_write	i2c_WRITE<i2c_ARGS>


////////////////////////////////////////////////////////////////////////////
// I2C Control Status Bits - Emulates the PIC18F hardware I2C implementation
////////////////////////////////////////////////////////////////////////////
// define I2C i2C_SSPCON1 control bits
#define	i2c_WCOL	7
#define	i2c_SSPOV	6
#define	i2c_SSPEN	5
#define	i2c_CKP		4
#define	i2c_SSPM3	3
#define	i2c_SSPM2	2
#define	i2c_SSPM1	1
#define	i2c_SSPM0	0

// define I2C SSPCON2 control bits
#define	i2c_GCEN 	7
#define	i2c_ACKSTAT	6
#define	i2c_ACKDT	5
#define	i2c_ACKEN	4
#define	i2c_RCEN	3
#define	i2c_PEN		2
#define	i2c_RSEN	1
#define	i2c_SEN		0

// define I2C SSPSTAT status bits
#define	i2c_DA		5
#define	i2c_P		4
#define	i2c_S		3
#define	i2c_RW		2
#define	i2c_UA		1
#define	i2c_BF		0


////////////////////////////////////////////////////////////////////////////
// I2C Control Flag Bits
////////////////////////////////////////////////////////////////////////////
// define I2C Mode bits
#define	i2c_HW			0x01
#define	i2c_400KHz		0x02	// 100KHz or 400KHz I2C clock (set = 400KHz)
#define	i2c_reset_wdt	0x04
#define i2c_SMP			0x80	


////////////////////////////////////////////////////////////////////////////
// I2C software constants
////////////////////////////////////////////////////////////////////////////
#define	dly 10	// number of 1us delay increments



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Start Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL 
void i2c_START(void)

{
	// Initiate the I2C START condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	delay_us(dly);
00A5  300A  	MOVLW 0x0A
00A6  1283  	BCF STATUS, RP0
00A7  1303  	BCF STATUS, RP1
00A8  00DF  	MOVWF delay_us_00000_arg_del
00A9  2010  	CALL delay_us_00000

	l_bclif = 0; // initialise the collision flag for this command
00AA  11C6  	BCF i2c_START_00000_1_l_bclif,3

	l_sspif = 0;
00AB  11C5  	BCF i2c_START_00000_1_l_sspif,3

		
	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
			
		l_sen = 1; // initiate START condition	

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation			
		l_sen = 1; // initiate START condition
00AC  1441  	BSF i2c_START_00000_1_l_sen,0

		l_scl_tris = 1; // ensure the SCL line is high
00AD  1683  	BSF STATUS, RP0
00AE  1505  	BSF i2c_START_00000_1_l_scl_tris,2

		l_sda_tris = 1; // ensure the SDA line is high	
00AF  1585  	BSF i2c_START_00000_1_l_sda_tris,3

		l_scl = 0; // prepare to set SCL line low
00B0  1283  	BCF STATUS, RP0
00B1  1105  	BCF i2c_START_00000_1_l_scl,2

		l_sda = 0; // prepare to set SDA line low
00B2  1185  	BCF i2c_START_00000_1_l_sda,3

		
		if (l_scl && l_sda)
00B3  1D05  	BTFSS i2c_START_00000_1_l_scl,2
00B4  28D2  	GOTO	label16
00B5  1D85  	BTFSS i2c_START_00000_1_l_sda,3
00B6  28D2  	GOTO	label16
00D2        label16

		{
			// good sign - no collision detected
			delay_us(dly);
00B7  300A  	MOVLW 0x0A
00B8  00DF  	MOVWF delay_us_00000_arg_del
00B9  2010  	CALL delay_us_00000

			
			if (!l_scl) // ensure the clock is still high
00BA  1905  	BTFSC i2c_START_00000_1_l_scl,2
00BB  28C0  	GOTO	label15
00C0        label15

			{
				l_bclif = 1;
00BC  15C6  	BSF i2c_START_00000_1_l_bclif,3

				l_s = 1;
00BD  15C2  	BSF i2c_START_00000_1_l_s,3

				l_sen = 0;
00BE  1041  	BCF i2c_START_00000_1_l_sen,0

				return;
			}
					
			l_sda = 0; // prepare to set SDA line low
00C0  1185  	BCF i2c_START_00000_1_l_sda,3

			l_sda_tris = 0; // SDA to output (driven low)
00C1  1683  	BSF STATUS, RP0
00C2  1185  	BCF i2c_START_00000_1_l_sda_tris,3


			delay_us(dly);					
00C3  300A  	MOVLW 0x0A
00C4  1283  	BCF STATUS, RP0
00C5  00DF  	MOVWF delay_us_00000_arg_del
00C6  2010  	CALL delay_us_00000

			l_scl = 0; // prepare to set SCL line low
00C7  1105  	BCF i2c_START_00000_1_l_scl,2

			l_scl_tris = 0; // SCL to output (driven low)
00C8  1683  	BSF STATUS, RP0
00C9  1105  	BCF i2c_START_00000_1_l_scl_tris,2


			delay_us(dly);					
00CA  300A  	MOVLW 0x0A
00CB  1283  	BCF STATUS, RP0
00CC  00DF  	MOVWF delay_us_00000_arg_del
00CD  2010  	CALL delay_us_00000

			l_s = 1; // set 'S' bit flag (start bit detected)
00CE  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0; // clear flag
00CF  1041  	BCF i2c_START_00000_1_l_sen,0

			l_sspif = 1; // flag end of start condition interrupt	
00D0  15C5  	BSF i2c_START_00000_1_l_sspif,3

		}
		else
		{
			// here is SDA or SCL are low at the start - indicates a bus collision
			l_bclif = 1;
00D2  15C6  	BSF i2c_START_00000_1_l_bclif,3

			l_s = 1; // set 'S' bit flag (start bit detected)
00D3  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0;
00D4  1041  	BCF i2c_START_00000_1_l_sen,0

			l_rsen = 0;
00D5  10C1  	BCF i2c_START_00000_1_l_rsen,1

			l_pen = 0;
00D6  1141  	BCF i2c_START_00000_1_l_pen,2

			l_rcen = 0;								
00D7  11C1  	BCF i2c_START_00000_1_l_rcen,3

			l_acken = 0;			
00D8  1241  	BCF i2c_START_00000_1_l_acken,4

		}
	}
}
00BF  0008  	RETURN
00D1  0008  	RETURN
00D9  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Restart Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_RESTART(void)
{
	// Initiate the I2C RESTART condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
			
	delay_us(dly);
	l_bclif = 0; // initialise the collision flag for this command
	l_sspif = 0;

	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_rsen = 1; // initiate RESTART condition
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation	
		l_rsen = 1;
		l_scl = 0;
		l_sda = 0;
		
		if (!l_scl)
		{
			// good sign - no other I2C activity in progress
			l_sda_tris = 1; // float SDA line high	(should already be in this condition)	
			delay_us(dly);
		
			// about to float the clock line
			// ensure the data line is still high
			if (!l_sda)
			{
				// problem - SDA is low, a bus collision has occurred				
				l_bclif = 1; // set the bus collision flag	
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_scl_tris = 1; // float SCL line (high)	
				return;
			}
												
			l_scl_tris = 1; // float SCL line (high)

			// wait until any clock stretching has finished
			while (!l_scl)
				if (T_MODE & i2c_reset_wdt)
					clear_wdt();	
			delay_us(dly);
			
			// here we are about to drive SDA low
			// first ensure SCL is still high
			if (!l_scl)
			{
				// problem - SCL is low, a bus collision has occurred
				l_bclif = 1; // set the bus collision flag
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_sda_tris = 1; // float SDA line (high)
				return;
			}
				
			l_sda_tris = 0; // drive SDA low
			l_s = 1; // set 'S' bit flag (start bit detected)

			delay_us(dly);
			l_scl_tris = 0; // drive SCL low
			l_rsen = 0;
			l_pen = 0;
			l_sen = 0;			
			l_rcen = 0;								
			l_acken = 0;			
			l_sspif = 1; // flag end of start condition interrupt
		}
		else
		{
			// SCL is high at the start
			// some other I2C activity in progress		
			l_rsen = 0; // clear flag
			// exit without further action
		}
	}
}



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Stop Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_STOP(void)

{ 
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_p@T_i2c_SSPSTAT.i2c_P; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;

	l_bclif = 0; // initialise the collision flag for this command
0075  1283  	BCF STATUS, RP0
0076  1303  	BCF STATUS, RP1
0077  11C6  	BCF i2c_STOP_00000_1_l_bclif,3

	l_sspif = 0;
0078  11C5  	BCF i2c_STOP_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_pen = 1; // initiate STOP condition on the I2C bus	
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
		
	}
	else
	{
		//	Software I2C implementation
		l_pen = 1; // initiate STOP condition on the I2C bus
0079  1541  	BSF i2c_STOP_00000_1_l_pen,2

		delay_us(dly);
007A  300A  	MOVLW 0x0A
007B  00DF  	MOVWF delay_us_00000_arg_del
007C  2010  	CALL delay_us_00000

		
		l_scl = 0; // prepare to set SCL line low
007D  1105  	BCF i2c_STOP_00000_1_l_scl,2

		l_sda = 0; // prepare to set SDA line low
007E  1185  	BCF i2c_STOP_00000_1_l_sda,3

		l_scl_tris = 0; // drive SCL line low (should already be low)
007F  1683  	BSF STATUS, RP0
0080  1105  	BCF i2c_STOP_00000_1_l_scl_tris,2

		l_sda_tris = 0; // drive SDA line low
0081  1185  	BCF i2c_STOP_00000_1_l_sda_tris,3


		delay_us(dly);		
0082  300A  	MOVLW 0x0A
0083  1283  	BCF STATUS, RP0
0084  00DF  	MOVWF delay_us_00000_arg_del
0085  2010  	CALL delay_us_00000

		l_scl_tris = 1; // float SCL line (high)
0086  1683  	BSF STATUS, RP0
0087  1505  	BSF i2c_STOP_00000_1_l_scl_tris,2

		
		// wait until any clock stretching has finished
		while (!l_scl)
0088        label11
0088  1283  	BCF STATUS, RP0
0089  1905  	BTFSC i2c_STOP_00000_1_l_scl,2
008A  288D  	GOTO	label12
008C  2888  	GOTO	label11
008D        label12

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
008B  0064  	CLRWDT

						
		delay_us(dly);
008D  300A  	MOVLW 0x0A
008E  00DF  	MOVWF delay_us_00000_arg_del
008F  2010  	CALL delay_us_00000

		l_sda_tris = 1; // float SDA line
0090  1683  	BSF STATUS, RP0
0091  1585  	BSF i2c_STOP_00000_1_l_sda_tris,3

		delay_us(dly);		
0092  300A  	MOVLW 0x0A
0093  1283  	BCF STATUS, RP0
0094  00DF  	MOVWF delay_us_00000_arg_del
0095  2010  	CALL delay_us_00000

		
		// here the SDA line should be high - if not a collision has occurred				
		if (!l_sda || !l_scl)
0096  1D85  	BTFSS i2c_STOP_00000_1_l_sda,3
0097  289A  	GOTO	label13
0098  1905  	BTFSC i2c_STOP_00000_1_l_scl,2
0099  289E  	GOTO	label14
009A        label13
009E        label14

		{
			// problem - SDA or SCL is low, a bus collision has occurred
			l_bclif = 1; // set the bus collision flag	
009A  15C6  	BSF i2c_STOP_00000_1_l_bclif,3

			l_s = 0; // clear 'S' bit flag
009B  11C2  	BCF i2c_STOP_00000_1_l_s,3

			l_pen = 0; // clear flag
009C  1141  	BCF i2c_STOP_00000_1_l_pen,2

		}
		else
		{		
			l_p = 1;
009E  1642  	BSF i2c_STOP_00000_1_l_p,4

			l_pen = 0;
009F  1141  	BCF i2c_STOP_00000_1_l_pen,2

			l_sen = 0;
00A0  1041  	BCF i2c_STOP_00000_1_l_sen,0

			l_rsen = 0;			
00A1  10C1  	BCF i2c_STOP_00000_1_l_rsen,1

			l_rcen = 0;								
00A2  11C1  	BCF i2c_STOP_00000_1_l_rcen,3

			l_acken = 0;
00A3  1241  	BCF i2c_STOP_00000_1_l_acken,4

		}
	}
}
009D  0008  	RETURN
00A4  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Write Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_WRITE(unsigned char i2c_data)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;	
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
	
	char BitMask;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
0024  11C6  	BCF i2c_WRITE_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
0025  11C5  	BCF i2c_WRITE_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
				
		l_wcol = 0; // clear write collision flag	
		i2c_SSPBUF = i2c_data;

		// test if a write collision occurred
		if (l_wcol)
			return (1); // error exit	

		// wait until MSSP Tx register is empty
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
								
		return (0); // successful exit
	}

	// here for i2c software driver
	l_wcol = 0; // clear write collision flag	
0026  13C0  	BCF i2c_WRITE_00000_1_l_wcol,7

	i2c_SSPBUF = i2c_data;
0027  085C  	MOVF i2c_WRITE_00000_arg_i2c_data, W
0028  00C4  	MOVWF i2c_WRITE_00000_1_i2c_SSPBUF

	
	l_scl = 0; // prepare to set SCL line low
0029  1105  	BCF i2c_WRITE_00000_1_l_scl,2

	l_sda = 0; // prepare to set SDA line low
002A  1185  	BCF i2c_WRITE_00000_1_l_sda,3

	l_rw = 0; // signal we are doing a write
002B  1142  	BCF i2c_WRITE_00000_1_l_rw,2


	for (BitMask = 0x80; BitMask; BitMask>>=1)
002C  3080  	MOVLW 0x80
002D  00DD  	MOVWF i2c_WRITE_00000_1_BitMask
002E        label3
002E  08DD  	MOVF i2c_WRITE_00000_1_BitMask, F
002F  1903  	BTFSC STATUS,Z
0030  2851  	GOTO	label8
004E  1003  	BCF STATUS,C
004F  0CDD  	RRF i2c_WRITE_00000_1_BitMask, F
0050  282E  	GOTO	label3
0051        label8

	{
		if (i2c_data & BitMask)
0031  085D  	MOVF i2c_WRITE_00000_1_BitMask, W
0032  055C  	ANDWF i2c_WRITE_00000_arg_i2c_data, W
0033  1903  	BTFSC STATUS,Z
0034  2838  	GOTO	label4
0038        label4

			l_sda_tris = 1; // float SDA high	
0035  1683  	BSF STATUS, RP0
0036  1585  	BSF i2c_WRITE_00000_1_l_sda_tris,3

		else
0037  283A  	GOTO	label5
003A        label5

			l_sda_tris = 0; // drive SDA low
0038  1683  	BSF STATUS, RP0
0039  1185  	BCF i2c_WRITE_00000_1_l_sda_tris,3

		delay_us(dly);
003A  300A  	MOVLW 0x0A
003B  1283  	BCF STATUS, RP0
003C  00DF  	MOVWF delay_us_00000_arg_del
003D  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
003E  1683  	BSF STATUS, RP0
003F  1505  	BSF i2c_WRITE_00000_1_l_scl_tris,2


		// wait until any clock stretching has finished
		while (!l_scl)
0040        label6
0040  1283  	BCF STATUS, RP0
0041  1905  	BTFSC i2c_WRITE_00000_1_l_scl,2
0042  2845  	GOTO	label7
0044  2840  	GOTO	label6
0045        label7

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
0043  0064  	CLRWDT

		delay_us(dly);
0045  300A  	MOVLW 0x0A
0046  00DF  	MOVWF delay_us_00000_arg_del
0047  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low	
0048  1683  	BSF STATUS, RP0
0049  1105  	BCF i2c_WRITE_00000_1_l_scl_tris,2

		delay_us(dly);
004A  300A  	MOVLW 0x0A
004B  1283  	BCF STATUS, RP0
004C  00DF  	MOVWF delay_us_00000_arg_del
004D  2010  	CALL delay_us_00000

	}
	// serialized out the data
	// now get the status		
	// set SSPIF
	l_sspif = 1;
0051  15C5  	BSF i2c_WRITE_00000_1_l_sspif,3

	l_acken = 1;
0052  1641  	BSF i2c_WRITE_00000_1_l_acken,4

	l_ackdt = 0;
0053  12C1  	BCF i2c_WRITE_00000_1_l_ackdt,5

	l_sda_tris = 1; // float SDA high
0054  1683  	BSF STATUS, RP0
0055  1585  	BSF i2c_WRITE_00000_1_l_sda_tris,3

	
	delay_us(dly);
0056  300A  	MOVLW 0x0A
0057  1283  	BCF STATUS, RP0
0058  00DF  	MOVWF delay_us_00000_arg_del
0059  2010  	CALL delay_us_00000

	
	l_scl_tris = 1; // float SCL high
005A  1683  	BSF STATUS, RP0
005B  1505  	BSF i2c_WRITE_00000_1_l_scl_tris,2

	
	// wait until any clock stretching has finished
	while (!l_scl)
005C        label9
005C  1283  	BCF STATUS, RP0
005D  1905  	BTFSC i2c_WRITE_00000_1_l_scl,2
005E  2861  	GOTO	label10
0060  285C  	GOTO	label9
0061        label10

		if (T_MODE & i2c_reset_wdt)
			clear_wdt();	
005F  0064  	CLRWDT

	delay_us(dly);
0061  300A  	MOVLW 0x0A
0062  00DF  	MOVWF delay_us_00000_arg_del
0063  2010  	CALL delay_us_00000


	// get the status bit
	local_ack = l_sda;
0064  105E  	BCF i2c_WRITE_00000_1_local_ack,0
0065  1985  	BTFSC i2c_WRITE_00000_1_l_sda,3
0066  145E  	BSF i2c_WRITE_00000_1_local_ack,0

	delay_us(dly);
0067  300A  	MOVLW 0x0A
0068  00DF  	MOVWF delay_us_00000_arg_del
0069  2010  	CALL delay_us_00000


	l_scl_tris = 0; // drive SCL low	
006A  1683  	BSF STATUS, RP0
006B  1105  	BCF i2c_WRITE_00000_1_l_scl_tris,2

	l_acken = 0;
006C  1283  	BCF STATUS, RP0
006D  1241  	BCF i2c_WRITE_00000_1_l_acken,4

	delay_us(dly);
006E  300A  	MOVLW 0x0A
006F  00DF  	MOVWF delay_us_00000_arg_del
0070  2010  	CALL delay_us_00000

	return(local_ack);
0071  01DF  	CLRF CompTempVarRet549
0072  185E  	BTFSC i2c_WRITE_00000_1_local_ack,0
0073  0ADF  	INCF CompTempVarRet549, F

}
0074  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Read Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_READ(char ack_status)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	char BitMask;
	char i2c_data;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
013A  11C6  	BCF i2c_READ_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
013B  11C5  	BCF i2c_READ_00000_1_l_sspif,3

	l_wcol = 0; // clear write collision flag	
013C  13C0  	BCF i2c_READ_00000_1_l_wcol,7


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// enable master for 1 byte reception	
		l_rcen = 1;

		// wait until byte received
		while(!l_sspif || !l_bf)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// read the byte from the Rx register
		i2c_data = i2c_SSPBUF;			
			
		// wait until the bus is idle		
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		if (ack_status)
			l_ackdt = 1; // preset ack bit
		else
			l_ackdt = 0; // preset ack bit

		l_sspif = 0;
		l_acken = 1; // acknowledge sequence enable

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();								
	}
	else
	{
		// here for i2c software driver
		l_rcen = 1;
013D  15C1  	BSF i2c_READ_00000_1_l_rcen,3

		l_ackdt = ack_status;
013E  185A  	BTFSC i2c_READ_00000_arg_ack_status,0
013F  16C1  	BSF i2c_READ_00000_1_l_ackdt,5
0140  1C5A  	BTFSS i2c_READ_00000_arg_ack_status,0
0141  12C1  	BCF i2c_READ_00000_1_l_ackdt,5

		l_rw = 1;
0142  1542  	BSF i2c_READ_00000_1_l_rw,2

		l_scl = 0; // prepare to set SCL line low
0143  1105  	BCF i2c_READ_00000_1_l_scl,2

		l_sda = 0; // prepare to set SDA line low	
0144  1185  	BCF i2c_READ_00000_1_l_sda,3


		// prepare to serialize in the byte
		l_sda_tris = 1; // float SDA
0145  1683  	BSF STATUS, RP0
0146  1585  	BSF i2c_READ_00000_1_l_sda_tris,3

		delay_us(dly);
0147  300A  	MOVLW 0x0A
0148  1283  	BCF STATUS, RP0
0149  00DF  	MOVWF delay_us_00000_arg_del
014A  2010  	CALL delay_us_00000

		i2c_data = 0;
014B  01DC  	CLRF i2c_READ_00000_1_i2c_data

		for (BitMask = 0x80; BitMask; BitMask>>=1)
014C  3080  	MOVLW 0x80
014D  00DB  	MOVWF i2c_READ_00000_1_BitMask
014E        label22
014E  08DB  	MOVF i2c_READ_00000_1_BitMask, F
014F  1903  	BTFSC STATUS,Z
0150  296B  	GOTO	label26
0168  1003  	BCF STATUS,C
0169  0CDB  	RRF i2c_READ_00000_1_BitMask, F
016A  294E  	GOTO	label22
016B        label26

		{
			l_scl_tris = 1; // float SCL high
0151  1683  	BSF STATUS, RP0
0152  1505  	BSF i2c_READ_00000_1_l_scl_tris,2

			// wait until any clock stretching has finished
			while (!l_scl)
0153        label23
0153  1283  	BCF STATUS, RP0
0154  1905  	BTFSC i2c_READ_00000_1_l_scl,2
0155  2958  	GOTO	label24
0157  2953  	GOTO	label23
0158        label24

				if (T_MODE & i2c_reset_wdt)
					clear_wdt();		
0156  0064  	CLRWDT

			delay_us(dly);
0158  300A  	MOVLW 0x0A
0159  00DF  	MOVWF delay_us_00000_arg_del
015A  2010  	CALL delay_us_00000


			// read the current bit
			l_sda_tris = 1; // float SDA
015B  1683  	BSF STATUS, RP0
015C  1585  	BSF i2c_READ_00000_1_l_sda_tris,3

			if (l_sda)
015D  1283  	BCF STATUS, RP0
015E  1D85  	BTFSS i2c_READ_00000_1_l_sda,3
015F  2962  	GOTO	label25
0162        label25

				i2c_data |= BitMask;
0160  085B  	MOVF i2c_READ_00000_1_BitMask, W
0161  04DC  	IORWF i2c_READ_00000_1_i2c_data, F

			l_scl_tris = 0; // drive SCL low
0162  1683  	BSF STATUS, RP0
0163  1105  	BCF i2c_READ_00000_1_l_scl_tris,2

			delay_us(dly);
0164  300A  	MOVLW 0x0A
0165  1283  	BCF STATUS, RP0
0166  00DF  	MOVWF delay_us_00000_arg_del
0167  2010  	CALL delay_us_00000

		}
		// flag receive complete			
		l_sspif = 1;
016B  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		l_rcen = 0;
016C  11C1  	BCF i2c_READ_00000_1_l_rcen,3

		
		// set the ACK state
		if (ack_status)	
016D  08DA  	MOVF i2c_READ_00000_arg_ack_status, F
016E  1903  	BTFSC STATUS,Z
016F  2973  	GOTO	label27
0173        label27

			l_sda_tris = 1; // float SDA high
0170  1683  	BSF STATUS, RP0
0171  1585  	BSF i2c_READ_00000_1_l_sda_tris,3

		else
0172  2975  	GOTO	label28
0175        label28

			l_sda_tris = 0; // drive SDA low
0173  1683  	BSF STATUS, RP0
0174  1185  	BCF i2c_READ_00000_1_l_sda_tris,3

		delay_us(dly);
0175  300A  	MOVLW 0x0A
0176  1283  	BCF STATUS, RP0
0177  00DF  	MOVWF delay_us_00000_arg_del
0178  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
0179  1683  	BSF STATUS, RP0
017A  1505  	BSF i2c_READ_00000_1_l_scl_tris,2


		// wait until any clock stretching has finished
		while (!l_scl)
017B        label29
017B  1283  	BCF STATUS, RP0
017C  1905  	BTFSC i2c_READ_00000_1_l_scl,2
017D  2980  	GOTO	label30
017F  297B  	GOTO	label29
0180        label30

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
017E  0064  	CLRWDT

	
		l_sspif = 0; // clear SSPIF
0180  11C5  	BCF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
0181  300A  	MOVLW 0x0A
0182  00DF  	MOVWF delay_us_00000_arg_del
0183  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low		
0184  1683  	BSF STATUS, RP0
0185  1105  	BCF i2c_READ_00000_1_l_scl_tris,2

		l_sspif = 1;
0186  1283  	BCF STATUS, RP0
0187  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
0188  300A  	MOVLW 0x0A
0189  00DF  	MOVWF delay_us_00000_arg_del
018A  2010  	CALL delay_us_00000

	}
	return(i2c_data);
018B  085C  	MOVF i2c_READ_00000_1_i2c_data, W
018C  00DD  	MOVWF CompTempVarRet550

}
018D  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Initialization
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_INIT(unsigned char i2c_divisor)

{
	volatile unsigned char i2c_SSPADD@T_i2c_SSPADD, i2c_SSPSTAT@T_i2c_SSPSTAT;
	volatile unsigned char i2c_SSPCON1@T_i2c_SSPCON1,i2c_SSPCON2@T_i2c_SSPCON2;

	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_sspen@T_i2c_SSPCON1.i2c_SSPEN, l_smp@T_i2c_SSPSTAT.T_i2c_SMP_BIT;

	l_sda_tris = 1;
018E  1683  	BSF STATUS, RP0
018F  1585  	BSF i2c_INIT_00000_1_l_sda_tris,3

	l_scl_tris = 1;
0190  1505  	BSF i2c_INIT_00000_1_l_scl_tris,2

	
	i2c_SSPCON1 = 0x00; // initialise the I2C control register (mirrors HW SSPCON1)	
0191  1283  	BCF STATUS, RP0
0192  01C0  	CLRF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPADD = i2c_divisor; // get the I2C baud rate divisor
0193  085A  	MOVF i2c_INIT_00000_arg_i2c_divisor, W
0194  00C3  	MOVWF i2c_INIT_00000_1_i2c_SSPADD

	i2c_SSPCON1 = 0x08; // initialise the I2C control register (mirrors HW SSPCON1)	
0195  3008  	MOVLW 0x08
0196  00C0  	MOVWF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPCON2 = 0x00; // initialise the I2C control register (mirrors HW SSPCON2)	
0197  01C1  	CLRF i2c_INIT_00000_1_i2c_SSPCON2

	
	i2c_SSPSTAT = 0x00; // initialise the I2C status register (mirrors HW SSPSTAT)
0198  01C2  	CLRF i2c_INIT_00000_1_i2c_SSPSTAT

	
	if (T_MODE & i2c_SMP)
		l_smp = 1;
0199  17C2  	BSF i2c_INIT_00000_1_l_smp,7


	l_sspif = 0; // initialise the I2C SSP interrupt status
019A  11C5  	BCF i2c_INIT_00000_1_l_sspif,3

	l_bclif = 0; // initialise the I2C BCL interrupt status
019B  11C6  	BCF i2c_INIT_00000_1_l_bclif,3

	l_sda = 0;
019C  1185  	BCF i2c_INIT_00000_1_l_sda,3

	l_scl = 0;
019D  1105  	BCF i2c_INIT_00000_1_l_scl,2

	l_sspen = 1; // enable I2C
019E  16C0  	BSF i2c_INIT_00000_1_l_sspen,5

	
	i2c_STOP<_I2C_TEMPL_ARGS>();
019F  2075  	CALL i2c_STOP_00000

}
01A0  0008  	RETURN







////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  2B7E  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00BA  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00BB  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00BC  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2BC8  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010  3003  	MOVLW 0x03
0011  07DF  	ADDWF delay_us_00000_arg_del, F
0012  0CDF  	RRF delay_us_00000_arg_del, F
0013  0CDF  	RRF delay_us_00000_arg_del, F
0014  307F  	MOVLW 0x7F
0015  05DF  	ANDWF delay_us_00000_arg_del, F
0016        label1
0016  0000  	NOP
0017  0BDF  	DECFSZ delay_us_00000_arg_del, F
0018  2816  	GOTO	label1
0019  0008  	RETURN
001A        ; } delay_us function end

001A        delay_10us_00000
001A        ; { delay_10us ; function begin
001A        label2
001A  0000  	NOP
001B  0000  	NOP
001C  0000  	NOP
001D  0000  	NOP
001E  0000  	NOP
001F  0000  	NOP
0020  0000  	NOP
0021  0BDF  	DECFSZ delay_10us_00000_arg_del, F
0022  281A  	GOTO	label2
0023  0008  	RETURN
0024        ; } delay_10us function end














01CA        __mul_16s__0000F
01CA        ; { __mul_16s_16s__16 ; function begin
01CA  01E9  	CLRF __mul_16s__0000F_1_i
01CB  01EC  	CLRF CompTempVarRet386
01CC  01ED  	CLRF CompTempVarRet386+D'1'
01CD  0865  	MOVF __mul_16s__0000F_arg_a, W
01CE  00EA  	MOVWF __mul_16s__0000F_1_t
01CF  0866  	MOVF __mul_16s__0000F_arg_a+D'1', W
01D0  00EB  	MOVWF __mul_16s__0000F_1_t+D'1'
01D1  1FE8  	BTFSS __mul_16s__0000F_arg_b+D'1',7
01D2  29D9  	GOTO	label31
01D3  17E9  	BSF __mul_16s__0000F_1_i,7
01D4  09E7  	COMF __mul_16s__0000F_arg_b, F
01D5  09E8  	COMF __mul_16s__0000F_arg_b+D'1', F
01D6  0AE7  	INCF __mul_16s__0000F_arg_b, F
01D7  1903  	BTFSC gbl_status,2
01D8  0AE8  	INCF __mul_16s__0000F_arg_b+D'1', F
01D9        label31
01D9  1A69  	BTFSC __mul_16s__0000F_1_i,4
01DA  29EB  	GOTO	label33
01DB  1C67  	BTFSS __mul_16s__0000F_arg_b,0
01DC  29E3  	GOTO	label32
01DD  086A  	MOVF __mul_16s__0000F_1_t, W
01DE  07EC  	ADDWF CompTempVarRet386, F
01DF  086B  	MOVF __mul_16s__0000F_1_t+D'1', W
01E0  1803  	BTFSC gbl_status,0
01E1  0F6B  	INCFSZ __mul_16s__0000F_1_t+D'1', W
01E2  07ED  	ADDWF CompTempVarRet386+D'1', F
01E3        label32
01E3  1003  	BCF gbl_status,0
01E4  0CE8  	RRF __mul_16s__0000F_arg_b+D'1', F
01E5  0CE7  	RRF __mul_16s__0000F_arg_b, F
01E6  1003  	BCF gbl_status,0
01E7  0DEA  	RLF __mul_16s__0000F_1_t, F
01E8  0DEB  	RLF __mul_16s__0000F_1_t+D'1', F
01E9  0AE9  	INCF __mul_16s__0000F_1_i, F
01EA  29D9  	GOTO	label31
01EB        label33
01EB  1FE9  	BTFSS __mul_16s__0000F_1_i,7
01EC  0008  	RETURN
01ED  09EC  	COMF CompTempVarRet386, F
01EE  09ED  	COMF CompTempVarRet386+D'1', F
01EF  0AEC  	INCF CompTempVarRet386, F
01F0  1903  	BTFSC gbl_status,2
01F1  0AED  	INCF CompTempVarRet386+D'1', F
01F2  0008  	RETURN
01F3        ; } __mul_16s_16s__16 function end













037E        _startup

03C5  118A  	BCF PCLATH,3
03C6  120A  	BCF PCLATH,4
03C7  2B59  	GOTO	main

2007  3F18  	DW 0x3F18
