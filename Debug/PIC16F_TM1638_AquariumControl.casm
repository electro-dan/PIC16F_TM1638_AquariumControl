;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 8.01
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

#ifndef _PIC16F_TM1638_AquariumControl_H_
#define _PIC16F_TM1638_AquariumControl_H_

// Tasks
#define TASK_TIMER0 1
#define TASK_TIMER1 2

// Port bits
#define oneWireBus (portc.5)
#define oneWireTris (trisc.5)
#define tm1638dio (portb.1)
#define tm1638dioTris (trisb.1)
#define tm1638clk (portb.2)
#define tm1638strobe (portb.3)
#define WHITE_LED (portc.1)
#define BLUE_LED (portc.2)
#define FAN (porta.1)
#define HEATER (porta.0)

// Timer 0 preload
#define TMR0PRELOAD 61
// This means timer 1 will overflow when 1 cycle completes, generating the interrupt
#define TMR1HV 0xFF
#define TMR1LV 0xFF

// I2C initialisation for built in software handling
// i2c options
#define use_i2c_SW
// clock SCL on RA3, data SDA on RA4
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)
// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3


// I2C addresses (8 bit)
#define ds3231Addr 0xD0 // Left shifted 7 bit address 0x68
#define at24c32Addr 0xAE // Left shifted 7 bit address 0x57

// Time and date variables
char gBcdSecond = 0; // 0 to 0x59
0A48  1283  	BCF STATUS, RP0
0A49  1303  	BCF STATUS, RP1
0A4A  01B7  	CLRF gbl_gBcdSecond

char gBcdMinute = 0; // 0 to 0x59
0A4B  01B8  	CLRF gbl_gBcdMinute

char gBcdHour = 0; // 0 to 0x23 or 1 to 0x12. Also contains 12/24 setting at bit 6. If 12 hour, AM/PM uses bit 5
0A4C  01B9  	CLRF gbl_gBcdHour

char gDayOfWeek = 1; // 1 to 7
0A4D  3001  	MOVLW 0x01
0A4E  00BA  	MOVWF gbl_gDayOfWeek

char gBcdDayOfMonth = 1; // 1 to 0x31
0A4F  3001  	MOVLW 0x01
0A50  00BB  	MOVWF gbl_gBcdDayOfMonth

char gBcdMonth = 1; // 1 to 0x12 + century at bit 7
0A51  3001  	MOVLW 0x01
0A52  00BC  	MOVWF gbl_gBcdMonth

char gBcdYear = 0x23; // Init to 0x23
0A53  3023  	MOVLW 0x23
0A54  00BD  	MOVWF gbl_gBcdYear

// Days in each month
rom char *gDaysInMonth = {0x31, 0x28, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31};
0A55  3000  	MOVLW 0x00
0A56  00BE  	MOVWF gbl_gDaysInMonth

// List of leap years, where the Feb days will be 29 instead
rom char *gLeapYears = {0x04, 0x08, 0x12, 0x16, 0x20, 0x24, 0x28, 0x32, 0x36, 0x40, 0x44, 0x48, 0x52, 0x56, 0x60, 0x64, 0x68, 0x72, 0x76, 0x80, 0x84, 0x88, 0x92, 0x96};
0A57  3001  	MOVLW 0x01
0A58  00BF  	MOVWF gbl_gLeapYears


// Timer variables
char iTimer0FlashCounts = 0;
0A59  01C8  	CLRF gbl_iTimer0FlashCounts

char iTimer0KeyCounts = 0;
0A5A  01C9  	CLRF gbl_iTimer0KeyCounts

char iFlashDigitOff = 0;
0A5B  01CA  	CLRF gbl_iFlashDigitOff

char iDigitToFlash = 8; // 8 = no digit to flash
0A5C  3008  	MOVLW 0x08
0A5D  00CB  	MOVWF gbl_iDigitToFlash


// Hold the upper and lower bytes from the ds18b20
char cTempH = 1;
0A5E  3001  	MOVLW 0x01
0A5F  00CC  	MOVWF gbl_cTempH

char cTempL = 70;
0A60  3046  	MOVLW 0x46
0A61  00CD  	MOVWF gbl_cTempL

signed int iTempOld = 0;
0A62  01B3  	CLRF gbl_iTempOld
0A63  01B4  	CLRF gbl_iTempOld+D'1'

//char iDecimalPosition = 2;

int giDS3231ValueBCD = 0x0000;
0A64  01B5  	CLRF gbl_giDS3231ValueBCD
0A65  01B6  	CLRF gbl_giDS3231ValueBCD+D'1'

char giDS3231ValueTruncCBCD = 0x00;
0A66  01CE  	CLRF gbl_giDS3231ValueTruncCBCD

char gbDS3231IsMinus = 0;
0A67  01CF  	CLRF gbl_gbDS3231IsMinus


char cTask = 0; // Used for task scheduler
0A68  01D0  	CLRF gbl_cTask


// States
bool gbFanOn = 0;
0A69  1051  	BCF gbl_gbFanOn,0

bool gbHeaterOn = 0;
0A6A  10D1  	BCF gbl_gbHeaterOn,1

char gcDisplayMode = 0;
0A6B  01D2  	CLRF gbl_gcDisplayMode

char gcSetMode = 0;
0A6C  01D3  	CLRF gbl_gcSetMode

char gcHourMode = 0;
0A6D  01D4  	CLRF gbl_gcHourMode

char gcTriggerMode = 0;
0A6E  01D5  	CLRF gbl_gcTriggerMode


// Triggers
char gBcdWhiteOnMinute = 0; // 0 to 59
0A6F  01D6  	CLRF gbl_gBcdWhiteOnMinute

char gBcdWhiteOnHour = 0; // 0 to 23
0A70  01D7  	CLRF gbl_gBcdWhiteOnHour

char gBcdWhiteOffMinute = 0; // 0 to 59
0A71  01D8  	CLRF gbl_gBcdWhiteOffMinute

char gBcdWhiteOffHour = 0; // 0 to 23
0A72  01D9  	CLRF gbl_gBcdWhiteOffHour


char gBcdBlueOnMinute = 0; // 0 to 59
0A73  01DA  	CLRF gbl_gBcdBlueOnMinute

char gBcdBlueOnHour = 0; // 0 to 23
0A74  01DB  	CLRF gbl_gBcdBlueOnHour

char gBcdBlueOffMinute = 0; // 0 to 59
0A75  01DC  	CLRF gbl_gBcdBlueOffMinute

char gBcdBlueOffHour = 0; // 0 to 23
0A76  01DD  	CLRF gbl_gBcdBlueOffHour


char gBcdBlue2OnMinute = 0; // 0 to 59
0A77  01DE  	CLRF gbl_gBcdBlue2OnMinute

char gBcdBlue2OnHour = 0; // 0 to 23
0A78  01DF  	CLRF gbl_gBcdBlue2OnHour

char gBcdBlue2OffMinute = 0; // 0 to 59
0A79  01E0  	CLRF gbl_gBcdBlue2OffMinute

char gBcdBlue2OffHour = 0; // 0 to 23
0A7A  01E1  	CLRF gbl_gBcdBlue2OffHour


char gBcdFanOnTemp = 0x28; // Degrees C
0A7B  3028  	MOVLW 0x28
0A7C  00E2  	MOVWF gbl_gBcdFanOnTemp

char gBcdFanOffTemp = 0x27; // Degrees C
0A7D  3027  	MOVLW 0x27
0A7E  00E3  	MOVWF gbl_gBcdFanOffTemp


char gBcdHeaterOnTemp = 0x24; // Degrees C
0A7F  3024  	MOVLW 0x24
0A80  00E4  	MOVWF gbl_gBcdHeaterOnTemp

char gBcdHeaterOffTemp = 0x25; // Degrees C
0A81  3025  	MOVLW 0x25
0A82  00E5  	MOVWF gbl_gBcdHeaterOffTemp


// Used to output the segments from numbers
char tm1638MaxDigits = 8;
0A83  3008  	MOVLW 0x08
0A84  00E6  	MOVWF gbl_tm1638MaxDigits

rom char *tm1638DisplayNumtoSeg = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F};
0A85  3002  	MOVLW 0x02
0A86  00E7  	MOVWF gbl_tm1638DisplayNumtoSeg

char tm1638Dot = 0x80;
0A87  3080  	MOVLW 0x80
0A88  00E8  	MOVWF gbl_tm1638Dot

char tm1638Brightness = 7; // 0 to 7
0A89  3007  	MOVLW 0x07
0A8A  00E9  	MOVWF gbl_tm1638Brightness

// 0x40 [01000000] = indicate command to display data
char tm1638ByteSetData = 0x40;
0A8B  3040  	MOVLW 0x40
0A8C  00EA  	MOVWF gbl_tm1638ByteSetData

// 0x42 [01000010] = indicate command to read data
char tm1638ByteReadData = 0x42;
0A8D  3042  	MOVLW 0x42
0A8E  00EB  	MOVWF gbl_tm1638ByteReadData

// 0xC0 [11000000] = write out all bytes
char tm1638ByteSetAddr = 0xC0;
0A8F  30C0  	MOVLW 0xC0
0A90  00EC  	MOVWF gbl_tm1638ByteSetAddr

// 0x88 [10001000] - Display ON, plus brightness
char tm1638ByteSetOn = 0x88;
0A91  3088  	MOVLW 0x88
0A92  00ED  	MOVWF gbl_tm1638ByteSetOn


// Copy of the data to write / on the display
char tm1638Data[] = {0, 0, 0, 0, 0, 0, 0, 0};
0A93  01A0  	CLRF gbl_tm1638Data
0A94  01A1  	CLRF gbl_tm1638Data+D'1'
0A95  01A2  	CLRF gbl_tm1638Data+D'2'
0A96  01A3  	CLRF gbl_tm1638Data+D'3'
0A97  01A4  	CLRF gbl_tm1638Data+D'4'
0A98  01A5  	CLRF gbl_tm1638Data+D'5'
0A99  01A6  	CLRF gbl_tm1638Data+D'6'
0A9A  01A7  	CLRF gbl_tm1638Data+D'7'

// Copy of the LED status
char tm1638LEDs[] = {0, 0, 0, 0, 0, 0, 0, 0};
0A9B  01A8  	CLRF gbl_tm1638LEDs
0A9C  01A9  	CLRF gbl_tm1638LEDs+D'1'
0A9D  01AA  	CLRF gbl_tm1638LEDs+D'2'
0A9E  01AB  	CLRF gbl_tm1638LEDs+D'3'
0A9F  01AC  	CLRF gbl_tm1638LEDs+D'4'
0AA0  01AD  	CLRF gbl_tm1638LEDs+D'5'
0AA1  01AE  	CLRF gbl_tm1638LEDs+D'6'
0AA2  01AF  	CLRF gbl_tm1638LEDs+D'7'

// Copy of the keys
char tm1638Keys = 0;
0AA3  01EE  	CLRF gbl_tm1638Keys

char tm1638KeysOld = 0;
0AA4  01EF  	CLRF gbl_tm1638KeysOld

// For printing
char iPrintStartDigit = 0;
0AA5  01F0  	CLRF gbl_iPrintStartDigit

char iPrintDotDigit = 8;
0AA6  3008  	MOVLW 0x08
0AA7  00F1  	MOVWF gbl_iPrintDotDigit

// For adjusting bcd numbers up 1 or down !1
char iBcdAdjustment = 1;
0AA8  3001  	MOVLW 0x01
0AA9  00F2  	MOVWF gbl_iBcdAdjustment


// DS18B20 functions
char oneWireIsPresent = 0;
0AAA  01F3  	CLRF gbl_oneWireIsPresent

char oneWireResetStage = 0;
0AAB  01F4  	CLRF gbl_oneWireResetStage

void oneWireBusReset();
void oneWireTxByte(char data);
void oneWireTxBytes(char data, char data2);
char oneWireRxByte();

// AT24C32 (EEPROM)
void at24c32WriteAll();
void at24c32ReadAll();

// DS3231 functions
void ds3231Write(char ds3231Reg, char bWrite);
void ds3231Init();
void ds3231Start();
void ds3231Stop();
void ds3231WriteDateTime();
void ds3231ReadDateTime();
char ds3231ReadRegister(char cRegAddress);

// TM1638 functions
void tm1638ByteWrite(char bWrite);
void tm1638DisplayOn();
void nibbleTo7Seg(char bNibble);
void bcdTo7Seg(char iBcdIn);
void zeroToBlank(char iDigit);
void tm1638UpdateDisplay();
void tm1638ReadKeys();

// General functions
int binToBcd(int iBin);
void convertTemp();
void startTemp();
void readTemp();

char bcdAdjust(char bcd, char bcdMax, char bcdMin);
void adjustDateTime();
void adjustTrigger();
void processKeys();

#endif

#include <system.h>
#include <i2c_driver.h>
#include "PIC16F_TM1638_AquariumControl.h"

//Target PIC16F628A configuration word
#pragma DATA _CONFIG, _BODEN_OFF & _PWRTE_ON & _WDT_OFF & _CP_OFF & _XT_OSC // Brown out reset off, Power-up Timer on, Watchdog timer off, Code Protection off, XT oscillator

//Set clock frequency (for software delays) - 4MHz
#pragma CLOCK_FREQ	4000000


/*********************************************************************************************
  void oneWireBusReset()
  First part of the reset routine - drive the bus low for 500us
*********************************************************************************************/
void oneWireBusReset() {

    char isPresent;
    oneWireTris = 1; // start with high
08D9  1683  	BSF STATUS, RP0
08DA  1303  	BCF STATUS, RP1
08DB  1687  	BSF gbl_trisc,5

    isPresent = 0;
08DC  1283  	BCF STATUS, RP0
08DD  01F5  	CLRF oneWireBus_00014_1_isPresent

    // Send the reset pulse - drive low for 500us
    oneWireBus = 0;
08DE  1287  	BCF gbl_portc,5

    oneWireTris = 0;
08DF  1683  	BSF STATUS, RP0
08E0  1287  	BCF gbl_trisc,5

    delay_10us(50);
08E1  3032  	MOVLW 0x32
08E2  1283  	BCF STATUS, RP0
08E3  00FA  	MOVWF delay_10us_00000_arg_del
08E4  118A  	BCF PCLATH,3
08E5  2079  	CALL delay_10us_00000

    // Release line and wait 70us for PD Pulse
    oneWireTris = 1;
08E6  1683  	BSF STATUS, RP0
08E7  1687  	BSF gbl_trisc,5

    delay_10us(7);
08E8  3007  	MOVLW 0x07
08E9  1283  	BCF STATUS, RP0
08EA  00FA  	MOVWF delay_10us_00000_arg_del
08EB  2079  	CALL delay_10us_00000

    // Now sample, if there is a sensor on the bus, the line should be low
    if (oneWireBus) {
08EC  1A87  	BTFSC gbl_portc,5

        oneWireIsPresent = 0; // no devices
08ED  01F3  	CLRF gbl_oneWireIsPresent

    }
    delay_10us(50);
08EE  3032  	MOVLW 0x32
08EF  00FA  	MOVWF delay_10us_00000_arg_del
08F0  2079  	CALL delay_10us_00000

}
08F1  0008  	RETURN


/*********************************************************************************************
  void oneWireTxByte(char data)
  Transmits a single byte from the bus
*********************************************************************************************/
void oneWireTxByte(char cData) {

    char cTemp = 1;
0183  3001  	MOVLW 0x01
0184  00F8  	MOVWF oneWireTxB_00015_1_cTemp

    // Loop through the eight bits in the byte
    for (char i = 0; i < 8; i++) {
0185  01F9  	CLRF oneWireTxB_00015_2_i
0186        label26
0186  3008  	MOVLW 0x08
0187  0279  	SUBWF oneWireTxB_00015_2_i, W
0188  1803  	BTFSC STATUS,C
019D  0AF9  	INCF oneWireTxB_00015_2_i, F
019E  2986  	GOTO	label26

        // Send the LSB first

        // Drive the line low initially for 3us
        oneWireTris = 0;
018A  1683  	BSF STATUS, RP0
018B  1287  	BCF gbl_trisc,5

        oneWireBus = 0;
018C  1283  	BCF STATUS, RP0
018D  1287  	BCF gbl_portc,5


        // Delay not needed for 4MHz PIC
        //delay_us(3); // Delay 3us

        if (cData & cTemp) {
018E  0878  	MOVF oneWireTxB_00015_1_cTemp, W
018F  0577  	ANDWF oneWireTxB_00015_arg_cData, W
0190  1903  	BTFSC STATUS,Z
0191  2994  	GOTO	label27

            oneWireTris = 1; // Release the bus
0192  1683  	BSF STATUS, RP0
0193  1687  	BSF gbl_trisc,5

        }

        delay_10us(5); // Delay 60us - 50us works fine with code delays
0194  3005  	MOVLW 0x05
0195  1283  	BCF STATUS, RP0
0196  00FA  	MOVWF delay_10us_00000_arg_del
0197  2079  	CALL delay_10us_00000

        oneWireTris = 1; // Release the bus
0198  1683  	BSF STATUS, RP0
0199  1687  	BSF gbl_trisc,5


        // move the test bit
        cTemp <<= 1;
019A  1003  	BCF STATUS,C
019B  1283  	BCF STATUS, RP0
019C  0DF8  	RLF oneWireTxB_00015_1_cTemp, F

    }
}
0189  0008  	RETURN


/*********************************************************************************************
  void oneWireTxBytes(char data, char data2)
  Transmits a 2 bytes from the bus
*********************************************************************************************/
void oneWireTxBytes(char cData, char cData2) {

    // Reset first - done in main
    //oneWireBusReset();
    // Send first byte
    oneWireTxByte(cData);
04CB  0875  	MOVF oneWireTxB_00016_arg_cData, W
04CC  00F7  	MOVWF oneWireTxB_00015_arg_cData
04CD  2183  	CALL oneWireTxB_00015

    // Send second byte
    oneWireTxByte(cData2);
04CE  0876  	MOVF oneWireTxB_00016_arg_cData2, W
04CF  00F7  	MOVWF oneWireTxB_00015_arg_cData
04D0  2183  	CALL oneWireTxB_00015

}
04D1  0008  	RETURN


/*********************************************************************************************
  char oneWireRxByte()
  Receives a single byte from the bus
*********************************************************************************************/
char oneWireRxByte() {

    char cDataIn = 0;
04D2  1283  	BCF STATUS, RP0
04D3  1303  	BCF STATUS, RP1
04D4  01F5  	CLRF oneWireRxB_00017_1_cDataIn

    // Loop through the eight bits in the byte
    for(char i = 0; i < 8; i++) {
04D5  01F6  	CLRF oneWireRxB_00017_2_i
04D6        label99
04D6  3008  	MOVLW 0x08
04D7  0276  	SUBWF oneWireRxB_00017_2_i, W
04D8  1803  	BTFSC STATUS,C
04D9  2CED  	GOTO	label100
04EB  0AF6  	INCF oneWireRxB_00017_2_i, F
04EC  2CD6  	GOTO	label99
04ED        label100

        // Bring bus low for 15us
        oneWireTris = 0;
04DA  1683  	BSF STATUS, RP0
04DB  1287  	BCF gbl_trisc,5

        oneWireBus = 0;
04DC  1283  	BCF STATUS, RP0
04DD  1287  	BCF gbl_portc,5


        // Delay not needed for 4MHz PIC
        //delay_us(15); // Delay 15us

        // Release bus for 6us, this is enough time for the slave to respond
        oneWireTris = 1;
04DE  1683  	BSF STATUS, RP0
04DF  1687  	BSF gbl_trisc,5

        delay_us(3); // Delay 6us
04E0  3003  	MOVLW 0x03
04E1  1283  	BCF STATUS, RP0
04E2  00FB  	MOVWF delay_us_00000_arg_del
04E3  2010  	CALL delay_us_00000


        // Shift data already received left
        cDataIn >>= 1;
04E4  1003  	BCF STATUS,C
04E5  0CF5  	RRF oneWireRxB_00017_1_cDataIn, F


        // Check the value of the onewire bus - set the MSB of cDataIn if so
        if (oneWireBus)
04E6  1A87  	BTFSC gbl_portc,5

            cDataIn.7 = 1;
04E7  17F5  	BSF oneWireRxB_00017_1_cDataIn,7


        // To finish time slot
        delay_10us(6); // 60us
04E8  3006  	MOVLW 0x06
04E9  00FA  	MOVWF delay_10us_00000_arg_del
04EA  2079  	CALL delay_10us_00000

    }

    return cDataIn;
04ED  0875  	MOVF oneWireRxB_00017_1_cDataIn, W
04EE  00F6  	MOVWF CompTempVarRet549

}
04EF  0008  	RETURN




/*********************************************************************************************
  void at24c32WriteAll()
  Write multiple bytes
  from https://www.instructables.com/The-Most-Comprehensive-Guide-to-Programming-the-AT/
*********************************************************************************************/
void at24c32WriteAll() {

	i2c_start();
0629  212A  	CALL i2c_START_00000

	i2c_write(at24c32Addr); // address + write
062A  30AE  	MOVLW 0xAE
062B  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
062C  20A9  	CALL i2c_WRITE_00000

	// start at address 0
	i2c_write(0); // First word address (only 4 bits of the 12 bit byte address)
062D  01F8  	CLRF i2c_WRITE_00000_arg_i2c_data
062E  20A9  	CALL i2c_WRITE_00000

	i2c_write(0); // Second word address
062F  01F8  	CLRF i2c_WRITE_00000_arg_i2c_data
0630  20A9  	CALL i2c_WRITE_00000

	// Write data bytes
	// We're only writing 18 bytes here, so no need to worry about row rollover after 32 bytes
	i2c_write(0x44); // To indicate AT24C32 has been written to
0631  3044  	MOVLW 0x44
0632  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
0633  20A9  	CALL i2c_WRITE_00000

	i2c_write(gBcdWhiteOnMinute);
0634  0856  	MOVF gbl_gBcdWhiteOnMinute, W
0635  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
0636  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOnHour);
0637  0857  	MOVF gbl_gBcdWhiteOnHour, W
0638  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
0639  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOffMinute);
063A  0858  	MOVF gbl_gBcdWhiteOffMinute, W
063B  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
063C  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOffHour);
063D  0859  	MOVF gbl_gBcdWhiteOffHour, W
063E  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
063F  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOnMinute);
0640  085A  	MOVF gbl_gBcdBlueOnMinute, W
0641  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
0642  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOnHour);
0643  085B  	MOVF gbl_gBcdBlueOnHour, W
0644  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
0645  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOffMinute);
0646  085C  	MOVF gbl_gBcdBlueOffMinute, W
0647  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
0648  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOffHour);
0649  085D  	MOVF gbl_gBcdBlueOffHour, W
064A  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
064B  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdFanOnTemp);
064C  0862  	MOVF gbl_gBcdFanOnTemp, W
064D  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
064E  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdFanOffTemp);
064F  0863  	MOVF gbl_gBcdFanOffTemp, W
0650  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
0651  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdHeaterOnTemp);
0652  0864  	MOVF gbl_gBcdHeaterOnTemp, W
0653  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
0654  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdHeaterOffTemp);
0655  0865  	MOVF gbl_gBcdHeaterOffTemp, W
0656  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
0657  20A9  	CALL i2c_WRITE_00000

    i2c_write(gcHourMode);
0658  0854  	MOVF gbl_gcHourMode, W
0659  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
065A  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlue2OnMinute);
065B  085E  	MOVF gbl_gBcdBlue2OnMinute, W
065C  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
065D  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlue2OnHour);
065E  085F  	MOVF gbl_gBcdBlue2OnHour, W
065F  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
0660  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlue2OffMinute);
0661  0860  	MOVF gbl_gBcdBlue2OffMinute, W
0662  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
0663  20A9  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlue2OffHour);
0664  0861  	MOVF gbl_gBcdBlue2OffHour, W
0665  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
0666  20A9  	CALL i2c_WRITE_00000

	i2c_stop();
0667  20FA  	CALL i2c_STOP_00000

	delay_ms(10); // Write Cycle Time
0668  300A  	MOVLW 0x0A
0669  00F6  	MOVWF delay_ms_00000_arg_del
066A  2083  	CALL delay_ms_00000

}
066B  0008  	RETURN


/*********************************************************************************************
  void at24c32ReadAll()
  Read all bytes
*********************************************************************************************/
void at24c32ReadAll() {

	i2c_start();
066C  212A  	CALL i2c_START_00000

	i2c_write(at24c32Addr); // address + write
066D  30AE  	MOVLW 0xAE
066E  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
066F  20A9  	CALL i2c_WRITE_00000

	// start at address 0
	i2c_write(0); // First word address (only 4 bits of the 12 bit byte address)
0670  01F8  	CLRF i2c_WRITE_00000_arg_i2c_data
0671  20A9  	CALL i2c_WRITE_00000

	i2c_write(0); // Second word address
0672  01F8  	CLRF i2c_WRITE_00000_arg_i2c_data
0673  20A9  	CALL i2c_WRITE_00000

	i2c_stop(); // Don't actually write a byte, just stop
0674  20FA  	CALL i2c_STOP_00000


	i2c_start();
0675  212A  	CALL i2c_START_00000

	i2c_write(at24c32Addr + 1); // address + read
0676  30AF  	MOVLW 0xAF
0677  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
0678  20A9  	CALL i2c_WRITE_00000

	char hasWritten = i2c_read(0); // ack
0679  01F8  	CLRF i2c_READ_00000_arg_ack_status
067A  21E2  	CALL i2c_READ_00000
067B  087B  	MOVF CompTempVarRet551, W
067C  00F6  	MOVWF at24c32Rea_00019_1_hasWritten

	if (hasWritten != 0x44) {
067D  0876  	MOVF at24c32Rea_00019_1_hasWritten, W
067E  3A44  	XORLW 0x44
067F  1903  	BTFSC STATUS,Z
0680  2E85  	GOTO	label110
0685        label110

		i2c_read(1); // nack
0681  3001  	MOVLW 0x01
0682  00F8  	MOVWF i2c_READ_00000_arg_ack_status
0683  21E2  	CALL i2c_READ_00000

	} else {
0684  2ECA  	GOTO	label111
06CA        label111

		gBcdWhiteOnMinute = i2c_read(0); // ack
0685  01F8  	CLRF i2c_READ_00000_arg_ack_status
0686  21E2  	CALL i2c_READ_00000
0687  087B  	MOVF CompTempVarRet551, W
0688  00D6  	MOVWF gbl_gBcdWhiteOnMinute

		gBcdWhiteOnHour = i2c_read(0); // ack
0689  01F8  	CLRF i2c_READ_00000_arg_ack_status
068A  21E2  	CALL i2c_READ_00000
068B  087B  	MOVF CompTempVarRet551, W
068C  00D7  	MOVWF gbl_gBcdWhiteOnHour

		gBcdWhiteOffMinute = i2c_read(0); // ack
068D  01F8  	CLRF i2c_READ_00000_arg_ack_status
068E  21E2  	CALL i2c_READ_00000
068F  087B  	MOVF CompTempVarRet551, W
0690  00D8  	MOVWF gbl_gBcdWhiteOffMinute

		gBcdWhiteOffHour = i2c_read(0); // ack
0691  01F8  	CLRF i2c_READ_00000_arg_ack_status
0692  21E2  	CALL i2c_READ_00000
0693  087B  	MOVF CompTempVarRet551, W
0694  00D9  	MOVWF gbl_gBcdWhiteOffHour

		gBcdBlueOnMinute = i2c_read(0); // ack
0695  01F8  	CLRF i2c_READ_00000_arg_ack_status
0696  21E2  	CALL i2c_READ_00000
0697  087B  	MOVF CompTempVarRet551, W
0698  00DA  	MOVWF gbl_gBcdBlueOnMinute

		gBcdBlueOnHour = i2c_read(0); // ack
0699  01F8  	CLRF i2c_READ_00000_arg_ack_status
069A  21E2  	CALL i2c_READ_00000
069B  087B  	MOVF CompTempVarRet551, W
069C  00DB  	MOVWF gbl_gBcdBlueOnHour

		gBcdBlueOffMinute = i2c_read(0); // ack
069D  01F8  	CLRF i2c_READ_00000_arg_ack_status
069E  21E2  	CALL i2c_READ_00000
069F  087B  	MOVF CompTempVarRet551, W
06A0  00DC  	MOVWF gbl_gBcdBlueOffMinute

		gBcdBlueOffHour = i2c_read(0); // ack
06A1  01F8  	CLRF i2c_READ_00000_arg_ack_status
06A2  21E2  	CALL i2c_READ_00000
06A3  087B  	MOVF CompTempVarRet551, W
06A4  00DD  	MOVWF gbl_gBcdBlueOffHour

		gBcdFanOnTemp = i2c_read(0); // ack
06A5  01F8  	CLRF i2c_READ_00000_arg_ack_status
06A6  21E2  	CALL i2c_READ_00000
06A7  087B  	MOVF CompTempVarRet551, W
06A8  00E2  	MOVWF gbl_gBcdFanOnTemp

		gBcdFanOffTemp = i2c_read(0); // ack
06A9  01F8  	CLRF i2c_READ_00000_arg_ack_status
06AA  21E2  	CALL i2c_READ_00000
06AB  087B  	MOVF CompTempVarRet551, W
06AC  00E3  	MOVWF gbl_gBcdFanOffTemp

		gBcdHeaterOnTemp = i2c_read(0); // ack
06AD  01F8  	CLRF i2c_READ_00000_arg_ack_status
06AE  21E2  	CALL i2c_READ_00000
06AF  087B  	MOVF CompTempVarRet551, W
06B0  00E4  	MOVWF gbl_gBcdHeaterOnTemp

		gBcdHeaterOffTemp = i2c_read(0); // ack
06B1  01F8  	CLRF i2c_READ_00000_arg_ack_status
06B2  21E2  	CALL i2c_READ_00000
06B3  087B  	MOVF CompTempVarRet551, W
06B4  00E5  	MOVWF gbl_gBcdHeaterOffTemp

		gcHourMode = i2c_read(0); // ack
06B5  01F8  	CLRF i2c_READ_00000_arg_ack_status
06B6  21E2  	CALL i2c_READ_00000
06B7  087B  	MOVF CompTempVarRet551, W
06B8  00D4  	MOVWF gbl_gcHourMode

		gBcdBlue2OnMinute = i2c_read(0); // ack
06B9  01F8  	CLRF i2c_READ_00000_arg_ack_status
06BA  21E2  	CALL i2c_READ_00000
06BB  087B  	MOVF CompTempVarRet551, W
06BC  00DE  	MOVWF gbl_gBcdBlue2OnMinute

		gBcdBlue2OnHour = i2c_read(0); // ack
06BD  01F8  	CLRF i2c_READ_00000_arg_ack_status
06BE  21E2  	CALL i2c_READ_00000
06BF  087B  	MOVF CompTempVarRet551, W
06C0  00DF  	MOVWF gbl_gBcdBlue2OnHour

		gBcdBlue2OffMinute = i2c_read(0); // ack
06C1  01F8  	CLRF i2c_READ_00000_arg_ack_status
06C2  21E2  	CALL i2c_READ_00000
06C3  087B  	MOVF CompTempVarRet551, W
06C4  00E0  	MOVWF gbl_gBcdBlue2OffMinute

		gBcdBlue2OffHour = i2c_read(1); // nack
06C5  3001  	MOVLW 0x01
06C6  00F8  	MOVWF i2c_READ_00000_arg_ack_status
06C7  21E2  	CALL i2c_READ_00000
06C8  087B  	MOVF CompTempVarRet551, W
06C9  00E1  	MOVWF gbl_gBcdBlue2OffHour

	}
	i2c_stop();
06CA  20FA  	CALL i2c_STOP_00000

}
06CB  0008  	RETURN



/*********************************************************************************************
  void ds3231Write(char ds3231Reg, char bWrite)
  Write one byte
*********************************************************************************************/
void ds3231Write(char ds3231Reg, char bWrite) {

	i2c_start();
0236  212A  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
0237  30D0  	MOVLW 0xD0
0238  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
0239  20A9  	CALL i2c_WRITE_00000

	i2c_write(ds3231Reg); // start at address
023A  0876  	MOVF ds3231Writ_0001A_arg_ds3231Reg, W
023B  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
023C  20A9  	CALL i2c_WRITE_00000

	i2c_write(bWrite); // start at address
023D  0877  	MOVF ds3231Writ_0001A_arg_bWrite, W
023E  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
023F  20A9  	CALL i2c_WRITE_00000

	i2c_stop();
0240  20FA  	CALL i2c_STOP_00000

}
0241  0008  	RETURN


/*********************************************************************************************
  void ds3231Init()
  Initialise the DS3231
  from https://github.com/adafruit/RTClib
*********************************************************************************************/
void ds3231Init() {

	/* control register 0Eh
    bit7 EOSC   Enable Oscillator (1 if oscillator must be stopped when on battery)
    bit6 BBSQW  Battery Backed Square Wave - 0 means square wave disabled when VCC falls below VPF (power fail voltage)
    bit5 CONV   Convert temperature (1 forces a conversion)
    bit4 RS2    Rate select - frequency of square wave output - NA for DS3231M
    bit3 RS1    Rate select - NA for DS3231M
    bit2 INTCN  Interrupt control (1 for use of the alarms and to disable square wave)
    bit1 A2IE   Alarm2 interrupt enable (1 to enable)
    bit0 A1IE   Alarm1 interrupt enable (1 to enable)
    */
	ds3231Write(0x0E, 0x00);
0534  300E  	MOVLW 0x0E
0535  1283  	BCF STATUS, RP0
0536  1303  	BCF STATUS, RP1
0537  00F6  	MOVWF ds3231Writ_0001A_arg_ds3231Reg
0538  01F7  	CLRF ds3231Writ_0001A_arg_bWrite
0539  2236  	CALL ds3231Writ_0001A

	/* Status Register 0Fh
    bit7 OSF     Oscillator stopped flag - clear oscillator stop flag at init
    bit3 EN32kHz Enable 32kHz Output - 0 for disabled
    bit2 BSY     Busy
    bit1 A2F     Alarm 2 Flag
    bit0 A1F     Alarm 1 Flag
    */
	ds3231Write(0x0F, 0x00);
053A  300F  	MOVLW 0x0F
053B  00F6  	MOVWF ds3231Writ_0001A_arg_ds3231Reg
053C  01F7  	CLRF ds3231Writ_0001A_arg_bWrite
053D  2236  	CALL ds3231Writ_0001A

}
053E  0008  	RETURN


/*********************************************************************************************
  void ds3231WriteDateTime()
  Write the date to the DS3231
*********************************************************************************************/
void ds3231WriteDateTime() {

	i2c_start();
0503  212A  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
0504  30D0  	MOVLW 0xD0
0505  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
0506  20A9  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
0507  01F8  	CLRF i2c_WRITE_00000_arg_i2c_data
0508  20A9  	CALL i2c_WRITE_00000

	i2c_write(0); // seconds
0509  01F8  	CLRF i2c_WRITE_00000_arg_i2c_data
050A  20A9  	CALL i2c_WRITE_00000

	i2c_write(gBcdMinute); // minutes
050B  0838  	MOVF gbl_gBcdMinute, W
050C  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
050D  20A9  	CALL i2c_WRITE_00000

	i2c_write(gBcdHour); // hours
050E  0839  	MOVF gbl_gBcdHour, W
050F  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
0510  20A9  	CALL i2c_WRITE_00000

	i2c_write(gDayOfWeek); // day of week
0511  083A  	MOVF gbl_gDayOfWeek, W
0512  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
0513  20A9  	CALL i2c_WRITE_00000

	i2c_write(gBcdDayOfMonth); // day of month
0514  083B  	MOVF gbl_gBcdDayOfMonth, W
0515  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
0516  20A9  	CALL i2c_WRITE_00000

	i2c_write(gBcdMonth); // month + century
0517  083C  	MOVF gbl_gBcdMonth, W
0518  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
0519  20A9  	CALL i2c_WRITE_00000

	i2c_write(gBcdYear); // year
051A  083D  	MOVF gbl_gBcdYear, W
051B  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
051C  20A9  	CALL i2c_WRITE_00000

	i2c_stop();
051D  20FA  	CALL i2c_STOP_00000

}
051E  0008  	RETURN


/*********************************************************************************************
  void ds3231ReadDateTime()
  Write the date to the DS3231
*********************************************************************************************/
void ds3231ReadDateTime() {

	i2c_start();
0931  118A  	BCF PCLATH,3
0932  212A  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
0933  30D0  	MOVLW 0xD0
0934  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
0935  20A9  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
0936  01F8  	CLRF i2c_WRITE_00000_arg_i2c_data
0937  20A9  	CALL i2c_WRITE_00000

	i2c_stop();
0938  20FA  	CALL i2c_STOP_00000


	i2c_start();
0939  212A  	CALL i2c_START_00000

	i2c_write(ds3231Addr + 1); // address + read
093A  30D1  	MOVLW 0xD1
093B  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
093C  20A9  	CALL i2c_WRITE_00000

	gBcdSecond = i2c_read(0); // ack
093D  01F8  	CLRF i2c_READ_00000_arg_ack_status
093E  21E2  	CALL i2c_READ_00000
093F  087B  	MOVF CompTempVarRet551, W
0940  00B7  	MOVWF gbl_gBcdSecond

	gBcdMinute = i2c_read(0); // ack
0941  01F8  	CLRF i2c_READ_00000_arg_ack_status
0942  21E2  	CALL i2c_READ_00000
0943  087B  	MOVF CompTempVarRet551, W
0944  00B8  	MOVWF gbl_gBcdMinute

	gBcdHour = i2c_read(0); // ack
0945  01F8  	CLRF i2c_READ_00000_arg_ack_status
0946  21E2  	CALL i2c_READ_00000
0947  087B  	MOVF CompTempVarRet551, W
0948  00B9  	MOVWF gbl_gBcdHour

	gDayOfWeek = i2c_read(0); // ack
0949  01F8  	CLRF i2c_READ_00000_arg_ack_status
094A  21E2  	CALL i2c_READ_00000
094B  087B  	MOVF CompTempVarRet551, W
094C  00BA  	MOVWF gbl_gDayOfWeek

	gBcdDayOfMonth = i2c_read(0); // ack
094D  01F8  	CLRF i2c_READ_00000_arg_ack_status
094E  21E2  	CALL i2c_READ_00000
094F  087B  	MOVF CompTempVarRet551, W
0950  00BB  	MOVWF gbl_gBcdDayOfMonth

	gBcdMonth = i2c_read(0); // ack
0951  01F8  	CLRF i2c_READ_00000_arg_ack_status
0952  21E2  	CALL i2c_READ_00000
0953  087B  	MOVF CompTempVarRet551, W
0954  00BC  	MOVWF gbl_gBcdMonth

	gBcdYear = i2c_read(1); // nack
0955  3001  	MOVLW 0x01
0956  00F8  	MOVWF i2c_READ_00000_arg_ack_status
0957  21E2  	CALL i2c_READ_00000
0958  087B  	MOVF CompTempVarRet551, W
0959  00BD  	MOVWF gbl_gBcdYear

	i2c_stop();
095A  20FA  	CALL i2c_STOP_00000

}
095B  0008  	RETURN


/*********************************************************************************************
  char ds3231ReadRegister(char cRegAddress)
  Read one byte from a given DS3231 register address
*********************************************************************************************/
char ds3231ReadRegister(char cRegAddress) {

	char cStatus;
	i2c_start();
051F  212A  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
0520  30D0  	MOVLW 0xD0
0521  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
0522  20A9  	CALL i2c_WRITE_00000

	i2c_write(cRegAddress); // start at requested address
0523  0876  	MOVF ds3231Read_0001D_arg_cRegAddress, W
0524  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
0525  20A9  	CALL i2c_WRITE_00000

	i2c_stop();
0526  20FA  	CALL i2c_STOP_00000


	i2c_start();
0527  212A  	CALL i2c_START_00000

	i2c_write(ds3231Addr + 1); // address + read
0528  30D1  	MOVLW 0xD1
0529  00F8  	MOVWF i2c_WRITE_00000_arg_i2c_data
052A  20A9  	CALL i2c_WRITE_00000

	cStatus = i2c_read(1); // read the byte, then nack
052B  3001  	MOVLW 0x01
052C  00F8  	MOVWF i2c_READ_00000_arg_ack_status
052D  21E2  	CALL i2c_READ_00000
052E  087B  	MOVF CompTempVarRet551, W
052F  00F7  	MOVWF ds3231Read_0001D_1_cStatus

    i2c_stop();
0530  20FA  	CALL i2c_STOP_00000

    return cStatus;
0531  0877  	MOVF ds3231Read_0001D_1_cStatus, W
0532  00F8  	MOVWF CompTempVarRet552

}
0533  0008  	RETURN




/*********************************************************************************************
  void tm1638ByteWrite(char bWrite)
  Write one byte
  from http://www.piclearning.net/280/pic-and-tm1638-ledkey-module.php
*********************************************************************************************/
void tm1638ByteWrite(char bWrite) {

    for (char i = 0; i < 8; i++) {
0170  01FA  	CLRF tm1638Byte_0001E_2_i
0171        label25
0171  3008  	MOVLW 0x08
0172  027A  	SUBWF tm1638Byte_0001E_2_i, W
0173  1803  	BTFSC STATUS,C
0181  0AFA  	INCF tm1638Byte_0001E_2_i, F
0182  2971  	GOTO	label25

        tm1638dio = (bWrite & 0x01);
0175  3001  	MOVLW 0x01
0176  0579  	ANDWF tm1638Byte_0001E_arg_bWrite, W
0177  00FB  	MOVWF CompTempVar553
0178  187B  	BTFSC CompTempVar553,0
0179  1486  	BSF gbl_portb,1
017A  1C7B  	BTFSS CompTempVar553,0
017B  1086  	BCF gbl_portb,1

        tm1638clk = 0;
017C  1106  	BCF gbl_portb,2

        bWrite = (bWrite >> 1);
017D  08F9  	MOVF tm1638Byte_0001E_arg_bWrite, F
017E  1003  	BCF STATUS,C
017F  0CF9  	RRF tm1638Byte_0001E_arg_bWrite, F

        tm1638clk = 1;
0180  1506  	BSF gbl_portb,2

    }
}
0174  0008  	RETURN


/*********************************************************************************************
  void tm1638DisplayOn()
  Turns the display on, with defined brightness
*********************************************************************************************/
void tm1638DisplayOn() {

    // Write 0x8F [10001000] to set display ON with pulse width 14/16
    tm1638strobe = 0;
04C3  1283  	BCF STATUS, RP0
04C4  1303  	BCF STATUS, RP1
04C5  1186  	BCF gbl_portb,3

    tm1638ByteWrite(0x88);
04C6  3088  	MOVLW 0x88
04C7  00F9  	MOVWF tm1638Byte_0001E_arg_bWrite
04C8  2170  	CALL tm1638Byte_0001E

    tm1638strobe = 1;
04C9  1586  	BSF gbl_portb,3

}
04CA  0008  	RETURN




/*********************************************************************************************
  void nibbleTo7Seg(char iNibble)
  Convert a single nibble into the 7-segment representation (two digits)
  7-segment digit to be written will be iPrintStartDigit, which is auto-incremented after
  If iPrintDotDigit matches, the dot on the display digit will be added
*********************************************************************************************/
void nibbleTo7Seg(char bNibble) {

	char s7SegDisplay = tm1638DisplayNumtoSeg[bNibble & 0x0F];
008F  0867  	MOVF gbl_tm1638DisplayNumtoSeg, W
0090  00FE  	MOVWF __rom_get_00000_arg_objNumb
0091  300F  	MOVLW 0x0F
0092  057C  	ANDWF nibbleTo7S_00020_arg_bNibble, W
0093  1683  	BSF STATUS, RP0
0094  00A0  	MOVWF __rom_get_00000_arg_idx
0095  201A  	CALL __rom_get_00000
0096  1283  	BCF STATUS, RP0
0097  00FD  	MOVWF nibbleTo7S_00020_1_s7SegDisplay

	if (iPrintStartDigit == iPrintDotDigit)
0098  0871  	MOVF gbl_iPrintDotDigit, W
0099  0670  	XORWF gbl_iPrintStartDigit, W
009A  118A  	BCF PCLATH,3
009B  120A  	BCF PCLATH,4
009C  1D03  	BTFSS STATUS,Z
009D  28A0  	GOTO	label10
00A0        label10

        s7SegDisplay |= tm1638Dot;
009E  0868  	MOVF gbl_tm1638Dot, W
009F  04FD  	IORWF nibbleTo7S_00020_1_s7SegDisplay, F

    tm1638Data[iPrintStartDigit] = s7SegDisplay;
00A0  1383  	BCF	STATUS,IRP
00A1  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
00A2  0084  	MOVWF FSR
00A3  0870  	MOVF gbl_iPrintStartDigit, W
00A4  0784  	ADDWF FSR, F
00A5  087D  	MOVF nibbleTo7S_00020_1_s7SegDisplay, W
00A6  0080  	MOVWF INDF

    iPrintStartDigit++;
00A7  0AF0  	INCF gbl_iPrintStartDigit, F

}
00A8  0008  	RETURN


/*********************************************************************************************
  void bcdTo7Seg(char iBcdIn)
  Convert a single bcd byte into the 7-segment representation (two digits)
*********************************************************************************************/
void bcdTo7Seg(char iBcdIn) {

    nibbleTo7Seg(iBcdIn >> 4);
0242  0E7B  	SWAPF bcdTo7Seg_00000_arg_iBcdIn, W
0243  390F  	ANDLW 0x0F
0244  00FC  	MOVWF nibbleTo7S_00020_arg_bNibble
0245  208F  	CALL nibbleTo7S_00020

    nibbleTo7Seg(iBcdIn);
0246  087B  	MOVF bcdTo7Seg_00000_arg_iBcdIn, W
0247  00FC  	MOVWF nibbleTo7S_00020_arg_bNibble
0248  208F  	CALL nibbleTo7S_00020

}
0249  0008  	RETURN


/*********************************************************************************************
  void zeroToBlank(char iDigit)
  For the given digit, change a zero to blank. Used for removing left filled zeroes
*********************************************************************************************/
void zeroToBlank(char iDigit) {

    // replace zero with blank
    if (tm1638Data[iDigit] == 0x3F)
015F  1383  	BCF	STATUS,IRP
0160  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
0161  0084  	MOVWF FSR
0162  087B  	MOVF zeroToBlan_00021_arg_iDigit, W
0163  0784  	ADDWF FSR, F
0164  0800  	MOVF INDF, W
0165  3A3F  	XORLW 0x3F
0166  1D03  	BTFSS STATUS,Z

        tm1638Data[iDigit] = 0;
0168  1383  	BCF	STATUS,IRP
0169  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
016A  0084  	MOVWF FSR
016B  087B  	MOVF zeroToBlan_00021_arg_iDigit, W
016C  0784  	ADDWF FSR, F
016D  3000  	MOVLW 0x00
016E  0080  	MOVWF INDF


}
0167  0008  	RETURN
016F  0008  	RETURN


/*********************************************************************************************
  void tm1638UpdateDisplay()
  Publish the tm1638Data and tm1638LEDs arrays to the display
*********************************************************************************************/
void tm1638UpdateDisplay() {


    // Display current temperature unless set, trigger or alt display mode is active
    if ((gcDisplayMode == 2) | gcSetMode | gcTriggerMode) {
029D  1283  	BCF STATUS, RP0
029E  1303  	BCF STATUS, RP1
029F  01F6  	CLRF CompTempVar559
02A0  3002  	MOVLW 0x02
02A1  0252  	SUBWF gbl_gcDisplayMode, W
02A2  1903  	BTFSC STATUS,Z
02A3  0AF6  	INCF CompTempVar559, F
02A4  0853  	MOVF gbl_gcSetMode, W
02A5  04F6  	IORWF CompTempVar559, F
02A6  0855  	MOVF gbl_gcTriggerMode, W
02A7  0476  	IORWF CompTempVar559, W
02A8  1903  	BTFSC STATUS,Z
02A9  2C0D  	GOTO	label81
040D        label81

        if (gcSetMode == 1) {
02AA  0353  	DECF gbl_gcSetMode, W
02AB  1D03  	BTFSS STATUS,Z
02AC  2AB9  	GOTO	label53
02B9        label53

            // Display year in the first 4 digits, for setting RTC year
            // Start printing from digit 0
            iDigitToFlash = 3; // 4th digit will flash
02AD  3003  	MOVLW 0x03
02AE  00CB  	MOVWF gbl_iDigitToFlash

            iPrintStartDigit = 0;
02AF  01F0  	CLRF gbl_iPrintStartDigit

            iPrintDotDigit = 3;
02B0  3003  	MOVLW 0x03
02B1  00F1  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(0x20); // Display 20 in digits 0 and 1 (no dot)
02B2  3020  	MOVLW 0x20
02B3  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02B4  2242  	CALL bcdTo7Seg_00000

            bcdTo7Seg(gBcdYear); // Display year in digits 2 and 3 (+dot on 3)
02B5  083D  	MOVF gbl_gBcdYear, W
02B6  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02B7  2242  	CALL bcdTo7Seg_00000

        } else if (gcSetMode == 4) {
02B8  2C3B  	GOTO	label84
02B9  0853  	MOVF gbl_gcSetMode, W
02BA  3A04  	XORLW 0x04
02BB  1D03  	BTFSS STATUS,Z
02BC  2AD1  	GOTO	label54
02D1        label54

            // Display day of week - 'day' followed by number 1 to 7 on 4th digit, for setting RTC day of week
            iDigitToFlash = 3; // 4th digit will flash
02BD  3003  	MOVLW 0x03
02BE  00CB  	MOVWF gbl_iDigitToFlash

            tm1638Data[0] = 0x5E; // d
02BF  305E  	MOVLW 0x5E
02C0  00A0  	MOVWF gbl_tm1638Data

            tm1638Data[1] = 0x5F; // a
02C1  305F  	MOVLW 0x5F
02C2  00A1  	MOVWF gbl_tm1638Data+D'1'

            tm1638Data[2] = 0x6E; // y
02C3  306E  	MOVLW 0x6E
02C4  00A2  	MOVWF gbl_tm1638Data+D'2'

            tm1638Data[3] = tm1638DisplayNumtoSeg[gDayOfWeek] + tm1638Dot;
02C5  0867  	MOVF gbl_tm1638DisplayNumtoSeg, W
02C6  00FE  	MOVWF __rom_get_00000_arg_objNumb
02C7  083A  	MOVF gbl_gDayOfWeek, W
02C8  1683  	BSF STATUS, RP0
02C9  00A0  	MOVWF __rom_get_00000_arg_idx
02CA  201A  	CALL __rom_get_00000
02CB  1283  	BCF STATUS, RP0
02CC  0768  	ADDWF gbl_tm1638Dot, W
02CD  00A3  	MOVWF gbl_tm1638Data+D'3'

        } else if (gcSetMode == 5) {
02CE  118A  	BCF PCLATH,3
02CF  120A  	BCF PCLATH,4
02D0  2C3B  	GOTO	label84
02D1  0853  	MOVF gbl_gcSetMode, W
02D2  3A05  	XORLW 0x05
02D3  1D03  	BTFSS STATUS,Z
02D4  2AE7  	GOTO	label57
02E7        label57

            // Display 24h or 12h setting in first 4 digits, for setting the time display preference
            iDigitToFlash = 1; // 2nd digit will flash
02D5  3001  	MOVLW 0x01
02D6  00CB  	MOVWF gbl_iDigitToFlash

            if (gcHourMode) {
02D7  08D4  	MOVF gbl_gcHourMode, F
02D8  1903  	BTFSC STATUS,Z
02D9  2ADF  	GOTO	label55
02DF        label55

				tm1638Data[0] = 0x06; // 1
02DA  3006  	MOVLW 0x06
02DB  00A0  	MOVWF gbl_tm1638Data

				tm1638Data[1] = 0x5B; // 2
02DC  305B  	MOVLW 0x5B
02DD  00A1  	MOVWF gbl_tm1638Data+D'1'

			} else {
02DE  2AE3  	GOTO	label56
02E3        label56

				tm1638Data[0] = 0x5B; // 2
02DF  305B  	MOVLW 0x5B
02E0  00A0  	MOVWF gbl_tm1638Data

				tm1638Data[1] = 0x66; // 4
02E1  3066  	MOVLW 0x66
02E2  00A1  	MOVWF gbl_tm1638Data+D'1'

			}
            tm1638Data[2] = 0x74; // h
02E3  3074  	MOVLW 0x74
02E4  00A2  	MOVWF gbl_tm1638Data+D'2'

            tm1638Data[3] = 0x00; // blank
02E5  01A3  	CLRF gbl_tm1638Data+D'3'

        } else if (gcTriggerMode) {
02E6  2C3B  	GOTO	label84
02E7  08D5  	MOVF gbl_gcTriggerMode, F
02E8  1903  	BTFSC STATUS,Z
02E9  2BE0  	GOTO	label74
03E0        label74

            // Show relevant display of trigger time or temperature
            iPrintDotDigit = 5;
02EA  3005  	MOVLW 0x05
02EB  00F1  	MOVWF gbl_iPrintDotDigit

            switch (gcTriggerMode) {
031D  2C3B  	GOTO	label84

                case 1:
02EC  0855  	MOVF gbl_gcTriggerMode, W
02ED  3A01  	XORLW 0x01
02EE  1903  	BTFSC STATUS,Z
02EF  2B1E  	GOTO	label58
031E        label58

                    // White LED on hour, shows as 'L On' followed by hh:mm with 6th digit flashing
                    tm1638Data[0] = 0x38; // L
031E  3038  	MOVLW 0x38
031F  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x00; // space
0320  01A1  	CLRF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x3F; // O
0321  303F  	MOVLW 0x3F
0322  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x54; // n
0323  3054  	MOVLW 0x54
0324  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
0325  3005  	MOVLW 0x05
0326  00CB  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
0327  3004  	MOVLW 0x04
0328  00F0  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOnHour); // Display hour in digits 4 and 5 (dot on 5)
0329  0857  	MOVF gbl_gBcdWhiteOnHour, W
032A  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
032B  2242  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdWhiteOnMinute); // Display minute in digits 6 and 7 (no dot)
032C  0856  	MOVF gbl_gBcdWhiteOnMinute, W
032D  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
032E  2242  	CALL bcdTo7Seg_00000

                    break;
032F  2C3B  	GOTO	label84

                case 2:
02F0  3A03  	XORLW 0x03
02F1  1903  	BTFSC STATUS,Z
02F2  2B30  	GOTO	label59
0330        label59

                    // White LED on minute, shows as 'L On' followed by hh:mm with 8th digit flashing
                    iDigitToFlash = 7;
0330  3007  	MOVLW 0x07
0331  00CB  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0332  3006  	MOVLW 0x06
0333  00F0  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOnMinute); // Display minute in digits 6 and 7 (no dot)
0334  0856  	MOVF gbl_gBcdWhiteOnMinute, W
0335  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0336  2242  	CALL bcdTo7Seg_00000

                    break;
0337  2C3B  	GOTO	label84

                case 3:
02F3  3A01  	XORLW 0x01
02F4  1903  	BTFSC STATUS,Z
02F5  2B38  	GOTO	label60
0338        label60

                    // White LED off hour, shows as 'L OF' followed by hh:mm with 6th digit flashing
                    tm1638Data[3] = 0x71; // F
0338  3071  	MOVLW 0x71
0339  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
033A  3005  	MOVLW 0x05
033B  00CB  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
033C  3004  	MOVLW 0x04
033D  00F0  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOffHour);
033E  0859  	MOVF gbl_gBcdWhiteOffHour, W
033F  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0340  2242  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdWhiteOffMinute); // Display minute in digits 6 and 7 (no dot)
0341  0858  	MOVF gbl_gBcdWhiteOffMinute, W
0342  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0343  2242  	CALL bcdTo7Seg_00000

                    break;
0344  2C3B  	GOTO	label84

                case 4:
02F6  3A07  	XORLW 0x07
02F7  1903  	BTFSC STATUS,Z
02F8  2B45  	GOTO	label61
0345        label61

                    // White LED off minute, shows as 'L OF' followed by hh:mm with 8th digit flashing
                    iDigitToFlash = 7;
0345  3007  	MOVLW 0x07
0346  00CB  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0347  3006  	MOVLW 0x06
0348  00F0  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOffMinute); // Display minute in digits 6 and 7 (no dot)
0349  0858  	MOVF gbl_gBcdWhiteOffMinute, W
034A  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
034B  2242  	CALL bcdTo7Seg_00000

                    break;
034C  2C3B  	GOTO	label84

                case 5:
02F9  3A01  	XORLW 0x01
02FA  1903  	BTFSC STATUS,Z
02FB  2B4D  	GOTO	label62
034D        label62

                    // 1st Blue LED on hour, shows as 'b1On' followed by hh:mm with 6th digit flashing
                    tm1638Data[0] = 0x7C; // b
034D  307C  	MOVLW 0x7C
034E  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x06; // 1
034F  3006  	MOVLW 0x06
0350  00A1  	MOVWF gbl_tm1638Data+D'1'

                    //tm1638Data[2] = 0x3F; // O
                    tm1638Data[3] = 0x54; // n
0351  3054  	MOVLW 0x54
0352  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
0353  3005  	MOVLW 0x05
0354  00CB  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
0355  3004  	MOVLW 0x04
0356  00F0  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOnHour); // Display hour in digits 4 and 5 (dot on 5)
0357  085B  	MOVF gbl_gBcdBlueOnHour, W
0358  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0359  2242  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlueOnMinute); // Display minute in digits 6 and 7 (no dot)
035A  085A  	MOVF gbl_gBcdBlueOnMinute, W
035B  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
035C  2242  	CALL bcdTo7Seg_00000

                    break;
035D  2C3B  	GOTO	label84

                case 6:
02FC  3A03  	XORLW 0x03
02FD  1903  	BTFSC STATUS,Z
02FE  2B5E  	GOTO	label63
035E        label63

                    // 1st Blue LED on minute, shows as 'b1On' followed by hh:mm with 8th digit flashing
                    iDigitToFlash = 7;
035E  3007  	MOVLW 0x07
035F  00CB  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0360  3006  	MOVLW 0x06
0361  00F0  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOnMinute); // Display minute in digits 6 and 7 (no dot)
0362  085A  	MOVF gbl_gBcdBlueOnMinute, W
0363  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0364  2242  	CALL bcdTo7Seg_00000

                    break;
0365  2C3B  	GOTO	label84

                case 7:
02FF  3A01  	XORLW 0x01
0300  1903  	BTFSC STATUS,Z
0301  2B66  	GOTO	label64
0366        label64

                    // 1st Blue LED off hour, shows as 'b1OF' followed by hh:mm with 6th digit flashing
                    tm1638Data[3] = 0x71; // F
0366  3071  	MOVLW 0x71
0367  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
0368  3005  	MOVLW 0x05
0369  00CB  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
036A  3004  	MOVLW 0x04
036B  00F0  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOffHour); // Display hour in digits 4 and 5 (dot on 5)
036C  085D  	MOVF gbl_gBcdBlueOffHour, W
036D  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
036E  2242  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlueOffMinute); // Display minute in digits 6 and 7 (no dot)
036F  085C  	MOVF gbl_gBcdBlueOffMinute, W
0370  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0371  2242  	CALL bcdTo7Seg_00000

                    break;
0372  2C3B  	GOTO	label84

                case 8:
0302  3A0F  	XORLW 0x0F
0303  1903  	BTFSC STATUS,Z
0304  2B73  	GOTO	label65
0373        label65

                    // 1st Blue LED off minute, shows as 'b1OF' followed by hh:mm with 8th digit flashing
                    iDigitToFlash = 7;
0373  3007  	MOVLW 0x07
0374  00CB  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0375  3006  	MOVLW 0x06
0376  00F0  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOffMinute); // Display minute in digits 6 and 7 (no dot)
0377  085C  	MOVF gbl_gBcdBlueOffMinute, W
0378  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0379  2242  	CALL bcdTo7Seg_00000

                    break;
037A  2C3B  	GOTO	label84

                case 9:
0305  3A01  	XORLW 0x01
0306  1903  	BTFSC STATUS,Z
0307  2B7B  	GOTO	label66
037B        label66

                    // 2nd Blue LED on hour, shows as 'b2On' followed by hh:mm with 6th digit flashing
                    tm1638Data[0] = 0x7C; // b
037B  307C  	MOVLW 0x7C
037C  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x5B; // 2
037D  305B  	MOVLW 0x5B
037E  00A1  	MOVWF gbl_tm1638Data+D'1'

                    //tm1638Data[2] = 0x3F; // O
                    tm1638Data[3] = 0x54; // n
037F  3054  	MOVLW 0x54
0380  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
0381  3005  	MOVLW 0x05
0382  00CB  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
0383  3004  	MOVLW 0x04
0384  00F0  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlue2OnHour); // Display hour in digits 4 and 5 (dot on 5)
0385  085F  	MOVF gbl_gBcdBlue2OnHour, W
0386  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0387  2242  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlue2OnMinute); // Display minute in digits 6 and 7 (no dot)
0388  085E  	MOVF gbl_gBcdBlue2OnMinute, W
0389  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
038A  2242  	CALL bcdTo7Seg_00000

                    break;
038B  2C3B  	GOTO	label84

                case 10:
0308  3A03  	XORLW 0x03
0309  1903  	BTFSC STATUS,Z
030A  2B8C  	GOTO	label67
038C        label67

                    // 2nd Blue LED on minute, shows as 'b2On' followed by hh:mm with 8th digit flashing
                    iDigitToFlash = 7;
038C  3007  	MOVLW 0x07
038D  00CB  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
038E  3006  	MOVLW 0x06
038F  00F0  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlue2OnMinute); // Display minute in digits 6 and 7 (no dot)
0390  085E  	MOVF gbl_gBcdBlue2OnMinute, W
0391  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0392  2242  	CALL bcdTo7Seg_00000

                    break;
0393  2C3B  	GOTO	label84

                case 11:
030B  3A01  	XORLW 0x01
030C  1903  	BTFSC STATUS,Z
030D  2B94  	GOTO	label68
0394        label68

                    // 2nd Blue LED off hour, shows as 'b2OF' followed by hh:mm with 6th digit flashing
                    tm1638Data[3] = 0x71; // F
0394  3071  	MOVLW 0x71
0395  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
0396  3005  	MOVLW 0x05
0397  00CB  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
0398  3004  	MOVLW 0x04
0399  00F0  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlue2OffHour); // Display hour in digits 4 and 5 (dot on 5)
039A  0861  	MOVF gbl_gBcdBlue2OffHour, W
039B  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
039C  2242  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlue2OffMinute); // Display minute in digits 6 and 7 (no dot)
039D  0860  	MOVF gbl_gBcdBlue2OffMinute, W
039E  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
039F  2242  	CALL bcdTo7Seg_00000

                    break;
03A0  2C3B  	GOTO	label84

                case 12:
030E  3A07  	XORLW 0x07
030F  1903  	BTFSC STATUS,Z
0310  2BA1  	GOTO	label69
03A1        label69

                    // 2nd Blue LED off minute, shows as 'b2OF' followed by hh:mm with 8th digit flashing
                    iDigitToFlash = 7;
03A1  3007  	MOVLW 0x07
03A2  00CB  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
03A3  3006  	MOVLW 0x06
03A4  00F0  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlue2OffMinute); // Display minute in digits 6 and 7 (no dot)
03A5  0860  	MOVF gbl_gBcdBlue2OffMinute, W
03A6  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03A7  2242  	CALL bcdTo7Seg_00000

                    break;
03A8  2C3B  	GOTO	label84

                case 13:
0311  3A01  	XORLW 0x01
0312  1903  	BTFSC STATUS,Z
0313  2BA9  	GOTO	label70
03A9        label70

                    // Fan on temperature, shows as 'Fan On' followed by nn (temperature in degrees C) with 8th digit flashing
                    tm1638Data[0] = 0x71; // F
03A9  3071  	MOVLW 0x71
03AA  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x5F; // a
03AB  305F  	MOVLW 0x5F
03AC  00A1  	MOVWF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x54; // n
03AD  3054  	MOVLW 0x54
03AE  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x00; // space
03AF  01A3  	CLRF gbl_tm1638Data+D'3'

                    tm1638Data[4] = 0x3F; // O
03B0  303F  	MOVLW 0x3F
03B1  00A4  	MOVWF gbl_tm1638Data+D'4'

                    tm1638Data[5] = 0x54; // n
03B2  3054  	MOVLW 0x54
03B3  00A5  	MOVWF gbl_tm1638Data+D'5'

                    iDigitToFlash = 7;
03B4  3007  	MOVLW 0x07
03B5  00CB  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
03B6  3006  	MOVLW 0x06
03B7  00F0  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdFanOnTemp); // Display celsius in digits 6 and 7 (no dot)
03B8  0862  	MOVF gbl_gBcdFanOnTemp, W
03B9  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03BA  2242  	CALL bcdTo7Seg_00000

                    break;
03BB  2C3B  	GOTO	label84

                case 14:
0314  3A03  	XORLW 0x03
0315  1903  	BTFSC STATUS,Z
0316  2BBC  	GOTO	label71
03BC        label71

                    // Fan off temperature, shows as 'Fan OF' followed by nn (temperature in degrees C) with 8th digit flashing
                    tm1638Data[5] = 0x71; // F
03BC  3071  	MOVLW 0x71
03BD  00A5  	MOVWF gbl_tm1638Data+D'5'

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
03BE  3006  	MOVLW 0x06
03BF  00F0  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdFanOffTemp); // Display celsius in digits 6 and 7 (no dot)
03C0  0863  	MOVF gbl_gBcdFanOffTemp, W
03C1  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03C2  2242  	CALL bcdTo7Seg_00000

                    break;
03C3  2C3B  	GOTO	label84

                case 15:
0317  3A01  	XORLW 0x01
0318  1903  	BTFSC STATUS,Z
0319  2BC4  	GOTO	label72
03C4        label72

                    // Heater on temperature, shows as 'HeatOn' followed by nn (temperature in degrees C) with 8th digit flashing
                    tm1638Data[0] = 0x76; // H
03C4  3076  	MOVLW 0x76
03C5  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x7B; // e
03C6  307B  	MOVLW 0x7B
03C7  00A1  	MOVWF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x5F; // a
03C8  305F  	MOVLW 0x5F
03C9  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x78; // t
03CA  3078  	MOVLW 0x78
03CB  00A3  	MOVWF gbl_tm1638Data+D'3'

                    tm1638Data[4] = 0x3F; // O
03CC  303F  	MOVLW 0x3F
03CD  00A4  	MOVWF gbl_tm1638Data+D'4'

                    tm1638Data[5] = 0x54; // n
03CE  3054  	MOVLW 0x54
03CF  00A5  	MOVWF gbl_tm1638Data+D'5'

                    iDigitToFlash = 7;
03D0  3007  	MOVLW 0x07
03D1  00CB  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
03D2  3006  	MOVLW 0x06
03D3  00F0  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdHeaterOnTemp); // Display celsius in digits 6 and 7 (no dot)
03D4  0864  	MOVF gbl_gBcdHeaterOnTemp, W
03D5  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03D6  2242  	CALL bcdTo7Seg_00000

                    break;
03D7  2C3B  	GOTO	label84

                case 16:
031A  3A1F  	XORLW 0x1F
031B  1903  	BTFSC STATUS,Z
031C  2BD8  	GOTO	label73
03D8        label73

                    // Heater off temperature, shows as 'HeatOF' followed by nn (temperature in degrees C) with 8th digit flashing
                    tm1638Data[5] = 0x71; // f
03D8  3071  	MOVLW 0x71
03D9  00A5  	MOVWF gbl_tm1638Data+D'5'

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
03DA  3006  	MOVLW 0x06
03DB  00F0  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdHeaterOffTemp); // Display celsius in digits 6 and 7 (no dot)
03DC  0865  	MOVF gbl_gBcdHeaterOffTemp, W
03DD  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03DE  2242  	CALL bcdTo7Seg_00000

                    break;
            }
        } else {
03DF  2C3B  	GOTO	label84

            // If in set mode, set the relevant digit to flash
            switch (gcSetMode) {
03FC        label80

                case 2:
03E0  0853  	MOVF gbl_gcSetMode, W
03E1  3A02  	XORLW 0x02
03E2  1903  	BTFSC STATUS,Z
03E3  2BEE  	GOTO	label75
03EE        label75

                    // Month
                    iDigitToFlash = 3;
03EE  3003  	MOVLW 0x03
03EF  00CB  	MOVWF gbl_iDigitToFlash

                    break;
03F0  2BFC  	GOTO	label80

                case 3:
03E4  3A01  	XORLW 0x01
03E5  1903  	BTFSC STATUS,Z
03E6  2BF1  	GOTO	label76
03F1        label76

                    // Day of month
                    iDigitToFlash = 1;
03F1  3001  	MOVLW 0x01
03F2  00CB  	MOVWF gbl_iDigitToFlash

                    break;
03F3  2BFC  	GOTO	label80

                case 6:
03E7  3A05  	XORLW 0x05
03E8  1903  	BTFSC STATUS,Z
03E9  2BF4  	GOTO	label77
03F4        label77

                    // Clock Hour
                    iDigitToFlash = 5;
03F4  3005  	MOVLW 0x05
03F5  00CB  	MOVWF gbl_iDigitToFlash

                    break;
03F6  2BFC  	GOTO	label80

                case 7:
03EA  3A01  	XORLW 0x01
03EB  1903  	BTFSC STATUS,Z
03EC  2BF7  	GOTO	label78
03F7        label78

                    // Clock Minute
                    iDigitToFlash = 7;
03F7  3007  	MOVLW 0x07
03F8  00CB  	MOVWF gbl_iDigitToFlash

                    break;
03F9  2BFC  	GOTO	label80

                default:
03ED  2BFA  	GOTO	label79
03FA        label79

                    iDigitToFlash = 8; // digit no flashing
03FA  3008  	MOVLW 0x08
03FB  00CB  	MOVWF gbl_iDigitToFlash

            }
            // Display date in DD.MM format when in set mode or gcDisplayMode = 2
            iPrintStartDigit = 0;
03FC  01F0  	CLRF gbl_iPrintStartDigit

            iPrintDotDigit = 1;
03FD  3001  	MOVLW 0x01
03FE  00F1  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(gBcdDayOfMonth); // Display day of month in digits 0 and 1 (+dot on 1)
03FF  083B  	MOVF gbl_gBcdDayOfMonth, W
0400  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0401  2242  	CALL bcdTo7Seg_00000

            zeroToBlank(0); // left fill zero with blank
0402  01FB  	CLRF zeroToBlan_00021_arg_iDigit
0403  215F  	CALL zeroToBlan_00021


            iPrintDotDigit = 3;
0404  3003  	MOVLW 0x03
0405  00F1  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(gBcdMonth); // Display month in digits 2 and 3 (+dot on 3)
0406  083C  	MOVF gbl_gBcdMonth, W
0407  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0408  2242  	CALL bcdTo7Seg_00000

            zeroToBlank(2); // left fill zero with blank
0409  3002  	MOVLW 0x02
040A  00FB  	MOVWF zeroToBlan_00021_arg_iDigit
040B  215F  	CALL zeroToBlan_00021

        }
    } else {
040C  2C3B  	GOTO	label84

        iDigitToFlash = 8; // No flashing digit in normal mode
040D  3008  	MOVLW 0x08
040E  00CB  	MOVWF gbl_iDigitToFlash

        // translate DS3231 temperature to digit values
        iPrintDotDigit = 1;
040F  3001  	MOVLW 0x01
0410  00F1  	MOVWF gbl_iPrintDotDigit

        if (gcDisplayMode == 1) // no dot on the first two digits for fahrenheit
0411  0352  	DECF gbl_gcDisplayMode, W
0412  1D03  	BTFSS STATUS,Z
0413  2C16  	GOTO	label82
0416        label82

			iPrintDotDigit = 2;
0414  3002  	MOVLW 0x02
0415  00F1  	MOVWF gbl_iPrintDotDigit

        // For -10 or below, shift digits right
        if (gbDS3231IsMinus && (giDS3231ValueBCD & 0xF000)) {
0416  08CF  	MOVF gbl_gbDS3231IsMinus, F
0417  1903  	BTFSC STATUS,Z
0418  2C2B  	GOTO	label83
0419  30F0  	MOVLW 0xF0
041A  0536  	ANDWF gbl_giDS3231ValueBCD+D'1', W
041B  1903  	BTFSC STATUS,Z
041C  2C2B  	GOTO	label83
042B        label83

            giDS3231ValueBCD >>= 4;
041D  0D36  	RLF gbl_giDS3231ValueBCD+D'1', W
041E  0CB6  	RRF gbl_giDS3231ValueBCD+D'1', F
041F  0CB5  	RRF gbl_giDS3231ValueBCD, F
0420  0D36  	RLF gbl_giDS3231ValueBCD+D'1', W
0421  0CB6  	RRF gbl_giDS3231ValueBCD+D'1', F
0422  0CB5  	RRF gbl_giDS3231ValueBCD, F
0423  0D36  	RLF gbl_giDS3231ValueBCD+D'1', W
0424  0CB6  	RRF gbl_giDS3231ValueBCD+D'1', F
0425  0CB5  	RRF gbl_giDS3231ValueBCD, F
0426  0D36  	RLF gbl_giDS3231ValueBCD+D'1', W
0427  0CB6  	RRF gbl_giDS3231ValueBCD+D'1', F
0428  0CB5  	RRF gbl_giDS3231ValueBCD, F

            iPrintDotDigit = 2;
0429  3002  	MOVLW 0x02
042A  00F1  	MOVWF gbl_iPrintDotDigit

        }
        // Display current temperature in digits 0 to 3 (+dot on digit 1 and 3)
        iPrintStartDigit = 0;
042B  01F0  	CLRF gbl_iPrintStartDigit

        bcdTo7Seg(giDS3231ValueBCD >> 8);
042C  0836  	MOVF gbl_giDS3231ValueBCD+D'1', W
042D  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
042E  2242  	CALL bcdTo7Seg_00000

        bcdTo7Seg(giDS3231ValueBCD);
042F  0835  	MOVF gbl_giDS3231ValueBCD, W
0430  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0431  2242  	CALL bcdTo7Seg_00000

        // Also display dot on 4th digit (always)
		tm1638Data[3] |= tm1638Dot;
0432  0868  	MOVF gbl_tm1638Dot, W
0433  04A3  	IORWF gbl_tm1638Data+D'3', F

        // left fill zero with blank (1st digit)
        zeroToBlank(0);
0434  01FB  	CLRF zeroToBlan_00021_arg_iDigit
0435  215F  	CALL zeroToBlan_00021

        // If minus, overwrite left most digit with minus sign
        if (gbDS3231IsMinus)
0436  08CF  	MOVF gbl_gbDS3231IsMinus, F
0437  1903  	BTFSC STATUS,Z
0438  2C3B  	GOTO	label84
043B        label84

            tm1638Data[0] = 0x40;
0439  3040  	MOVLW 0x40
043A  00A0  	MOVWF gbl_tm1638Data

    }

    // Display clock HH.MM in last 4 digits of TM1638 (unless in trigger mode)
    if (!gcTriggerMode) {
043B  08D5  	MOVF gbl_gcTriggerMode, F
043C  1D03  	BTFSS STATUS,Z
043D  2C75  	GOTO	label90
0475        label90

        // Flash dot every second
        if (gBcdSecond.0)
043E  1C37  	BTFSS gbl_gBcdSecond,0
043F  2C43  	GOTO	label85
0443        label85

			iPrintDotDigit = 5;
0440  3005  	MOVLW 0x05
0441  00F1  	MOVWF gbl_iPrintDotDigit

		else
0442  2C45  	GOTO	label86
0445        label86

			iPrintDotDigit = 8;
0443  3008  	MOVLW 0x08
0444  00F1  	MOVWF gbl_iPrintDotDigit


        char cBcdHourDisp = gBcdHour;
0445  0839  	MOVF gbl_gBcdHour, W
0446  00FA  	MOVWF tm1638Upda_00022_198_cBcdH_00024

        // 12h clock handling - convert from 24h
        if (gcHourMode && (gBcdHour > 0x12)) {
0447  08D4  	MOVF gbl_gcHourMode, F
0448  1903  	BTFSC STATUS,Z
0449  2C59  	GOTO	label87
044A  0839  	MOVF gbl_gBcdHour, W
044B  3C12  	SUBLW 0x12
044C  1803  	BTFSC STATUS,C
044D  2C59  	GOTO	label87

			// convert to 12h
			cBcdHourDisp -= 0x12;
044E  3012  	MOVLW 0x12
044F  02FA  	SUBWF tm1638Upda_00022_198_cBcdH_00024, F

			// For 8 and 9pm, take off another 6
			if ((cBcdHourDisp & 0x0F) > 7)
0450  300F  	MOVLW 0x0F
0451  057A  	ANDWF tm1638Upda_00022_198_cBcdH_00024, W
0452  00FB  	MOVWF CompTempVar599
0453  087B  	MOVF CompTempVar599, W
0454  3C07  	SUBLW 0x07
0455  1803  	BTFSC STATUS,C
0456  2C59  	GOTO	label87
0459        label87

                cBcdHourDisp -= 6;
0457  3006  	MOVLW 0x06
0458  02FA  	SUBWF tm1638Upda_00022_198_cBcdH_00024, F

        }
        if (gcHourMode && gBcdHour == 0) {
0459  08D4  	MOVF gbl_gcHourMode, F
045A  1903  	BTFSC STATUS,Z
045B  2C61  	GOTO	label88
045C  08B9  	MOVF gbl_gBcdHour, F
045D  1D03  	BTFSS STATUS,Z
045E  2C61  	GOTO	label88
0461        label88

			cBcdHourDisp = 0x12; // 12am
045F  3012  	MOVLW 0x12
0460  00FA  	MOVWF tm1638Upda_00022_198_cBcdH_00024

        }
        iPrintStartDigit = 4;
0461  3004  	MOVLW 0x04
0462  00F0  	MOVWF gbl_iPrintStartDigit

        bcdTo7Seg(cBcdHourDisp); // Display hour in digits 4 and 5 (dot on 5)
0463  087A  	MOVF tm1638Upda_00022_198_cBcdH_00024, W
0464  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0465  2242  	CALL bcdTo7Seg_00000

        // left fill zero with blank (for 5th digit)
        zeroToBlank(4);
0466  3004  	MOVLW 0x04
0467  00FB  	MOVWF zeroToBlan_00021_arg_iDigit
0468  215F  	CALL zeroToBlan_00021

        if (gcHourMode && (gBcdHour > 0x11)) {
0469  08D4  	MOVF gbl_gcHourMode, F
046A  1903  	BTFSC STATUS,Z
046B  2C72  	GOTO	label89
046C  0839  	MOVF gbl_gBcdHour, W
046D  3C11  	SUBLW 0x11
046E  1803  	BTFSC STATUS,C
046F  2C72  	GOTO	label89
0472        label89

			// PM dot
			iPrintDotDigit = 7;
0470  3007  	MOVLW 0x07
0471  00F1  	MOVWF gbl_iPrintDotDigit

        }
        bcdTo7Seg(gBcdMinute); // Display minute in digits 6 and 7 (no dot)
0472  0838  	MOVF gbl_gBcdMinute, W
0473  00FB  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0474  2242  	CALL bcdTo7Seg_00000

    }

    // Light LED for set mode
    char cCompareSetMode = gcSetMode;
0475  0853  	MOVF gbl_gcSetMode, W
0476  00F7  	MOVWF tm1638Upda_00022_1_cCompar_00023

    for (char i = 2; i < 8; i++) {
0477  3002  	MOVLW 0x02
0478  00F9  	MOVWF tm1638Upda_00022_3_i
0479        label91
0479  3008  	MOVLW 0x08
047A  0279  	SUBWF tm1638Upda_00022_3_i, W
047B  1803  	BTFSC STATUS,C
047C  2C92  	GOTO	label94
0490  0AF9  	INCF tm1638Upda_00022_3_i, F
0491  2C79  	GOTO	label91
0492        label94

        if (i == cCompareSetMode)
047D  0877  	MOVF tm1638Upda_00022_1_cCompar_00023, W
047E  0679  	XORWF tm1638Upda_00022_3_i, W
047F  1D03  	BTFSS STATUS,Z
0480  2C89  	GOTO	label92
0489        label92

            tm1638LEDs[i] = 1;
0481  1383  	BCF	STATUS,IRP
0482  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
0483  0084  	MOVWF FSR
0484  0879  	MOVF tm1638Upda_00022_3_i, W
0485  0784  	ADDWF FSR, F
0486  3001  	MOVLW 0x01
0487  0080  	MOVWF INDF

        else
0488  2C90  	GOTO	label93
0490        label93

            tm1638LEDs[i] = 0;
0489  1383  	BCF	STATUS,IRP
048A  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
048B  0084  	MOVWF FSR
048C  0879  	MOVF tm1638Upda_00022_3_i, W
048D  0784  	ADDWF FSR, F
048E  3000  	MOVLW 0x00
048F  0080  	MOVWF INDF

    }
    tm1638LEDs[0] = HEATER; // Light 1st LED if the heater is on
0492  01A8  	CLRF gbl_tm1638LEDs
0493  1805  	BTFSC gbl_porta,0
0494  0AA8  	INCF gbl_tm1638LEDs, F

    tm1638LEDs[1] = FAN; // Light 2nd LED if the fans are on
0495  01A9  	CLRF gbl_tm1638LEDs+D'1'
0496  1885  	BTFSC gbl_porta,1
0497  0AA9  	INCF gbl_tm1638LEDs+D'1', F


    // Now we have the data for the LED 7-segment display and LEDs, push these to the TM1638

    // Write 0x40 [01000000] (table 5.1) to indicate command to display data - [Write data to display register]
    tm1638strobe = 0;
0498  1186  	BCF gbl_portb,3

    tm1638ByteWrite(tm1638ByteSetData);
0499  086A  	MOVF gbl_tm1638ByteSetData, W
049A  00F9  	MOVWF tm1638Byte_0001E_arg_bWrite
049B  2170  	CALL tm1638Byte_0001E

    tm1638strobe = 1;
049C  1586  	BSF gbl_portb,3


    // Specify the display address 0xC0 [11000000] (table 5.2) [Display address 00H] then write out all 16 bytes
    tm1638strobe = 0;
049D  1186  	BCF gbl_portb,3

    tm1638ByteWrite(tm1638ByteSetAddr);
049E  086C  	MOVF gbl_tm1638ByteSetAddr, W
049F  00F9  	MOVWF tm1638Byte_0001E_arg_bWrite
04A0  2170  	CALL tm1638Byte_0001E

    for (char i = 0; i < tm1638MaxDigits; i++) {
04A1  01F8  	CLRF tm1638Upda_00022_2_i
04A2        label95
04A2  0866  	MOVF gbl_tm1638MaxDigits, W
04A3  0278  	SUBWF tm1638Upda_00022_2_i, W
04A4  1803  	BTFSC STATUS,C
04A5  2CC1  	GOTO	label98
04BF  0AF8  	INCF tm1638Upda_00022_2_i, F
04C0  2CA2  	GOTO	label95
04C1        label98

        // display 7-segment digit first
        // If flashing the digit, alternate a blank output
        if (iFlashDigitOff.0 && (i == iDigitToFlash))
04A6  1C4A  	BTFSS gbl_iFlashDigitOff,0
04A7  2CAF  	GOTO	label96
04A8  084B  	MOVF gbl_iDigitToFlash, W
04A9  0678  	XORWF tm1638Upda_00022_2_i, W
04AA  1D03  	BTFSS STATUS,Z
04AB  2CAF  	GOTO	label96
04AF        label96

            tm1638ByteWrite(0);
04AC  01F9  	CLRF tm1638Byte_0001E_arg_bWrite
04AD  2170  	CALL tm1638Byte_0001E

        else
04AE  2CB7  	GOTO	label97
04B7        label97

            tm1638ByteWrite(tm1638Data[i]);
04AF  1383  	BCF	STATUS,IRP
04B0  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
04B1  0084  	MOVWF FSR
04B2  0878  	MOVF tm1638Upda_00022_2_i, W
04B3  0784  	ADDWF FSR, F
04B4  0800  	MOVF INDF, W
04B5  00F9  	MOVWF tm1638Byte_0001E_arg_bWrite
04B6  2170  	CALL tm1638Byte_0001E

        // then LED
        tm1638ByteWrite(tm1638LEDs[i]);
04B7  1383  	BCF	STATUS,IRP
04B8  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
04B9  0084  	MOVWF FSR
04BA  0878  	MOVF tm1638Upda_00022_2_i, W
04BB  0784  	ADDWF FSR, F
04BC  0800  	MOVF INDF, W
04BD  00F9  	MOVWF tm1638Byte_0001E_arg_bWrite
04BE  2170  	CALL tm1638Byte_0001E

    }
    tm1638strobe = 1;
04C1  1586  	BSF gbl_portb,3

}
04C2  0008  	RETURN


/*********************************************************************************************
  void tm1638ReadKeys()
  Reads the keys status into tm1638Keys
  from http://www.piclearning.net/280/pic-and-tm1638-ledkey-module.php
*********************************************************************************************/
void tm1638ReadKeys() {

    // Write 0x42 [01000010] to indicate command to read data
    tm1638strobe = 0;
082C  1283  	BCF STATUS, RP0
082D  1303  	BCF STATUS, RP1
082E  1186  	BCF gbl_portb,3

    tm1638ByteWrite(tm1638ByteReadData);
082F  086B  	MOVF gbl_tm1638ByteReadData, W
0830  00F9  	MOVWF tm1638Byte_0001E_arg_bWrite
0831  118A  	BCF PCLATH,3
0832  2170  	CALL tm1638Byte_0001E


    tm1638dioTris = 1; // Set data pin to input
0833  1683  	BSF STATUS, RP0
0834  1486  	BSF gbl_trisb,1

    char tm1638KeysTemp = 32;
0835  3020  	MOVLW 0x20
0836  1283  	BCF STATUS, RP0
0837  00F6  	MOVWF tm1638Read_00025_1_tm1638K_00026

    // Read 4 bytes
    for (char i = 0; i < 32; i++) {
0838  01F7  	CLRF tm1638Read_00025_2_i
0839        label141
0839  3020  	MOVLW 0x20
083A  0277  	SUBWF tm1638Read_00025_2_i, W
083B  158A  	BSF PCLATH,3
083C  1803  	BTFSC STATUS,C
083D  284C  	GOTO	label143
084A  0AF7  	INCF tm1638Read_00025_2_i, F
084B  2839  	GOTO	label141
084C        label143

        tm1638KeysTemp--;
083E  03F6  	DECF tm1638Read_00025_1_tm1638K_00026, F

        tm1638clk = 0;
083F  1106  	BCF gbl_portb,2

        delay_us(1);
0840  3001  	MOVLW 0x01
0841  00FB  	MOVWF delay_us_00000_arg_del
0842  118A  	BCF PCLATH,3
0843  2010  	CALL delay_us_00000

        if(tm1638dio)
0844  158A  	BSF PCLATH,3
0845  1C86  	BTFSS gbl_portb,1
0846  2849  	GOTO	label142
0849        label142

            tm1638KeysTemp <<= 1;
0847  1003  	BCF STATUS,C
0848  0DF6  	RLF tm1638Read_00025_1_tm1638K_00026, F

        tm1638clk = 1;
0849  1506  	BSF gbl_portb,2

    }
    tm1638dioTris = 0; // Set data pin to output
084C  1683  	BSF STATUS, RP0
084D  1086  	BCF gbl_trisb,1

    tm1638strobe = 1;
084E  1283  	BCF STATUS, RP0
084F  1586  	BSF gbl_portb,3


    tm1638Keys = tm1638KeysTemp;
0850  0876  	MOVF tm1638Read_00025_1_tm1638K_00026, W
0851  00EE  	MOVWF gbl_tm1638Keys

    /*
    1F = 0001 1111
	17 = 0001 0111
	0F = 0000 1111
	07 = 0000 0111
	1B = 0001 1011
	13 = 0001 0011
	0B = 0000 1011
	03 = 0000 0111
	*/
}
0852  0008  	RETURN


/*********************************************************************************************
  int intToBcd(int iValue)
  Used to split the 16 bit integer into bcd parts (max 9999)
*********************************************************************************************/
int intToBcd(int iValue) {

    int iBcdOut = 0;
019F  01A2  	CLRF intToBcd_00000_1_iBcdOut
01A0  01A3  	CLRF intToBcd_00000_1_iBcdOut+D'1'

    // Split via loops = less program memory needed, may be slower executing
    // https://electronics.stackexchange.com/questions/158563/how-to-split-a-floating-point-number-into-individual-digits
    iBcdOut = 0;
01A1  01A2  	CLRF intToBcd_00000_1_iBcdOut
01A2  01A3  	CLRF intToBcd_00000_1_iBcdOut+D'1'


    // incrementing variables for each digit
    // determine to thousands digit
    while (iValue >= 1000) {
01A3        label28
01A3  3003  	MOVLW 0x03
01A4  0221  	SUBWF intToBcd_00000_arg_iValue+D'1', W
01A5  1D03  	BTFSS STATUS,Z
01A6  29A9  	GOTO	label29
01A7  30E8  	MOVLW 0xE8
01A8  0220  	SUBWF intToBcd_00000_arg_iValue, W
01A9        label29
01A9  1C03  	BTFSS STATUS,C
01AA  29B6  	GOTO	label30
01AB  1BA1  	BTFSC intToBcd_00000_arg_iValue+D'1',7
01AC  29B6  	GOTO	label30
01B5  29A3  	GOTO	label28
01B6        label30

        iValue -= 1000;
01AD  30E8  	MOVLW 0xE8
01AE  02A0  	SUBWF intToBcd_00000_arg_iValue, F
01AF  3003  	MOVLW 0x03
01B0  1C03  	BTFSS STATUS,C
01B1  03A1  	DECF intToBcd_00000_arg_iValue+D'1', F
01B2  02A1  	SUBWF intToBcd_00000_arg_iValue+D'1', F

        // each time we take off 1000, the digit is incremented
        iBcdOut += 0x1000;
01B3  3010  	MOVLW 0x10
01B4  07A3  	ADDWF intToBcd_00000_1_iBcdOut+D'1', F

    }

    // determine to hundreds digit
    while (iValue >= 100) {
01B6  0821  	MOVF intToBcd_00000_arg_iValue+D'1', W
01B7  3A80  	XORLW 0x80
01B8  00A4  	MOVWF CompTempVar645
01B9  3080  	MOVLW 0x80
01BA  0224  	SUBWF CompTempVar645, W
01BB  1D03  	BTFSS STATUS,Z
01BC  29BF  	GOTO	label31
01BD  3064  	MOVLW 0x64
01BE  0220  	SUBWF intToBcd_00000_arg_iValue, W
01BF        label31
01BF  1C03  	BTFSS STATUS,C
01C0  29C7  	GOTO	label32
01C6  29B6  	GOTO	label30
01C7        label32

        iValue -= 100;
01C1  3064  	MOVLW 0x64
01C2  02A0  	SUBWF intToBcd_00000_arg_iValue, F
01C3  1C03  	BTFSS STATUS,C
01C4  03A1  	DECF intToBcd_00000_arg_iValue+D'1', F

        // each time we take off 100, the digit is incremented
        iBcdOut += 0x100;
01C5  0AA3  	INCF intToBcd_00000_1_iBcdOut+D'1', F

    }

    // determine to tens digit
    while (iValue >= 10) {
01C7  0821  	MOVF intToBcd_00000_arg_iValue+D'1', W
01C8  3A80  	XORLW 0x80
01C9  00A4  	MOVWF CompTempVar646
01CA  3080  	MOVLW 0x80
01CB  0224  	SUBWF CompTempVar646, W
01CC  1D03  	BTFSS STATUS,Z
01CD  29D0  	GOTO	label33
01CE  300A  	MOVLW 0x0A
01CF  0220  	SUBWF intToBcd_00000_arg_iValue, W
01D0        label33
01D0  1C03  	BTFSS STATUS,C
01D1  29DB  	GOTO	label34
01DA  29C7  	GOTO	label32
01DB        label34

        iValue -= 10;
01D2  300A  	MOVLW 0x0A
01D3  02A0  	SUBWF intToBcd_00000_arg_iValue, F
01D4  1C03  	BTFSS STATUS,C
01D5  03A1  	DECF intToBcd_00000_arg_iValue+D'1', F

        // each time we take off 10, the left most digit is incremented
        iBcdOut += 0x10;
01D6  3010  	MOVLW 0x10
01D7  07A2  	ADDWF intToBcd_00000_1_iBcdOut, F
01D8  1803  	BTFSC STATUS,C
01D9  0AA3  	INCF intToBcd_00000_1_iBcdOut+D'1', F

    }

    // the last digit is what's left on iValue
    iBcdOut += iValue;
01DB  0820  	MOVF intToBcd_00000_arg_iValue, W
01DC  07A2  	ADDWF intToBcd_00000_1_iBcdOut, F
01DD  0821  	MOVF intToBcd_00000_arg_iValue+D'1', W
01DE  1803  	BTFSC STATUS,C
01DF  0AA3  	INCF intToBcd_00000_1_iBcdOut+D'1', F
01E0  07A3  	ADDWF intToBcd_00000_1_iBcdOut+D'1', F

}
01E1  0008  	RETURN


/*********************************************************************************************
  void convertTemp()
  Used to convert the ds18b20 temperature to display values
*********************************************************************************************/
void convertTemp() {

    // convert both bytes to a 16bit int - e.g. 0000 0001 0100 0110 (1 and 70, gives 326)
    signed int iTemp = (cTempH << 8) | cTempL;
053F  1283  	BCF STATUS, RP0
0540  1303  	BCF STATUS, RP1
0541  01F6  	CLRF convertTem_00027_1_iTemp
0542  084C  	MOVF gbl_cTempH, W
0543  00F7  	MOVWF convertTem_00027_1_iTemp+D'1'
0544  084D  	MOVF gbl_cTempL, W
0545  04F6  	IORWF convertTem_00027_1_iTemp, F

    signed int iTemp2 = iTemp;
0546  0876  	MOVF convertTem_00027_1_iTemp, W
0547  00F8  	MOVWF convertTem_00027_1_iTemp2
0548  0877  	MOVF convertTem_00027_1_iTemp+D'1', W
0549  00F9  	MOVWF convertTem_00027_1_iTemp2+D'1'

    // Compare to previous and ignore erroneous readings
    // Ignore startup reading (85 degrees - 1360) or anything greater
    if (iTemp > 1359)
054A  3C05  	SUBLW 0x05
054B  1D03  	BTFSS STATUS,Z
054C  2D4F  	GOTO	label101
054D  0876  	MOVF convertTem_00027_1_iTemp, W
054E  3C4F  	SUBLW 0x4F
054F        label101
054F  1803  	BTFSC STATUS,C
0550  2D54  	GOTO	label102
0551  1BF7  	BTFSC convertTem_00027_1_iTemp+D'1',7
0552  2D54  	GOTO	label102
0554        label102

        return;
    if (iTempOld != 0) {
0554  08B3  	MOVF gbl_iTempOld, F
0555  1D03  	BTFSS STATUS,Z
0556  2D5A  	GOTO	label103
0557  08B4  	MOVF gbl_iTempOld+D'1', F
0558  1903  	BTFSC STATUS,Z
0559  2D8C  	GOTO	label106
055A        label103

        // If the temperature difference exceeds 10 degrees (160) in either direction, ignore reading
        if ((iTemp + 160) > iTempOld)
055A  30A0  	MOVLW 0xA0
055B  0776  	ADDWF convertTem_00027_1_iTemp, W
055C  00FE  	MOVWF CompTempVar620
055D  0877  	MOVF convertTem_00027_1_iTemp+D'1', W
055E  1683  	BSF STATUS, RP0
055F  00A0  	MOVWF CompTempVar621
0560  1803  	BTFSC STATUS,C
0561  0AA0  	INCF CompTempVar621, F
0562  1283  	BCF STATUS, RP0
0563  0834  	MOVF gbl_iTempOld+D'1', W
0564  3A80  	XORLW 0x80
0565  1683  	BSF STATUS, RP0
0566  00A3  	MOVWF CompTempVar624
0567  0820  	MOVF CompTempVar621, W
0568  3A80  	XORLW 0x80
0569  0223  	SUBWF CompTempVar624, W
056A  1D03  	BTFSS STATUS,Z
056B  2D6F  	GOTO	label104
056C  1283  	BCF STATUS, RP0
056D  087E  	MOVF CompTempVar620, W
056E  0233  	SUBWF gbl_iTempOld, W
056F        label104
056F  1C03  	BTFSS STATUS,C

            return;
        if ((iTemp - 160) < iTempOld)
0571  30A0  	MOVLW 0xA0
0572  1283  	BCF STATUS, RP0
0573  0276  	SUBWF convertTem_00027_1_iTemp, W
0574  1683  	BSF STATUS, RP0
0575  00A1  	MOVWF CompTempVar622
0576  1283  	BCF STATUS, RP0
0577  0877  	MOVF convertTem_00027_1_iTemp+D'1', W
0578  1683  	BSF STATUS, RP0
0579  00A2  	MOVWF CompTempVar623
057A  1C03  	BTFSS STATUS,C
057B  03A2  	DECF CompTempVar623, F
057C  0822  	MOVF CompTempVar623, W
057D  3A80  	XORLW 0x80
057E  00A3  	MOVWF CompTempVar625
057F  1283  	BCF STATUS, RP0
0580  0834  	MOVF gbl_iTempOld+D'1', W
0581  3A80  	XORLW 0x80
0582  1683  	BSF STATUS, RP0
0583  0223  	SUBWF CompTempVar625, W
0584  1D03  	BTFSS STATUS,Z
0585  2D8A  	GOTO	label105
0586  1283  	BCF STATUS, RP0
0587  0833  	MOVF gbl_iTempOld, W
0588  1683  	BSF STATUS, RP0
0589  0221  	SUBWF CompTempVar622, W
058A        label105
058A  1C03  	BTFSS STATUS,C

            return;
    }
    iTempOld = iTemp;
058C  1283  	BCF STATUS, RP0
058D  0876  	MOVF convertTem_00027_1_iTemp, W
058E  00B3  	MOVWF gbl_iTempOld
058F  0877  	MOVF convertTem_00027_1_iTemp+D'1', W
0590  00B4  	MOVWF gbl_iTempOld+D'1'


    // this gets celsius * 100 - https://www.phanderson.com/PIC/PICC/sourceboost/ds18b20_1.html
    // celsius value is always required for triggering
	gbDS3231IsMinus = (iTemp2 < 0);
0591  01CF  	CLRF gbl_gbDS3231IsMinus
0592  1BF9  	BTFSC convertTem_00027_1_iTemp2+D'1',7
0593  0ACF  	INCF gbl_gbDS3231IsMinus, F

	if (gbDS3231IsMinus) {
0594  08CF  	MOVF gbl_gbDS3231IsMinus, F
0595  1903  	BTFSC STATUS,Z
0596  2D9C  	GOTO	label107

		iTemp2 = ~iTemp2 + 1;
0597  09F8  	COMF convertTem_00027_1_iTemp2, F
0598  09F9  	COMF convertTem_00027_1_iTemp2+D'1', F
0599  0AF8  	INCF convertTem_00027_1_iTemp2, F
059A  1903  	BTFSC STATUS,Z
059B  0AF9  	INCF convertTem_00027_1_iTemp2+D'1', F
059C        label107

	}
    int iValueC = (6 * iTemp2) + (iTemp2 / 4);
059C  3006  	MOVLW 0x06
059D  1683  	BSF STATUS, RP0
059E  00A0  	MOVWF __mul_16s__0000F_arg_a
059F  01A1  	CLRF __mul_16s__0000F_arg_a+D'1'
05A0  1283  	BCF STATUS, RP0
05A1  0878  	MOVF convertTem_00027_1_iTemp2, W
05A2  1683  	BSF STATUS, RP0
05A3  00A2  	MOVWF __mul_16s__0000F_arg_b
05A4  1283  	BCF STATUS, RP0
05A5  0879  	MOVF convertTem_00027_1_iTemp2+D'1', W
05A6  1683  	BSF STATUS, RP0
05A7  00A3  	MOVWF __mul_16s__0000F_arg_b+D'1'
05A8  2274  	CALL __mul_16s__0000F
05A9  0827  	MOVF CompTempVarRet387, W
05AA  1283  	BCF STATUS, RP0
05AB  00FA  	MOVWF convertTem_00027_1_iValueC
05AC  1683  	BSF STATUS, RP0
05AD  0828  	MOVF CompTempVarRet387+D'1', W
05AE  1283  	BCF STATUS, RP0
05AF  00FD  	MOVWF CompTempVar617
05B0  0878  	MOVF convertTem_00027_1_iTemp2, W
05B1  00FC  	MOVWF CompTempVar614
05B2  0879  	MOVF convertTem_00027_1_iTemp2+D'1', W
05B3  00FB  	MOVWF convertTem_00027_1_iValueC+D'1'
05B4  0D79  	RLF convertTem_00027_1_iTemp2+D'1', W
05B5  0CFB  	RRF convertTem_00027_1_iValueC+D'1', F
05B6  0CFC  	RRF CompTempVar614, F
05B7  0D79  	RLF convertTem_00027_1_iTemp2+D'1', W
05B8  0CFB  	RRF convertTem_00027_1_iValueC+D'1', F
05B9  0CFC  	RRF CompTempVar614, F
05BA  087C  	MOVF CompTempVar614, W
05BB  07FA  	ADDWF convertTem_00027_1_iValueC, F
05BC  087D  	MOVF CompTempVar617, W
05BD  1803  	BTFSC STATUS,C
05BE  0AFB  	INCF convertTem_00027_1_iValueC+D'1', F
05BF  07FB  	ADDWF convertTem_00027_1_iValueC+D'1', F

    // Split the temperature reading into digits
    giDS3231ValueBCD = intToBcd(iValueC);
05C0  087A  	MOVF convertTem_00027_1_iValueC, W
05C1  1683  	BSF STATUS, RP0
05C2  00A0  	MOVWF intToBcd_00000_arg_iValue
05C3  1283  	BCF STATUS, RP0
05C4  087B  	MOVF convertTem_00027_1_iValueC+D'1', W
05C5  1683  	BSF STATUS, RP0
05C6  00A1  	MOVWF intToBcd_00000_arg_iValue+D'1'
05C7  219F  	CALL intToBcd_00000
05C8  0822  	MOVF CompTempVarRet644, W
05C9  1283  	BCF STATUS, RP0
05CA  00B5  	MOVWF gbl_giDS3231ValueBCD
05CB  1683  	BSF STATUS, RP0
05CC  0823  	MOVF CompTempVarRet644+D'1', W
05CD  1283  	BCF STATUS, RP0
05CE  00B6  	MOVWF gbl_giDS3231ValueBCD+D'1'

    // Truncated value for triggering heater/fans
    giDS3231ValueTruncCBCD = giDS3231ValueBCD >> 8;
05CF  0836  	MOVF gbl_giDS3231ValueBCD+D'1', W
05D0  00CE  	MOVWF gbl_giDS3231ValueTruncCBCD


    if (gcDisplayMode == 1) {
05D1  0352  	DECF gbl_gcDisplayMode, W
05D2  1D03  	BTFSS STATUS,Z

		// -17.8125 (-285/65251) results in minus fahrenheit (-0.125), -17.75 (-284/65250) results in positive fahrenheit (1)
        // this gets Fahrenheit * 10 - https://www.electro-tech-online.com/threads/temperature-sensor-ds18b20-display-fahrenhiet.117377/
        iTemp2 = ((iTemp + 4) / 8) + iTemp + 320;
05D4  3004  	MOVLW 0x04
05D5  0776  	ADDWF convertTem_00027_1_iTemp, W
05D6  1683  	BSF STATUS, RP0
05D7  00A0  	MOVWF CompTempVar635
05D8  1283  	BCF STATUS, RP0
05D9  0877  	MOVF convertTem_00027_1_iTemp+D'1', W
05DA  1683  	BSF STATUS, RP0
05DB  00A2  	MOVWF CompTempVar638
05DC  1803  	BTFSC STATUS,C
05DD  0AA2  	INCF CompTempVar638, F
05DE  0822  	MOVF CompTempVar638, W
05DF  1283  	BCF STATUS, RP0
05E0  00FE  	MOVWF CompTempVar632
05E1  1683  	BSF STATUS, RP0
05E2  0D22  	RLF CompTempVar638, W
05E3  1283  	BCF STATUS, RP0
05E4  0CFE  	RRF CompTempVar632, F
05E5  1683  	BSF STATUS, RP0
05E6  0CA0  	RRF CompTempVar635, F
05E7  0D22  	RLF CompTempVar638, W
05E8  1283  	BCF STATUS, RP0
05E9  0CFE  	RRF CompTempVar632, F
05EA  1683  	BSF STATUS, RP0
05EB  0CA0  	RRF CompTempVar635, F
05EC  0D22  	RLF CompTempVar638, W
05ED  1283  	BCF STATUS, RP0
05EE  0CFE  	RRF CompTempVar632, F
05EF  1683  	BSF STATUS, RP0
05F0  0CA0  	RRF CompTempVar635, F
05F1  1283  	BCF STATUS, RP0
05F2  0876  	MOVF convertTem_00027_1_iTemp, W
05F3  1683  	BSF STATUS, RP0
05F4  07A0  	ADDWF CompTempVar635, F
05F5  1283  	BCF STATUS, RP0
05F6  0877  	MOVF convertTem_00027_1_iTemp+D'1', W
05F7  1683  	BSF STATUS, RP0
05F8  00A1  	MOVWF CompTempVar636
05F9  1283  	BCF STATUS, RP0
05FA  087E  	MOVF CompTempVar632, W
05FB  1C03  	BTFSS STATUS,C
05FC  2DFF  	GOTO	label108
05FD  1683  	BSF STATUS, RP0
05FE  0AA1  	INCF CompTempVar636, F
05FF  1683  	BSF STATUS, RP0
0600  07A1  	ADDWF CompTempVar636, F
0601  3040  	MOVLW 0x40
0602  07A0  	ADDWF CompTempVar635, F
0603  3001  	MOVLW 0x01
0604  1803  	BTFSC STATUS,C
0605  0AA1  	INCF CompTempVar636, F
0606  07A1  	ADDWF CompTempVar636, F
0607  0820  	MOVF CompTempVar635, W
0608  1283  	BCF STATUS, RP0
0609  00F8  	MOVWF convertTem_00027_1_iTemp2
060A  1683  	BSF STATUS, RP0
060B  0821  	MOVF CompTempVar636, W
060C  1283  	BCF STATUS, RP0
060D  00F9  	MOVWF convertTem_00027_1_iTemp2+D'1'

        // convert to absolute value
        gbDS3231IsMinus = (iTemp2 < 0);
060E  01CF  	CLRF gbl_gbDS3231IsMinus
060F  1BF9  	BTFSC convertTem_00027_1_iTemp2+D'1',7
0610  0ACF  	INCF gbl_gbDS3231IsMinus, F

        if (gbDS3231IsMinus) {
0611  08CF  	MOVF gbl_gbDS3231IsMinus, F
0612  1903  	BTFSC STATUS,Z
0613  2E19  	GOTO	label109

            iTemp2 = ~iTemp2 + 1;
0614  09F8  	COMF convertTem_00027_1_iTemp2, F
0615  09F9  	COMF convertTem_00027_1_iTemp2+D'1', F
0616  0AF8  	INCF convertTem_00027_1_iTemp2, F
0617  1903  	BTFSC STATUS,Z
0618  0AF9  	INCF convertTem_00027_1_iTemp2+D'1', F
0619        label109

        }
        // Split the temperature reading into digits
        giDS3231ValueBCD = intToBcd(iTemp2);
0619  0878  	MOVF convertTem_00027_1_iTemp2, W
061A  1683  	BSF STATUS, RP0
061B  00A0  	MOVWF intToBcd_00000_arg_iValue
061C  1283  	BCF STATUS, RP0
061D  0879  	MOVF convertTem_00027_1_iTemp2+D'1', W
061E  1683  	BSF STATUS, RP0
061F  00A1  	MOVWF intToBcd_00000_arg_iValue+D'1'
0620  219F  	CALL intToBcd_00000
0621  0822  	MOVF CompTempVarRet644, W
0622  1283  	BCF STATUS, RP0
0623  00B5  	MOVWF gbl_giDS3231ValueBCD
0624  1683  	BSF STATUS, RP0
0625  0823  	MOVF CompTempVarRet644+D'1', W
0626  1283  	BCF STATUS, RP0
0627  00B6  	MOVWF gbl_giDS3231ValueBCD+D'1'

	}
}
0553  0008  	RETURN
0570  0008  	RETURN
058B  0008  	RETURN
058C        label106
05D3  0008  	RETURN
0628  0008  	RETURN


/*********************************************************************************************
  void startTemp()
  Sends the Convert T [44h] function command to the ds18b20
*********************************************************************************************/
void startTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // 44 is the convert function
    oneWireTxBytes(0xCC, 0x44);
0853  30CC  	MOVLW 0xCC
0854  1283  	BCF STATUS, RP0
0855  1303  	BCF STATUS, RP1
0856  00F5  	MOVWF oneWireTxB_00016_arg_cData
0857  3044  	MOVLW 0x44
0858  00F6  	MOVWF oneWireTxB_00016_arg_cData2
0859  118A  	BCF PCLATH,3
085A  24CB  	CALL oneWireTxB_00016

}
085B  0008  	RETURN


/*********************************************************************************************
  void readTemp()
  Sends the Read Scratchpad [BEh] function command to the ds18b20
*********************************************************************************************/
void readTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // BE indicates to read scratchpad
    oneWireTxBytes(0xCC, 0xBE);
085C  30CC  	MOVLW 0xCC
085D  1283  	BCF STATUS, RP0
085E  1303  	BCF STATUS, RP1
085F  00F5  	MOVWF oneWireTxB_00016_arg_cData
0860  30BE  	MOVLW 0xBE
0861  00F6  	MOVWF oneWireTxB_00016_arg_cData2
0862  118A  	BCF PCLATH,3
0863  24CB  	CALL oneWireTxB_00016

    // Now get the temperature from the scratchpad
    // This is in the first two bytes - so get those only and ignore the rest
    cTempL = oneWireRxByte();
0864  24D2  	CALL oneWireRxB_00017
0865  0876  	MOVF CompTempVarRet549, W
0866  00CD  	MOVWF gbl_cTempL

    cTempH = oneWireRxByte();
0867  24D2  	CALL oneWireRxB_00017
0868  0876  	MOVF CompTempVarRet549, W
0869  00CC  	MOVWF gbl_cTempH

}
086A  0008  	RETURN


/*********************************************************************************************
  char bcdAdjust(char bcd, char bcdMax, char bcdMin)
  Increment or Decrement a BCD variable for sending to the DS3231, within a given range
  Must set iBcdAdjustment (up/down increment) first
*********************************************************************************************/
char bcdAdjust(char bcd, char bcdMax, char bcdMin) {

    if (iBcdAdjustment == 1) {
024A  0372  	DECF gbl_iBcdAdjustment, W
024B  1D03  	BTFSS STATUS,Z
024C  2A60  	GOTO	label46
0260        label46

        // Increment
        // if at maximum, reset to minimum
        if (bcd == bcdMax)
024D  0879  	MOVF bcdAdjust_00000_arg_bcdMax, W
024E  0678  	XORWF bcdAdjust_00000_arg_bcd, W
024F  1D03  	BTFSS STATUS,Z
0250  2A54  	GOTO	label44
0254        label44

            bcd = bcdMin;
0251  087A  	MOVF bcdAdjust_00000_arg_bcdMin, W
0252  00F8  	MOVWF bcdAdjust_00000_arg_bcd

        else if ((bcd & 0x0F) == 9)
0253  2A71  	GOTO	label49
0254  300F  	MOVLW 0x0F
0255  0578  	ANDWF bcdAdjust_00000_arg_bcd, W
0256  00FB  	MOVWF CompTempVar648
0257  087B  	MOVF CompTempVar648, W
0258  3A09  	XORLW 0x09
0259  1D03  	BTFSS STATUS,Z
025A  2A5E  	GOTO	label45
025E        label45

            bcd += 0x07; // add 0x10 (16), minus 9
025B  3007  	MOVLW 0x07
025C  07F8  	ADDWF bcdAdjust_00000_arg_bcd, F

        else
025D  2A71  	GOTO	label49

            bcd++;
025E  0AF8  	INCF bcdAdjust_00000_arg_bcd, F

    } else {
025F  2A71  	GOTO	label49

        // Decrement
        // if at minimum, reset to maximum
        if (bcd == bcdMin)
0260  087A  	MOVF bcdAdjust_00000_arg_bcdMin, W
0261  0678  	XORWF bcdAdjust_00000_arg_bcd, W
0262  1D03  	BTFSS STATUS,Z
0263  2A67  	GOTO	label47
0267        label47

            bcd = bcdMax;
0264  0879  	MOVF bcdAdjust_00000_arg_bcdMax, W
0265  00F8  	MOVWF bcdAdjust_00000_arg_bcd

        else if ((bcd & 0x0F) == 0)
0266  2A71  	GOTO	label49
0267  300F  	MOVLW 0x0F
0268  0578  	ANDWF bcdAdjust_00000_arg_bcd, W
0269  00FB  	MOVWF CompTempVar649
026A  08FB  	MOVF CompTempVar649, F
026B  1D03  	BTFSS STATUS,Z
026C  2A70  	GOTO	label48
0270        label48

            bcd -= 0x07; // minus 0x10 (16), add 9
026D  3007  	MOVLW 0x07
026E  02F8  	SUBWF bcdAdjust_00000_arg_bcd, F

        else
026F  2A71  	GOTO	label49
0271        label49

            bcd--;
0270  03F8  	DECF bcdAdjust_00000_arg_bcd, F

    }
    return bcd;
0271  0878  	MOVF bcdAdjust_00000_arg_bcd, W
0272  00FB  	MOVWF CompTempVarRet647

}
0273  0008  	RETURN


/*********************************************************************************************
  void adjustDateTime()
  Increment or Decrement a BCD variable for sending to the DS3231, within a given range
  Must set iBcdAdjustment (up/down increment) first
*********************************************************************************************/
void adjustDateTime() {

    switch (gcSetMode) {

        case 1:
079F  1283  	BCF STATUS, RP0
07A0  1303  	BCF STATUS, RP1
07A1  0853  	MOVF gbl_gcSetMode, W
07A2  3A01  	XORLW 0x01
07A3  1903  	BTFSC STATUS,Z
07A4  2FB9  	GOTO	label130
07B9        label130

            // Setting year - from 00 to 99
            gBcdYear = bcdAdjust(gBcdYear, 0x99, 0x00);
07B9  083D  	MOVF gbl_gBcdYear, W
07BA  00F8  	MOVWF bcdAdjust_00000_arg_bcd
07BB  3099  	MOVLW 0x99
07BC  00F9  	MOVWF bcdAdjust_00000_arg_bcdMax
07BD  01FA  	CLRF bcdAdjust_00000_arg_bcdMin
07BE  224A  	CALL bcdAdjust_00000
07BF  087B  	MOVF CompTempVarRet647, W
07C0  00BD  	MOVWF gbl_gBcdYear

            break;
        case 2:
07A5  3A03  	XORLW 0x03
07A6  1903  	BTFSC STATUS,Z
07A7  2FC2  	GOTO	label131
07C2        label131

            // Setting month - from 1 to 12
            gBcdMonth = bcdAdjust(gBcdMonth, 0x12, 0x01);
07C2  083C  	MOVF gbl_gBcdMonth, W
07C3  00F8  	MOVWF bcdAdjust_00000_arg_bcd
07C4  3012  	MOVLW 0x12
07C5  00F9  	MOVWF bcdAdjust_00000_arg_bcdMax
07C6  3001  	MOVLW 0x01
07C7  00FA  	MOVWF bcdAdjust_00000_arg_bcdMin
07C8  224A  	CALL bcdAdjust_00000
07C9  087B  	MOVF CompTempVarRet647, W
07CA  00BC  	MOVWF gbl_gBcdMonth

            break;
        case 3:
07A8  3A01  	XORLW 0x01
07A9  1903  	BTFSC STATUS,Z
07AA  2FCC  	GOTO	label132
07CC        label132

            // Setting day of month - from 1 to max days in month (i.e. 31, 30 or 28/29)
            char iMonth = gBcdMonth;
07CC  083C  	MOVF gbl_gBcdMonth, W
07CD  00F6  	MOVWF adjustDate_00028_1_iMonth

            if (iMonth & 0xF0)
07CE  30F0  	MOVLW 0xF0
07CF  0576  	ANDWF adjustDate_00028_1_iMonth, W
07D0  1903  	BTFSC STATUS,Z
07D1  2FD7  	GOTO	label133
07D7        label133

                iMonth += (gBcdMonth >> 4);
07D2  0E3C  	SWAPF gbl_gBcdMonth, W
07D3  390F  	ANDLW 0x0F
07D4  00F8  	MOVWF CompTempVar650
07D5  0878  	MOVF CompTempVar650, W
07D6  07F6  	ADDWF adjustDate_00028_1_iMonth, F

            iMonth--; // Make 0 to 11 index based
07D7  03F6  	DECF adjustDate_00028_1_iMonth, F

            char bcdMaxDay = gDaysInMonth[iMonth];
07D8  083E  	MOVF gbl_gDaysInMonth, W
07D9  00FE  	MOVWF __rom_get_00000_arg_objNumb
07DA  0876  	MOVF adjustDate_00028_1_iMonth, W
07DB  1683  	BSF STATUS, RP0
07DC  00A0  	MOVWF __rom_get_00000_arg_idx
07DD  201A  	CALL __rom_get_00000
07DE  1283  	BCF STATUS, RP0
07DF  00F7  	MOVWF adjustDate_00028_1_bcdMaxDay

            // If February(1), adjust max days for leap years
            if (iMonth == 1) {
07E0  0376  	DECF adjustDate_00028_1_iMonth, W
07E1  118A  	BCF PCLATH,3
07E2  120A  	BCF PCLATH,4
07E3  1D03  	BTFSS STATUS,Z
07E4  2FFD  	GOTO	label136

                // See if the 24 leap years since 2000 match the current year
                for (char i = 0; i < 24; i++) {
07E5  01F8  	CLRF adjustDate_00028_16_i
07E6        label134
07E6  3018  	MOVLW 0x18
07E7  0278  	SUBWF adjustDate_00028_16_i, W
07E8  1803  	BTFSC STATUS,C
07E9  2FFD  	GOTO	label136
07FB  0AF8  	INCF adjustDate_00028_16_i, F
07FC  2FE6  	GOTO	label134
07FD        label136

                    if (gLeapYears[i] == gBcdYear) {
07EA  083F  	MOVF gbl_gLeapYears, W
07EB  00FE  	MOVWF __rom_get_00000_arg_objNumb
07EC  0878  	MOVF adjustDate_00028_16_i, W
07ED  1683  	BSF STATUS, RP0
07EE  00A0  	MOVWF __rom_get_00000_arg_idx
07EF  201A  	CALL __rom_get_00000
07F0  1283  	BCF STATUS, RP0
07F1  00F9  	MOVWF CompTempVar651
07F2  083D  	MOVF gbl_gBcdYear, W
07F3  0679  	XORWF CompTempVar651, W
07F4  118A  	BCF PCLATH,3
07F5  120A  	BCF PCLATH,4
07F6  1D03  	BTFSS STATUS,Z
07F7  2FFB  	GOTO	label135
07FB        label135

                        bcdMaxDay = 0x29;
07F8  3029  	MOVLW 0x29
07F9  00F7  	MOVWF adjustDate_00028_1_bcdMaxDay

                        break;
07FA  2FFD  	GOTO	label136

                    }
                }
            }
            gBcdDayOfMonth = bcdAdjust(gBcdDayOfMonth, bcdMaxDay, 0x01);
07FD  083B  	MOVF gbl_gBcdDayOfMonth, W
07FE  00F8  	MOVWF bcdAdjust_00000_arg_bcd
07FF  0877  	MOVF adjustDate_00028_1_bcdMaxDay, W
0800  00F9  	MOVWF bcdAdjust_00000_arg_bcdMax
0801  3001  	MOVLW 0x01
0802  00FA  	MOVWF bcdAdjust_00000_arg_bcdMin
0803  224A  	CALL bcdAdjust_00000
0804  087B  	MOVF CompTempVarRet647, W
0805  00BB  	MOVWF gbl_gBcdDayOfMonth

            break;
        case 4:
07AB  3A07  	XORLW 0x07
07AC  158A  	BSF PCLATH,3
07AD  1903  	BTFSC STATUS,Z
07AE  2807  	GOTO	label137
0807        label137

            // Setting day of week - from 1 to 7
            gDayOfWeek = bcdAdjust(gDayOfWeek, 0x07, 0x01);
0807  083A  	MOVF gbl_gDayOfWeek, W
0808  00F8  	MOVWF bcdAdjust_00000_arg_bcd
0809  3007  	MOVLW 0x07
080A  00F9  	MOVWF bcdAdjust_00000_arg_bcdMax
080B  3001  	MOVLW 0x01
080C  00FA  	MOVWF bcdAdjust_00000_arg_bcdMin
080D  118A  	BCF PCLATH,3
080E  224A  	CALL bcdAdjust_00000
080F  087B  	MOVF CompTempVarRet647, W
0810  00BA  	MOVWF gbl_gDayOfWeek

            break;
        case 5:
07AF  3A01  	XORLW 0x01
07B0  1903  	BTFSC STATUS,Z
07B1  2812  	GOTO	label138
0812        label138

            // Setting 12h/24h
            gcHourMode++;
0812  0AD4  	INCF gbl_gcHourMode, F

            if (gcHourMode > 2)
0813  0854  	MOVF gbl_gcHourMode, W
0814  3C02  	SUBLW 0x02
0815  1C03  	BTFSS STATUS,C

				gcHourMode = 0;
0816  01D4  	CLRF gbl_gcHourMode

            break;
        case 6:
07B2  3A03  	XORLW 0x03
07B3  1903  	BTFSC STATUS,Z
07B4  2818  	GOTO	label139
0818        label139

            // Setting hour - from 0 to 23
            gBcdHour = bcdAdjust(gBcdHour, 0x23, 0x00);
0818  0839  	MOVF gbl_gBcdHour, W
0819  00F8  	MOVWF bcdAdjust_00000_arg_bcd
081A  3023  	MOVLW 0x23
081B  00F9  	MOVWF bcdAdjust_00000_arg_bcdMax
081C  01FA  	CLRF bcdAdjust_00000_arg_bcdMin
081D  118A  	BCF PCLATH,3
081E  224A  	CALL bcdAdjust_00000
081F  087B  	MOVF CompTempVarRet647, W
0820  00B9  	MOVWF gbl_gBcdHour

            break;
        case 7:
07B5  3A01  	XORLW 0x01
07B6  1903  	BTFSC STATUS,Z
07B7  2822  	GOTO	label140
0822        label140

            // Setting minute - from 0 to 59
            gBcdMinute = bcdAdjust(gBcdMinute, 0x59, 0x00);
0822  0838  	MOVF gbl_gBcdMinute, W
0823  00F8  	MOVWF bcdAdjust_00000_arg_bcd
0824  3059  	MOVLW 0x59
0825  00F9  	MOVWF bcdAdjust_00000_arg_bcdMax
0826  01FA  	CLRF bcdAdjust_00000_arg_bcdMin
0827  118A  	BCF PCLATH,3
0828  224A  	CALL bcdAdjust_00000
0829  087B  	MOVF CompTempVarRet647, W
082A  00B8  	MOVWF gbl_gBcdMinute

            break;
    }
}
07B8  0008  	RETURN
07C1  0008  	RETURN
07CB  0008  	RETURN
0806  0008  	RETURN
0811  0008  	RETURN
0817  0008  	RETURN
0821  0008  	RETURN
082B  0008  	RETURN


/*********************************************************************************************
  void adjustTrigger()
  Increment or Decrement a trigger time or temperate
  Must set iBcdAdjustment first
*********************************************************************************************/
void adjustTrigger() {

    switch (gcTriggerMode) {

        case 1:
06CC  1283  	BCF STATUS, RP0
06CD  1303  	BCF STATUS, RP1
06CE  0855  	MOVF gbl_gcTriggerMode, W
06CF  3A01  	XORLW 0x01
06D0  1903  	BTFSC STATUS,Z
06D1  2F00  	GOTO	label112
0700        label112

            // White LED on hour - from 0 to 23
            gBcdWhiteOnHour = bcdAdjust(gBcdWhiteOnHour, 0x23, 0x00);
0700  0857  	MOVF gbl_gBcdWhiteOnHour, W
0701  00F8  	MOVWF bcdAdjust_00000_arg_bcd
0702  3023  	MOVLW 0x23
0703  00F9  	MOVWF bcdAdjust_00000_arg_bcdMax
0704  01FA  	CLRF bcdAdjust_00000_arg_bcdMin
0705  224A  	CALL bcdAdjust_00000
0706  087B  	MOVF CompTempVarRet647, W
0707  00D7  	MOVWF gbl_gBcdWhiteOnHour

            break;
        case 2:
06D2  3A03  	XORLW 0x03
06D3  1903  	BTFSC STATUS,Z
06D4  2F09  	GOTO	label113
0709        label113

            // White LED on minute - from 0 to 59
            gBcdWhiteOnMinute = bcdAdjust(gBcdWhiteOnMinute, 0x59, 0x00);
0709  0856  	MOVF gbl_gBcdWhiteOnMinute, W
070A  00F8  	MOVWF bcdAdjust_00000_arg_bcd
070B  3059  	MOVLW 0x59
070C  00F9  	MOVWF bcdAdjust_00000_arg_bcdMax
070D  01FA  	CLRF bcdAdjust_00000_arg_bcdMin
070E  224A  	CALL bcdAdjust_00000
070F  087B  	MOVF CompTempVarRet647, W
0710  00D6  	MOVWF gbl_gBcdWhiteOnMinute

            break;
        case 3:
06D5  3A01  	XORLW 0x01
06D6  1903  	BTFSC STATUS,Z
06D7  2F12  	GOTO	label114
0712        label114

            // White LED off hour - from 0 to 23
            gBcdWhiteOffHour = bcdAdjust(gBcdWhiteOffHour, 0x23, 0x00);
0712  0859  	MOVF gbl_gBcdWhiteOffHour, W
0713  00F8  	MOVWF bcdAdjust_00000_arg_bcd
0714  3023  	MOVLW 0x23
0715  00F9  	MOVWF bcdAdjust_00000_arg_bcdMax
0716  01FA  	CLRF bcdAdjust_00000_arg_bcdMin
0717  224A  	CALL bcdAdjust_00000
0718  087B  	MOVF CompTempVarRet647, W
0719  00D9  	MOVWF gbl_gBcdWhiteOffHour

            break;
        case 4:
06D8  3A07  	XORLW 0x07
06D9  1903  	BTFSC STATUS,Z
06DA  2F1B  	GOTO	label115
071B        label115

            // White LED off minute - from 0 to 59
            gBcdWhiteOffMinute = bcdAdjust(gBcdWhiteOffMinute, 0x59, 0x00);
071B  0858  	MOVF gbl_gBcdWhiteOffMinute, W
071C  00F8  	MOVWF bcdAdjust_00000_arg_bcd
071D  3059  	MOVLW 0x59
071E  00F9  	MOVWF bcdAdjust_00000_arg_bcdMax
071F  01FA  	CLRF bcdAdjust_00000_arg_bcdMin
0720  224A  	CALL bcdAdjust_00000
0721  087B  	MOVF CompTempVarRet647, W
0722  00D8  	MOVWF gbl_gBcdWhiteOffMinute

            break;
        case 5:
06DB  3A01  	XORLW 0x01
06DC  1903  	BTFSC STATUS,Z
06DD  2F24  	GOTO	label116
0724        label116

            // 1st Blue LED on hour - from 0 to 23
            gBcdBlueOnHour = bcdAdjust(gBcdBlueOnHour, 0x23, 0x00);
0724  085B  	MOVF gbl_gBcdBlueOnHour, W
0725  00F8  	MOVWF bcdAdjust_00000_arg_bcd
0726  3023  	MOVLW 0x23
0727  00F9  	MOVWF bcdAdjust_00000_arg_bcdMax
0728  01FA  	CLRF bcdAdjust_00000_arg_bcdMin
0729  224A  	CALL bcdAdjust_00000
072A  087B  	MOVF CompTempVarRet647, W
072B  00DB  	MOVWF gbl_gBcdBlueOnHour

            break;
        case 6:
06DE  3A03  	XORLW 0x03
06DF  1903  	BTFSC STATUS,Z
06E0  2F2D  	GOTO	label117
072D        label117

            // 1st Blue LED on minute - from 0 to 59
            gBcdBlueOnMinute = bcdAdjust(gBcdBlueOnMinute, 0x59, 0x00);
072D  085A  	MOVF gbl_gBcdBlueOnMinute, W
072E  00F8  	MOVWF bcdAdjust_00000_arg_bcd
072F  3059  	MOVLW 0x59
0730  00F9  	MOVWF bcdAdjust_00000_arg_bcdMax
0731  01FA  	CLRF bcdAdjust_00000_arg_bcdMin
0732  224A  	CALL bcdAdjust_00000
0733  087B  	MOVF CompTempVarRet647, W
0734  00DA  	MOVWF gbl_gBcdBlueOnMinute

            break;
        case 7:
06E1  3A01  	XORLW 0x01
06E2  1903  	BTFSC STATUS,Z
06E3  2F36  	GOTO	label118
0736        label118

            // 1st Blue LED off hour - from 0 to 23
            gBcdBlueOffHour = bcdAdjust(gBcdBlueOffHour, 0x23, 0x00);
0736  085D  	MOVF gbl_gBcdBlueOffHour, W
0737  00F8  	MOVWF bcdAdjust_00000_arg_bcd
0738  3023  	MOVLW 0x23
0739  00F9  	MOVWF bcdAdjust_00000_arg_bcdMax
073A  01FA  	CLRF bcdAdjust_00000_arg_bcdMin
073B  224A  	CALL bcdAdjust_00000
073C  087B  	MOVF CompTempVarRet647, W
073D  00DD  	MOVWF gbl_gBcdBlueOffHour

            break;
        case 8:
06E4  3A0F  	XORLW 0x0F
06E5  1903  	BTFSC STATUS,Z
06E6  2F3F  	GOTO	label119
073F        label119

            // 1st Blue LED off minute - from 0 to 59
            gBcdBlueOffMinute = bcdAdjust(gBcdBlueOffMinute, 0x59, 0x00);
073F  085C  	MOVF gbl_gBcdBlueOffMinute, W
0740  00F8  	MOVWF bcdAdjust_00000_arg_bcd
0741  3059  	MOVLW 0x59
0742  00F9  	MOVWF bcdAdjust_00000_arg_bcdMax
0743  01FA  	CLRF bcdAdjust_00000_arg_bcdMin
0744  224A  	CALL bcdAdjust_00000
0745  087B  	MOVF CompTempVarRet647, W
0746  00DC  	MOVWF gbl_gBcdBlueOffMinute

            break;
        case 9:
06E7  3A01  	XORLW 0x01
06E8  1903  	BTFSC STATUS,Z
06E9  2F48  	GOTO	label120
0748        label120

            // 2nd Blue LED on hour - from 0 to 23
            gBcdBlue2OnHour = bcdAdjust(gBcdBlue2OnHour, 0x23, 0x00);
0748  085F  	MOVF gbl_gBcdBlue2OnHour, W
0749  00F8  	MOVWF bcdAdjust_00000_arg_bcd
074A  3023  	MOVLW 0x23
074B  00F9  	MOVWF bcdAdjust_00000_arg_bcdMax
074C  01FA  	CLRF bcdAdjust_00000_arg_bcdMin
074D  224A  	CALL bcdAdjust_00000
074E  087B  	MOVF CompTempVarRet647, W
074F  00DF  	MOVWF gbl_gBcdBlue2OnHour

            break;
        case 10:
06EA  3A03  	XORLW 0x03
06EB  1903  	BTFSC STATUS,Z
06EC  2F51  	GOTO	label121
0751        label121

            // 2nd Blue LED on minute - from 0 to 59
            gBcdBlue2OnMinute = bcdAdjust(gBcdBlue2OnMinute, 0x59, 0x00);
0751  085E  	MOVF gbl_gBcdBlue2OnMinute, W
0752  00F8  	MOVWF bcdAdjust_00000_arg_bcd
0753  3059  	MOVLW 0x59
0754  00F9  	MOVWF bcdAdjust_00000_arg_bcdMax
0755  01FA  	CLRF bcdAdjust_00000_arg_bcdMin
0756  224A  	CALL bcdAdjust_00000
0757  087B  	MOVF CompTempVarRet647, W
0758  00DE  	MOVWF gbl_gBcdBlue2OnMinute

            break;
        case 11:
06ED  3A01  	XORLW 0x01
06EE  1903  	BTFSC STATUS,Z
06EF  2F5A  	GOTO	label122
075A        label122

            // 2nd Blue LED off hour - from 0 to 23
            gBcdBlue2OffHour = bcdAdjust(gBcdBlue2OffHour, 0x23, 0x00);
075A  0861  	MOVF gbl_gBcdBlue2OffHour, W
075B  00F8  	MOVWF bcdAdjust_00000_arg_bcd
075C  3023  	MOVLW 0x23
075D  00F9  	MOVWF bcdAdjust_00000_arg_bcdMax
075E  01FA  	CLRF bcdAdjust_00000_arg_bcdMin
075F  224A  	CALL bcdAdjust_00000
0760  087B  	MOVF CompTempVarRet647, W
0761  00E1  	MOVWF gbl_gBcdBlue2OffHour

            break;
        case 12:
06F0  3A07  	XORLW 0x07
06F1  1903  	BTFSC STATUS,Z
06F2  2F63  	GOTO	label123
0763        label123

            // 2nd Blue LED off minute - from 0 to 59
            gBcdBlue2OffMinute = bcdAdjust(gBcdBlue2OffMinute, 0x59, 0x00);
0763  0860  	MOVF gbl_gBcdBlue2OffMinute, W
0764  00F8  	MOVWF bcdAdjust_00000_arg_bcd
0765  3059  	MOVLW 0x59
0766  00F9  	MOVWF bcdAdjust_00000_arg_bcdMax
0767  01FA  	CLRF bcdAdjust_00000_arg_bcdMin
0768  224A  	CALL bcdAdjust_00000
0769  087B  	MOVF CompTempVarRet647, W
076A  00E0  	MOVWF gbl_gBcdBlue2OffMinute

            break;
        case 13:
06F3  3A01  	XORLW 0x01
06F4  1903  	BTFSC STATUS,Z
06F5  2F6C  	GOTO	label124
076C        label124

            // Fan on temp - between 20 and 40 degrees C
            gBcdFanOnTemp = bcdAdjust(gBcdFanOnTemp, 0x40, 0x20);
076C  0862  	MOVF gbl_gBcdFanOnTemp, W
076D  00F8  	MOVWF bcdAdjust_00000_arg_bcd
076E  3040  	MOVLW 0x40
076F  00F9  	MOVWF bcdAdjust_00000_arg_bcdMax
0770  3020  	MOVLW 0x20
0771  00FA  	MOVWF bcdAdjust_00000_arg_bcdMin
0772  224A  	CALL bcdAdjust_00000
0773  087B  	MOVF CompTempVarRet647, W
0774  00E2  	MOVWF gbl_gBcdFanOnTemp

            break;
        case 14:
06F6  3A03  	XORLW 0x03
06F7  1903  	BTFSC STATUS,Z
06F8  2F76  	GOTO	label125
0776        label125

            // Fan off temp - off must be lower than on, min 20 degrees C
            if (gBcdFanOffTemp > gBcdFanOnTemp)
0776  0863  	MOVF gbl_gBcdFanOffTemp, W
0777  0262  	SUBWF gbl_gBcdFanOnTemp, W
0778  1803  	BTFSC STATUS,C
0779  2F7C  	GOTO	label126
077C        label126

				gBcdFanOffTemp = gBcdFanOnTemp;
077A  0862  	MOVF gbl_gBcdFanOnTemp, W
077B  00E3  	MOVWF gbl_gBcdFanOffTemp

            gBcdFanOffTemp = bcdAdjust(gBcdFanOffTemp, gBcdFanOnTemp, 0x20);
077C  0863  	MOVF gbl_gBcdFanOffTemp, W
077D  00F8  	MOVWF bcdAdjust_00000_arg_bcd
077E  0862  	MOVF gbl_gBcdFanOnTemp, W
077F  00F9  	MOVWF bcdAdjust_00000_arg_bcdMax
0780  3020  	MOVLW 0x20
0781  00FA  	MOVWF bcdAdjust_00000_arg_bcdMin
0782  224A  	CALL bcdAdjust_00000
0783  087B  	MOVF CompTempVarRet647, W
0784  00E3  	MOVWF gbl_gBcdFanOffTemp

            break;
        case 15:
06F9  3A01  	XORLW 0x01
06FA  1903  	BTFSC STATUS,Z
06FB  2F86  	GOTO	label127
0786        label127

            // Heater on temp - between 0 and 40 degrees C
            gBcdHeaterOnTemp = bcdAdjust(gBcdHeaterOnTemp, 0x40, 0);
0786  0864  	MOVF gbl_gBcdHeaterOnTemp, W
0787  00F8  	MOVWF bcdAdjust_00000_arg_bcd
0788  3040  	MOVLW 0x40
0789  00F9  	MOVWF bcdAdjust_00000_arg_bcdMax
078A  01FA  	CLRF bcdAdjust_00000_arg_bcdMin
078B  224A  	CALL bcdAdjust_00000
078C  087B  	MOVF CompTempVarRet647, W
078D  00E4  	MOVWF gbl_gBcdHeaterOnTemp

            break;
        case 16:
06FC  3A1F  	XORLW 0x1F
06FD  1903  	BTFSC STATUS,Z
06FE  2F8F  	GOTO	label128
078F        label128

            // Heater off temp - off must be equal or higher than on - max 40 degrees C
            if (gBcdHeaterOffTemp < gBcdHeaterOnTemp)
078F  0864  	MOVF gbl_gBcdHeaterOnTemp, W
0790  0265  	SUBWF gbl_gBcdHeaterOffTemp, W
0791  1803  	BTFSC STATUS,C
0792  2F95  	GOTO	label129
0795        label129

				gBcdHeaterOffTemp = gBcdHeaterOnTemp;
0793  0864  	MOVF gbl_gBcdHeaterOnTemp, W
0794  00E5  	MOVWF gbl_gBcdHeaterOffTemp

            gBcdHeaterOffTemp = bcdAdjust(gBcdHeaterOffTemp, 0x40, gBcdHeaterOnTemp);
0795  0865  	MOVF gbl_gBcdHeaterOffTemp, W
0796  00F8  	MOVWF bcdAdjust_00000_arg_bcd
0797  3040  	MOVLW 0x40
0798  00F9  	MOVWF bcdAdjust_00000_arg_bcdMax
0799  0864  	MOVF gbl_gBcdHeaterOnTemp, W
079A  00FA  	MOVWF bcdAdjust_00000_arg_bcdMin
079B  224A  	CALL bcdAdjust_00000
079C  087B  	MOVF CompTempVarRet647, W
079D  00E5  	MOVWF gbl_gBcdHeaterOffTemp

            break;
    }
}
06FF  0008  	RETURN
0708  0008  	RETURN
0711  0008  	RETURN
071A  0008  	RETURN
0723  0008  	RETURN
072C  0008  	RETURN
0735  0008  	RETURN
073E  0008  	RETURN
0747  0008  	RETURN
0750  0008  	RETURN
0759  0008  	RETURN
0762  0008  	RETURN
076B  0008  	RETURN
0775  0008  	RETURN
0785  0008  	RETURN
078E  0008  	RETURN
079E  0008  	RETURN


/*********************************************************************************************
  void processKeys()
  Action a key press
*********************************************************************************************/
void processKeys() {

    // Key hex codes based on result from tm1638ReadKeys, from http://www.piclearning.net/280/pic-and-tm1638-ledkey-module.php
    switch (tm1638Keys) {

        case 0x1F:
086B  1283  	BCF STATUS, RP0
086C  1303  	BCF STATUS, RP1
086D  086E  	MOVF gbl_tm1638Keys, W
086E  3A1F  	XORLW 0x1F
086F  1903  	BTFSC STATUS,Z
0870  2887  	GOTO	label144
0887        label144

            // Toggle white light on/off
            WHITE_LED = !WHITE_LED;
0887  01F6  	CLRF CompTempVar652
0888  1C87  	BTFSS gbl_portc,1
0889  0AF6  	INCF CompTempVar652, F
088A  1876  	BTFSC CompTempVar652,0
088B  1487  	BSF gbl_portc,1
088C  1C76  	BTFSS CompTempVar652,0
088D  1087  	BCF gbl_portc,1

            break;
        case 0x17:
0871  3A08  	XORLW 0x08
0872  1903  	BTFSC STATUS,Z
0873  288F  	GOTO	label145
088F        label145

            // Toggle blue light on/off
            BLUE_LED = !BLUE_LED;
088F  01F6  	CLRF CompTempVar653
0890  1D07  	BTFSS gbl_portc,2
0891  0AF6  	INCF CompTempVar653, F
0892  1876  	BTFSC CompTempVar653,0
0893  1507  	BSF gbl_portc,2
0894  1C76  	BTFSS CompTempVar653,0
0895  1107  	BCF gbl_portc,2

            break;
        case 0x0F:
0874  3A18  	XORLW 0x18
0875  1903  	BTFSC STATUS,Z
0876  2897  	GOTO	label146
0897        label146

            // Toggle fan on/off
            gbFanOn = !gbFanOn;
0897  01F6  	CLRF CompTempVar654
0898  1C51  	BTFSS gbl_gbFanOn,0
0899  0AF6  	INCF CompTempVar654, F
089A  1051  	BCF gbl_gbFanOn,0
089B  0876  	MOVF CompTempVar654, W
089C  1D03  	BTFSS STATUS,Z
089D  1451  	BSF gbl_gbFanOn,0

            break;
        case 0x07:
0877  3A08  	XORLW 0x08
0878  1903  	BTFSC STATUS,Z
0879  289F  	GOTO	label147
089F        label147

            // Exit other modes
            if (gcTriggerMode)
089F  08D5  	MOVF gbl_gcTriggerMode, F
08A1  1D03  	BTFSS STATUS,Z

                at24c32WriteAll(); // Exiting trigger mode, save the new triggers to EEPROM chip
08A0  118A  	BCF PCLATH,3
08A2  2629  	CALL at24c32Wri_00018

            gcSetMode = 0;
08A3  01D3  	CLRF gbl_gcSetMode

            gcTriggerMode = 0;
08A4  01D5  	CLRF gbl_gcTriggerMode

            // Display temp C/temp F/date
            gcDisplayMode++;
08A5  0AD2  	INCF gbl_gcDisplayMode, F

            if (gcDisplayMode > 3)
08A6  0852  	MOVF gbl_gcDisplayMode, W
08A7  3C03  	SUBLW 0x03
08A8  1C03  	BTFSS STATUS,C

                gcDisplayMode = 0;
08A9  01D2  	CLRF gbl_gcDisplayMode

            convertTemp(); // force conversion (no read)
08AA  253F  	CALL convertTem_00027

            break;
        case 0x1B:
087A  3A1C  	XORLW 0x1C
087B  1903  	BTFSC STATUS,Z
087C  28AC  	GOTO	label148
08AC        label148

            // Exit other modes
            gcTriggerMode = 0;
08AC  01D5  	CLRF gbl_gcTriggerMode

            // Adjust set mode
            gcSetMode++;
08AD  0AD3  	INCF gbl_gcSetMode, F

            if (gcSetMode > 7) {
08AE  0853  	MOVF gbl_gcSetMode, W
08AF  3C07  	SUBLW 0x07
08B0  1803  	BTFSC STATUS,C

                ds3231WriteDateTime();
08B2  118A  	BCF PCLATH,3
08B3  2503  	CALL ds3231Writ_0001B

                gcSetMode = 0;
08B4  01D3  	CLRF gbl_gcSetMode

            }
            break;
        case 0x13:
087D  3A08  	XORLW 0x08
087E  1903  	BTFSC STATUS,Z
087F  28B6  	GOTO	label149
08B6        label149

            // Adjust down
            iBcdAdjustment = 0;
08B6  01F2  	CLRF gbl_iBcdAdjustment

            if (gcSetMode) {
08B7  08D3  	MOVF gbl_gcSetMode, F
08B8  1903  	BTFSC STATUS,Z
08B9  28BD  	GOTO	label150
08BD        label150

                adjustDateTime();
08BA  118A  	BCF PCLATH,3
08BB  279F  	CALL adjustDate_00028

            } else if (gcTriggerMode) {
08BD  08D5  	MOVF gbl_gcTriggerMode, F
08BF  1D03  	BTFSS STATUS,Z

                adjustTrigger();
08BE  118A  	BCF PCLATH,3
08C0  26CC  	CALL adjustTrig_00029

            }
            break;
        case 0x0B:
0880  3A18  	XORLW 0x18
0881  1903  	BTFSC STATUS,Z
0882  28C2  	GOTO	label151
08C2        label151

            iBcdAdjustment = 1;
08C2  3001  	MOVLW 0x01
08C3  00F2  	MOVWF gbl_iBcdAdjustment

            // Adjust up
            if (gcSetMode) {
08C4  08D3  	MOVF gbl_gcSetMode, F
08C5  1903  	BTFSC STATUS,Z
08C6  28CA  	GOTO	label152
08CA        label152

                adjustDateTime();
08C7  118A  	BCF PCLATH,3
08C8  279F  	CALL adjustDate_00028

            } else if (gcTriggerMode) {
08CA  08D5  	MOVF gbl_gcTriggerMode, F
08CC  1D03  	BTFSS STATUS,Z

                adjustTrigger();
08CB  118A  	BCF PCLATH,3
08CD  26CC  	CALL adjustTrig_00029

            }
            break;
        case 0x03:
0883  3A08  	XORLW 0x08
0884  1903  	BTFSC STATUS,Z
0885  28CF  	GOTO	label153
08CF        label153

            // Exit set mode
            gcSetMode = 0;
08CF  01D3  	CLRF gbl_gcSetMode

            // Adjust timer mode
            gcTriggerMode++;
08D0  0AD5  	INCF gbl_gcTriggerMode, F

            if (gcTriggerMode > 16) {
08D1  0855  	MOVF gbl_gcTriggerMode, W
08D2  3C10  	SUBLW 0x10
08D3  1803  	BTFSC STATUS,C

                at24c32WriteAll(); // Exiting trigger mode, save the new triggers to EEPROM chip
08D5  118A  	BCF PCLATH,3
08D6  2629  	CALL at24c32Wri_00018

                gcTriggerMode = 0;
08D7  01D5  	CLRF gbl_gcTriggerMode

            }
            break;
    }
}
0886  0008  	RETURN
088E  0008  	RETURN
0896  0008  	RETURN
089E  0008  	RETURN
08AB  0008  	RETURN
08B1  0008  	RETURN
08B5  0008  	RETURN
08BC  0008  	RETURN
08C1  0008  	RETURN
08C9  0008  	RETURN
08CE  0008  	RETURN
08D4  0008  	RETURN
08D8  0008  	RETURN


/*********************************************************************************************
  void interrupt()
  Interrupt handler
*********************************************************************************************/
void interrupt() {

    // Interrupt on timer0 - flash digit delay
    if (intcon.T0IF) {
0AAF  1D0B  	BTFSS gbl_intcon,2
0AB0  2AB7  	GOTO	label182
0AB7        label182

        tmr0 = TMR0PRELOAD;
0AB1  303D  	MOVLW 0x3D
0AB2  1283  	BCF STATUS, RP0
0AB3  1303  	BCF STATUS, RP1
0AB4  0081  	MOVWF gbl_tmr0

        cTask.TASK_TIMER0 = 1;
0AB5  14D0  	BSF gbl_cTask,1

        // Clear interrupt flag
        intcon.T0IF = 0;
0AB6  110B  	BCF gbl_intcon,2

    }
    // Handle timer1 interrupt - delay counter from DS3231
    if (pir1.TMR1IF) {
0AB7  1283  	BCF STATUS, RP0
0AB8  1303  	BCF STATUS, RP1
0AB9  1C0C  	BTFSS gbl_pir1,0
0ABA  2AC0  	GOTO	label183
0AC0        label183

        tmr1h = TMR1HV;      // preset for timer1 MSB register
0ABB  30FF  	MOVLW 0xFF
0ABC  008F  	MOVWF gbl_tmr1h

        tmr1l = TMR1LV;      // preset for timer1 LSB register
0ABD  008E  	MOVWF gbl_tmr1l


        pir1.TMR1IF = 0;     // Clear interrupt flag
0ABE  100C  	BCF gbl_pir1,0

        cTask.TASK_TIMER1 = 1;
0ABF  1550  	BSF gbl_cTask,2

    }
}
0AC0  0E32  	SWAPF Int1BContext+D'2', W
0AC1  0084  	MOVWF FSR
0AC2  0E31  	SWAPF Int1BContext+D'1', W
0AC3  008A  	MOVWF PCLATH
0AC4  0E30  	SWAPF Int1BContext, W
0AC5  0083  	MOVWF STATUS
0AC6  0EFF  	SWAPF Int1Context, F
0AC7  0E7F  	SWAPF Int1Context, W
0AC8  0009  	RETFIE


/*********************************************************************************************
  void initialise()
  Function called once only to initialise variables and
  setup the PIC registers
*********************************************************************************************/
void initialise() {

    //PIC16F73 doesn't have an internal oscillator
    //pcon.OSCF = 1; // 4MHz internal osc

    // Configure port A
    /*
    RA7     Doesn't exist
    RA6     Doesn't exist
    RA5
    RA4
    RA3
    RA2
    RA1     OUT FANS
    RA0     OUT HEATER
    */
    trisa = 0x00; // all outputs
08F2  1683  	BSF STATUS, RP0
08F3  1303  	BCF STATUS, RP1
08F4  0185  	CLRF gbl_trisa

    porta = 0x00; // All off
08F5  1283  	BCF STATUS, RP0
08F6  0185  	CLRF gbl_porta


    // Configure port B
    /*
    RB7     ICSP PGD
    RB6     ICSP PGC
    RB5
    RB4
    RB3     OUT TM1638 STB
    RB2     OUT TM1638 CLK
    RB1     IN/OUT TM1638 DIO
    RB0
    */
    trisb = 0x00; // all outputs by default
08F7  1683  	BSF STATUS, RP0
08F8  0186  	CLRF gbl_trisb

    portb = 0x0E; // default TM1638 pins high
08F9  300E  	MOVLW 0x0E
08FA  1283  	BCF STATUS, RP0
08FB  0086  	MOVWF gbl_portb


    // Configure port C
    /*
    RC7
    RC6
    RC5     IN/OUT DS18B20
    RC4     IN/OUT DS3231M I2C SDA
    RC3     IN/OUT DS3231M I2C CLK
    RC2     OUT BLUE LIGHT PWM
    RC1     OUT WHITE LIGHT PWM
    RC0     IN SQW DS3231M
    */
    trisc = 0x21; // RC0 and RC5 inputs
08FC  3021  	MOVLW 0x21
08FD  1683  	BSF STATUS, RP0
08FE  0087  	MOVWF gbl_trisc

    portc = 0x38; // default DS18B20 and DS3231 pins high
08FF  3038  	MOVLW 0x38
0900  1283  	BCF STATUS, RP0
0901  0087  	MOVWF gbl_portc


    option_reg = 0;
0902  1683  	BSF STATUS, RP0
0903  0181  	CLRF gbl_option_reg

    option_reg.NOT_RBPU = 1; // disable port b pull ups
0904  1781  	BSF gbl_option_reg,7


    // ADC setup
    // PIC16F73 doesn't have comparators, setting cmcon may be needed for some PICs
    //cmcon = 7; // disable all comparators so port a is usable as digital io
    adcon1 = 7; // Set RA0,RA1,RA2,RA5,RA3 all to digital I/O
0905  3007  	MOVLW 0x07
0906  009F  	MOVWF gbl_adcon1



    // Setup timer 0, used for flashing display
    // Timer calculator: http://eng-serve.com/pic/pic_timer.html
    // Timer0 Registers Prescaler= 256 - TMR0 Preset = 61 - Freq = 20.03 Hz - Period = 0.049920 seconds
    //option_reg.T0CS = 0; // bit 5  TMR0 Clock Source Select bit...0 = Internal Clock (CLKO) 1 = Transition on T0CKI pin
    //option_reg.T0SE = 0; // bit 4 TMR0 Source Edge Select bit 0 = low/high 1 = high/low
    //option_reg.PSA = 0; // bit 3  Prescaler Assignment bit...0 = Prescaler is assigned to the Timer0
    option_reg.PS2 = 1; // bits 2-0  PS2:PS0: Prescaler Rate Select bits
0907  1501  	BSF gbl_option_reg,2

    option_reg.PS1 = 1;
0908  1481  	BSF gbl_option_reg,1

    option_reg.PS0 = 1;
0909  1401  	BSF gbl_option_reg,0

    tmr0 = TMR0PRELOAD; // preset for timer register (61)
090A  303D  	MOVLW 0x3D
090B  1283  	BCF STATUS, RP0
090C  0081  	MOVWF gbl_tmr0

    intcon.T0IF = 0; // Clear timer 1 interrupt flag bit
090D  110B  	BCF gbl_intcon,2

    intcon.T0IE = 1; // Timer 1 interrupt enabled
090E  168B  	BSF gbl_intcon,5


    // Setup timer 1, used to update clock display and periodically ask for a temperature reading
    // Timer 1 setup - interrupt on DS3231 SQW 1Hz
    // Timer1 Registers Prescaler= 1 - TMR1 Preset = 65535 - Freq = 1 Hz
    // Bits 5-4 T1CKPS1:T1CKPS0 = 00: Prescaler Rate Select bits, 00 = 1:1 prescaler
    // Bit 3 T1OSCEN = 0: Timer1 LP Oscillator Enable Control bit, 0 = off
    // Bit 2 NOT_T1SYNC = 1: Timer1 External Clock Input Synchronization Control bit, 1 = Do not synchronize external clock input
    // Bit 1 TMR1CS = 1: Timer1 Clock Source Select bit, 1 = External clock from T1OSO/T1CKI pin (on the rising edge)
    // Bit 0 TMR1ON = 0: Timer1 On Bit, 0 = off
    t1con = 0b00000111;
090F  3007  	MOVLW 0x07
0910  0090  	MOVWF gbl_t1con

    tmr1h = TMR1HV;      // preset for timer1 MSB register
0911  30FF  	MOVLW 0xFF
0912  008F  	MOVWF gbl_tmr1h

    tmr1l = TMR1LV;      // preset for timer1 LSB register
0913  008E  	MOVWF gbl_tmr1l

    pie1.TMR1IE = 1;     // Timer 1 interrupt
0914  1683  	BSF STATUS, RP0
0915  140C  	BSF gbl_pie1,0


    // No task at initialisation
    cTask = 0;
0916  1283  	BCF STATUS, RP0
0917  01D0  	CLRF gbl_cTask


	// I2C Bus initialisation - baud rate divisor not applicable for software implementation
	i2c_init(1);
0918  3001  	MOVLW 0x01
0919  00F6  	MOVWF i2c_INIT_00000_arg_i2c_divisor
091A  118A  	BCF PCLATH,3
091B  24F0  	CALL i2c_INIT_00000


	// Startup delay
	delay_ms(500);
091C  30F4  	MOVLW 0xF4
091D  00F6  	MOVWF delay_ms_00000_arg_del
091E  2083  	CALL delay_ms_00000


    // Read in variables from EEPROM
    at24c32ReadAll();
091F  266C  	CALL at24c32Rea_00019


    // Check if the DS3231 needs initilising
    char cStatus = ds3231ReadRegister(0x0F); // Read the status register
0920  300F  	MOVLW 0x0F
0921  00F6  	MOVWF ds3231Read_0001D_arg_cRegAddress
0922  251F  	CALL ds3231Read_0001D
0923  0878  	MOVF CompTempVarRet552, W
0924  00F5  	MOVWF initialise_00000_1_cStatus

    // If the oscillator (OSF bit in status register) has stopped, then init and write a default date/time
    // This is only expected first time, or backup battery not present/empty in DS3231M module
    if (cStatus.7) {
0925  158A  	BSF PCLATH,3
0926  1FF5  	BTFSS initialise_00000_1_cStatus,7
0927  292B  	GOTO	label154
092B        label154

        ds3231Init();
0928  118A  	BCF PCLATH,3
0929  2534  	CALL ds3231Init_00000

        ds3231WriteDateTime();
092A  2503  	CALL ds3231Writ_0001B

    }

	tm1638DisplayOn();
092B  118A  	BCF PCLATH,3
092C  24C3  	CALL tm1638Disp_0001F

    tm1638UpdateDisplay();
092D  229D  	CALL tm1638Upda_00022


    // Enable interrupts
    intcon.GIE = 1;
092E  178B  	BSF gbl_intcon,7

    intcon.PEIE = 1;
092F  170B  	BSF gbl_intcon,6

}
0930  0008  	RETURN


/*********************************************************************************************
  void main()
  Entry method. Loops infinitely with a simple task scheduler.
*********************************************************************************************/
void main() {

    initialise();
095C  20F2  	CALL initialise_00000


    // Endless loop
    while(1) {
095D        label155

        // Task scheduler
        // If there are tasks to be performed, find out the
        // most recent task from the array and execute it
        while (cTask > 0) {
095D  0850  	MOVF gbl_cTask, W
095E  3C00  	SUBLW 0x00
095F  158A  	BSF PCLATH,3
0960  1803  	BTFSC STATUS,C
0961  295D  	GOTO	label155

            if (cTask.TASK_TIMER1) {
0962  1D50  	BTFSS gbl_cTask,2
0963  2A16  	GOTO	label175
0A16        label175

                if (!gcSetMode) {
0964  08D3  	MOVF gbl_gcSetMode, F
0965  1D03  	BTFSS STATUS,Z
0966  29A4  	GOTO	label161

                    // Don't read date/time when in set mode
                    ds3231ReadDateTime();
0967  2131  	CALL ds3231Read_0001C

                    if ((gBcdSecond == 0x29) || (gBcdSecond == 0x59)) {
0968  0837  	MOVF gbl_gBcdSecond, W
0969  3A29  	XORLW 0x29
096A  158A  	BSF PCLATH,3
096B  1903  	BTFSC STATUS,Z
096C  2971  	GOTO	label156
096D  0837  	MOVF gbl_gBcdSecond, W
096E  3A59  	XORLW 0x59
096F  1D03  	BTFSS STATUS,Z
0970  2976  	GOTO	label157
0971        label156
0976        label157

                        // Ask to convert for temperature reading at 29 seconds or 59 seconds past the minute
                        oneWireBusReset();
0971  20D9  	CALL oneWireBus_00014

                        startTemp();
0972  158A  	BSF PCLATH,3
0973  2053  	CALL startTemp_00000

                    } else if ((gBcdSecond == 0) || (gBcdSecond == 0x30)) {
0974  158A  	BSF PCLATH,3
0975  2981  	GOTO	label159
0976  08B7  	MOVF gbl_gBcdSecond, F
0977  1903  	BTFSC STATUS,Z
0978  297D  	GOTO	label158
0979  0837  	MOVF gbl_gBcdSecond, W
097A  3A30  	XORLW 0x30
097B  1D03  	BTFSS STATUS,Z
097C  2981  	GOTO	label159
097D        label158
0981        label159
0A46  158A  	BSF PCLATH,3
0A47  295D  	GOTO	label155

                        // 1 second later, read the converted temperature
                        oneWireBusReset();
097D  20D9  	CALL oneWireBus_00014

                        readTemp();
097E  158A  	BSF PCLATH,3
097F  205C  	CALL readTemp_00000

                        // store it in the array, next display refresh will pick it up
                        convertTemp();
0980  253F  	CALL convertTem_00027

                    }
                    // daylight savings time handling (UK/europe) - last sunday of March or October (this can fall between the 25th and the 31st)
                    if ((gBcdSecond == 0) && (gDayOfWeek == 7) && (gBcdDayOfMonth > 0x24)) {
0981  1283  	BCF STATUS, RP0
0982  08B7  	MOVF gbl_gBcdSecond, F
0983  158A  	BSF PCLATH,3
0984  1D03  	BTFSS STATUS,Z
0985  29A4  	GOTO	label161
0986  083A  	MOVF gbl_gDayOfWeek, W
0987  3A07  	XORLW 0x07
0988  1D03  	BTFSS STATUS,Z
0989  29A4  	GOTO	label161
098A  083B  	MOVF gbl_gBcdDayOfMonth, W
098B  3C24  	SUBLW 0x24
098C  1803  	BTFSC STATUS,C
098D  29A4  	GOTO	label161

						// In March, at 1AM, apply daylight savings time if appropriate
						if ((gBcdHour == 1) && (gBcdMonth == 3)) {
098E  0339  	DECF gbl_gBcdHour, W
098F  1D03  	BTFSS STATUS,Z
0990  2998  	GOTO	label160
0991  083C  	MOVF gbl_gBcdMonth, W
0992  3A03  	XORLW 0x03
0993  1D03  	BTFSS STATUS,Z
0994  2998  	GOTO	label160
0998        label160

							gBcdHour++; // one hour forwards
0995  0AB9  	INCF gbl_gBcdHour, F

							ds3231WriteDateTime();
0996  118A  	BCF PCLATH,3
0997  2503  	CALL ds3231Writ_0001B

						}
						// In October, at 2AM, remove daylight savings time if appropriate (UK/europe) daylight savings time if appropriate (UK/europe) - last sunday of October
						if ((gBcdHour == 2) && (gBcdMonth == 0x10)) {
0998  0839  	MOVF gbl_gBcdHour, W
0999  3A02  	XORLW 0x02
099A  158A  	BSF PCLATH,3
099B  1D03  	BTFSS STATUS,Z
099C  29A4  	GOTO	label161
099D  083C  	MOVF gbl_gBcdMonth, W
099E  3A10  	XORLW 0x10
099F  1D03  	BTFSS STATUS,Z
09A0  29A4  	GOTO	label161
09A4        label161

							gBcdHour--; // one hour back
09A1  03B9  	DECF gbl_gBcdHour, F

							ds3231WriteDateTime();
09A2  118A  	BCF PCLATH,3
09A3  2503  	CALL ds3231Writ_0001B

						}
					}
                }
                if (!gcTriggerMode) {
09A4  08D5  	MOVF gbl_gcTriggerMode, F
09A5  158A  	BSF PCLATH,3
09A6  1D03  	BTFSS STATUS,Z
09A7  2A0D  	GOTO	label173

					// Don't activate triggers when in trigger set mode
					// Trigger white led
					// Don't activate/deactivate if on and off set hour/min are the same
					if ((gBcdWhiteOnHour != gBcdWhiteOffHour) || (gBcdWhiteOnMinute != gBcdWhiteOffMinute)) {
09A8  0859  	MOVF gbl_gBcdWhiteOffHour, W
09A9  0657  	XORWF gbl_gBcdWhiteOnHour, W
09AA  1D03  	BTFSS STATUS,Z
09AB  29B0  	GOTO	label162
09AC  0858  	MOVF gbl_gBcdWhiteOffMinute, W
09AD  0656  	XORWF gbl_gBcdWhiteOnMinute, W
09AE  1903  	BTFSC STATUS,Z
09AF  29C0  	GOTO	label164
09B0        label162

						if ((gBcdHour == gBcdWhiteOnHour) && (gBcdMinute == gBcdWhiteOnMinute)) {
09B0  0857  	MOVF gbl_gBcdWhiteOnHour, W
09B1  0639  	XORWF gbl_gBcdHour, W
09B2  1D03  	BTFSS STATUS,Z
09B3  29B8  	GOTO	label163
09B4  0856  	MOVF gbl_gBcdWhiteOnMinute, W
09B5  0638  	XORWF gbl_gBcdMinute, W
09B6  1903  	BTFSC STATUS,Z

							WHITE_LED = 1;
09B7  1487  	BSF gbl_portc,1
09B8        label163

						}
						if ((gBcdHour == gBcdWhiteOffHour) && (gBcdMinute == gBcdWhiteOffMinute)) {
09B8  0859  	MOVF gbl_gBcdWhiteOffHour, W
09B9  0639  	XORWF gbl_gBcdHour, W
09BA  1D03  	BTFSS STATUS,Z
09BB  29C0  	GOTO	label164
09BC  0858  	MOVF gbl_gBcdWhiteOffMinute, W
09BD  0638  	XORWF gbl_gBcdMinute, W
09BE  1903  	BTFSC STATUS,Z

							WHITE_LED = 0;
09BF  1087  	BCF gbl_portc,1
09C0        label164

						}
					}
					// Trigger blue led
					// Don't activate/deactivate if on and off set hour/min are the same
					if ((gBcdBlueOnHour != gBcdBlueOffHour) || (gBcdBlueOnMinute != gBcdBlueOffMinute)) {
09C0  085D  	MOVF gbl_gBcdBlueOffHour, W
09C1  065B  	XORWF gbl_gBcdBlueOnHour, W
09C2  1D03  	BTFSS STATUS,Z
09C3  29C8  	GOTO	label165
09C4  085C  	MOVF gbl_gBcdBlueOffMinute, W
09C5  065A  	XORWF gbl_gBcdBlueOnMinute, W
09C6  1903  	BTFSC STATUS,Z
09C7  29D8  	GOTO	label167
09C8        label165

						if ((gBcdHour == gBcdBlueOnHour) && (gBcdMinute == gBcdBlueOnMinute)) {
09C8  085B  	MOVF gbl_gBcdBlueOnHour, W
09C9  0639  	XORWF gbl_gBcdHour, W
09CA  1D03  	BTFSS STATUS,Z
09CB  29D0  	GOTO	label166
09CC  085A  	MOVF gbl_gBcdBlueOnMinute, W
09CD  0638  	XORWF gbl_gBcdMinute, W
09CE  1903  	BTFSC STATUS,Z

							BLUE_LED = 1;
09CF  1507  	BSF gbl_portc,2
09D0        label166

						}
						if ((gBcdHour == gBcdBlueOffHour) && (gBcdMinute == gBcdBlueOffMinute)) {
09D0  085D  	MOVF gbl_gBcdBlueOffHour, W
09D1  0639  	XORWF gbl_gBcdHour, W
09D2  1D03  	BTFSS STATUS,Z
09D3  29D8  	GOTO	label167
09D4  085C  	MOVF gbl_gBcdBlueOffMinute, W
09D5  0638  	XORWF gbl_gBcdMinute, W
09D6  1903  	BTFSC STATUS,Z

							BLUE_LED = 0;
09D7  1107  	BCF gbl_portc,2
09D8        label167

						}
					}
					// 2nd Trigger blue led
					// Don't activate/deactivate if on and off set hour/min are the same
					if ((gBcdBlue2OnHour != gBcdBlue2OffHour) || (gBcdBlue2OnMinute != gBcdBlue2OffMinute)) {
09D8  0861  	MOVF gbl_gBcdBlue2OffHour, W
09D9  065F  	XORWF gbl_gBcdBlue2OnHour, W
09DA  1D03  	BTFSS STATUS,Z
09DB  29E0  	GOTO	label168
09DC  0860  	MOVF gbl_gBcdBlue2OffMinute, W
09DD  065E  	XORWF gbl_gBcdBlue2OnMinute, W
09DE  1903  	BTFSC STATUS,Z
09DF  29F0  	GOTO	label170
09E0        label168

						if ((gBcdHour == gBcdBlue2OnHour) && (gBcdMinute == gBcdBlue2OnMinute)) {
09E0  085F  	MOVF gbl_gBcdBlue2OnHour, W
09E1  0639  	XORWF gbl_gBcdHour, W
09E2  1D03  	BTFSS STATUS,Z
09E3  29E8  	GOTO	label169
09E4  085E  	MOVF gbl_gBcdBlue2OnMinute, W
09E5  0638  	XORWF gbl_gBcdMinute, W
09E6  1903  	BTFSC STATUS,Z

							BLUE_LED = 1;
09E7  1507  	BSF gbl_portc,2
09E8        label169

						}
						if ((gBcdHour == gBcdBlue2OffHour) && (gBcdMinute == gBcdBlue2OffMinute)) {
09E8  0861  	MOVF gbl_gBcdBlue2OffHour, W
09E9  0639  	XORWF gbl_gBcdHour, W
09EA  1D03  	BTFSS STATUS,Z
09EB  29F0  	GOTO	label170
09EC  0860  	MOVF gbl_gBcdBlue2OffMinute, W
09ED  0638  	XORWF gbl_gBcdMinute, W
09EE  1903  	BTFSC STATUS,Z

							BLUE_LED = 0;
09EF  1107  	BCF gbl_portc,2
09F0        label170

						}
					}
					// Trigger fan
					// Don't activate/deactivate if on and off temperature are the same
					if (gBcdFanOnTemp != gBcdFanOffTemp) {
09F0  0863  	MOVF gbl_gBcdFanOffTemp, W
09F1  0662  	XORWF gbl_gBcdFanOnTemp, W
09F2  1903  	BTFSC STATUS,Z
09F3  29FC  	GOTO	label171

						if (giDS3231ValueTruncCBCD >= gBcdFanOnTemp) {
09F4  0862  	MOVF gbl_gBcdFanOnTemp, W
09F5  024E  	SUBWF gbl_giDS3231ValueTruncCBCD, W
09F6  1803  	BTFSC STATUS,C

							FAN = 1;
09F7  1485  	BSF gbl_porta,1

						}
						if (giDS3231ValueTruncCBCD <= gBcdFanOffTemp) {
09F8  084E  	MOVF gbl_giDS3231ValueTruncCBCD, W
09F9  0263  	SUBWF gbl_gBcdFanOffTemp, W
09FA  1803  	BTFSC STATUS,C

							FAN = 0;
09FB  1085  	BCF gbl_porta,1
09FC        label171

						}
					}
					// Forced on
					if (gbFanOn)
09FC  1851  	BTFSC gbl_gbFanOn,0

						FAN = 1;
09FD  1485  	BSF gbl_porta,1

					// Trigger heater
					// Don't activate/deactivate if on and off temperature are the same
					if (gBcdHeaterOnTemp != gBcdHeaterOffTemp) {
09FE  0865  	MOVF gbl_gBcdHeaterOffTemp, W
09FF  0664  	XORWF gbl_gBcdHeaterOnTemp, W
0A00  1903  	BTFSC STATUS,Z
0A01  2A0A  	GOTO	label172

						if (giDS3231ValueTruncCBCD <= gBcdHeaterOnTemp) {
0A02  084E  	MOVF gbl_giDS3231ValueTruncCBCD, W
0A03  0264  	SUBWF gbl_gBcdHeaterOnTemp, W
0A04  1803  	BTFSC STATUS,C

							HEATER = 1;
0A05  1405  	BSF gbl_porta,0

						}
						if (giDS3231ValueTruncCBCD >= gBcdHeaterOffTemp) {
0A06  0865  	MOVF gbl_gBcdHeaterOffTemp, W
0A07  024E  	SUBWF gbl_giDS3231ValueTruncCBCD, W
0A08  1803  	BTFSC STATUS,C

							HEATER = 0;
0A09  1005  	BCF gbl_porta,0
0A0A        label172

						}
					}
					// If temperature is minus, always trigger heater
					if (gbDS3231IsMinus)
0A0A  08CF  	MOVF gbl_gbDS3231IsMinus, F
0A0B  1D03  	BTFSS STATUS,Z

						HEATER = 1;
0A0C  1405  	BSF gbl_porta,0
0A0D        label173

				}
				// Display time and temperature or date on TM1638 after clock tick
				if (!gcTriggerMode && !gcSetMode) {
0A0D  08D5  	MOVF gbl_gcTriggerMode, F
0A0E  1D03  	BTFSS STATUS,Z
0A0F  2A15  	GOTO	label174
0A10  08D3  	MOVF gbl_gcSetMode, F
0A11  1D03  	BTFSS STATUS,Z
0A12  2A15  	GOTO	label174
0A15        label174

					tm1638UpdateDisplay();
0A13  118A  	BCF PCLATH,3
0A14  229D  	CALL tm1638Upda_00022

                }

                cTask.TASK_TIMER1 = 0;
0A15  1150  	BCF gbl_cTask,2

            }
            if (cTask.TASK_TIMER0) {
0A16  158A  	BSF PCLATH,3
0A17  1CD0  	BTFSS gbl_cTask,1
0A18  295D  	GOTO	label155

				// Task should happen about every 50ms
                // Digit flashing - see if 10 counts has happened for an ~half second count
                iTimer0FlashCounts++;
0A19  0AC8  	INCF gbl_iTimer0FlashCounts, F

				if (iTimer0FlashCounts > 9) {
0A1A  0848  	MOVF gbl_iTimer0FlashCounts, W
0A1B  3C09  	SUBLW 0x09
0A1C  1803  	BTFSC STATUS,C
0A1D  2A28  	GOTO	label177

					iFlashDigitOff++;
0A1E  0ACA  	INCF gbl_iFlashDigitOff, F

					iTimer0FlashCounts = 0;
0A1F  01C8  	CLRF gbl_iTimer0FlashCounts

					// If in set or trigger mode, update the display every ~half second to flash a digit
					if (gcSetMode || gcTriggerMode)
0A20  08D3  	MOVF gbl_gcSetMode, F
0A21  1D03  	BTFSS STATUS,Z
0A22  2A26  	GOTO	label176
0A23  08D5  	MOVF gbl_gcTriggerMode, F
0A24  1903  	BTFSC STATUS,Z
0A25  2A28  	GOTO	label177
0A26        label176

						tm1638UpdateDisplay();
0A26  118A  	BCF PCLATH,3
0A27  229D  	CALL tm1638Upda_00022

				}
				// Poll keys
				tm1638ReadKeys();
0A28  158A  	BSF PCLATH,3
0A29  202C  	CALL tm1638Read_00025

				// Button state changed
                char processKeys = 0;
0A2A  01F5  	CLRF main_104_processKeys

                if (tm1638Keys != tm1638KeysOld) {
0A2B  086F  	MOVF gbl_tm1638KeysOld, W
0A2C  066E  	XORWF gbl_tm1638Keys, W
0A2D  1903  	BTFSC STATUS,Z
0A2E  2A32  	GOTO	label178
0A32        label178

                    processKeys = 1;
0A2F  3001  	MOVLW 0x01
0A30  00F5  	MOVWF main_104_processKeys

                } else if (tm1638Keys != 0) {
0A31  2A3C  	GOTO	label179
0A32  08EE  	MOVF gbl_tm1638Keys, F
0A33  1903  	BTFSC STATUS,Z
0A34  2A3C  	GOTO	label179

                    // Button held
                    iTimer0KeyCounts++;
0A35  0AC9  	INCF gbl_iTimer0KeyCounts, F

                    // If button held more than 250ms
                    if (iTimer0KeyCounts > 4) {
0A36  0849  	MOVF gbl_iTimer0KeyCounts, W
0A37  3C04  	SUBLW 0x04
0A38  1803  	BTFSC STATUS,C
0A39  2A3C  	GOTO	label179
0A3C        label179

                        processKeys = 1;
0A3A  3001  	MOVLW 0x01
0A3B  00F5  	MOVWF main_104_processKeys

                    }
                }
                if (processKeys) {
0A3C  08F5  	MOVF main_104_processKeys, F
0A3D  1903  	BTFSC STATUS,Z
0A3E  2A45  	GOTO	label180
0A45        label180

					processKeys();
0A3F  206B  	CALL processKey_0002A

					tm1638UpdateDisplay();
0A40  118A  	BCF PCLATH,3
0A41  229D  	CALL tm1638Upda_00022

					tm1638KeysOld = tm1638Keys;
0A42  086E  	MOVF gbl_tm1638Keys, W
0A43  00EF  	MOVWF gbl_tm1638KeysOld

                    iTimer0KeyCounts = 0;
0A44  01C9  	CLRF gbl_iTimer0KeyCounts

                }
                cTask.TASK_TIMER0 = 0;
0A45  10D0  	BCF gbl_cTask,1

            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
// I2C Communications Library for I2C MASTER
////////////////////////////////////////////////////////////////////////////
// Author(s): Andrew Smallridge
// Date 15 November 2004
//
// Copyright(C) 2004-2006 Andrew Smallridge
// Copyright(C) 2004-2010 Pavel Baranov
// Copyright(C) 2004-2010 David Hobday
// Existing constants predefined for i2c hardware driver and i2s software
// emulation for the PIC 18F2xx and 18F4xx processors. For hardware support
// on other PICs the constants must be mapped to the corresponding register
// map of the target device
////////////////////////////////////////////////////////////////////////////

/*
////////////////////////////////////////////////////////////////////////////
//	The following three sections should be copied to the user's program:
//		i2c master hardware / software mode definition
//		i2c software implementation template arguments and variables
// 		i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////
// i2c master hardware / software mode definition
//
// For i2c hardware support comment out the #define use_ic2_SW line
////////////////////////////////////////////////////////////////////////////
//#define use_i2c_SW

#if defined use_i2c_SW
////////////////////////////////////////////////////////////////////////////
// i2c software implementation template arguments and variables
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)

// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and software emalated i2c RAM locations. These constants are
// then used by the templated functions. When changing the address of an emulated
// register the corresponding constant mapping must also be changed.
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3					

#else
////////////////////////////////////////////////////////////////////////////
// i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP |i2c_HW)

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and PIC's i2c register locations. These constants are
// then used by the templated functions. 
#define PORTC		0x0f82
#define TRISC		0x0f94
#define e_SSPCON1	0xfc6
#define e_SSPCON2	0xfc5
#define e_SSPSTAT	0xfc7
#define e_SSPADD	0xfc8
#define e_SSPBUF	0xfc9
#define e_SSPIF_PIR	0xf9e
#define e_BCLIF_PIR	0xfa1
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3

#endif

*/


////////////////////////////////////////////////////////////////////////////
// Define the common i2c template structure
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL	template <unsigned char T_SCL_BIT, unsigned short T_SCL_PORT,	\
					unsigned short T_SCL_TRIS, unsigned char T_SDA_BIT, 			\
					unsigned short T_SDA_PORT, unsigned short T_SDA_TRIS,			\
					unsigned short T_i2c_SSPCON1, unsigned short T_i2c_SSPCON2, 	\
					unsigned short T_i2c_SSPSTAT, unsigned short T_i2c_SSPBUF, 		\
					unsigned char T_i2c_SSPIF_BIT, unsigned short T_i2c_SSPIF_PIR,	\
					unsigned char T_i2c_BCLIF_BIT, unsigned short T_i2c_BCLIF_PIR,	\
					unsigned char T_i2c_SMP_BIT, unsigned short T_i2c_SSPADD, 		\
					unsigned char T_MODE>

////////////////////////////////////////////////////////////////////////////
// Define the common i2c template parameters
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL_ARGS	T_SCL_BIT, T_SCL_PORT, T_SCL_TRIS, T_SDA_BIT, 			\
						T_SDA_PORT, T_SDA_TRIS, T_i2c_SSPCON1, T_i2c_SSPCON2, 	\
						T_i2c_SSPSTAT, T_i2c_SSPBUF, T_i2c_SSPIF_BIT, 			\
						T_i2c_SSPIF_PIR, T_i2c_BCLIF_BIT, T_i2c_BCLIF_PIR,		\
						T_i2c_SMP_BIT, T_i2c_SSPADD, T_MODE

////////////////////////////////////////////////////////////////////////////
// Helpers that hide template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_init	i2c_INIT<i2c_ARGS>
#define i2c_start	i2c_START<i2c_ARGS>
#define i2c_restart	i2c_RESTART<i2c_ARGS>
#define i2c_stop	i2c_STOP<i2c_ARGS>
#define i2c_read	i2c_READ<i2c_ARGS>
#define i2c_write	i2c_WRITE<i2c_ARGS>


////////////////////////////////////////////////////////////////////////////
// I2C Control Status Bits - Emulates the PIC18F hardware I2C implementation
////////////////////////////////////////////////////////////////////////////
// define I2C i2C_SSPCON1 control bits
#define	i2c_WCOL	7
#define	i2c_SSPOV	6
#define	i2c_SSPEN	5
#define	i2c_CKP		4
#define	i2c_SSPM3	3
#define	i2c_SSPM2	2
#define	i2c_SSPM1	1
#define	i2c_SSPM0	0

// define I2C SSPCON2 control bits
#define	i2c_GCEN 	7
#define	i2c_ACKSTAT	6
#define	i2c_ACKDT	5
#define	i2c_ACKEN	4
#define	i2c_RCEN	3
#define	i2c_PEN		2
#define	i2c_RSEN	1
#define	i2c_SEN		0

// define I2C SSPSTAT status bits
#define	i2c_DA		5
#define	i2c_P		4
#define	i2c_S		3
#define	i2c_RW		2
#define	i2c_UA		1
#define	i2c_BF		0


////////////////////////////////////////////////////////////////////////////
// I2C Control Flag Bits
////////////////////////////////////////////////////////////////////////////
// define I2C Mode bits
#define	i2c_HW			0x01
#define	i2c_400KHz		0x02	// 100KHz or 400KHz I2C clock (set = 400KHz)
#define	i2c_reset_wdt	0x04
#define i2c_SMP			0x80	


////////////////////////////////////////////////////////////////////////////
// I2C software constants
////////////////////////////////////////////////////////////////////////////
#define	dly 10	// number of 1us delay increments



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Start Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL 
void i2c_START(void)

{
	// Initiate the I2C START condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	delay_us(dly);
012A  300A  	MOVLW 0x0A
012B  1283  	BCF STATUS, RP0
012C  1303  	BCF STATUS, RP1
012D  00FB  	MOVWF delay_us_00000_arg_del
012E  2010  	CALL delay_us_00000

	l_bclif = 0; // initialise the collision flag for this command
012F  11C6  	BCF i2c_START_00000_1_l_bclif,3

	l_sspif = 0;
0130  11C5  	BCF i2c_START_00000_1_l_sspif,3

		
	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
			
		l_sen = 1; // initiate START condition	

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation			
		l_sen = 1; // initiate START condition
0131  1441  	BSF i2c_START_00000_1_l_sen,0

		l_scl_tris = 1; // ensure the SCL line is high
0132  1683  	BSF STATUS, RP0
0133  1587  	BSF i2c_START_00000_1_l_scl_tris,3

		l_sda_tris = 1; // ensure the SDA line is high	
0134  1607  	BSF i2c_START_00000_1_l_sda_tris,4

		l_scl = 0; // prepare to set SCL line low
0135  1283  	BCF STATUS, RP0
0136  1187  	BCF i2c_START_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low
0137  1207  	BCF i2c_START_00000_1_l_sda,4

		
		if (l_scl && l_sda)
0138  1D87  	BTFSS i2c_START_00000_1_l_scl,3
0139  2957  	GOTO	label24
013A  1E07  	BTFSS i2c_START_00000_1_l_sda,4
013B  2957  	GOTO	label24
0157        label24

		{
			// good sign - no collision detected
			delay_us(dly);
013C  300A  	MOVLW 0x0A
013D  00FB  	MOVWF delay_us_00000_arg_del
013E  2010  	CALL delay_us_00000

			
			if (!l_scl) // ensure the clock is still high
013F  1987  	BTFSC i2c_START_00000_1_l_scl,3
0140  2945  	GOTO	label23
0145        label23

			{
				l_bclif = 1;
0141  15C6  	BSF i2c_START_00000_1_l_bclif,3

				l_s = 1;
0142  15C2  	BSF i2c_START_00000_1_l_s,3

				l_sen = 0;
0143  1041  	BCF i2c_START_00000_1_l_sen,0

				return;
			}
					
			l_sda = 0; // prepare to set SDA line low
0145  1207  	BCF i2c_START_00000_1_l_sda,4

			l_sda_tris = 0; // SDA to output (driven low)
0146  1683  	BSF STATUS, RP0
0147  1207  	BCF i2c_START_00000_1_l_sda_tris,4


			delay_us(dly);					
0148  300A  	MOVLW 0x0A
0149  1283  	BCF STATUS, RP0
014A  00FB  	MOVWF delay_us_00000_arg_del
014B  2010  	CALL delay_us_00000

			l_scl = 0; // prepare to set SCL line low
014C  1187  	BCF i2c_START_00000_1_l_scl,3

			l_scl_tris = 0; // SCL to output (driven low)
014D  1683  	BSF STATUS, RP0
014E  1187  	BCF i2c_START_00000_1_l_scl_tris,3


			delay_us(dly);					
014F  300A  	MOVLW 0x0A
0150  1283  	BCF STATUS, RP0
0151  00FB  	MOVWF delay_us_00000_arg_del
0152  2010  	CALL delay_us_00000

			l_s = 1; // set 'S' bit flag (start bit detected)
0153  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0; // clear flag
0154  1041  	BCF i2c_START_00000_1_l_sen,0

			l_sspif = 1; // flag end of start condition interrupt	
0155  15C5  	BSF i2c_START_00000_1_l_sspif,3

		}
		else
		{
			// here is SDA or SCL are low at the start - indicates a bus collision
			l_bclif = 1;
0157  15C6  	BSF i2c_START_00000_1_l_bclif,3

			l_s = 1; // set 'S' bit flag (start bit detected)
0158  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0;
0159  1041  	BCF i2c_START_00000_1_l_sen,0

			l_rsen = 0;
015A  10C1  	BCF i2c_START_00000_1_l_rsen,1

			l_pen = 0;
015B  1141  	BCF i2c_START_00000_1_l_pen,2

			l_rcen = 0;								
015C  11C1  	BCF i2c_START_00000_1_l_rcen,3

			l_acken = 0;			
015D  1241  	BCF i2c_START_00000_1_l_acken,4

		}
	}
}
0144  0008  	RETURN
0156  0008  	RETURN
015E  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Restart Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_RESTART(void)
{
	// Initiate the I2C RESTART condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
			
	delay_us(dly);
	l_bclif = 0; // initialise the collision flag for this command
	l_sspif = 0;

	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_rsen = 1; // initiate RESTART condition
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation	
		l_rsen = 1;
		l_scl = 0;
		l_sda = 0;
		
		if (!l_scl)
		{
			// good sign - no other I2C activity in progress
			l_sda_tris = 1; // float SDA line high	(should already be in this condition)	
			delay_us(dly);
		
			// about to float the clock line
			// ensure the data line is still high
			if (!l_sda)
			{
				// problem - SDA is low, a bus collision has occurred				
				l_bclif = 1; // set the bus collision flag	
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_scl_tris = 1; // float SCL line (high)	
				return;
			}
												
			l_scl_tris = 1; // float SCL line (high)

			// wait until any clock stretching has finished
			while (!l_scl)
				if (T_MODE & i2c_reset_wdt)
					clear_wdt();	
			delay_us(dly);
			
			// here we are about to drive SDA low
			// first ensure SCL is still high
			if (!l_scl)
			{
				// problem - SCL is low, a bus collision has occurred
				l_bclif = 1; // set the bus collision flag
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_sda_tris = 1; // float SDA line (high)
				return;
			}
				
			l_sda_tris = 0; // drive SDA low
			l_s = 1; // set 'S' bit flag (start bit detected)

			delay_us(dly);
			l_scl_tris = 0; // drive SCL low
			l_rsen = 0;
			l_pen = 0;
			l_sen = 0;			
			l_rcen = 0;								
			l_acken = 0;			
			l_sspif = 1; // flag end of start condition interrupt
		}
		else
		{
			// SCL is high at the start
			// some other I2C activity in progress		
			l_rsen = 0; // clear flag
			// exit without further action
		}
	}
}



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Stop Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_STOP(void)

{ 
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_p@T_i2c_SSPSTAT.i2c_P; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;

	l_bclif = 0; // initialise the collision flag for this command
00FA  1283  	BCF STATUS, RP0
00FB  1303  	BCF STATUS, RP1
00FC  11C6  	BCF i2c_STOP_00000_1_l_bclif,3

	l_sspif = 0;
00FD  11C5  	BCF i2c_STOP_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_pen = 1; // initiate STOP condition on the I2C bus	
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
		
	}
	else
	{
		//	Software I2C implementation
		l_pen = 1; // initiate STOP condition on the I2C bus
00FE  1541  	BSF i2c_STOP_00000_1_l_pen,2

		delay_us(dly);
00FF  300A  	MOVLW 0x0A
0100  00FB  	MOVWF delay_us_00000_arg_del
0101  2010  	CALL delay_us_00000

		
		l_scl = 0; // prepare to set SCL line low
0102  1187  	BCF i2c_STOP_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low
0103  1207  	BCF i2c_STOP_00000_1_l_sda,4

		l_scl_tris = 0; // drive SCL line low (should already be low)
0104  1683  	BSF STATUS, RP0
0105  1187  	BCF i2c_STOP_00000_1_l_scl_tris,3

		l_sda_tris = 0; // drive SDA line low
0106  1207  	BCF i2c_STOP_00000_1_l_sda_tris,4


		delay_us(dly);		
0107  300A  	MOVLW 0x0A
0108  1283  	BCF STATUS, RP0
0109  00FB  	MOVWF delay_us_00000_arg_del
010A  2010  	CALL delay_us_00000

		l_scl_tris = 1; // float SCL line (high)
010B  1683  	BSF STATUS, RP0
010C  1587  	BSF i2c_STOP_00000_1_l_scl_tris,3

		
		// wait until any clock stretching has finished
		while (!l_scl)
010D        label19
010D  1283  	BCF STATUS, RP0
010E  1987  	BTFSC i2c_STOP_00000_1_l_scl,3
010F  2912  	GOTO	label20
0111  290D  	GOTO	label19
0112        label20

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
0110  0064  	CLRWDT

						
		delay_us(dly);
0112  300A  	MOVLW 0x0A
0113  00FB  	MOVWF delay_us_00000_arg_del
0114  2010  	CALL delay_us_00000

		l_sda_tris = 1; // float SDA line
0115  1683  	BSF STATUS, RP0
0116  1607  	BSF i2c_STOP_00000_1_l_sda_tris,4

		delay_us(dly);		
0117  300A  	MOVLW 0x0A
0118  1283  	BCF STATUS, RP0
0119  00FB  	MOVWF delay_us_00000_arg_del
011A  2010  	CALL delay_us_00000

		
		// here the SDA line should be high - if not a collision has occurred				
		if (!l_sda || !l_scl)
011B  1E07  	BTFSS i2c_STOP_00000_1_l_sda,4
011C  291F  	GOTO	label21
011D  1987  	BTFSC i2c_STOP_00000_1_l_scl,3
011E  2923  	GOTO	label22
011F        label21
0123        label22

		{
			// problem - SDA or SCL is low, a bus collision has occurred
			l_bclif = 1; // set the bus collision flag	
011F  15C6  	BSF i2c_STOP_00000_1_l_bclif,3

			l_s = 0; // clear 'S' bit flag
0120  11C2  	BCF i2c_STOP_00000_1_l_s,3

			l_pen = 0; // clear flag
0121  1141  	BCF i2c_STOP_00000_1_l_pen,2

		}
		else
		{		
			l_p = 1;
0123  1642  	BSF i2c_STOP_00000_1_l_p,4

			l_pen = 0;
0124  1141  	BCF i2c_STOP_00000_1_l_pen,2

			l_sen = 0;
0125  1041  	BCF i2c_STOP_00000_1_l_sen,0

			l_rsen = 0;			
0126  10C1  	BCF i2c_STOP_00000_1_l_rsen,1

			l_rcen = 0;								
0127  11C1  	BCF i2c_STOP_00000_1_l_rcen,3

			l_acken = 0;
0128  1241  	BCF i2c_STOP_00000_1_l_acken,4

		}
	}
}
0122  0008  	RETURN
0129  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Write Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_WRITE(unsigned char i2c_data)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;	
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
	
	char BitMask;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
00A9  11C6  	BCF i2c_WRITE_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
00AA  11C5  	BCF i2c_WRITE_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
				
		l_wcol = 0; // clear write collision flag	
		i2c_SSPBUF = i2c_data;

		// test if a write collision occurred
		if (l_wcol)
			return (1); // error exit	

		// wait until MSSP Tx register is empty
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
								
		return (0); // successful exit
	}

	// here for i2c software driver
	l_wcol = 0; // clear write collision flag	
00AB  13C0  	BCF i2c_WRITE_00000_1_l_wcol,7

	i2c_SSPBUF = i2c_data;
00AC  0878  	MOVF i2c_WRITE_00000_arg_i2c_data, W
00AD  00C4  	MOVWF i2c_WRITE_00000_1_i2c_SSPBUF

	
	l_scl = 0; // prepare to set SCL line low
00AE  1187  	BCF i2c_WRITE_00000_1_l_scl,3

	l_sda = 0; // prepare to set SDA line low
00AF  1207  	BCF i2c_WRITE_00000_1_l_sda,4

	l_rw = 0; // signal we are doing a write
00B0  1142  	BCF i2c_WRITE_00000_1_l_rw,2


	for (BitMask = 0x80; BitMask; BitMask>>=1)
00B1  3080  	MOVLW 0x80
00B2  00F9  	MOVWF i2c_WRITE_00000_1_BitMask
00B3        label11
00B3  08F9  	MOVF i2c_WRITE_00000_1_BitMask, F
00B4  1903  	BTFSC STATUS,Z
00B5  28D6  	GOTO	label16
00D3  1003  	BCF STATUS,C
00D4  0CF9  	RRF i2c_WRITE_00000_1_BitMask, F
00D5  28B3  	GOTO	label11
00D6        label16

	{
		if (i2c_data & BitMask)
00B6  0879  	MOVF i2c_WRITE_00000_1_BitMask, W
00B7  0578  	ANDWF i2c_WRITE_00000_arg_i2c_data, W
00B8  1903  	BTFSC STATUS,Z
00B9  28BD  	GOTO	label12
00BD        label12

			l_sda_tris = 1; // float SDA high	
00BA  1683  	BSF STATUS, RP0
00BB  1607  	BSF i2c_WRITE_00000_1_l_sda_tris,4

		else
00BC  28BF  	GOTO	label13
00BF        label13

			l_sda_tris = 0; // drive SDA low
00BD  1683  	BSF STATUS, RP0
00BE  1207  	BCF i2c_WRITE_00000_1_l_sda_tris,4

		delay_us(dly);
00BF  300A  	MOVLW 0x0A
00C0  1283  	BCF STATUS, RP0
00C1  00FB  	MOVWF delay_us_00000_arg_del
00C2  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
00C3  1683  	BSF STATUS, RP0
00C4  1587  	BSF i2c_WRITE_00000_1_l_scl_tris,3


		// wait until any clock stretching has finished
		while (!l_scl)
00C5        label14
00C5  1283  	BCF STATUS, RP0
00C6  1987  	BTFSC i2c_WRITE_00000_1_l_scl,3
00C7  28CA  	GOTO	label15
00C9  28C5  	GOTO	label14
00CA        label15

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
00C8  0064  	CLRWDT

		delay_us(dly);
00CA  300A  	MOVLW 0x0A
00CB  00FB  	MOVWF delay_us_00000_arg_del
00CC  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low	
00CD  1683  	BSF STATUS, RP0
00CE  1187  	BCF i2c_WRITE_00000_1_l_scl_tris,3

		delay_us(dly);
00CF  300A  	MOVLW 0x0A
00D0  1283  	BCF STATUS, RP0
00D1  00FB  	MOVWF delay_us_00000_arg_del
00D2  2010  	CALL delay_us_00000

	}
	// serialized out the data
	// now get the status		
	// set SSPIF
	l_sspif = 1;
00D6  15C5  	BSF i2c_WRITE_00000_1_l_sspif,3

	l_acken = 1;
00D7  1641  	BSF i2c_WRITE_00000_1_l_acken,4

	l_ackdt = 0;
00D8  12C1  	BCF i2c_WRITE_00000_1_l_ackdt,5

	l_sda_tris = 1; // float SDA high
00D9  1683  	BSF STATUS, RP0
00DA  1607  	BSF i2c_WRITE_00000_1_l_sda_tris,4

	
	delay_us(dly);
00DB  300A  	MOVLW 0x0A
00DC  1283  	BCF STATUS, RP0
00DD  00FB  	MOVWF delay_us_00000_arg_del
00DE  2010  	CALL delay_us_00000

	
	l_scl_tris = 1; // float SCL high
00DF  1683  	BSF STATUS, RP0
00E0  1587  	BSF i2c_WRITE_00000_1_l_scl_tris,3

	
	// wait until any clock stretching has finished
	while (!l_scl)
00E1        label17
00E1  1283  	BCF STATUS, RP0
00E2  1987  	BTFSC i2c_WRITE_00000_1_l_scl,3
00E3  28E6  	GOTO	label18
00E5  28E1  	GOTO	label17
00E6        label18

		if (T_MODE & i2c_reset_wdt)
			clear_wdt();	
00E4  0064  	CLRWDT

	delay_us(dly);
00E6  300A  	MOVLW 0x0A
00E7  00FB  	MOVWF delay_us_00000_arg_del
00E8  2010  	CALL delay_us_00000


	// get the status bit
	local_ack = l_sda;
00E9  107A  	BCF i2c_WRITE_00000_1_local_ack,0
00EA  1A07  	BTFSC i2c_WRITE_00000_1_l_sda,4
00EB  147A  	BSF i2c_WRITE_00000_1_local_ack,0

	delay_us(dly);
00EC  300A  	MOVLW 0x0A
00ED  00FB  	MOVWF delay_us_00000_arg_del
00EE  2010  	CALL delay_us_00000


	l_scl_tris = 0; // drive SCL low	
00EF  1683  	BSF STATUS, RP0
00F0  1187  	BCF i2c_WRITE_00000_1_l_scl_tris,3

	l_acken = 0;
00F1  1283  	BCF STATUS, RP0
00F2  1241  	BCF i2c_WRITE_00000_1_l_acken,4

	delay_us(dly);
00F3  300A  	MOVLW 0x0A
00F4  00FB  	MOVWF delay_us_00000_arg_del
00F5  2010  	CALL delay_us_00000

	return(local_ack);
00F6  01FB  	CLRF CompTempVarRet550
00F7  187A  	BTFSC i2c_WRITE_00000_1_local_ack,0
00F8  0AFB  	INCF CompTempVarRet550, F

}
00F9  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Read Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_READ(char ack_status)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	char BitMask;
	char i2c_data;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
01E2  11C6  	BCF i2c_READ_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
01E3  11C5  	BCF i2c_READ_00000_1_l_sspif,3

	l_wcol = 0; // clear write collision flag	
01E4  13C0  	BCF i2c_READ_00000_1_l_wcol,7


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// enable master for 1 byte reception	
		l_rcen = 1;

		// wait until byte received
		while(!l_sspif || !l_bf)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// read the byte from the Rx register
		i2c_data = i2c_SSPBUF;			
			
		// wait until the bus is idle		
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		if (ack_status)
			l_ackdt = 1; // preset ack bit
		else
			l_ackdt = 0; // preset ack bit

		l_sspif = 0;
		l_acken = 1; // acknowledge sequence enable

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();								
	}
	else
	{
		// here for i2c software driver
		l_rcen = 1;
01E5  15C1  	BSF i2c_READ_00000_1_l_rcen,3

		l_ackdt = ack_status;
01E6  1878  	BTFSC i2c_READ_00000_arg_ack_status,0
01E7  16C1  	BSF i2c_READ_00000_1_l_ackdt,5
01E8  1C78  	BTFSS i2c_READ_00000_arg_ack_status,0
01E9  12C1  	BCF i2c_READ_00000_1_l_ackdt,5

		l_rw = 1;
01EA  1542  	BSF i2c_READ_00000_1_l_rw,2

		l_scl = 0; // prepare to set SCL line low
01EB  1187  	BCF i2c_READ_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low	
01EC  1207  	BCF i2c_READ_00000_1_l_sda,4


		// prepare to serialize in the byte
		l_sda_tris = 1; // float SDA
01ED  1683  	BSF STATUS, RP0
01EE  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

		delay_us(dly);
01EF  300A  	MOVLW 0x0A
01F0  1283  	BCF STATUS, RP0
01F1  00FB  	MOVWF delay_us_00000_arg_del
01F2  2010  	CALL delay_us_00000

		i2c_data = 0;
01F3  01FA  	CLRF i2c_READ_00000_1_i2c_data

		for (BitMask = 0x80; BitMask; BitMask>>=1)
01F4  3080  	MOVLW 0x80
01F5  00F9  	MOVWF i2c_READ_00000_1_BitMask
01F6        label35
01F6  08F9  	MOVF i2c_READ_00000_1_BitMask, F
01F7  1903  	BTFSC STATUS,Z
01F8  2A13  	GOTO	label39
0210  1003  	BCF STATUS,C
0211  0CF9  	RRF i2c_READ_00000_1_BitMask, F
0212  29F6  	GOTO	label35
0213        label39

		{
			l_scl_tris = 1; // float SCL high
01F9  1683  	BSF STATUS, RP0
01FA  1587  	BSF i2c_READ_00000_1_l_scl_tris,3

			// wait until any clock stretching has finished
			while (!l_scl)
01FB        label36
01FB  1283  	BCF STATUS, RP0
01FC  1987  	BTFSC i2c_READ_00000_1_l_scl,3
01FD  2A00  	GOTO	label37
01FF  29FB  	GOTO	label36
0200        label37

				if (T_MODE & i2c_reset_wdt)
					clear_wdt();		
01FE  0064  	CLRWDT

			delay_us(dly);
0200  300A  	MOVLW 0x0A
0201  00FB  	MOVWF delay_us_00000_arg_del
0202  2010  	CALL delay_us_00000


			// read the current bit
			l_sda_tris = 1; // float SDA
0203  1683  	BSF STATUS, RP0
0204  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

			if (l_sda)
0205  1283  	BCF STATUS, RP0
0206  1E07  	BTFSS i2c_READ_00000_1_l_sda,4
0207  2A0A  	GOTO	label38
020A        label38

				i2c_data |= BitMask;
0208  0879  	MOVF i2c_READ_00000_1_BitMask, W
0209  04FA  	IORWF i2c_READ_00000_1_i2c_data, F

			l_scl_tris = 0; // drive SCL low
020A  1683  	BSF STATUS, RP0
020B  1187  	BCF i2c_READ_00000_1_l_scl_tris,3

			delay_us(dly);
020C  300A  	MOVLW 0x0A
020D  1283  	BCF STATUS, RP0
020E  00FB  	MOVWF delay_us_00000_arg_del
020F  2010  	CALL delay_us_00000

		}
		// flag receive complete			
		l_sspif = 1;
0213  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		l_rcen = 0;
0214  11C1  	BCF i2c_READ_00000_1_l_rcen,3

		
		// set the ACK state
		if (ack_status)	
0215  08F8  	MOVF i2c_READ_00000_arg_ack_status, F
0216  1903  	BTFSC STATUS,Z
0217  2A1B  	GOTO	label40
021B        label40

			l_sda_tris = 1; // float SDA high
0218  1683  	BSF STATUS, RP0
0219  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

		else
021A  2A1D  	GOTO	label41
021D        label41

			l_sda_tris = 0; // drive SDA low
021B  1683  	BSF STATUS, RP0
021C  1207  	BCF i2c_READ_00000_1_l_sda_tris,4

		delay_us(dly);
021D  300A  	MOVLW 0x0A
021E  1283  	BCF STATUS, RP0
021F  00FB  	MOVWF delay_us_00000_arg_del
0220  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
0221  1683  	BSF STATUS, RP0
0222  1587  	BSF i2c_READ_00000_1_l_scl_tris,3


		// wait until any clock stretching has finished
		while (!l_scl)
0223        label42
0223  1283  	BCF STATUS, RP0
0224  1987  	BTFSC i2c_READ_00000_1_l_scl,3
0225  2A28  	GOTO	label43
0227  2A23  	GOTO	label42
0228        label43

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
0226  0064  	CLRWDT

	
		l_sspif = 0; // clear SSPIF
0228  11C5  	BCF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
0229  300A  	MOVLW 0x0A
022A  00FB  	MOVWF delay_us_00000_arg_del
022B  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low		
022C  1683  	BSF STATUS, RP0
022D  1187  	BCF i2c_READ_00000_1_l_scl_tris,3

		l_sspif = 1;
022E  1283  	BCF STATUS, RP0
022F  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
0230  300A  	MOVLW 0x0A
0231  00FB  	MOVWF delay_us_00000_arg_del
0232  2010  	CALL delay_us_00000

	}
	return(i2c_data);
0233  087A  	MOVF i2c_READ_00000_1_i2c_data, W
0234  00FB  	MOVWF CompTempVarRet551

}
0235  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Initialization
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_INIT(unsigned char i2c_divisor)

{
	volatile unsigned char i2c_SSPADD@T_i2c_SSPADD, i2c_SSPSTAT@T_i2c_SSPSTAT;
	volatile unsigned char i2c_SSPCON1@T_i2c_SSPCON1,i2c_SSPCON2@T_i2c_SSPCON2;

	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_sspen@T_i2c_SSPCON1.i2c_SSPEN, l_smp@T_i2c_SSPSTAT.T_i2c_SMP_BIT;

	l_sda_tris = 1;
04F0  1683  	BSF STATUS, RP0
04F1  1607  	BSF i2c_INIT_00000_1_l_sda_tris,4

	l_scl_tris = 1;
04F2  1587  	BSF i2c_INIT_00000_1_l_scl_tris,3

	
	i2c_SSPCON1 = 0x00; // initialise the I2C control register (mirrors HW SSPCON1)	
04F3  1283  	BCF STATUS, RP0
04F4  01C0  	CLRF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPADD = i2c_divisor; // get the I2C baud rate divisor
04F5  0876  	MOVF i2c_INIT_00000_arg_i2c_divisor, W
04F6  00C3  	MOVWF i2c_INIT_00000_1_i2c_SSPADD

	i2c_SSPCON1 = 0x08; // initialise the I2C control register (mirrors HW SSPCON1)	
04F7  3008  	MOVLW 0x08
04F8  00C0  	MOVWF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPCON2 = 0x00; // initialise the I2C control register (mirrors HW SSPCON2)	
04F9  01C1  	CLRF i2c_INIT_00000_1_i2c_SSPCON2

	
	i2c_SSPSTAT = 0x00; // initialise the I2C status register (mirrors HW SSPSTAT)
04FA  01C2  	CLRF i2c_INIT_00000_1_i2c_SSPSTAT

	
	if (T_MODE & i2c_SMP)
		l_smp = 1;
04FB  17C2  	BSF i2c_INIT_00000_1_l_smp,7


	l_sspif = 0; // initialise the I2C SSP interrupt status
04FC  11C5  	BCF i2c_INIT_00000_1_l_sspif,3

	l_bclif = 0; // initialise the I2C BCL interrupt status
04FD  11C6  	BCF i2c_INIT_00000_1_l_bclif,3

	l_sda = 0;
04FE  1207  	BCF i2c_INIT_00000_1_l_sda,4

	l_scl = 0;
04FF  1187  	BCF i2c_INIT_00000_1_l_scl,3

	l_sspen = 1; // enable I2C
0500  16C0  	BSF i2c_INIT_00000_1_l_sspen,5

	
	i2c_STOP<_I2C_TEMPL_ARGS>();
0501  20FA  	CALL i2c_STOP_00000

}
0502  0008  	RETURN







////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  158A  	BSF PCLATH,3
0001  2A48  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B0  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00B1  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00B2  	MOVWF Int1BContext+D'2'
000D  158A  	BSF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2AAF  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010  3003  	MOVLW 0x03
0011  07FB  	ADDWF delay_us_00000_arg_del, F
0012  0CFB  	RRF delay_us_00000_arg_del, F
0013  0CFB  	RRF delay_us_00000_arg_del, F
0014  307F  	MOVLW 0x7F
0015  05FB  	ANDWF delay_us_00000_arg_del, F
0016        label1
0016  0000  	NOP
0017  0BFB  	DECFSZ delay_us_00000_arg_del, F
0018  2816  	GOTO	label1
0019  0008  	RETURN
001A        ; } delay_us function end

001A        __rom_get_00000
001A        ; { __rom_get ; function begin
001A  1283  	BCF STATUS, RP0
001B  087E  	MOVF __rom_get_00000_arg_objNumb, W
001C  1683  	BSF STATUS, RP0
001D  00A2  	MOVWF __rom_get_00000_1_romAddr+D'1'
001E  01A1  	CLRF __rom_get_00000_1_romAddr
001F  1003  	BCF STATUS,C
0020  0DA2  	RLF __rom_get_00000_1_romAddr+D'1', F
0021  0DA1  	RLF __rom_get_00000_1_romAddr, F
0022  0DA2  	RLF __rom_get_00000_1_romAddr+D'1', F
0023  0DA1  	RLF __rom_get_00000_1_romAddr, F
0024  07A2  	ADDWF __rom_get_00000_1_romAddr+D'1', F
0025  1803  	BTFSC STATUS,C
0026  0AA1  	INCF __rom_get_00000_1_romAddr, F
0027  07A2  	ADDWF __rom_get_00000_1_romAddr+D'1', F
0028  1803  	BTFSC STATUS,C
0029  0AA1  	INCF __rom_get_00000_1_romAddr, F
002A  3035  	MOVLW	LOW( label2 )
002B  07A2  	ADDWF __rom_get_00000_1_romAddr+D'1', F
002C  1803  	BTFSC STATUS,C
002D  0AA1  	INCF __rom_get_00000_1_romAddr, F
002E  3000  	MOVLW	HIGH( label2 )
002F  0721  	ADDWF __rom_get_00000_1_romAddr, W
0030  008A  	MOVWF PCLATH
0031  0820  	MOVF __rom_get_00000_arg_idx, W
0032  00A1  	MOVWF __rom_get_00000_1_romAddr
0033  0822  	MOVF __rom_get_00000_1_romAddr+D'1', W
0034  0082  	MOVWF PCL
0035        label2
0035  3000  	MOVLW	HIGH( label3 )
0036  008A  	MOVWF PCLATH
0037  3000  	MOVLW	HIGH( label4 )
0038  00A2  	MOVWF __rom_get_00000_1_romAddr+D'1'
0039  304B  	MOVLW	LOW( label4 )
003A  2844  	GOTO	label3
003B  3000  	MOVLW	HIGH( label3 )
003C  008A  	MOVWF PCLATH
003D  3000  	MOVLW	HIGH( label5 )
003E  00A2  	MOVWF __rom_get_00000_1_romAddr+D'1'
003F  3057  	MOVLW	LOW( label5 )
0040  2844  	GOTO	label3
0041  3000  	MOVLW	HIGH( label6 )
0042  00A2  	MOVWF __rom_get_00000_1_romAddr+D'1'
0043  306F  	MOVLW	LOW( label6 )
0044        label3
0044  07A1  	ADDWF __rom_get_00000_1_romAddr, F
0045  1803  	BTFSC STATUS,C
0046  0AA2  	INCF __rom_get_00000_1_romAddr+D'1', F
0047  0822  	MOVF __rom_get_00000_1_romAddr+D'1', W
0048  008A  	MOVWF PCLATH
0049  0821  	MOVF __rom_get_00000_1_romAddr, W
004A  0082  	MOVWF PCL
004B        label4
004B  3431  	RETLW 0x31
004C  3428  	RETLW 0x28
004D  3431  	RETLW 0x31
004E  3430  	RETLW 0x30
004F  3431  	RETLW 0x31
0050  3430  	RETLW 0x30
0051  3431  	RETLW 0x31
0052  3431  	RETLW 0x31
0053  3430  	RETLW 0x30
0054  3431  	RETLW 0x31
0055  3430  	RETLW 0x30
0056  3431  	RETLW 0x31
0057        label5
0057  3404  	RETLW 0x04
0058  3408  	RETLW 0x08
0059  3412  	RETLW 0x12
005A  3416  	RETLW 0x16
005B  3420  	RETLW 0x20
005C  3424  	RETLW 0x24
005D  3428  	RETLW 0x28
005E  3432  	RETLW 0x32
005F  3436  	RETLW 0x36
0060  3440  	RETLW 0x40
0061  3444  	RETLW 0x44
0062  3448  	RETLW 0x48
0063  3452  	RETLW 0x52
0064  3456  	RETLW 0x56
0065  3460  	RETLW 0x60
0066  3464  	RETLW 0x64
0067  3468  	RETLW 0x68
0068  3472  	RETLW 0x72
0069  3476  	RETLW 0x76
006A  3480  	RETLW 0x80
006B  3484  	RETLW 0x84
006C  3488  	RETLW 0x88
006D  3492  	RETLW 0x92
006E  3496  	RETLW 0x96
006F        label6
006F  343F  	RETLW 0x3F
0070  3406  	RETLW 0x06
0071  345B  	RETLW 0x5B
0072  344F  	RETLW 0x4F
0073  3466  	RETLW 0x66
0074  346D  	RETLW 0x6D
0075  347D  	RETLW 0x7D
0076  3407  	RETLW 0x07
0077  347F  	RETLW 0x7F
0078  346F  	RETLW 0x6F
0079        ; } __rom_get function end

0079        delay_10us_00000
0079        ; { delay_10us ; function begin
0079        label7
0079  0000  	NOP
007A  0000  	NOP
007B  0000  	NOP
007C  0000  	NOP
007D  0000  	NOP
007E  0000  	NOP
007F  0000  	NOP
0080  0BFA  	DECFSZ delay_10us_00000_arg_del, F
0081  2879  	GOTO	label7
0082  0008  	RETURN
0083        ; } delay_10us function end

0083        delay_ms_00000
0083        ; { delay_ms ; function begin
0083  08F6  	MOVF delay_ms_00000_arg_del, F
0084  1D03  	BTFSS STATUS,Z
0085  2887  	GOTO	label8
0086  0008  	RETURN
0087        label8
0087  30F9  	MOVLW 0xF9
0088        label9
0088  3EFF  	ADDLW 0xFF
0089  1D03  	BTFSS STATUS,Z
008A  2888  	GOTO	label9
008B  0000  	NOP
008C  0BF6  	DECFSZ delay_ms_00000_arg_del, F
008D  2887  	GOTO	label8
008E  0008  	RETURN
008F        ; } delay_ms function end











0274        __mul_16s__0000F
0274        ; { __mul_16s_16s__16 ; function begin
0274  01A4  	CLRF __mul_16s__0000F_1_i
0275  01A7  	CLRF CompTempVarRet387
0276  01A8  	CLRF CompTempVarRet387+D'1'
0277  0820  	MOVF __mul_16s__0000F_arg_a, W
0278  00A5  	MOVWF __mul_16s__0000F_1_t
0279  0821  	MOVF __mul_16s__0000F_arg_a+D'1', W
027A  00A6  	MOVWF __mul_16s__0000F_1_t+D'1'
027B  1FA3  	BTFSS __mul_16s__0000F_arg_b+D'1',7
027C  2A83  	GOTO	label50
027D  17A4  	BSF __mul_16s__0000F_1_i,7
027E  09A2  	COMF __mul_16s__0000F_arg_b, F
027F  09A3  	COMF __mul_16s__0000F_arg_b+D'1', F
0280  0AA2  	INCF __mul_16s__0000F_arg_b, F
0281  1903  	BTFSC gbl_status,2
0282  0AA3  	INCF __mul_16s__0000F_arg_b+D'1', F
0283        label50
0283  1A24  	BTFSC __mul_16s__0000F_1_i,4
0284  2A95  	GOTO	label52
0285  1C22  	BTFSS __mul_16s__0000F_arg_b,0
0286  2A8D  	GOTO	label51
0287  0825  	MOVF __mul_16s__0000F_1_t, W
0288  07A7  	ADDWF CompTempVarRet387, F
0289  0826  	MOVF __mul_16s__0000F_1_t+D'1', W
028A  1803  	BTFSC gbl_status,0
028B  0F26  	INCFSZ __mul_16s__0000F_1_t+D'1', W
028C  07A8  	ADDWF CompTempVarRet387+D'1', F
028D        label51
028D  1003  	BCF gbl_status,0
028E  0CA3  	RRF __mul_16s__0000F_arg_b+D'1', F
028F  0CA2  	RRF __mul_16s__0000F_arg_b, F
0290  1003  	BCF gbl_status,0
0291  0DA5  	RLF __mul_16s__0000F_1_t, F
0292  0DA6  	RLF __mul_16s__0000F_1_t+D'1', F
0293  0AA4  	INCF __mul_16s__0000F_1_i, F
0294  2A83  	GOTO	label50
0295        label52
0295  1FA4  	BTFSS __mul_16s__0000F_1_i,7
0296  0008  	RETURN
0297  09A7  	COMF CompTempVarRet387, F
0298  09A8  	COMF CompTempVarRet387+D'1', F
0299  0AA7  	INCF CompTempVarRet387, F
029A  1903  	BTFSC gbl_status,2
029B  0AA8  	INCF CompTempVarRet387+D'1', F
029C  0008  	RETURN
029D        ; } __mul_16s_16s__16 function end





































0A48        _startup

0AAC  158A  	BSF PCLATH,3
0AAD  120A  	BCF PCLATH,4
0AAE  295C  	GOTO	main

2007  3FB1  	DW 0x3FB1
