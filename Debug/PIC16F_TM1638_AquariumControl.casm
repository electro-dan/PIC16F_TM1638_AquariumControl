;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 8.01
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

#ifndef _PIC16F_TM1638_AquariumControl_H_
#define _PIC16F_TM1638_AquariumControl_H_

#define TASK_TIMER0 1
#define TASK_TIMER1 2

#define oneWireBus (portc.5)
#define oneWireTris (trisc.5)
#define tm1638dio (portb.1)
#define tm1638dioTris (trisb.1)
#define tm1638clk (portb.2)
#define tm1638strobe (portb.3)
#define WHITE_LED (portc.1)
#define BLUE_LED (portc.2)
#define FAN (porta.1)
#define HEATER (porta.0)

// Timer 0 preload

#define TMR0PRELOAD 61
// This means timer 1 will overflow when 1 cycle completes, generating the interrupt
#define TMR1HV 0xFF
#define TMR1LV 0xFF

// i2c options
#define use_i2c_SW
// clock SCL on RA3, data SDA on RA4
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)
// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3

#define ds3231_addr 0xD0 // Left shifted 7 bit address 0x68
#define at24c32_addr 0xAE // Left shifted 7 bit address 0x57

// Time and date variables
char gBcdSecond = 0; // 0 to 59
07DE  1283  	BCF STATUS, RP0
07DF  1303  	BCF STATUS, RP1
07E0  01B5  	CLRF gbl_gBcdSecond

char gBcdMinute = 0; // 0 to 59
07E1  01B6  	CLRF gbl_gBcdMinute

char gBcdHour = 0; // 0 to 23 or 1 to 12. Also contains 12/24 setting at bit 6. If 12 hour, AM/PM uses bit 5
07E2  01B7  	CLRF gbl_gBcdHour

char gDayOfWeek = 1; // 1 to 7
07E3  3001  	MOVLW 0x01
07E4  00B8  	MOVWF gbl_gDayOfWeek

char gBcdDayOfMonth = 1; // 1 to 31
07E5  3001  	MOVLW 0x01
07E6  00B9  	MOVWF gbl_gBcdDayOfMonth

char gBcdMonth = 1; // 1 to 12 + century at bit 7
07E7  3001  	MOVLW 0x01
07E8  00BA  	MOVWF gbl_gBcdMonth

char gBcdYear = 0x23; // Init to 0x23
07E9  3023  	MOVLW 0x23
07EA  00BB  	MOVWF gbl_gBcdYear

rom char *gDaysInMonth = {0x31, 0x28, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31}; // Days in each month
07EB  3000  	MOVLW 0x00
07EC  00BC  	MOVWF gbl_gDaysInMonth

rom char *gLeapYears = {0x04, 0x08, 0x12, 0x16, 0x20, 0x24, 0x28, 0x32, 0x36, 0x40, 0x44, 0x48, 0x52, 0x56, 0x60, 0x64, 0x68, 0x72, 0x76, 0x80, 0x84, 0x88, 0x92, 0x96}; // List of leap years
07ED  3001  	MOVLW 0x01
07EE  00BD  	MOVWF gbl_gLeapYears


// Timer variables
char iTimer0Counts = 0;
07EF  01BE  	CLRF gbl_iTimer0Counts

char iFlashDigitOff = 0;
07F0  01BF  	CLRF gbl_iFlashDigitOff

char iDigitToFlash = 8; // 8 = no digit to flash
07F1  3008  	MOVLW 0x08
07F2  00C8  	MOVWF gbl_iDigitToFlash


// Hold the upper and lower bytes from the ds18b20
char cTempH = 1;
07F3  3001  	MOVLW 0x01
07F4  00C9  	MOVWF gbl_cTempH

char cTempL = 70;
07F5  3046  	MOVLW 0x46
07F6  00CA  	MOVWF gbl_cTempL

//char iDecimalPosition = 2;

int giDS3231ValueBCD = 0x2000;
07F7  01B3  	CLRF gbl_giDS3231ValueBCD
07F8  3020  	MOVLW 0x20
07F9  00B4  	MOVWF gbl_giDS3231ValueBCD+D'1'

char gbDS3231IsMinus = 0;
07FA  01CB  	CLRF gbl_gbDS3231IsMinus


char cTask = 0; // Used for task scheduler
07FB  01CC  	CLRF gbl_cTask


// States
bool gbWhiteOn = 0;
07FC  104D  	BCF gbl_gbWhiteOn,0

bool gbBlueOn = 0;
07FD  10CD  	BCF gbl_gbBlueOn,1

bool gbFanOn = 0;
07FE  114D  	BCF gbl_gbFanOn,2

bool gbHeaterOn = 0;
07FF  11CD  	BCF gbl_gbHeaterOn,3

bool gbFlashOff = 0;
0800  124D  	BCF gbl_gbFlashOff,4

char gcDisplayMode = 0;
0801  01CE  	CLRF gbl_gcDisplayMode

char gcSetMode = 0;
0802  01CF  	CLRF gbl_gcSetMode

char gcTriggerMode = 0;
0803  01D0  	CLRF gbl_gcTriggerMode


// Triggers
char gBcdWhiteOnMinute = 0; // 0 to 59
0804  01D1  	CLRF gbl_gBcdWhiteOnMinute

char gBcdWhiteOnHour = 0; // 0 to 23
0805  01D2  	CLRF gbl_gBcdWhiteOnHour

char gBcdWhiteOffMinute = 0; // 0 to 59
0806  01D3  	CLRF gbl_gBcdWhiteOffMinute

char gBcdWhiteOffHour = 0; // 0 to 23
0807  01D4  	CLRF gbl_gBcdWhiteOffHour


char gBcdBlueOnMinute = 0; // 0 to 59
0808  01D5  	CLRF gbl_gBcdBlueOnMinute

char gBcdBlueOnHour = 0; // 0 to 23
0809  01D6  	CLRF gbl_gBcdBlueOnHour

char gBcdBlueOffMinute = 0; // 0 to 59
080A  01D7  	CLRF gbl_gBcdBlueOffMinute

char gBcdBlueOffHour = 0; // 0 to 23
080B  01D8  	CLRF gbl_gBcdBlueOffHour


char gBcdFanOnTemp = 0x28; // Degrees C
080C  3028  	MOVLW 0x28
080D  00D9  	MOVWF gbl_gBcdFanOnTemp

char gBcdFanOffTemp = 0x27; // Degrees C
080E  3027  	MOVLW 0x27
080F  00DA  	MOVWF gbl_gBcdFanOffTemp


char gBcdHeaterOnTemp = 0x24; // Degrees C
0810  3024  	MOVLW 0x24
0811  00DB  	MOVWF gbl_gBcdHeaterOnTemp

char gBcdHeaterOffTemp = 0x25; // Degrees C
0812  3025  	MOVLW 0x25
0813  00DC  	MOVWF gbl_gBcdHeaterOffTemp


// Used to output the segments from numbers
char tm1638MaxDigits = 8;
0814  3008  	MOVLW 0x08
0815  00DD  	MOVWF gbl_tm1638MaxDigits

rom char *tm1638DisplayNumtoSeg = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f};
0816  3002  	MOVLW 0x02
0817  00DE  	MOVWF gbl_tm1638DisplayNumtoSeg

char tm1638Dot = 0x80;
0818  3080  	MOVLW 0x80
0819  00DF  	MOVWF gbl_tm1638Dot

char tm1638Brightness = 7; // 0 to 7
081A  3007  	MOVLW 0x07
081B  00E0  	MOVWF gbl_tm1638Brightness

// 0x40 [01000000] = indicate command to display data
char tm1638ByteSetData = 0x40;
081C  3040  	MOVLW 0x40
081D  00E1  	MOVWF gbl_tm1638ByteSetData

// 0x42 [01000010] = indicate command to read data
char tm1638ByteReadData = 0x42;
081E  3042  	MOVLW 0x42
081F  00E2  	MOVWF gbl_tm1638ByteReadData

// 0xC0 [11000000] = write out all bytes
char tm1638ByteSetAddr = 0xC0;
0820  30C0  	MOVLW 0xC0
0821  00E3  	MOVWF gbl_tm1638ByteSetAddr

// 0x88 [10001000] - Display ON, plus brightness
char tm1638ByteSetOn = 0x88;
0822  3088  	MOVLW 0x88
0823  00E4  	MOVWF gbl_tm1638ByteSetOn


// Copy of the data to write / on the display
char tm1638Data[] = {0, 0, 0, 0, 0, 0, 0, 0};
0824  01A0  	CLRF gbl_tm1638Data
0825  01A1  	CLRF gbl_tm1638Data+D'1'
0826  01A2  	CLRF gbl_tm1638Data+D'2'
0827  01A3  	CLRF gbl_tm1638Data+D'3'
0828  01A4  	CLRF gbl_tm1638Data+D'4'
0829  01A5  	CLRF gbl_tm1638Data+D'5'
082A  01A6  	CLRF gbl_tm1638Data+D'6'
082B  01A7  	CLRF gbl_tm1638Data+D'7'

// Copy of the LED status
char tm1638LEDs[] = {0, 0, 0, 0, 0, 0, 0, 0};
082C  01A8  	CLRF gbl_tm1638LEDs
082D  01A9  	CLRF gbl_tm1638LEDs+D'1'
082E  01AA  	CLRF gbl_tm1638LEDs+D'2'
082F  01AB  	CLRF gbl_tm1638LEDs+D'3'
0830  01AC  	CLRF gbl_tm1638LEDs+D'4'
0831  01AD  	CLRF gbl_tm1638LEDs+D'5'
0832  01AE  	CLRF gbl_tm1638LEDs+D'6'
0833  01AF  	CLRF gbl_tm1638LEDs+D'7'

// Copy of the keys
char tm1638Keys = 0;
0834  01E5  	CLRF gbl_tm1638Keys

char tm1638KeysOld = 0;
0835  01E6  	CLRF gbl_tm1638KeysOld

// For printing
char iPrintStartDigit = 0;
0836  01E7  	CLRF gbl_iPrintStartDigit

char iPrintDotDigit = 8;
0837  3008  	MOVLW 0x08
0838  00E8  	MOVWF gbl_iPrintDotDigit

// For adjusting bcd numbers up 1 or down !1
char iBcdAdjustment = 1;
0839  3001  	MOVLW 0x01
083A  00E9  	MOVWF gbl_iBcdAdjustment


// DS18B20 functions
char oneWireIsPresent = 0;
083B  01EA  	CLRF gbl_oneWireIsPresent

char oneWireResetStage = 0;
083C  01EB  	CLRF gbl_oneWireResetStage

void oneWireBusReset();
void oneWireTxByte(char data);
void oneWireTxBytes(char data, char data2);
char oneWireRxByte();

// EEPROM functions
void eepromWriteAll();
char eepromWrite(char address, char data);
void eepromReadAll();
char eepromRead(char address);

// DS3231 functions
void ds3231Write(char ds3231Reg, char bWrite);
void ds3231Init();
void ds3231Start();
void ds3231Stop();
void ds3231WriteDateTime();
void ds3231ReadDateTime();
char ds3231ReadRegister(char cRegAddress);

// TM1638 functions
void tm1638ByteWrite(char bWrite);
void bcdTo7Seg(char iBcdIn);
void tm1638DisplayOn();
void tm1638UpdateDisplay();
void tm1638ReadKeys();

// General functions
int binToBcd(int iBin);
void startTemp();
void readTemp();

char bcdAdjust(char bcd, char bcdMax, char bcdMin);
void adjustDateTime();
void adjustTrigger();
void processKeys();

#endif

#include <system.h>
#include <i2c_driver.h>
#include "PIC16F_TM1638_AquariumControl.h"

//Target PIC16F628A configuration word
#pragma DATA _CONFIG, _BODEN_OFF & _PWRTE_ON & _WDT_OFF & _CP_OFF & _XT_OSC // Brown out reset off, Power-up Timer on, Watchdog timer off, Code Protection off, XT oscillator

//Set clock frequency (for software delays) - 4MHz
#pragma CLOCK_FREQ	4000000

    
/*********************************************************************************************
  void oneWireBusReset()
  First part of the reset routine - drive the bus low for 500us
*********************************************************************************************/
void oneWireBusReset() {

    char isPresent;
    oneWireTris = 1; // start with high
0676  1683  	BSF STATUS, RP0
0677  1303  	BCF STATUS, RP1
0678  1687  	BSF gbl_trisc,5

    isPresent = 0;
0679  1283  	BCF STATUS, RP0
067A  01ED  	CLRF oneWireBus_00017_1_isPresent

    // Send the reset pulse - drive low for 500us
    oneWireBus = 0;      
067B  1287  	BCF gbl_portc,5

    oneWireTris = 0;
067C  1683  	BSF STATUS, RP0
067D  1287  	BCF gbl_trisc,5

    delay_10us(50);
067E  3032  	MOVLW 0x32
067F  1283  	BCF STATUS, RP0
0680  00F2  	MOVWF delay_10us_00000_arg_del
0681  2077  	CALL delay_10us_00000

    // Release line and wait 70us for PD Pulse
    oneWireTris = 1;
0682  1683  	BSF STATUS, RP0
0683  1687  	BSF gbl_trisc,5

    delay_10us(7);
0684  3007  	MOVLW 0x07
0685  1283  	BCF STATUS, RP0
0686  00F2  	MOVWF delay_10us_00000_arg_del
0687  2077  	CALL delay_10us_00000

    // Now sample, if there is a sensor on the bus, the line should be low
    if (oneWireBus) {
0688  1A87  	BTFSC gbl_portc,5

        oneWireIsPresent = 0; // no devices
0689  01EA  	CLRF gbl_oneWireIsPresent

    }
    delay_10us(50);
068A  3032  	MOVLW 0x32
068B  00F2  	MOVWF delay_10us_00000_arg_del
068C  2077  	CALL delay_10us_00000

}
068D  0008  	RETURN


/*********************************************************************************************
  void oneWireTxByte(char data)
  Transmits a single byte from the bus
*********************************************************************************************/
void oneWireTxByte(char cData) {

    char cTemp = 1;
016E  3001  	MOVLW 0x01
016F  00F0  	MOVWF oneWireTxB_00018_1_cTemp

    // Loop through the eight bits in the byte
    for (char i = 0; i < 8; i++) {
0170  01F1  	CLRF oneWireTxB_00018_2_i
0171        label26
0171  3008  	MOVLW 0x08
0172  0271  	SUBWF oneWireTxB_00018_2_i, W
0173  1803  	BTFSC STATUS,C
0188  0AF1  	INCF oneWireTxB_00018_2_i, F
0189  2971  	GOTO	label26

        // Send the LSB first

        // Drive the line low initially for 3us
        oneWireTris = 0;
0175  1683  	BSF STATUS, RP0
0176  1287  	BCF gbl_trisc,5

        oneWireBus = 0;
0177  1283  	BCF STATUS, RP0
0178  1287  	BCF gbl_portc,5


        // Delay not needed for 4MHz PIC
        //delay_us(3); // Delay 3us
        
        if (cData & cTemp) {
0179  0870  	MOVF oneWireTxB_00018_1_cTemp, W
017A  056F  	ANDWF oneWireTxB_00018_arg_cData, W
017B  1903  	BTFSC STATUS,Z
017C  297F  	GOTO	label27

            oneWireTris = 1; // Release the bus
017D  1683  	BSF STATUS, RP0
017E  1687  	BSF gbl_trisc,5

        }
        
        delay_10us(5); // Delay 60us - 50us works fine with code delays
017F  3005  	MOVLW 0x05
0180  1283  	BCF STATUS, RP0
0181  00F2  	MOVWF delay_10us_00000_arg_del
0182  2077  	CALL delay_10us_00000

        oneWireTris = 1; // Release the bus
0183  1683  	BSF STATUS, RP0
0184  1687  	BSF gbl_trisc,5

        
        // move the test bit
        cTemp <<= 1;
0185  1003  	BCF STATUS,C
0186  1283  	BCF STATUS, RP0
0187  0DF0  	RLF oneWireTxB_00018_1_cTemp, F

    }
}
0174  0008  	RETURN


/*********************************************************************************************
  void oneWireTxBytes(char data, char data2)
  Transmits a 2 bytes from the bus
*********************************************************************************************/
void oneWireTxBytes(char cData, char cData2) {

    // Reset first - done in main
    //oneWireBusReset();
    // Send first byte
    oneWireTxByte(cData);
03AB  086D  	MOVF oneWireTxB_00019_arg_cData, W
03AC  00EF  	MOVWF oneWireTxB_00018_arg_cData
03AD  216E  	CALL oneWireTxB_00018

    // Send second byte
    oneWireTxByte(cData2);
03AE  086E  	MOVF oneWireTxB_00019_arg_cData2, W
03AF  00EF  	MOVWF oneWireTxB_00018_arg_cData
03B0  216E  	CALL oneWireTxB_00018

}
03B1  0008  	RETURN


/*********************************************************************************************
  char oneWireRxByte()
  Receives a single byte from the bus
*********************************************************************************************/
char oneWireRxByte() {

    char cDataIn = 0;
03B2  1283  	BCF STATUS, RP0
03B3  1303  	BCF STATUS, RP1
03B4  01ED  	CLRF oneWireRxB_0001A_1_cDataIn

    // Loop through the eight bits in the byte
    for(char i = 0; i < 8; i++) {
03B5  01EE  	CLRF oneWireRxB_0001A_2_i
03B6        label77
03B6  3008  	MOVLW 0x08
03B7  026E  	SUBWF oneWireRxB_0001A_2_i, W
03B8  1803  	BTFSC STATUS,C
03B9  2BCD  	GOTO	label78
03CB  0AEE  	INCF oneWireRxB_0001A_2_i, F
03CC  2BB6  	GOTO	label77
03CD        label78

        // Bring bus low for 15us
        oneWireTris = 0;
03BA  1683  	BSF STATUS, RP0
03BB  1287  	BCF gbl_trisc,5

        oneWireBus = 0;
03BC  1283  	BCF STATUS, RP0
03BD  1287  	BCF gbl_portc,5


        // Delay not needed for 4MHz PIC
        //delay_us(15); // Delay 15us

        // Release bus for 6us, this is enough time for the slave to respond
        oneWireTris = 1;
03BE  1683  	BSF STATUS, RP0
03BF  1687  	BSF gbl_trisc,5

        delay_us(3); // Delay 6us
03C0  3003  	MOVLW 0x03
03C1  1283  	BCF STATUS, RP0
03C2  00F2  	MOVWF delay_us_00000_arg_del
03C3  2010  	CALL delay_us_00000

        
        // Shift data already received left
        cDataIn >>= 1;
03C4  1003  	BCF STATUS,C
03C5  0CED  	RRF oneWireRxB_0001A_1_cDataIn, F

        
        // Check the value of the onewire bus - set the MSB of cDataIn if so
        if (oneWireBus)
03C6  1A87  	BTFSC gbl_portc,5

            cDataIn.7 = 1;
03C7  17ED  	BSF oneWireRxB_0001A_1_cDataIn,7


        // To finish time slot
        delay_10us(6); // 60us
03C8  3006  	MOVLW 0x06
03C9  00F2  	MOVWF delay_10us_00000_arg_del
03CA  2077  	CALL delay_10us_00000

    } 
    
    return cDataIn;
03CD  086D  	MOVF oneWireRxB_0001A_1_cDataIn, W
03CE  00EE  	MOVWF CompTempVarRet551

}
03CF  0008  	RETURN


/*********************************************************************************************
  void at24c32WriteAll()
  Write multiple bytes
*********************************************************************************************/
void at24c32WriteAll() {

	// https://www.instructables.com/The-Most-Comprehensive-Guide-to-Programming-the-AT/
	i2c_start();
041F  2126  	CALL i2c_START_00000

	i2c_write(at24c32_addr); // address + write
0420  30AE  	MOVLW 0xAE
0421  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0422  20A5  	CALL i2c_WRITE_00000

	// start at address 0
	i2c_write(0); // First word address (only 4 bits of the 12 bit byte address)
0423  01EF  	CLRF i2c_WRITE_00000_arg_i2c_data
0424  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // Second word address 
0425  01EF  	CLRF i2c_WRITE_00000_arg_i2c_data
0426  20A5  	CALL i2c_WRITE_00000

	// Write data bytes
	// We're only writing 13 bytes here, so no need to worry about row rollover after 32 bytes
	i2c_write(0x44); // To indicate AT24C32 has been written to
0427  3044  	MOVLW 0x44
0428  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0429  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdWhiteOnMinute);
042A  0851  	MOVF gbl_gBcdWhiteOnMinute, W
042B  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
042C  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOnHour);
042D  0852  	MOVF gbl_gBcdWhiteOnHour, W
042E  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
042F  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOffMinute);
0430  0853  	MOVF gbl_gBcdWhiteOffMinute, W
0431  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0432  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOffHour);
0433  0854  	MOVF gbl_gBcdWhiteOffHour, W
0434  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0435  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOnMinute);
0436  0855  	MOVF gbl_gBcdBlueOnMinute, W
0437  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0438  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOnHour);
0439  0856  	MOVF gbl_gBcdBlueOnHour, W
043A  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
043B  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOffMinute);
043C  0857  	MOVF gbl_gBcdBlueOffMinute, W
043D  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
043E  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOffHour);
043F  0858  	MOVF gbl_gBcdBlueOffHour, W
0440  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0441  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdFanOnTemp);
0442  0859  	MOVF gbl_gBcdFanOnTemp, W
0443  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0444  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdFanOffTemp);
0445  085A  	MOVF gbl_gBcdFanOffTemp, W
0446  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0447  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdHeaterOnTemp);
0448  085B  	MOVF gbl_gBcdHeaterOnTemp, W
0449  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
044A  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdHeaterOffTemp);
044B  085C  	MOVF gbl_gBcdHeaterOffTemp, W
044C  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
044D  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
044E  20F6  	CALL i2c_STOP_00000

	delay_ms(10); // Write Cycle Time
044F  300A  	MOVLW 0x0A
0450  00EC  	MOVWF delay_ms_00000_arg_del
0451  2081  	CALL delay_ms_00000

}
0452  0008  	RETURN


/*********************************************************************************************
  void at24c32ReadAll()
  Read all bytes
*********************************************************************************************/
void at24c32ReadAll() {

	i2c_start();
0453  2126  	CALL i2c_START_00000

	i2c_write(at24c32_addr); // address + write
0454  30AE  	MOVLW 0xAE
0455  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0456  20A5  	CALL i2c_WRITE_00000

	// start at address 0
	i2c_write(0); // First word address (only 4 bits of the 12 bit byte address)
0457  01EF  	CLRF i2c_WRITE_00000_arg_i2c_data
0458  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // Second word address 
0459  01EF  	CLRF i2c_WRITE_00000_arg_i2c_data
045A  20A5  	CALL i2c_WRITE_00000

	i2c_stop(); // Don't actually write a byte, just stop
045B  20F6  	CALL i2c_STOP_00000

	
	i2c_start();
045C  2126  	CALL i2c_START_00000

	i2c_write(at24c32_addr + 1); // address + read
045D  30AF  	MOVLW 0xAF
045E  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
045F  20A5  	CALL i2c_WRITE_00000

	char hasWritten = i2c_read(0); // ack
0460  01EF  	CLRF i2c_READ_00000_arg_ack_status
0461  218A  	CALL i2c_READ_00000
0462  0872  	MOVF CompTempVarRet553, W
0463  00ED  	MOVWF at24c32Rea_0002A_1_hasWritten

	if (hasWritten != 0x44) {
0464  086D  	MOVF at24c32Rea_0002A_1_hasWritten, W
0465  3A44  	XORLW 0x44
0466  1903  	BTFSC STATUS,Z
0467  2C6C  	GOTO	label79
046C        label79

		i2c_read(1); // nack
0468  3001  	MOVLW 0x01
0469  00EF  	MOVWF i2c_READ_00000_arg_ack_status
046A  218A  	CALL i2c_READ_00000

	} else {
046B  2C9D  	GOTO	label80
049D        label80

		gBcdWhiteOnMinute = i2c_read(0); // ack
046C  01EF  	CLRF i2c_READ_00000_arg_ack_status
046D  218A  	CALL i2c_READ_00000
046E  0872  	MOVF CompTempVarRet553, W
046F  00D1  	MOVWF gbl_gBcdWhiteOnMinute

		gBcdWhiteOnHour = i2c_read(0); // ack
0470  01EF  	CLRF i2c_READ_00000_arg_ack_status
0471  218A  	CALL i2c_READ_00000
0472  0872  	MOVF CompTempVarRet553, W
0473  00D2  	MOVWF gbl_gBcdWhiteOnHour

		gBcdWhiteOffMinute = i2c_read(0); // ack
0474  01EF  	CLRF i2c_READ_00000_arg_ack_status
0475  218A  	CALL i2c_READ_00000
0476  0872  	MOVF CompTempVarRet553, W
0477  00D3  	MOVWF gbl_gBcdWhiteOffMinute

		gBcdWhiteOffHour = i2c_read(0); // ack
0478  01EF  	CLRF i2c_READ_00000_arg_ack_status
0479  218A  	CALL i2c_READ_00000
047A  0872  	MOVF CompTempVarRet553, W
047B  00D4  	MOVWF gbl_gBcdWhiteOffHour

		gBcdBlueOnMinute = i2c_read(0); // ack
047C  01EF  	CLRF i2c_READ_00000_arg_ack_status
047D  218A  	CALL i2c_READ_00000
047E  0872  	MOVF CompTempVarRet553, W
047F  00D5  	MOVWF gbl_gBcdBlueOnMinute

		gBcdBlueOnHour = i2c_read(0); // ack
0480  01EF  	CLRF i2c_READ_00000_arg_ack_status
0481  218A  	CALL i2c_READ_00000
0482  0872  	MOVF CompTempVarRet553, W
0483  00D6  	MOVWF gbl_gBcdBlueOnHour

		gBcdBlueOffMinute = i2c_read(0); // ack
0484  01EF  	CLRF i2c_READ_00000_arg_ack_status
0485  218A  	CALL i2c_READ_00000
0486  0872  	MOVF CompTempVarRet553, W
0487  00D7  	MOVWF gbl_gBcdBlueOffMinute

		gBcdBlueOffHour = i2c_read(0); // ack
0488  01EF  	CLRF i2c_READ_00000_arg_ack_status
0489  218A  	CALL i2c_READ_00000
048A  0872  	MOVF CompTempVarRet553, W
048B  00D8  	MOVWF gbl_gBcdBlueOffHour

		gBcdFanOnTemp = i2c_read(0); // ack
048C  01EF  	CLRF i2c_READ_00000_arg_ack_status
048D  218A  	CALL i2c_READ_00000
048E  0872  	MOVF CompTempVarRet553, W
048F  00D9  	MOVWF gbl_gBcdFanOnTemp

		gBcdFanOffTemp = i2c_read(0); // ack
0490  01EF  	CLRF i2c_READ_00000_arg_ack_status
0491  218A  	CALL i2c_READ_00000
0492  0872  	MOVF CompTempVarRet553, W
0493  00DA  	MOVWF gbl_gBcdFanOffTemp

		gBcdHeaterOnTemp = i2c_read(0); // ack
0494  01EF  	CLRF i2c_READ_00000_arg_ack_status
0495  218A  	CALL i2c_READ_00000
0496  0872  	MOVF CompTempVarRet553, W
0497  00DB  	MOVWF gbl_gBcdHeaterOnTemp

		gBcdHeaterOffTemp = i2c_read(1); // nack
0498  3001  	MOVLW 0x01
0499  00EF  	MOVWF i2c_READ_00000_arg_ack_status
049A  218A  	CALL i2c_READ_00000
049B  0872  	MOVF CompTempVarRet553, W
049C  00DC  	MOVWF gbl_gBcdHeaterOffTemp

	}
	i2c_stop();
049D  20F6  	CALL i2c_STOP_00000

}
049E  0008  	RETURN



/*********************************************************************************************
  void ds3231Write(char ds3231Reg, char bWrite)
  Write one byte
*********************************************************************************************/
void ds3231Write(char ds3231Reg, char bWrite) {

	i2c_start();
01DE  2126  	CALL i2c_START_00000

	i2c_write(ds3231_addr); // address + write
01DF  30D0  	MOVLW 0xD0
01E0  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
01E1  20A5  	CALL i2c_WRITE_00000

	i2c_write(ds3231Reg); // start at address
01E2  086D  	MOVF ds3231Writ_0001B_arg_ds3231Reg, W
01E3  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
01E4  20A5  	CALL i2c_WRITE_00000

	i2c_write(bWrite); // start at address
01E5  086E  	MOVF ds3231Writ_0001B_arg_bWrite, W
01E6  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
01E7  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
01E8  20F6  	CALL i2c_STOP_00000

}
01E9  0008  	RETURN


/*********************************************************************************************
  void ds3231Init()
  Initialise the DS3231
*********************************************************************************************/
void ds3231Init() {

	/* control register 0Eh
    bit7 EOSC   Enable Oscillator (1 if oscillator must be stopped when on battery)
    bit6 BBSQW  Battery Backed Square Wave - 0 means square wave disabled when VCC falls below VPF (power fail voltage)
    bit5 CONV   Convert temperature (1 forces a conversion)
    bit4 RS2    Rate select - frequency of square wave output - NA for DS3231M
    bit3 RS1    Rate select - NA for DS3231M
    bit2 INTCN  Interrupt control (1 for use of the alarms and to disable square wave)
    bit1 A2IE   Alarm2 interrupt enable (1 to enable)
    bit0 A1IE   Alarm1 interrupt enable (1 to enable)
    */
	ds3231Write(0x0E, 0x00);
0414  300E  	MOVLW 0x0E
0415  1283  	BCF STATUS, RP0
0416  1303  	BCF STATUS, RP1
0417  00ED  	MOVWF ds3231Writ_0001B_arg_ds3231Reg
0418  01EE  	CLRF ds3231Writ_0001B_arg_bWrite
0419  21DE  	CALL ds3231Writ_0001B

	/* Status Register 0Fh
    bit7 OSF     Oscillator stopped flag - clear oscillator stop flag at init
    bit3 EN32kHz Enable 32kHz Output - 0 for disabled
    bit2 BSY     Busy
    bit1 A2F     Alarm 2 Flag
    bit0 A1F     Alarm 1 Flag
    */
	ds3231Write(0x0F, 0x00);
041A  300F  	MOVLW 0x0F
041B  00ED  	MOVWF ds3231Writ_0001B_arg_ds3231Reg
041C  01EE  	CLRF ds3231Writ_0001B_arg_bWrite
041D  21DE  	CALL ds3231Writ_0001B

}
041E  0008  	RETURN


/*********************************************************************************************
  void ds3231WriteDateTime()
  Write the date to the DS3231
*********************************************************************************************/
void ds3231WriteDateTime() {

	i2c_start();
03E3  2126  	CALL i2c_START_00000

	i2c_write(ds3231_addr); // address + write
03E4  30D0  	MOVLW 0xD0
03E5  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
03E6  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
03E7  01EF  	CLRF i2c_WRITE_00000_arg_i2c_data
03E8  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // seconds
03E9  01EF  	CLRF i2c_WRITE_00000_arg_i2c_data
03EA  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdMinute); // minutes
03EB  0836  	MOVF gbl_gBcdMinute, W
03EC  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
03ED  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdHour); // hours
03EE  0837  	MOVF gbl_gBcdHour, W
03EF  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
03F0  20A5  	CALL i2c_WRITE_00000

	i2c_write(gDayOfWeek); // day of week
03F1  0838  	MOVF gbl_gDayOfWeek, W
03F2  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
03F3  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdDayOfMonth); // day of month
03F4  0839  	MOVF gbl_gBcdDayOfMonth, W
03F5  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
03F6  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdMonth); // month + century
03F7  083A  	MOVF gbl_gBcdMonth, W
03F8  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
03F9  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdYear); // year
03FA  083B  	MOVF gbl_gBcdYear, W
03FB  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
03FC  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
03FD  20F6  	CALL i2c_STOP_00000

}
03FE  0008  	RETURN


/*********************************************************************************************
  void ds3231ReadDateTime()
  Write the date to the DS3231
*********************************************************************************************/
void ds3231ReadDateTime() {

	i2c_start();
06C6  2126  	CALL i2c_START_00000

	i2c_write(ds3231_addr); // address + write
06C7  30D0  	MOVLW 0xD0
06C8  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
06C9  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
06CA  01EF  	CLRF i2c_WRITE_00000_arg_i2c_data
06CB  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
06CC  20F6  	CALL i2c_STOP_00000

	
	i2c_start();
06CD  2126  	CALL i2c_START_00000

	i2c_write(ds3231_addr + 1); // address + read
06CE  30D1  	MOVLW 0xD1
06CF  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
06D0  20A5  	CALL i2c_WRITE_00000

	gBcdSecond = i2c_read(0); // ack
06D1  01EF  	CLRF i2c_READ_00000_arg_ack_status
06D2  218A  	CALL i2c_READ_00000
06D3  0872  	MOVF CompTempVarRet553, W
06D4  00B5  	MOVWF gbl_gBcdSecond

	gBcdMinute = i2c_read(0); // ack
06D5  01EF  	CLRF i2c_READ_00000_arg_ack_status
06D6  218A  	CALL i2c_READ_00000
06D7  0872  	MOVF CompTempVarRet553, W
06D8  00B6  	MOVWF gbl_gBcdMinute

	gBcdHour = i2c_read(0); // ack
06D9  01EF  	CLRF i2c_READ_00000_arg_ack_status
06DA  218A  	CALL i2c_READ_00000
06DB  0872  	MOVF CompTempVarRet553, W
06DC  00B7  	MOVWF gbl_gBcdHour

	gDayOfWeek = i2c_read(0); // ack
06DD  01EF  	CLRF i2c_READ_00000_arg_ack_status
06DE  218A  	CALL i2c_READ_00000
06DF  0872  	MOVF CompTempVarRet553, W
06E0  00B8  	MOVWF gbl_gDayOfWeek

	gBcdDayOfMonth = i2c_read(0); // ack
06E1  01EF  	CLRF i2c_READ_00000_arg_ack_status
06E2  218A  	CALL i2c_READ_00000
06E3  0872  	MOVF CompTempVarRet553, W
06E4  00B9  	MOVWF gbl_gBcdDayOfMonth

	gBcdMonth = i2c_read(0); // ack
06E5  01EF  	CLRF i2c_READ_00000_arg_ack_status
06E6  218A  	CALL i2c_READ_00000
06E7  0872  	MOVF CompTempVarRet553, W
06E8  00BA  	MOVWF gbl_gBcdMonth

	gBcdYear = i2c_read(1); // nack
06E9  3001  	MOVLW 0x01
06EA  00EF  	MOVWF i2c_READ_00000_arg_ack_status
06EB  218A  	CALL i2c_READ_00000
06EC  0872  	MOVF CompTempVarRet553, W
06ED  00BB  	MOVWF gbl_gBcdYear

	i2c_stop();
06EE  20F6  	CALL i2c_STOP_00000

}
06EF  0008  	RETURN


/*********************************************************************************************
  char ds3231ReadRegister(char cRegAddress)
  Read one byte from a given DS3231 register address
*********************************************************************************************/
char ds3231ReadRegister(char cRegAddress) {

	char cStatus;
	i2c_start();
03FF  2126  	CALL i2c_START_00000

	i2c_write(ds3231_addr); // address + write
0400  30D0  	MOVLW 0xD0
0401  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0402  20A5  	CALL i2c_WRITE_00000

	i2c_write(cRegAddress); // start at requested address
0403  086D  	MOVF ds3231Read_0001E_arg_cRegAddress, W
0404  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0405  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
0406  20F6  	CALL i2c_STOP_00000

	
	i2c_start();
0407  2126  	CALL i2c_START_00000

	i2c_write(ds3231_addr + 1); // address + read
0408  30D1  	MOVLW 0xD1
0409  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
040A  20A5  	CALL i2c_WRITE_00000

	cStatus = i2c_read(1); // read the byte, then nack
040B  3001  	MOVLW 0x01
040C  00EF  	MOVWF i2c_READ_00000_arg_ack_status
040D  218A  	CALL i2c_READ_00000
040E  0872  	MOVF CompTempVarRet553, W
040F  00EE  	MOVWF ds3231Read_0001E_1_cStatus

    i2c_stop();
0410  20F6  	CALL i2c_STOP_00000

    return cStatus;
0411  086E  	MOVF ds3231Read_0001E_1_cStatus, W
0412  00EF  	MOVWF CompTempVarRet554

}
0413  0008  	RETURN


/*********************************************************************************************
  void tm1638ByteWrite(char bWrite)
  Write one byte
*********************************************************************************************/
void tm1638ByteWrite(char bWrite) {

    for (char i = 0; i < 8; i++) {
015B  01F1  	CLRF tm1638Byte_0001F_2_i
015C        label25
015C  3008  	MOVLW 0x08
015D  0271  	SUBWF tm1638Byte_0001F_2_i, W
015E  1803  	BTFSC STATUS,C
016C  0AF1  	INCF tm1638Byte_0001F_2_i, F
016D  295C  	GOTO	label25

        tm1638dio = (bWrite & 0x01);
0160  3001  	MOVLW 0x01
0161  0570  	ANDWF tm1638Byte_0001F_arg_bWrite, W
0162  00F2  	MOVWF CompTempVar555
0163  1872  	BTFSC CompTempVar555,0
0164  1486  	BSF gbl_portb,1
0165  1C72  	BTFSS CompTempVar555,0
0166  1086  	BCF gbl_portb,1

        tm1638clk = 0;
0167  1106  	BCF gbl_portb,2

        bWrite = (bWrite >> 1);
0168  08F0  	MOVF tm1638Byte_0001F_arg_bWrite, F
0169  1003  	BCF STATUS,C
016A  0CF0  	RRF tm1638Byte_0001F_arg_bWrite, F

        tm1638clk = 1;
016B  1506  	BSF gbl_portb,2

    }
}
015F  0008  	RETURN


/*********************************************************************************************
  void tm1638DisplayOn()
  Turns the display on, with defined brightness
*********************************************************************************************/
void tm1638DisplayOn() {

    // Write 0x8F [10001000] to set display ON with pulse width 14/16
    tm1638strobe = 0;
03A3  1283  	BCF STATUS, RP0
03A4  1303  	BCF STATUS, RP1
03A5  1186  	BCF gbl_portb,3

    tm1638ByteWrite(0x88);
03A6  3088  	MOVLW 0x88
03A7  00F0  	MOVWF tm1638Byte_0001F_arg_bWrite
03A8  215B  	CALL tm1638Byte_0001F

    tm1638strobe = 1;
03A9  1586  	BSF gbl_portb,3

}
03AA  0008  	RETURN


/*********************************************************************************************
  void nibbleTo7Seg(char iNibble)
  Convert a single nibble into the 7-segment representation (two digits)
  7-segment digit to be written will be iPrintStartDigit, which is auto-incremented after
  If iPrintDotDigit matches, the dot on the display digit will be added
*********************************************************************************************/
void nibbleTo7Seg(char bNibble) {

	char s7SegDisplay = tm1638DisplayNumtoSeg[bNibble & 0x0F];
008D  085E  	MOVF gbl_tm1638DisplayNumtoSeg, W
008E  00F4  	MOVWF __rom_get_00000_arg_objNumb
008F  300F  	MOVLW 0x0F
0090  0572  	ANDWF nibbleTo7S_00020_arg_bNibble, W
0091  00F5  	MOVWF __rom_get_00000_arg_idx
0092  201A  	CALL __rom_get_00000
0093  00F3  	MOVWF nibbleTo7S_00020_1_s7SegDisplay

	if (iPrintStartDigit == iPrintDotDigit)
0094  0868  	MOVF gbl_iPrintDotDigit, W
0095  0667  	XORWF gbl_iPrintStartDigit, W
0096  118A  	BCF PCLATH,3
0097  120A  	BCF PCLATH,4
0098  1D03  	BTFSS STATUS,Z
0099  289C  	GOTO	label10
009C        label10

        s7SegDisplay += tm1638Dot;
009A  085F  	MOVF gbl_tm1638Dot, W
009B  07F3  	ADDWF nibbleTo7S_00020_1_s7SegDisplay, F

    tm1638Data[iPrintStartDigit] = s7SegDisplay;
009C  1383  	BCF	STATUS,IRP
009D  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
009E  0084  	MOVWF FSR
009F  0867  	MOVF gbl_iPrintStartDigit, W
00A0  0784  	ADDWF FSR, F
00A1  0873  	MOVF nibbleTo7S_00020_1_s7SegDisplay, W
00A2  0080  	MOVWF INDF

    iPrintStartDigit++;
00A3  0AE7  	INCF gbl_iPrintStartDigit, F

}
00A4  0008  	RETURN


/*********************************************************************************************
  void bcdTo7Seg(char iBcdIn)
  Convert a single bcd byte into the 7-segment representation (two digits)
*********************************************************************************************/
void bcdTo7Seg(char iBcdIn) {

    nibbleTo7Seg(iBcdIn >> 4);
01EA  0E71  	SWAPF bcdTo7Seg_00000_arg_iBcdIn, W
01EB  390F  	ANDLW 0x0F
01EC  00F2  	MOVWF nibbleTo7S_00020_arg_bNibble
01ED  208D  	CALL nibbleTo7S_00020

    nibbleTo7Seg(iBcdIn);
01EE  0871  	MOVF bcdTo7Seg_00000_arg_iBcdIn, W
01EF  00F2  	MOVWF nibbleTo7S_00020_arg_bNibble
01F0  208D  	CALL nibbleTo7S_00020

}
01F1  0008  	RETURN


/*********************************************************************************************
  void tm1638UpdateDisplay()
  Publish the tm1638Data and tm1638LEDs arrays to the display
*********************************************************************************************/
void tm1638UpdateDisplay() {

    
    // Display current temperature unless set, trigger or alt display mode is active
    if (gcDisplayMode | gcSetMode | gcTriggerMode) {
021C  1283  	BCF STATUS, RP0
021D  1303  	BCF STATUS, RP1
021E  084F  	MOVF gbl_gcSetMode, W
021F  044E  	IORWF gbl_gcDisplayMode, W
0220  00ED  	MOVWF CompTempVar558
0221  0850  	MOVF gbl_gcTriggerMode, W
0222  046D  	IORWF CompTempVar558, W
0223  1903  	BTFSC STATUS,Z
0224  2B2F  	GOTO	label64
032F        label64

        if (gcSetMode == 1) {
0225  034F  	DECF gbl_gcSetMode, W
0226  1D03  	BTFSS STATUS,Z
0227  2A36  	GOTO	label43
0236        label43

            iDigitToFlash = 3;
0228  3003  	MOVLW 0x03
0229  00C8  	MOVWF gbl_iDigitToFlash

            // Display year
            // Start printing from digit 0
            iPrintStartDigit = 0;
022A  01E7  	CLRF gbl_iPrintStartDigit

            iPrintDotDigit = 1;
022B  3001  	MOVLW 0x01
022C  00E8  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(0x20); // Display 20 in digits 0 and 1 (+dot on 1)
022D  3020  	MOVLW 0x20
022E  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
022F  21EA  	CALL bcdTo7Seg_00000

            iPrintDotDigit = 3;
0230  3003  	MOVLW 0x03
0231  00E8  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(gBcdYear); // Display year in digits 2 and 3 (+dot on 3)
0232  083B  	MOVF gbl_gBcdYear, W
0233  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0234  21EA  	CALL bcdTo7Seg_00000

        } else if (gcSetMode == 4) {
0235  2B43  	GOTO	label65
0236  084F  	MOVF gbl_gcSetMode, W
0237  3A04  	XORLW 0x04
0238  1D03  	BTFSS STATUS,Z
0239  2A4C  	GOTO	label44
024C        label44

            iDigitToFlash = 3;
023A  3003  	MOVLW 0x03
023B  00C8  	MOVWF gbl_iDigitToFlash

            // Display day of week
            tm1638Data[0] = 0x5E; // d
023C  305E  	MOVLW 0x5E
023D  00A0  	MOVWF gbl_tm1638Data

            tm1638Data[1] = 0x5F; // a
023E  305F  	MOVLW 0x5F
023F  00A1  	MOVWF gbl_tm1638Data+D'1'

            tm1638Data[2] = 0x6E; // y
0240  306E  	MOVLW 0x6E
0241  00A2  	MOVWF gbl_tm1638Data+D'2'

            tm1638Data[3] = tm1638DisplayNumtoSeg[gDayOfWeek] + tm1638Dot;
0242  085E  	MOVF gbl_tm1638DisplayNumtoSeg, W
0243  00F4  	MOVWF __rom_get_00000_arg_objNumb
0244  0838  	MOVF gbl_gDayOfWeek, W
0245  00F5  	MOVWF __rom_get_00000_arg_idx
0246  201A  	CALL __rom_get_00000
0247  075F  	ADDWF gbl_tm1638Dot, W
0248  00A3  	MOVWF gbl_tm1638Data+D'3'

        } else if (gcTriggerMode) {
0249  118A  	BCF PCLATH,3
024A  120A  	BCF PCLATH,4
024B  2B43  	GOTO	label65
024C  08D0  	MOVF gbl_gcTriggerMode, F
024D  1903  	BTFSC STATUS,Z
024E  2B07  	GOTO	label57
0307        label57

            iPrintDotDigit = 5;
024F  3005  	MOVLW 0x05
0250  00E8  	MOVWF gbl_iPrintDotDigit

            switch (gcTriggerMode) {
0276  2B43  	GOTO	label65

                case 1:
0251  0850  	MOVF gbl_gcTriggerMode, W
0252  3A01  	XORLW 0x01
0253  1903  	BTFSC STATUS,Z
0254  2A77  	GOTO	label45
0277        label45

                    // White LED on hour
                    tm1638Data[0] = 0x38; // L
0277  3038  	MOVLW 0x38
0278  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0; // 
0279  01A1  	CLRF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x3f; // O
027A  303F  	MOVLW 0x3F
027B  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x54; // n
027C  3054  	MOVLW 0x54
027D  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
027E  3005  	MOVLW 0x05
027F  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
0280  3004  	MOVLW 0x04
0281  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOnHour); // Display hour in digits 4 and 5 (dot on 5)
0282  0852  	MOVF gbl_gBcdWhiteOnHour, W
0283  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0284  21EA  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdWhiteOnMinute); // Display minute in digits 6 and 7 (no dot)
0285  0851  	MOVF gbl_gBcdWhiteOnMinute, W
0286  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0287  21EA  	CALL bcdTo7Seg_00000

                    break;
0288  2B43  	GOTO	label65

                case 2:
0255  3A03  	XORLW 0x03
0256  1903  	BTFSC STATUS,Z
0257  2A89  	GOTO	label46
0289        label46

                    // White LED on minute
                    iDigitToFlash = 7;
0289  3007  	MOVLW 0x07
028A  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
028B  3006  	MOVLW 0x06
028C  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOnMinute); // Display minute in digits 6 and 7 (no dot)
028D  0851  	MOVF gbl_gBcdWhiteOnMinute, W
028E  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
028F  21EA  	CALL bcdTo7Seg_00000

                    break;
0290  2B43  	GOTO	label65

                case 3:
0258  3A01  	XORLW 0x01
0259  1903  	BTFSC STATUS,Z
025A  2A91  	GOTO	label47
0291        label47

                    // White LED off hour
                    tm1638Data[3] = 0x71; // F
0291  3071  	MOVLW 0x71
0292  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
0293  3005  	MOVLW 0x05
0294  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
0295  3004  	MOVLW 0x04
0296  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOffHour); 
0297  0854  	MOVF gbl_gBcdWhiteOffHour, W
0298  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0299  21EA  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdWhiteOffMinute); // Display minute in digits 6 and 7 (no dot)
029A  0853  	MOVF gbl_gBcdWhiteOffMinute, W
029B  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
029C  21EA  	CALL bcdTo7Seg_00000

                    break;
029D  2B43  	GOTO	label65

                case 4:
025B  3A07  	XORLW 0x07
025C  1903  	BTFSC STATUS,Z
025D  2A9E  	GOTO	label48
029E        label48

                    // White LED off minute
                    iDigitToFlash = 7;
029E  3007  	MOVLW 0x07
029F  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
02A0  3006  	MOVLW 0x06
02A1  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOffMinute); // Display minute in digits 6 and 7 (no dot)
02A2  0853  	MOVF gbl_gBcdWhiteOffMinute, W
02A3  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02A4  21EA  	CALL bcdTo7Seg_00000

                    break;
02A5  2B43  	GOTO	label65

                case 5:
025E  3A01  	XORLW 0x01
025F  1903  	BTFSC STATUS,Z
0260  2AA6  	GOTO	label49
02A6        label49

                    // Blue LED on hour
                    tm1638Data[0] = 0x7C; // b
02A6  307C  	MOVLW 0x7C
02A7  00A0  	MOVWF gbl_tm1638Data

                    //tm1638Data[1] = 0x30; // l
                    //tm1638Data[2] = 0x3f; // O
                    tm1638Data[3] = 0x54; // n
02A8  3054  	MOVLW 0x54
02A9  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
02AA  3005  	MOVLW 0x05
02AB  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
02AC  3004  	MOVLW 0x04
02AD  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOnHour); // Display hour in digits 4 and 5 (dot on 5)
02AE  0856  	MOVF gbl_gBcdBlueOnHour, W
02AF  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02B0  21EA  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlueOnMinute); // Display minute in digits 6 and 7 (no dot)
02B1  0855  	MOVF gbl_gBcdBlueOnMinute, W
02B2  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02B3  21EA  	CALL bcdTo7Seg_00000

                    break;
02B4  2B43  	GOTO	label65

                case 6:
0261  3A03  	XORLW 0x03
0262  1903  	BTFSC STATUS,Z
0263  2AB5  	GOTO	label50
02B5        label50

                    // Blue LED on minute
                    iDigitToFlash = 7;
02B5  3007  	MOVLW 0x07
02B6  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
02B7  3006  	MOVLW 0x06
02B8  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOnMinute); // Display minute in digits 6 and 7 (no dot)
02B9  0855  	MOVF gbl_gBcdBlueOnMinute, W
02BA  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02BB  21EA  	CALL bcdTo7Seg_00000

                    break;
02BC  2B43  	GOTO	label65

                case 7:
0264  3A01  	XORLW 0x01
0265  1903  	BTFSC STATUS,Z
0266  2ABD  	GOTO	label51
02BD        label51

                    // Blue LED off hour
                    tm1638Data[3] = 0x71; // F
02BD  3071  	MOVLW 0x71
02BE  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
02BF  3005  	MOVLW 0x05
02C0  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
02C1  3004  	MOVLW 0x04
02C2  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOffHour); // Display hour in digits 4 and 5 (dot on 5)
02C3  0858  	MOVF gbl_gBcdBlueOffHour, W
02C4  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02C5  21EA  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlueOffMinute); // Display minute in digits 6 and 7 (no dot)
02C6  0857  	MOVF gbl_gBcdBlueOffMinute, W
02C7  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02C8  21EA  	CALL bcdTo7Seg_00000

                    break;
02C9  2B43  	GOTO	label65

                case 8:
0267  3A0F  	XORLW 0x0F
0268  1903  	BTFSC STATUS,Z
0269  2ACA  	GOTO	label52
02CA        label52

                    // Blue LED off minute
                    iDigitToFlash = 7;
02CA  3007  	MOVLW 0x07
02CB  00C8  	MOVWF gbl_iDigitToFlash

                    bcdTo7Seg(gBcdBlueOffMinute); // Display minute in digits 6 and 7 (no dot)
02CC  0857  	MOVF gbl_gBcdBlueOffMinute, W
02CD  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02CE  21EA  	CALL bcdTo7Seg_00000

                    break;
02CF  2B43  	GOTO	label65

                case 9:
026A  3A01  	XORLW 0x01
026B  1903  	BTFSC STATUS,Z
026C  2AD0  	GOTO	label53
02D0        label53

                    // Fan on temperature
                    tm1638Data[0] = 0x38; // F
02D0  3038  	MOVLW 0x38
02D1  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x30; // a
02D2  3030  	MOVLW 0x30
02D3  00A1  	MOVWF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x54; // n
02D4  3054  	MOVLW 0x54
02D5  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x00; // 
02D6  01A3  	CLRF gbl_tm1638Data+D'3'

                    tm1638Data[4] = 0x3f; // O
02D7  303F  	MOVLW 0x3F
02D8  00A4  	MOVWF gbl_tm1638Data+D'4'

                    tm1638Data[5] = 0x54; // n
02D9  3054  	MOVLW 0x54
02DA  00A5  	MOVWF gbl_tm1638Data+D'5'

                    iDigitToFlash = 7;
02DB  3007  	MOVLW 0x07
02DC  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
02DD  3006  	MOVLW 0x06
02DE  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdFanOnTemp); // Display celcius in digits 6 and 7 (no dot)
02DF  0859  	MOVF gbl_gBcdFanOnTemp, W
02E0  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02E1  21EA  	CALL bcdTo7Seg_00000

                    break;
02E2  2B43  	GOTO	label65

                case 10:
026D  3A03  	XORLW 0x03
026E  1903  	BTFSC STATUS,Z
026F  2AE3  	GOTO	label54
02E3        label54

                    // Fan off temperature
                    tm1638Data[5] = 0x71; // f
02E3  3071  	MOVLW 0x71
02E4  00A5  	MOVWF gbl_tm1638Data+D'5'

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
02E5  3006  	MOVLW 0x06
02E6  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdFanOffTemp); // Display celcius in digits 6 and 7 (no dot)
02E7  085A  	MOVF gbl_gBcdFanOffTemp, W
02E8  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02E9  21EA  	CALL bcdTo7Seg_00000

                    break;
02EA  2B43  	GOTO	label65

                case 11:
0270  3A01  	XORLW 0x01
0271  1903  	BTFSC STATUS,Z
0272  2AEB  	GOTO	label55
02EB        label55

                    // Heater on temperature
                    tm1638Data[0] = 0x76; // H
02EB  3076  	MOVLW 0x76
02EC  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x7B; // e
02ED  307B  	MOVLW 0x7B
02EE  00A1  	MOVWF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x30; // a
02EF  3030  	MOVLW 0x30
02F0  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x78; // t
02F1  3078  	MOVLW 0x78
02F2  00A3  	MOVWF gbl_tm1638Data+D'3'

                    tm1638Data[4] = 0x3f; // O
02F3  303F  	MOVLW 0x3F
02F4  00A4  	MOVWF gbl_tm1638Data+D'4'

                    tm1638Data[5] = 0x54; // n
02F5  3054  	MOVLW 0x54
02F6  00A5  	MOVWF gbl_tm1638Data+D'5'

                    iDigitToFlash = 7;
02F7  3007  	MOVLW 0x07
02F8  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
02F9  3006  	MOVLW 0x06
02FA  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdHeaterOnTemp); // Display celcius in digits 6 and 7 (no dot)
02FB  085B  	MOVF gbl_gBcdHeaterOnTemp, W
02FC  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02FD  21EA  	CALL bcdTo7Seg_00000

                    break;
02FE  2B43  	GOTO	label65

                case 12:
0273  3A07  	XORLW 0x07
0274  1903  	BTFSC STATUS,Z
0275  2AFF  	GOTO	label56
02FF        label56

                    // Heater off temperature
                    tm1638Data[5] = 0x71; // f
02FF  3071  	MOVLW 0x71
0300  00A5  	MOVWF gbl_tm1638Data+D'5'

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0301  3006  	MOVLW 0x06
0302  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdHeaterOffTemp); // Display celcius in digits 6 and 7 (no dot)
0303  085C  	MOVF gbl_gBcdHeaterOffTemp, W
0304  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0305  21EA  	CALL bcdTo7Seg_00000

                    break;
            }
        } else {
0306  2B43  	GOTO	label65

            switch (gcSetMode) {
0323        label63

                case 2:
0307  084F  	MOVF gbl_gcSetMode, W
0308  3A02  	XORLW 0x02
0309  1903  	BTFSC STATUS,Z
030A  2B15  	GOTO	label58
0315        label58

                    iDigitToFlash = 3;
0315  3003  	MOVLW 0x03
0316  00C8  	MOVWF gbl_iDigitToFlash

                    break;
0317  2B23  	GOTO	label63

                case 3:
030B  3A01  	XORLW 0x01
030C  1903  	BTFSC STATUS,Z
030D  2B18  	GOTO	label59
0318        label59

                    iDigitToFlash = 1;
0318  3001  	MOVLW 0x01
0319  00C8  	MOVWF gbl_iDigitToFlash

                    break;
031A  2B23  	GOTO	label63

                case 5:
030E  3A06  	XORLW 0x06
030F  1903  	BTFSC STATUS,Z
0310  2B1B  	GOTO	label60
031B        label60

                    iDigitToFlash = 5;
031B  3005  	MOVLW 0x05
031C  00C8  	MOVWF gbl_iDigitToFlash

                    break;
031D  2B23  	GOTO	label63

                case 6:
0311  3A03  	XORLW 0x03
0312  1903  	BTFSC STATUS,Z
0313  2B1E  	GOTO	label61
031E        label61

                    iDigitToFlash = 7;
031E  3007  	MOVLW 0x07
031F  00C8  	MOVWF gbl_iDigitToFlash

                    break;
0320  2B23  	GOTO	label63

                default:
0314  2B21  	GOTO	label62
0321        label62

                    iDigitToFlash = 8;
0321  3008  	MOVLW 0x08
0322  00C8  	MOVWF gbl_iDigitToFlash

            }
            // Display date DD.MM
            iPrintStartDigit = 0;
0323  01E7  	CLRF gbl_iPrintStartDigit

            iPrintDotDigit = 1;
0324  3001  	MOVLW 0x01
0325  00E8  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(gBcdDayOfMonth); // Display day of month in digits 0 and 1 (+dot on 1)
0326  0839  	MOVF gbl_gBcdDayOfMonth, W
0327  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0328  21EA  	CALL bcdTo7Seg_00000

            iPrintDotDigit = 3;
0329  3003  	MOVLW 0x03
032A  00E8  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(gBcdMonth); // Display month in digits 2 and 3 (+dot on 3)
032B  083A  	MOVF gbl_gBcdMonth, W
032C  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
032D  21EA  	CALL bcdTo7Seg_00000

        }
    } else {
032E  2B43  	GOTO	label65

        // translate DS3231 temperature to digit values
        iPrintDotDigit = 1;
032F  3001  	MOVLW 0x01
0330  00E8  	MOVWF gbl_iPrintDotDigit

        /*
        No support for -10 or below - aquarium should never get that cold!
        if (gbDS3231IsMinus && (giDS3231ValueBCD & 0xF000)) {
            // If minus and value less than or equal -10 (checked as >1000), shift the digits right
            giDS3231ValueBCD >>= 4;
            iPrintDotDigit = 2;
        }*/
        // Display current temperature in digits 0 to 3 (+dot on digit 1 and 3)
        iPrintStartDigit = 0;
0331  01E7  	CLRF gbl_iPrintStartDigit

        bcdTo7Seg(giDS3231ValueBCD >> 8);
0332  0834  	MOVF gbl_giDS3231ValueBCD+D'1', W
0333  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0334  21EA  	CALL bcdTo7Seg_00000

        iPrintDotDigit = 3;
0335  3003  	MOVLW 0x03
0336  00E8  	MOVWF gbl_iPrintDotDigit

        bcdTo7Seg(giDS3231ValueBCD);
0337  0833  	MOVF gbl_giDS3231ValueBCD, W
0338  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0339  21EA  	CALL bcdTo7Seg_00000


        // left fill zeroes with blanks up to the digit before the decimal place
        if (tm1638Data[0] == 0x3f)
033A  0820  	MOVF gbl_tm1638Data, W
033B  3A3F  	XORLW 0x3F
033C  1903  	BTFSC STATUS,Z

            tm1638Data[0] = 0;
033D  01A0  	CLRF gbl_tm1638Data

        // If minus, overwrite left most digit with minus sign
        if (gbDS3231IsMinus)
033E  08CB  	MOVF gbl_gbDS3231IsMinus, F
033F  1903  	BTFSC STATUS,Z
0340  2B43  	GOTO	label65
0343        label65

            tm1638Data[0] = 0x40;
0341  3040  	MOVLW 0x40
0342  00A0  	MOVWF gbl_tm1638Data

    }

    // HH.MM in last 4 digits of TM1638
    if (!gcTriggerMode) {
0343  08D0  	MOVF gbl_gcTriggerMode, F
0344  1D03  	BTFSS STATUS,Z
0345  2B55  	GOTO	label68
0355        label68

        iPrintStartDigit = 4;
0346  3004  	MOVLW 0x04
0347  00E7  	MOVWF gbl_iPrintStartDigit

        // Flash dot every second
        if (gBcdSecond.0)
0348  1C35  	BTFSS gbl_gBcdSecond,0
0349  2B4D  	GOTO	label66
034D        label66

			iPrintDotDigit = 5;
034A  3005  	MOVLW 0x05
034B  00E8  	MOVWF gbl_iPrintDotDigit

		else
034C  2B4F  	GOTO	label67
034F        label67

			iPrintDotDigit = 8;
034D  3008  	MOVLW 0x08
034E  00E8  	MOVWF gbl_iPrintDotDigit

        bcdTo7Seg(gBcdHour); // Display hour in digits 4 and 5 (dot on 5)
034F  0837  	MOVF gbl_gBcdHour, W
0350  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0351  21EA  	CALL bcdTo7Seg_00000

        bcdTo7Seg(gBcdMinute); // Display minute in digits 6 and 7 (no dot)
0352  0836  	MOVF gbl_gBcdMinute, W
0353  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0354  21EA  	CALL bcdTo7Seg_00000

    }

    // Light LED for set mode
    char cCompareSetMode = gcSetMode + 1;
0355  0A4F  	INCF gbl_gcSetMode, W
0356  00EE  	MOVWF tm1638Upda_00022_1_cCompar_00023

    for (char i = 2; i < 8; i++) {
0357  3002  	MOVLW 0x02
0358  00F0  	MOVWF tm1638Upda_00022_3_i
0359        label69
0359  3008  	MOVLW 0x08
035A  0270  	SUBWF tm1638Upda_00022_3_i, W
035B  1803  	BTFSC STATUS,C
035C  2B72  	GOTO	label72
0370  0AF0  	INCF tm1638Upda_00022_3_i, F
0371  2B59  	GOTO	label69
0372        label72

        if (i == cCompareSetMode)
035D  086E  	MOVF tm1638Upda_00022_1_cCompar_00023, W
035E  0670  	XORWF tm1638Upda_00022_3_i, W
035F  1D03  	BTFSS STATUS,Z
0360  2B69  	GOTO	label70
0369        label70

            tm1638LEDs[i] = 1;
0361  1383  	BCF	STATUS,IRP
0362  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
0363  0084  	MOVWF FSR
0364  0870  	MOVF tm1638Upda_00022_3_i, W
0365  0784  	ADDWF FSR, F
0366  3001  	MOVLW 0x01
0367  0080  	MOVWF INDF

        else
0368  2B70  	GOTO	label71
0370        label71

            tm1638LEDs[i] = 0;
0369  1383  	BCF	STATUS,IRP
036A  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
036B  0084  	MOVWF FSR
036C  0870  	MOVF tm1638Upda_00022_3_i, W
036D  0784  	ADDWF FSR, F
036E  3000  	MOVLW 0x00
036F  0080  	MOVWF INDF

    }
    tm1638LEDs[0] = HEATER;
0372  01A8  	CLRF gbl_tm1638LEDs
0373  1805  	BTFSC gbl_porta,0
0374  0AA8  	INCF gbl_tm1638LEDs, F

    tm1638LEDs[1] = FAN;
0375  01A9  	CLRF gbl_tm1638LEDs+D'1'
0376  1885  	BTFSC gbl_porta,1
0377  0AA9  	INCF gbl_tm1638LEDs+D'1', F


    // Write 0x40 [01000000] (table 5.1) to indicate command to display data - [Write data to display register]
    tm1638strobe = 0;
0378  1186  	BCF gbl_portb,3

    tm1638ByteWrite(tm1638ByteSetData);
0379  0861  	MOVF gbl_tm1638ByteSetData, W
037A  00F0  	MOVWF tm1638Byte_0001F_arg_bWrite
037B  215B  	CALL tm1638Byte_0001F

    tm1638strobe = 1;
037C  1586  	BSF gbl_portb,3

    
    tm1638strobe = 0;
037D  1186  	BCF gbl_portb,3

    // Specify the display address 0xC0 [11000000] (table 5.2) [Display address 00H] then write out all 16 bytes
    tm1638ByteWrite(tm1638ByteSetAddr);
037E  0863  	MOVF gbl_tm1638ByteSetAddr, W
037F  00F0  	MOVWF tm1638Byte_0001F_arg_bWrite
0380  215B  	CALL tm1638Byte_0001F

    for (char i = 0; i < tm1638MaxDigits; i++) {
0381  01EF  	CLRF tm1638Upda_00022_2_i
0382        label73
0382  085D  	MOVF gbl_tm1638MaxDigits, W
0383  026F  	SUBWF tm1638Upda_00022_2_i, W
0384  1803  	BTFSC STATUS,C
0385  2BA1  	GOTO	label76
039F  0AEF  	INCF tm1638Upda_00022_2_i, F
03A0  2B82  	GOTO	label73
03A1        label76

        // display digit first
        if (iFlashDigitOff.0 && (i == iDigitToFlash))
0386  1C3F  	BTFSS gbl_iFlashDigitOff,0
0387  2B8F  	GOTO	label74
0388  0848  	MOVF gbl_iDigitToFlash, W
0389  066F  	XORWF tm1638Upda_00022_2_i, W
038A  1D03  	BTFSS STATUS,Z
038B  2B8F  	GOTO	label74
038F        label74

            tm1638ByteWrite(0);
038C  01F0  	CLRF tm1638Byte_0001F_arg_bWrite
038D  215B  	CALL tm1638Byte_0001F

        else
038E  2B97  	GOTO	label75
0397        label75

            tm1638ByteWrite(tm1638Data[i]);
038F  1383  	BCF	STATUS,IRP
0390  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
0391  0084  	MOVWF FSR
0392  086F  	MOVF tm1638Upda_00022_2_i, W
0393  0784  	ADDWF FSR, F
0394  0800  	MOVF INDF, W
0395  00F0  	MOVWF tm1638Byte_0001F_arg_bWrite
0396  215B  	CALL tm1638Byte_0001F

        // then LED
        tm1638ByteWrite(tm1638LEDs[i]);
0397  1383  	BCF	STATUS,IRP
0398  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
0399  0084  	MOVWF FSR
039A  086F  	MOVF tm1638Upda_00022_2_i, W
039B  0784  	ADDWF FSR, F
039C  0800  	MOVF INDF, W
039D  00F0  	MOVWF tm1638Byte_0001F_arg_bWrite
039E  215B  	CALL tm1638Byte_0001F

    }
    tm1638strobe = 1;
03A1  1586  	BSF gbl_portb,3

}
03A2  0008  	RETURN


/*********************************************************************************************
  void tm1638ReadKeys()
  Reads the keys status into tm1638Keys
*********************************************************************************************/
void tm1638ReadKeys() {

    // Write 0x42 [01000010] to indicate command to read data
    tm1638strobe = 0;
05DA  1283  	BCF STATUS, RP0
05DB  1303  	BCF STATUS, RP1
05DC  1186  	BCF gbl_portb,3

    tm1638ByteWrite(tm1638ByteReadData);
05DD  0862  	MOVF gbl_tm1638ByteReadData, W
05DE  00F0  	MOVWF tm1638Byte_0001F_arg_bWrite
05DF  215B  	CALL tm1638Byte_0001F

    
    tm1638dioTris = 1; // Set data pin to input
05E0  1683  	BSF STATUS, RP0
05E1  1486  	BSF gbl_trisb,1

    char tm1638KeysTemp = 32;
05E2  3020  	MOVLW 0x20
05E3  1283  	BCF STATUS, RP0
05E4  00EC  	MOVWF tm1638Read_00024_1_tm1638K_00025

    // Read 4 bytes
    for (char i = 0; i < 32; i++) {
05E5  01ED  	CLRF tm1638Read_00024_2_i
05E6        label106
05E6  3020  	MOVLW 0x20
05E7  026D  	SUBWF tm1638Read_00024_2_i, W
05E8  1803  	BTFSC STATUS,C
05E9  2DF6  	GOTO	label108
05F4  0AED  	INCF tm1638Read_00024_2_i, F
05F5  2DE6  	GOTO	label106
05F6        label108

        tm1638KeysTemp--;
05EA  03EC  	DECF tm1638Read_00024_1_tm1638K_00025, F

        tm1638clk = 0;
05EB  1106  	BCF gbl_portb,2

        delay_us(1);
05EC  3001  	MOVLW 0x01
05ED  00F2  	MOVWF delay_us_00000_arg_del
05EE  2010  	CALL delay_us_00000

        if(tm1638dio)
05EF  1C86  	BTFSS gbl_portb,1
05F0  2DF3  	GOTO	label107
05F3        label107

            tm1638KeysTemp <<= 1;
05F1  1003  	BCF STATUS,C
05F2  0DEC  	RLF tm1638Read_00024_1_tm1638K_00025, F

        tm1638clk = 1;
05F3  1506  	BSF gbl_portb,2

    }
    tm1638dioTris = 0; // Set data pin to output
05F6  1683  	BSF STATUS, RP0
05F7  1086  	BCF gbl_trisb,1

    tm1638strobe = 1;
05F8  1283  	BCF STATUS, RP0
05F9  1586  	BSF gbl_portb,3


    tm1638Keys = tm1638KeysTemp;
05FA  086C  	MOVF tm1638Read_00024_1_tm1638K_00025, W
05FB  00E5  	MOVWF gbl_tm1638Keys

    /*
    1F = 0001 1111
	17 = 0001 0111
	0F = 0000 1111
	07 = 0000 0111
	1B = 0001 1011
	13 = 0001 0011
	0B = 0000 1011
	03 = 0000 0111
	*/
}
05FC  0008  	RETURN


/*********************************************************************************************
  void convertTemp()
  Used to split the 16 bit integer returned from the ds18b20 into parts for display
*********************************************************************************************/
void convertTemp() {

    // convert both bytes to a 16bit int - e.g. 0000 0001 0100 0110 (1 and 70, gives 326)
    signed int iTemp = (cTempH << 8) | cTempL;
06F0  1283  	BCF STATUS, RP0
06F1  1303  	BCF STATUS, RP1
06F2  01ED  	CLRF convertTem_0002B_1_iTemp
06F3  0849  	MOVF gbl_cTempH, W
06F4  00EE  	MOVWF convertTem_0002B_1_iTemp+D'1'
06F5  084A  	MOVF gbl_cTempL, W
06F6  04ED  	IORWF convertTem_0002B_1_iTemp, F

    
    // Celcius
    gbDS3231IsMinus = (iTemp < 0);
06F7  01CB  	CLRF gbl_gbDS3231IsMinus
06F8  1BEE  	BTFSC convertTem_0002B_1_iTemp+D'1',7
06F9  0ACB  	INCF gbl_gbDS3231IsMinus, F

    if (gbDS3231IsMinus) {
06FA  08CB  	MOVF gbl_gbDS3231IsMinus, F
06FB  1903  	BTFSC STATUS,Z
06FC  2F02  	GOTO	label120

        iTemp = ~iTemp + 1;
06FD  09ED  	COMF convertTem_0002B_1_iTemp, F
06FE  09EE  	COMF convertTem_0002B_1_iTemp+D'1', F
06FF  0AED  	INCF convertTem_0002B_1_iTemp, F
0700  1903  	BTFSC STATUS,Z
0701  0AEE  	INCF convertTem_0002B_1_iTemp+D'1', F
0702        label120

    }
    // this gets celcius * 100 - https://www.phanderson.com/PIC/PICC/sourceboost/ds18b20_1.html
    int iValue = (6 * iTemp) + (iTemp / 4);
0702  3006  	MOVLW 0x06
0703  00F3  	MOVWF __mul_16s__0000F_arg_a
0704  01F4  	CLRF __mul_16s__0000F_arg_a+D'1'
0705  086D  	MOVF convertTem_0002B_1_iTemp, W
0706  00F5  	MOVWF __mul_16s__0000F_arg_b
0707  086E  	MOVF convertTem_0002B_1_iTemp+D'1', W
0708  00F6  	MOVWF __mul_16s__0000F_arg_b+D'1'
0709  25B1  	CALL __mul_16s__0000F
070A  087A  	MOVF CompTempVarRet389, W
070B  00EF  	MOVWF convertTem_0002B_1_iValue
070C  087B  	MOVF CompTempVarRet389+D'1', W
070D  00F2  	MOVWF CompTempVar613
070E  086D  	MOVF convertTem_0002B_1_iTemp, W
070F  00F1  	MOVWF CompTempVar610
0710  086E  	MOVF convertTem_0002B_1_iTemp+D'1', W
0711  00F0  	MOVWF convertTem_0002B_1_iValue+D'1'
0712  0D6E  	RLF convertTem_0002B_1_iTemp+D'1', W
0713  0CF0  	RRF convertTem_0002B_1_iValue+D'1', F
0714  0CF1  	RRF CompTempVar610, F
0715  0D6E  	RLF convertTem_0002B_1_iTemp+D'1', W
0716  0CF0  	RRF convertTem_0002B_1_iValue+D'1', F
0717  0CF1  	RRF CompTempVar610, F
0718  0871  	MOVF CompTempVar610, W
0719  07EF  	ADDWF convertTem_0002B_1_iValue, F
071A  0872  	MOVF CompTempVar613, W
071B  1803  	BTFSC STATUS,C
071C  0AF0  	INCF convertTem_0002B_1_iValue+D'1', F
071D  07F0  	ADDWF convertTem_0002B_1_iValue+D'1', F


    // Split the temperature reading into digits
    
    // simple way, but more program memory needed for PIC12 or PIC16 (more than 100 words more)
    //giDS3231ValueBCD = iValue / 1000;
    //giDS3231ValueBCD += (iValue / 100) % 10;
    //giDS3231ValueBCD += (iValue / 10) % 10;
    //giDS3231ValueBCD += iValue % 10;
    
    // Double Dabble
    /*giDS3231ValueBCD = 0; // 16-bit BCD value - only supporting up to 9999
    int iTest = 32768; // Start testing from MSB
    // Loop through the 16 bits in the two bytes
    for (char i = 0; i < 16; i++) {
        // Shift one
        giDS3231ValueBCD <<= 1;
        // If the bit is set, add one
        if (iValue & iTest)
            giDS3231ValueBCD++;
        
        // Add 3 to any BCD column 5 or greater
        if ((giDS3231ValueBCD & 0x0F) > 0x04)
            giDS3231ValueBCD += 3;
        if ((giDS3231ValueBCD & 0xF0) > 0x49)
            giDS3231ValueBCD += 0x30;
        if ((giDS3231ValueBCD & 0xF00) > 0x499)
            giDS3231ValueBCD += 0x300;
        if ((giDS3231ValueBCD & 0xF000) > 0x4999)
            giDS3231ValueBCD += 0x3000;
        
        // move the test bit
        iTest >>= 1;
    }*/
    
    // less program memory needed - may be slower executing
    // https://electronics.stackexchange.com/questions/158563/how-to-split-a-floating-point-number-into-individual-digits
    giDS3231ValueBCD = 0;
071E  01B3  	CLRF gbl_giDS3231ValueBCD
071F  01B4  	CLRF gbl_giDS3231ValueBCD+D'1'


    // incrementing variables for each digit
    // determine to thousands digit
    while (iValue >= 1000) {
0720        label121
0720  3003  	MOVLW 0x03
0721  0270  	SUBWF convertTem_0002B_1_iValue+D'1', W
0722  1D03  	BTFSS STATUS,Z
0723  2F26  	GOTO	label122
0724  30E8  	MOVLW 0xE8
0725  026F  	SUBWF convertTem_0002B_1_iValue, W
0726        label122
0726  1C03  	BTFSS STATUS,C
0727  2F38  	GOTO	label123
0728  1BF0  	BTFSC convertTem_0002B_1_iValue+D'1',7
0729  2F38  	GOTO	label123
0737  2F20  	GOTO	label121
0738        label123

        iValue = iValue - 1000;
072A  30E8  	MOVLW 0xE8
072B  02EF  	SUBWF convertTem_0002B_1_iValue, F
072C  3003  	MOVLW 0x03
072D  1C03  	BTFSS STATUS,C
072E  3004  	MOVLW 0x04
072F  02F0  	SUBWF convertTem_0002B_1_iValue+D'1', F

        // each time we take off 1000, the digit is incremented
        giDS3231ValueBCD = giDS3231ValueBCD + 0x1000;
0730  3000  	MOVLW 0x00
0731  07B3  	ADDWF gbl_giDS3231ValueBCD, F
0732  08B4  	MOVF gbl_giDS3231ValueBCD+D'1', F
0733  3010  	MOVLW 0x10
0734  1803  	BTFSC STATUS,C
0735  0AB4  	INCF gbl_giDS3231ValueBCD+D'1', F
0736  07B4  	ADDWF gbl_giDS3231ValueBCD+D'1', F

    }

    // determine to hundreds digit
    while (iValue >= 100) {
0738  0870  	MOVF convertTem_0002B_1_iValue+D'1', W
0739  3A80  	XORLW 0x80
073A  00F3  	MOVWF CompTempVar625
073B  3080  	MOVLW 0x80
073C  0273  	SUBWF CompTempVar625, W
073D  1D03  	BTFSS STATUS,Z
073E  2F41  	GOTO	label124
073F  3064  	MOVLW 0x64
0740  026F  	SUBWF convertTem_0002B_1_iValue, W
0741        label124
0741  1C03  	BTFSS STATUS,C
0742  2F50  	GOTO	label125
074F  2F38  	GOTO	label123
0750        label125

        iValue = iValue - 100;
0743  3064  	MOVLW 0x64
0744  02EF  	SUBWF convertTem_0002B_1_iValue, F
0745  08F0  	MOVF convertTem_0002B_1_iValue+D'1', F
0746  1C03  	BTFSS STATUS,C
0747  03F0  	DECF convertTem_0002B_1_iValue+D'1', F

        // each time we take off 100, the digit is incremented
        giDS3231ValueBCD = giDS3231ValueBCD + 0x100;
0748  3000  	MOVLW 0x00
0749  07B3  	ADDWF gbl_giDS3231ValueBCD, F
074A  08B4  	MOVF gbl_giDS3231ValueBCD+D'1', F
074B  3001  	MOVLW 0x01
074C  1803  	BTFSC STATUS,C
074D  0AB4  	INCF gbl_giDS3231ValueBCD+D'1', F
074E  07B4  	ADDWF gbl_giDS3231ValueBCD+D'1', F

    }

    // determine to tens digit
    while (iValue >= 10) {
0750  0870  	MOVF convertTem_0002B_1_iValue+D'1', W
0751  3A80  	XORLW 0x80
0752  00F3  	MOVWF CompTempVar630
0753  3080  	MOVLW 0x80
0754  0273  	SUBWF CompTempVar630, W
0755  1D03  	BTFSS STATUS,Z
0756  2F59  	GOTO	label126
0757  300A  	MOVLW 0x0A
0758  026F  	SUBWF convertTem_0002B_1_iValue, W
0759        label126
0759  1C03  	BTFSS STATUS,C
075A  2F66  	GOTO	label127
0765  2F50  	GOTO	label125
0766        label127

        iValue = iValue - 10;
075B  300A  	MOVLW 0x0A
075C  02EF  	SUBWF convertTem_0002B_1_iValue, F
075D  08F0  	MOVF convertTem_0002B_1_iValue+D'1', F
075E  1C03  	BTFSS STATUS,C
075F  03F0  	DECF convertTem_0002B_1_iValue+D'1', F

        // each time we take off 10, the left most digit is incremented
        giDS3231ValueBCD = giDS3231ValueBCD + 0x10;
0760  3010  	MOVLW 0x10
0761  07B3  	ADDWF gbl_giDS3231ValueBCD, F
0762  08B4  	MOVF gbl_giDS3231ValueBCD+D'1', F
0763  1803  	BTFSC STATUS,C
0764  0AB4  	INCF gbl_giDS3231ValueBCD+D'1', F

    }

    // the last digit is what's left on iValue
    giDS3231ValueBCD = giDS3231ValueBCD + iValue;
0766  086F  	MOVF convertTem_0002B_1_iValue, W
0767  07B3  	ADDWF gbl_giDS3231ValueBCD, F
0768  0870  	MOVF convertTem_0002B_1_iValue+D'1', W
0769  00F3  	MOVWF CompTempVar636
076A  0834  	MOVF gbl_giDS3231ValueBCD+D'1', W
076B  1803  	BTFSC STATUS,C
076C  0AF3  	INCF CompTempVar636, F
076D  07F3  	ADDWF CompTempVar636, F
076E  0873  	MOVF CompTempVar636, W
076F  00B4  	MOVWF gbl_giDS3231ValueBCD+D'1'

}
0770  0008  	RETURN


/*********************************************************************************************
  void startTemp()
  Sends the Convert T [44h] function command to the ds18b20
*********************************************************************************************/
void startTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // 44 is the convert function
    oneWireTxBytes(0xCC, 0x44);
05FD  30CC  	MOVLW 0xCC
05FE  1283  	BCF STATUS, RP0
05FF  1303  	BCF STATUS, RP1
0600  00ED  	MOVWF oneWireTxB_00019_arg_cData
0601  3044  	MOVLW 0x44
0602  00EE  	MOVWF oneWireTxB_00019_arg_cData2
0603  23AB  	CALL oneWireTxB_00019

}
0604  0008  	RETURN


/*********************************************************************************************
  void startTemp()
  Sends the Read Scratchpad [BEh] function command to the ds18b20
*********************************************************************************************/
void readTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // BE indicates to read scratchpad
    oneWireTxBytes(0xCC, 0xBE);
0605  30CC  	MOVLW 0xCC
0606  1283  	BCF STATUS, RP0
0607  1303  	BCF STATUS, RP1
0608  00ED  	MOVWF oneWireTxB_00019_arg_cData
0609  30BE  	MOVLW 0xBE
060A  00EE  	MOVWF oneWireTxB_00019_arg_cData2
060B  23AB  	CALL oneWireTxB_00019

    // Now get the temperature from the scratchpad
    // This is in the first two bytes - so get those only and ignore the rest
    cTempL = oneWireRxByte();
060C  23B2  	CALL oneWireRxB_0001A
060D  086E  	MOVF CompTempVarRet551, W
060E  00CA  	MOVWF gbl_cTempL

    cTempH = oneWireRxByte();
060F  23B2  	CALL oneWireRxB_0001A
0610  086E  	MOVF CompTempVarRet551, W
0611  00C9  	MOVWF gbl_cTempH

}
0612  0008  	RETURN


/*********************************************************************************************
  char bcdAdjust(char bcd, char bcdMax, char bcdMin)
  Increment or Decrement a BCD variable for sending to the DS3231, within a given range
  Must set iBcdAdjustment first
*********************************************************************************************/
char bcdAdjust(char bcd, char bcdMax, char bcdMin) {

    if (iBcdAdjustment == 1) {
01F2  0369  	DECF gbl_iBcdAdjustment, W
01F3  1D03  	BTFSS STATUS,Z
01F4  2A08  	GOTO	label39
0208        label39

        // Increment
        // if at maximum, reset to minimum
        if (bcd == bcdMax)
01F5  086F  	MOVF bcdAdjust_00000_arg_bcdMax, W
01F6  066E  	XORWF bcdAdjust_00000_arg_bcd, W
01F7  1D03  	BTFSS STATUS,Z
01F8  29FC  	GOTO	label37
01FC        label37

            bcd = bcdMin;
01F9  0870  	MOVF bcdAdjust_00000_arg_bcdMin, W
01FA  00EE  	MOVWF bcdAdjust_00000_arg_bcd

        else if ((bcd & 0x0F) == 9)
01FB  2A19  	GOTO	label42
01FC  300F  	MOVLW 0x0F
01FD  056E  	ANDWF bcdAdjust_00000_arg_bcd, W
01FE  00F1  	MOVWF CompTempVar599
01FF  0871  	MOVF CompTempVar599, W
0200  3A09  	XORLW 0x09
0201  1D03  	BTFSS STATUS,Z
0202  2A06  	GOTO	label38
0206        label38

            bcd += 0x07; // add 0x10, minus 9
0203  3007  	MOVLW 0x07
0204  07EE  	ADDWF bcdAdjust_00000_arg_bcd, F

        else
0205  2A19  	GOTO	label42

            bcd++;
0206  0AEE  	INCF bcdAdjust_00000_arg_bcd, F

    } else {
0207  2A19  	GOTO	label42

        // Decrement
        // if at minimum, reset to maximum
        if (bcd == bcdMin)
0208  0870  	MOVF bcdAdjust_00000_arg_bcdMin, W
0209  066E  	XORWF bcdAdjust_00000_arg_bcd, W
020A  1D03  	BTFSS STATUS,Z
020B  2A0F  	GOTO	label40
020F        label40

            bcd = bcdMax;
020C  086F  	MOVF bcdAdjust_00000_arg_bcdMax, W
020D  00EE  	MOVWF bcdAdjust_00000_arg_bcd

        else if ((bcd & 0x0F) == 0)
020E  2A19  	GOTO	label42
020F  300F  	MOVLW 0x0F
0210  056E  	ANDWF bcdAdjust_00000_arg_bcd, W
0211  00F1  	MOVWF CompTempVar600
0212  08F1  	MOVF CompTempVar600, F
0213  1D03  	BTFSS STATUS,Z
0214  2A18  	GOTO	label41
0218        label41

            bcd -= 0x07; // mins 0x10, add 9
0215  3007  	MOVLW 0x07
0216  02EE  	SUBWF bcdAdjust_00000_arg_bcd, F

        else
0217  2A19  	GOTO	label42
0219        label42

            bcd--;
0218  03EE  	DECF bcdAdjust_00000_arg_bcd, F

    }
    return bcd;
0219  086E  	MOVF bcdAdjust_00000_arg_bcd, W
021A  00F1  	MOVWF CompTempVarRet598

}
021B  0008  	RETURN


/*********************************************************************************************
  void adjustDateTime()
  Increment or Decrement a BCD variable for sending to the DS3231, within a given range
  Must set iBcdAdjustment first
*********************************************************************************************/
void adjustDateTime() {

    switch (gcSetMode) {

        case 1:
0537  1283  	BCF STATUS, RP0
0538  1303  	BCF STATUS, RP1
0539  084F  	MOVF gbl_gcSetMode, W
053A  3A01  	XORLW 0x01
053B  1903  	BTFSC STATUS,Z
053C  2D4D  	GOTO	label93
054D        label93

            // Setting year
            gBcdYear = bcdAdjust(gBcdYear, 0x99, 0x00);
054D  083B  	MOVF gbl_gBcdYear, W
054E  00EE  	MOVWF bcdAdjust_00000_arg_bcd
054F  3099  	MOVLW 0x99
0550  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
0551  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
0552  21F2  	CALL bcdAdjust_00000
0553  0871  	MOVF CompTempVarRet598, W
0554  00BB  	MOVWF gbl_gBcdYear

            break;
        case 2:
053D  3A03  	XORLW 0x03
053E  1903  	BTFSC STATUS,Z
053F  2D56  	GOTO	label94
0556        label94

            // Setting month
            gBcdMonth = bcdAdjust(gBcdMonth, 0x12, 0x01);
0556  083A  	MOVF gbl_gBcdMonth, W
0557  00EE  	MOVWF bcdAdjust_00000_arg_bcd
0558  3012  	MOVLW 0x12
0559  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
055A  3001  	MOVLW 0x01
055B  00F0  	MOVWF bcdAdjust_00000_arg_bcdMin
055C  21F2  	CALL bcdAdjust_00000
055D  0871  	MOVF CompTempVarRet598, W
055E  00BA  	MOVWF gbl_gBcdMonth

            break;
        case 3:
0540  3A01  	XORLW 0x01
0541  1903  	BTFSC STATUS,Z
0542  2D60  	GOTO	label95
0560        label95

            // Setting day of month
            char iMonth = gBcdMonth;
0560  083A  	MOVF gbl_gBcdMonth, W
0561  00EC  	MOVWF adjustDate_00026_1_iMonth

            if (iMonth & 0xF0)
0562  30F0  	MOVLW 0xF0
0563  056C  	ANDWF adjustDate_00026_1_iMonth, W
0564  1903  	BTFSC STATUS,Z
0565  2D6B  	GOTO	label96
056B        label96

                iMonth += (gBcdMonth >> 4);
0566  0E3A  	SWAPF gbl_gBcdMonth, W
0567  390F  	ANDLW 0x0F
0568  00EE  	MOVWF CompTempVar601
0569  086E  	MOVF CompTempVar601, W
056A  07EC  	ADDWF adjustDate_00026_1_iMonth, F

            iMonth--; // Make 0 to 11 index based
056B  03EC  	DECF adjustDate_00026_1_iMonth, F

            char bcdMaxDay = gDaysInMonth[iMonth]; 
056C  083C  	MOVF gbl_gDaysInMonth, W
056D  00F4  	MOVWF __rom_get_00000_arg_objNumb
056E  086C  	MOVF adjustDate_00026_1_iMonth, W
056F  00F5  	MOVWF __rom_get_00000_arg_idx
0570  201A  	CALL __rom_get_00000
0571  00ED  	MOVWF adjustDate_00026_1_bcdMaxDay

            // If February, adjust max days for leap years
            if (iMonth == 1) {
0572  036C  	DECF adjustDate_00026_1_iMonth, W
0573  118A  	BCF PCLATH,3
0574  120A  	BCF PCLATH,4
0575  1D03  	BTFSS STATUS,Z
0576  2D8D  	GOTO	label99

                // See if the 24 leap years since 2000 match the current year
                for (char i = 0; i < 24; i++) {
0577  01EE  	CLRF adjustDate_00026_16_i
0578        label97
0578  3018  	MOVLW 0x18
0579  026E  	SUBWF adjustDate_00026_16_i, W
057A  1803  	BTFSC STATUS,C
057B  2D8D  	GOTO	label99
058B  0AEE  	INCF adjustDate_00026_16_i, F
058C  2D78  	GOTO	label97
058D        label99

                    if (gLeapYears[i] == gBcdYear) {
057C  083D  	MOVF gbl_gLeapYears, W
057D  00F4  	MOVWF __rom_get_00000_arg_objNumb
057E  086E  	MOVF adjustDate_00026_16_i, W
057F  00F5  	MOVWF __rom_get_00000_arg_idx
0580  201A  	CALL __rom_get_00000
0581  00EF  	MOVWF CompTempVar602
0582  083B  	MOVF gbl_gBcdYear, W
0583  066F  	XORWF CompTempVar602, W
0584  118A  	BCF PCLATH,3
0585  120A  	BCF PCLATH,4
0586  1D03  	BTFSS STATUS,Z
0587  2D8B  	GOTO	label98
058B        label98

                        bcdMaxDay = 0x29;
0588  3029  	MOVLW 0x29
0589  00ED  	MOVWF adjustDate_00026_1_bcdMaxDay

                        break;
058A  2D8D  	GOTO	label99

                    }
                }
            }
            gBcdDayOfMonth = bcdAdjust(gBcdDayOfMonth, bcdMaxDay, 0x01);
058D  0839  	MOVF gbl_gBcdDayOfMonth, W
058E  00EE  	MOVWF bcdAdjust_00000_arg_bcd
058F  086D  	MOVF adjustDate_00026_1_bcdMaxDay, W
0590  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
0591  3001  	MOVLW 0x01
0592  00F0  	MOVWF bcdAdjust_00000_arg_bcdMin
0593  21F2  	CALL bcdAdjust_00000
0594  0871  	MOVF CompTempVarRet598, W
0595  00B9  	MOVWF gbl_gBcdDayOfMonth

            break;
        case 4:
0543  3A07  	XORLW 0x07
0544  1903  	BTFSC STATUS,Z
0545  2D97  	GOTO	label100
0597        label100

            // Setting day of week
            gDayOfWeek = bcdAdjust(gDayOfWeek, 0x07, 0x01);
0597  0838  	MOVF gbl_gDayOfWeek, W
0598  00EE  	MOVWF bcdAdjust_00000_arg_bcd
0599  3007  	MOVLW 0x07
059A  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
059B  3001  	MOVLW 0x01
059C  00F0  	MOVWF bcdAdjust_00000_arg_bcdMin
059D  21F2  	CALL bcdAdjust_00000
059E  0871  	MOVF CompTempVarRet598, W
059F  00B8  	MOVWF gbl_gDayOfWeek

        case 5:
0546  3A01  	XORLW 0x01
0547  1903  	BTFSC STATUS,Z
0548  2DA0  	GOTO	label101
05A0        label101

            // Setting hour
            gBcdHour = bcdAdjust(gBcdHour, 0x23, 0x00);
05A0  0837  	MOVF gbl_gBcdHour, W
05A1  00EE  	MOVWF bcdAdjust_00000_arg_bcd
05A2  3023  	MOVLW 0x23
05A3  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
05A4  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
05A5  21F2  	CALL bcdAdjust_00000
05A6  0871  	MOVF CompTempVarRet598, W
05A7  00B7  	MOVWF gbl_gBcdHour

        case 6:
0549  3A03  	XORLW 0x03
054A  1903  	BTFSC STATUS,Z
054B  2DA8  	GOTO	label102
05A8        label102

            // Setting minute
            gBcdMinute = bcdAdjust(gBcdMinute, 0x59, 0x00);
05A8  0836  	MOVF gbl_gBcdMinute, W
05A9  00EE  	MOVWF bcdAdjust_00000_arg_bcd
05AA  3059  	MOVLW 0x59
05AB  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
05AC  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
05AD  21F2  	CALL bcdAdjust_00000
05AE  0871  	MOVF CompTempVarRet598, W
05AF  00B6  	MOVWF gbl_gBcdMinute

    }
}
054C  0008  	RETURN
0555  0008  	RETURN
055F  0008  	RETURN
0596  0008  	RETURN
05B0  0008  	RETURN


/*********************************************************************************************
  void adjustTrigger()
  Increment or Decrement a trigger time or temperate
  Must set iBcdAdjustment first
*********************************************************************************************/
void adjustTrigger() {

    switch (gcTriggerMode) {

        case 1:
049F  1283  	BCF STATUS, RP0
04A0  1303  	BCF STATUS, RP1
04A1  0850  	MOVF gbl_gcTriggerMode, W
04A2  3A01  	XORLW 0x01
04A3  1903  	BTFSC STATUS,Z
04A4  2CC7  	GOTO	label81
04C7        label81

            // White LED on hour
            gBcdWhiteOnHour = bcdAdjust(gBcdWhiteOnHour, 0x23, 0x00);
04C7  0852  	MOVF gbl_gBcdWhiteOnHour, W
04C8  00EE  	MOVWF bcdAdjust_00000_arg_bcd
04C9  3023  	MOVLW 0x23
04CA  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
04CB  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
04CC  21F2  	CALL bcdAdjust_00000
04CD  0871  	MOVF CompTempVarRet598, W
04CE  00D2  	MOVWF gbl_gBcdWhiteOnHour

            break;
        case 2:
04A5  3A03  	XORLW 0x03
04A6  1903  	BTFSC STATUS,Z
04A7  2CD0  	GOTO	label82
04D0        label82

            // White LED on minute
            gBcdWhiteOnMinute = bcdAdjust(gBcdWhiteOnMinute, 0x59, 0x00);
04D0  0851  	MOVF gbl_gBcdWhiteOnMinute, W
04D1  00EE  	MOVWF bcdAdjust_00000_arg_bcd
04D2  3059  	MOVLW 0x59
04D3  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
04D4  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
04D5  21F2  	CALL bcdAdjust_00000
04D6  0871  	MOVF CompTempVarRet598, W
04D7  00D1  	MOVWF gbl_gBcdWhiteOnMinute

            break;
        case 3:
04A8  3A01  	XORLW 0x01
04A9  1903  	BTFSC STATUS,Z
04AA  2CD9  	GOTO	label83
04D9        label83

            // White LED off hour
            gBcdWhiteOffHour = bcdAdjust(gBcdWhiteOffHour, 0x23, 0x00);
04D9  0854  	MOVF gbl_gBcdWhiteOffHour, W
04DA  00EE  	MOVWF bcdAdjust_00000_arg_bcd
04DB  3023  	MOVLW 0x23
04DC  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
04DD  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
04DE  21F2  	CALL bcdAdjust_00000
04DF  0871  	MOVF CompTempVarRet598, W
04E0  00D4  	MOVWF gbl_gBcdWhiteOffHour

            break;
        case 4:
04AB  3A07  	XORLW 0x07
04AC  1903  	BTFSC STATUS,Z
04AD  2CE2  	GOTO	label84
04E2        label84

            // White LED off minute
            gBcdWhiteOffMinute = bcdAdjust(gBcdWhiteOffMinute, 0x59, 0x00);
04E2  0853  	MOVF gbl_gBcdWhiteOffMinute, W
04E3  00EE  	MOVWF bcdAdjust_00000_arg_bcd
04E4  3059  	MOVLW 0x59
04E5  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
04E6  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
04E7  21F2  	CALL bcdAdjust_00000
04E8  0871  	MOVF CompTempVarRet598, W
04E9  00D3  	MOVWF gbl_gBcdWhiteOffMinute

            break;
        case 5:
04AE  3A01  	XORLW 0x01
04AF  1903  	BTFSC STATUS,Z
04B0  2CEB  	GOTO	label85
04EB        label85

            // Blue LED on hour
            gBcdBlueOnHour = bcdAdjust(gBcdBlueOnHour, 0x23, 0x00);
04EB  0856  	MOVF gbl_gBcdBlueOnHour, W
04EC  00EE  	MOVWF bcdAdjust_00000_arg_bcd
04ED  3023  	MOVLW 0x23
04EE  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
04EF  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
04F0  21F2  	CALL bcdAdjust_00000
04F1  0871  	MOVF CompTempVarRet598, W
04F2  00D6  	MOVWF gbl_gBcdBlueOnHour

            break;
        case 6:
04B1  3A03  	XORLW 0x03
04B2  1903  	BTFSC STATUS,Z
04B3  2CF4  	GOTO	label86
04F4        label86

            // Blue LED on minute
            gBcdBlueOnMinute = bcdAdjust(gBcdBlueOnMinute, 0x59, 0x00);
04F4  0855  	MOVF gbl_gBcdBlueOnMinute, W
04F5  00EE  	MOVWF bcdAdjust_00000_arg_bcd
04F6  3059  	MOVLW 0x59
04F7  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
04F8  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
04F9  21F2  	CALL bcdAdjust_00000
04FA  0871  	MOVF CompTempVarRet598, W
04FB  00D5  	MOVWF gbl_gBcdBlueOnMinute

            break;
        case 7:
04B4  3A01  	XORLW 0x01
04B5  1903  	BTFSC STATUS,Z
04B6  2CFD  	GOTO	label87
04FD        label87

            // Blue LED off hour
            gBcdBlueOffHour = bcdAdjust(gBcdBlueOffHour, 0x23, 0x00);
04FD  0858  	MOVF gbl_gBcdBlueOffHour, W
04FE  00EE  	MOVWF bcdAdjust_00000_arg_bcd
04FF  3023  	MOVLW 0x23
0500  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
0501  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
0502  21F2  	CALL bcdAdjust_00000
0503  0871  	MOVF CompTempVarRet598, W
0504  00D8  	MOVWF gbl_gBcdBlueOffHour

            break;
        case 8:
04B7  3A0F  	XORLW 0x0F
04B8  1903  	BTFSC STATUS,Z
04B9  2D06  	GOTO	label88
0506        label88

            // Blue LED off minute
            gBcdBlueOffMinute = bcdAdjust(gBcdBlueOffMinute, 0x59, 0x00);
0506  0857  	MOVF gbl_gBcdBlueOffMinute, W
0507  00EE  	MOVWF bcdAdjust_00000_arg_bcd
0508  3059  	MOVLW 0x59
0509  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
050A  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
050B  21F2  	CALL bcdAdjust_00000
050C  0871  	MOVF CompTempVarRet598, W
050D  00D7  	MOVWF gbl_gBcdBlueOffMinute

            break;
        case 9:
04BA  3A01  	XORLW 0x01
04BB  1903  	BTFSC STATUS,Z
04BC  2D0F  	GOTO	label89
050F        label89

            // Fan on temp - between 20 and 40 degrees C
            gBcdFanOnTemp = bcdAdjust(gBcdFanOnTemp, 0x40, 0x20);
050F  0859  	MOVF gbl_gBcdFanOnTemp, W
0510  00EE  	MOVWF bcdAdjust_00000_arg_bcd
0511  3040  	MOVLW 0x40
0512  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
0513  3020  	MOVLW 0x20
0514  00F0  	MOVWF bcdAdjust_00000_arg_bcdMin
0515  21F2  	CALL bcdAdjust_00000
0516  0871  	MOVF CompTempVarRet598, W
0517  00D9  	MOVWF gbl_gBcdFanOnTemp

            break;
        case 10:
04BD  3A03  	XORLW 0x03
04BE  1903  	BTFSC STATUS,Z
04BF  2D19  	GOTO	label90
0519        label90

            // Fan off temp - off must be lower than on, min 20 degrees C
            gBcdFanOffTemp = bcdAdjust(gBcdFanOffTemp, gBcdFanOffTemp, 0x20);
0519  085A  	MOVF gbl_gBcdFanOffTemp, W
051A  00EE  	MOVWF bcdAdjust_00000_arg_bcd
051B  085A  	MOVF gbl_gBcdFanOffTemp, W
051C  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
051D  3020  	MOVLW 0x20
051E  00F0  	MOVWF bcdAdjust_00000_arg_bcdMin
051F  21F2  	CALL bcdAdjust_00000
0520  0871  	MOVF CompTempVarRet598, W
0521  00DA  	MOVWF gbl_gBcdFanOffTemp

            break;
        case 11:
04C0  3A01  	XORLW 0x01
04C1  1903  	BTFSC STATUS,Z
04C2  2D23  	GOTO	label91
0523        label91

            // Heater on temp - between 20 and 40 degrees C
            gBcdHeaterOnTemp = bcdAdjust(gBcdHeaterOnTemp, 0x40, 0x20);
0523  085B  	MOVF gbl_gBcdHeaterOnTemp, W
0524  00EE  	MOVWF bcdAdjust_00000_arg_bcd
0525  3040  	MOVLW 0x40
0526  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
0527  3020  	MOVLW 0x20
0528  00F0  	MOVWF bcdAdjust_00000_arg_bcdMin
0529  21F2  	CALL bcdAdjust_00000
052A  0871  	MOVF CompTempVarRet598, W
052B  00DB  	MOVWF gbl_gBcdHeaterOnTemp

            break;
        case 12:
04C3  3A07  	XORLW 0x07
04C4  1903  	BTFSC STATUS,Z
04C5  2D2D  	GOTO	label92
052D        label92

            // Heater off temp - off must be higher than on - max 40 degrees C
            gBcdHeaterOffTemp = bcdAdjust(gBcdHeaterOffTemp, 0x40, gBcdHeaterOnTemp);
052D  085C  	MOVF gbl_gBcdHeaterOffTemp, W
052E  00EE  	MOVWF bcdAdjust_00000_arg_bcd
052F  3040  	MOVLW 0x40
0530  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
0531  085B  	MOVF gbl_gBcdHeaterOnTemp, W
0532  00F0  	MOVWF bcdAdjust_00000_arg_bcdMin
0533  21F2  	CALL bcdAdjust_00000
0534  0871  	MOVF CompTempVarRet598, W
0535  00DC  	MOVWF gbl_gBcdHeaterOffTemp

            break;
    }
}
04C6  0008  	RETURN
04CF  0008  	RETURN
04D8  0008  	RETURN
04E1  0008  	RETURN
04EA  0008  	RETURN
04F3  0008  	RETURN
04FC  0008  	RETURN
0505  0008  	RETURN
050E  0008  	RETURN
0518  0008  	RETURN
0522  0008  	RETURN
052C  0008  	RETURN
0536  0008  	RETURN


/*********************************************************************************************
  void processKeys()
  Action a key press
*********************************************************************************************/
void processKeys() {

    switch (tm1638Keys) {

        case 0x1F:
0613  1283  	BCF STATUS, RP0
0614  1303  	BCF STATUS, RP1
0615  0865  	MOVF gbl_tm1638Keys, W
0616  3A1F  	XORLW 0x1F
0617  1903  	BTFSC STATUS,Z
0618  2E2F  	GOTO	label109
062F        label109

            // Toggle white light on/off
            WHITE_LED = !WHITE_LED;
062F  01EC  	CLRF CompTempVar603
0630  1C87  	BTFSS gbl_portc,1
0631  0AEC  	INCF CompTempVar603, F
0632  186C  	BTFSC CompTempVar603,0
0633  1487  	BSF gbl_portc,1
0634  1C6C  	BTFSS CompTempVar603,0
0635  1087  	BCF gbl_portc,1

            break;
        case 0x17:
0619  3A08  	XORLW 0x08
061A  1903  	BTFSC STATUS,Z
061B  2E37  	GOTO	label110
0637        label110

            // Toggle blue light on/off
            BLUE_LED = !BLUE_LED;
0637  01EC  	CLRF CompTempVar604
0638  1D07  	BTFSS gbl_portc,2
0639  0AEC  	INCF CompTempVar604, F
063A  186C  	BTFSC CompTempVar604,0
063B  1507  	BSF gbl_portc,2
063C  1C6C  	BTFSS CompTempVar604,0
063D  1107  	BCF gbl_portc,2

            break;
        case 0x0F:
061C  3A18  	XORLW 0x18
061D  1903  	BTFSC STATUS,Z
061E  2E3F  	GOTO	label111
063F        label111

            // Toggle fan on/off
            gbFanOn = !gbFanOn;
063F  01EC  	CLRF CompTempVar605
0640  1D4D  	BTFSS gbl_gbFanOn,2
0641  0AEC  	INCF CompTempVar605, F
0642  114D  	BCF gbl_gbFanOn,2
0643  086C  	MOVF CompTempVar605, W
0644  1D03  	BTFSS STATUS,Z
0645  154D  	BSF gbl_gbFanOn,2

            break;
        case 0x07:
061F  3A08  	XORLW 0x08
0620  1903  	BTFSC STATUS,Z
0621  2E47  	GOTO	label112
0647        label112

            // Exit other modes
            gcSetMode = 0;
0647  01CF  	CLRF gbl_gcSetMode

            gcTriggerMode = 0;
0648  01D0  	CLRF gbl_gcTriggerMode

            // Display temp C/temp F/date
            gcDisplayMode++;
0649  0ACE  	INCF gbl_gcDisplayMode, F

            if (gcDisplayMode > 2)
064A  084E  	MOVF gbl_gcDisplayMode, W
064B  3C02  	SUBLW 0x02
064C  1C03  	BTFSS STATUS,C

                gcDisplayMode = 0;
064D  01CE  	CLRF gbl_gcDisplayMode

            break;
        case 0x1B:
0622  3A1C  	XORLW 0x1C
0623  1903  	BTFSC STATUS,Z
0624  2E4F  	GOTO	label113
064F        label113

            // Exit other modes
            gcTriggerMode = 0;
064F  01D0  	CLRF gbl_gcTriggerMode

            // Adjust set mode
            gcSetMode++;
0650  0ACF  	INCF gbl_gcSetMode, F

            if (gcSetMode > 6) {
0651  084F  	MOVF gbl_gcSetMode, W
0652  3C06  	SUBLW 0x06
0653  1803  	BTFSC STATUS,C

                ds3231WriteDateTime();
0655  23E3  	CALL ds3231Writ_0001C

                gcSetMode = 0;
0656  01CF  	CLRF gbl_gcSetMode

            }
            break;
        case 0x13:
0625  3A08  	XORLW 0x08
0626  1903  	BTFSC STATUS,Z
0627  2E58  	GOTO	label114
0658        label114

            // Adjust down
            iBcdAdjustment = 0;
0658  01E9  	CLRF gbl_iBcdAdjustment

            if (gcSetMode) {
0659  08CF  	MOVF gbl_gcSetMode, F
065A  1903  	BTFSC STATUS,Z
065B  2E5E  	GOTO	label115
065E        label115

                adjustDateTime();
065C  2537  	CALL adjustDate_00026

            } else if (gcTriggerMode) {
065E  08D0  	MOVF gbl_gcTriggerMode, F
065F  1D03  	BTFSS STATUS,Z

                adjustTrigger();
0660  249F  	CALL adjustTrig_00027

            }
            break;
        case 0x0B:
0628  3A18  	XORLW 0x18
0629  1903  	BTFSC STATUS,Z
062A  2E62  	GOTO	label116
0662        label116

            iBcdAdjustment = 1;
0662  3001  	MOVLW 0x01
0663  00E9  	MOVWF gbl_iBcdAdjustment

            // Adjust up
            if (gcSetMode) {
0664  08CF  	MOVF gbl_gcSetMode, F
0665  1903  	BTFSC STATUS,Z
0666  2E69  	GOTO	label117
0669        label117

                adjustDateTime();
0667  2537  	CALL adjustDate_00026

            } else if (gcTriggerMode) {
0669  08D0  	MOVF gbl_gcTriggerMode, F
066A  1D03  	BTFSS STATUS,Z

                adjustTrigger();
066B  249F  	CALL adjustTrig_00027

            }
            break;
        case 0x03:
062B  3A08  	XORLW 0x08
062C  1903  	BTFSC STATUS,Z
062D  2E6D  	GOTO	label118
066D        label118

            // Exit set mode
            gcSetMode = 0;
066D  01CF  	CLRF gbl_gcSetMode

            // Adjust timer mode
            gcTriggerMode++;
066E  0AD0  	INCF gbl_gcTriggerMode, F

            if (gcTriggerMode > 12) {
066F  0850  	MOVF gbl_gcTriggerMode, W
0670  3C0C  	SUBLW 0x0C
0671  1803  	BTFSC STATUS,C

                gcTriggerMode = 0;
0673  01D0  	CLRF gbl_gcTriggerMode

                at24c32WriteAll(); // Exiting trigger mode, save the new triggers to EEPROM chip
0674  241F  	CALL at24c32Wri_00029

            }
            break;
    }
}
062E  0008  	RETURN
0636  0008  	RETURN
063E  0008  	RETURN
0646  0008  	RETURN
064E  0008  	RETURN
0654  0008  	RETURN
0657  0008  	RETURN
065D  0008  	RETURN
0661  0008  	RETURN
0668  0008  	RETURN
066C  0008  	RETURN
0672  0008  	RETURN
0675  0008  	RETURN


/*********************************************************************************************
  void interrupt()
  Interrupt handler
*********************************************************************************************/
void interrupt() {

    // Interrupt on timer0 - flash digit delay
    if (intcon.T0IF) {
0840  1D0B  	BTFSS gbl_intcon,2
0841  2849  	GOTO	label141
0849        label141

        iTimer0Counts++;
0842  1283  	BCF STATUS, RP0
0843  1303  	BCF STATUS, RP1
0844  0ABE  	INCF gbl_iTimer0Counts, F

        tmr0 = TMR0PRELOAD;
0845  303D  	MOVLW 0x3D
0846  0081  	MOVWF gbl_tmr0

        cTask.TASK_TIMER0 = 1;
0847  14CC  	BSF gbl_cTask,1

        // Clear interrupt flag
        intcon.T0IF = 0; 
0848  110B  	BCF gbl_intcon,2

    }
    // Handle timer1 interrupt - delay counter from DS3231
    if (pir1.TMR1IF) {
0849  1283  	BCF STATUS, RP0
084A  1303  	BCF STATUS, RP1
084B  1C0C  	BTFSS gbl_pir1,0
084C  2852  	GOTO	label142
0852        label142

        tmr1h = TMR1HV;      // preset for timer1 MSB register
084D  30FF  	MOVLW 0xFF
084E  008F  	MOVWF gbl_tmr1h

        tmr1l = TMR1LV;      // preset for timer1 LSB register
084F  008E  	MOVWF gbl_tmr1l


        pir1.TMR1IF = 0;     // Clear interrupt flag
0850  100C  	BCF gbl_pir1,0

        cTask.TASK_TIMER1 = 1;
0851  154C  	BSF gbl_cTask,2

    }
}
0852  0E32  	SWAPF Int1BContext+D'2', W
0853  0084  	MOVWF FSR
0854  0E31  	SWAPF Int1BContext+D'1', W
0855  008A  	MOVWF PCLATH
0856  0E30  	SWAPF Int1BContext, W
0857  0083  	MOVWF STATUS
0858  0EFF  	SWAPF Int1Context, F
0859  0E7F  	SWAPF Int1Context, W
085A  0009  	RETFIE


/*********************************************************************************************
  void initialise()
  Function called once only to initialise variables and
  setup the PIC registers
*********************************************************************************************/
void initialise() {

    //PIC16F73 doesn't have an internal oscillator
    //pcon.OSCF = 1; // 4MHz internal osc

    // Configure port A
    /*
    RA7     Doesn't exist
    RA6     Doesn't exist
    RA5     
    RA4     
    RA3     
    RA2     
    RA1     OUT FANS
    RA0     OUT HEATER
    */
    trisa = 0x00; // all outputs
068E  1683  	BSF STATUS, RP0
068F  1303  	BCF STATUS, RP1
0690  0185  	CLRF gbl_trisa

    porta = 0x00; // All off
0691  1283  	BCF STATUS, RP0
0692  0185  	CLRF gbl_porta

    
    // Configure port B
    /*      
    RB7     ICSP PGD
    RB6     ICSP PGC
    RB5     
    RB4     
    RB3     OUT TM1638 STB
    RB2     OUT TM1638 CLK
    RB1     IN/OUT TM1638 DIO
    RB0     
    */
    trisb = 0x00; // all outputs by default
0693  1683  	BSF STATUS, RP0
0694  0186  	CLRF gbl_trisb

    portb = 0x0E; // default TM1638 pins high
0695  300E  	MOVLW 0x0E
0696  1283  	BCF STATUS, RP0
0697  0086  	MOVWF gbl_portb


    // Configure port C
    /*      
    RC7     
    RC6     
    RC5     IN/OUT DS18B20
    RC4     IN/OUT DS3231M I2C SDA
    RC3     IN/OUT DS3231M I2C CLK
    RC2     OUT BLUE LIGHT PWM
    RC1     OUT WHITE LIGHT PWM
    RC0     IN SQW DS3231M
    */
    trisc = 0x21; // RC0 and RC5 inputs
0698  3021  	MOVLW 0x21
0699  1683  	BSF STATUS, RP0
069A  0087  	MOVWF gbl_trisc

    portc = 0x38; // default DS18B20 and DS3231 pins high
069B  3038  	MOVLW 0x38
069C  1283  	BCF STATUS, RP0
069D  0087  	MOVWF gbl_portc


    option_reg = 0;
069E  1683  	BSF STATUS, RP0
069F  0181  	CLRF gbl_option_reg

    option_reg.NOT_RBPU = 1; // disable port b pull ups
06A0  1781  	BSF gbl_option_reg,7


    // ADC setup
    // PIC16F73 doesn't have comparators
    //cmcon = 7; // disable all comparators so port a is usable as digital io
    adcon1 = 7; // Set RA0,RA1,RA2,RA5,RA3 all to digital I/O
06A1  3007  	MOVLW 0x07
06A2  009F  	MOVWF gbl_adcon1



    // Setup timer 0, used for flashing display
    // Timer calculator: http://eng-serve.com/pic/pic_timer.html
    // Timer0 Registers Prescaler= 256 - TMR0 Preset = 61 - Freq = 20.03 Hz - Period = 0.049920 seconds
    //option_reg.T0CS = 0; // bit 5  TMR0 Clock Source Select bit...0 = Internal Clock (CLKO) 1 = Transition on T0CKI pin
    //option_reg.T0SE = 0; // bit 4 TMR0 Source Edge Select bit 0 = low/high 1 = high/low
    //option_reg.PSA = 0; // bit 3  Prescaler Assignment bit...0 = Prescaler is assigned to the Timer0
    option_reg.PS2 = 1; // bits 2-0  PS2:PS0: Prescaler Rate Select bits
06A3  1501  	BSF gbl_option_reg,2

    option_reg.PS1 = 1;
06A4  1481  	BSF gbl_option_reg,1

    option_reg.PS0 = 1;
06A5  1401  	BSF gbl_option_reg,0

    tmr0 = TMR0PRELOAD; // preset for timer register (61)
06A6  303D  	MOVLW 0x3D
06A7  1283  	BCF STATUS, RP0
06A8  0081  	MOVWF gbl_tmr0

    intcon.T0IF = 0; // Clear timer 1 interrupt flag bit
06A9  110B  	BCF gbl_intcon,2

    intcon.T0IE = 1; // Timer 1 interrupt enabled
06AA  168B  	BSF gbl_intcon,5


    // Setup timer 1, used to update clock display and periodically ask for a temperature reading
    // Timer 1 setup - interrupt on DS3231 SQW 1Hz
    // Timer1 Registers Prescaler= 1 - TMR1 Preset = 65535 - Freq = 1 Hz
    // Bits 5-4 T1CKPS1:T1CKPS0 = 00: Prescaler Rate Select bits, 00 = 1:1 prescaler
    // Bit 3 T1OSCEN = 0: Timer1 LP Oscillator Enable Control bit, 0 = off
    // Bit 2 NOT_T1SYNC = 1: Timer1 External Clock Input Synchronization Control bit, 1 = Do not synchronize external clock input
    // Bit 1 TMR1CS = 1: Timer1 Clock Source Select bit, 1 = External clock from T1OSO/T1CKI pin (on the rising edge)
    // Bit 0 TMR1ON = 0: Timer1 On Bit, 0 = off
    t1con = 0b00000111;
06AB  3007  	MOVLW 0x07
06AC  0090  	MOVWF gbl_t1con

    tmr1h = TMR1HV;      // preset for timer1 MSB register
06AD  30FF  	MOVLW 0xFF
06AE  008F  	MOVWF gbl_tmr1h

    tmr1l = TMR1LV;      // preset for timer1 LSB register
06AF  008E  	MOVWF gbl_tmr1l

    pie1.TMR1IE = 1;     // Timer 1 interrupt
06B0  1683  	BSF STATUS, RP0
06B1  140C  	BSF gbl_pie1,0

    
    // No task at initialisation
    cTask = 0;
06B2  1283  	BCF STATUS, RP0
06B3  01CC  	CLRF gbl_cTask

    
    // Enable interrupts
    intcon.GIE = 1;
06B4  178B  	BSF gbl_intcon,7

    intcon.PEIE = 1;
06B5  170B  	BSF gbl_intcon,6


	// I2C Bus initialisation - baud rate divisor not applicable for software implementation
	i2c_init(1); 
06B6  3001  	MOVLW 0x01
06B7  00ED  	MOVWF i2c_INIT_00000_arg_i2c_divisor
06B8  23D0  	CALL i2c_INIT_00000


    // Read in variables from EEPROM
    at24c32ReadAll();
06B9  2453  	CALL at24c32Rea_0002A


    // Check if the DS3231 needs initilising
    char cStatus = ds3231ReadRegister(0x0F); // Read the status register
06BA  300F  	MOVLW 0x0F
06BB  00ED  	MOVWF ds3231Read_0001E_arg_cRegAddress
06BC  23FF  	CALL ds3231Read_0001E
06BD  086F  	MOVF CompTempVarRet554, W
06BE  00EC  	MOVWF initialise_00000_1_cStatus

    // If the oscillator (OSF bit in status register) has stopped, then init and write a default date/time
    if (cStatus.7) {
06BF  1FEC  	BTFSS initialise_00000_1_cStatus,7
06C0  2EC3  	GOTO	label119
06C3        label119

        ds3231Init();
06C1  2414  	CALL ds3231Init_00000

        ds3231WriteDateTime();
06C2  23E3  	CALL ds3231Writ_0001C

    }
    
	tm1638DisplayOn();
06C3  23A3  	CALL tm1638Disp_00021

    tm1638UpdateDisplay();
06C4  221C  	CALL tm1638Upda_00022

}
06C5  0008  	RETURN


/*********************************************************************************************
  void main()
  Entry method. Loops infinitely with a simple task scheduler.
*********************************************************************************************/
void main() {

    initialise();
0771  268E  	CALL initialise_00000

    
    // Endless loop
    while(1) {
0772        label128

        // Task scheduler
        // If there are tasks to be performed, find out the
        // most recent task from the array and execute it
        while (cTask > 0) {
0772  084C  	MOVF gbl_cTask, W
0773  3C00  	SUBLW 0x00
0774  1803  	BTFSC STATUS,C
0775  2F72  	GOTO	label128

            if (cTask.TASK_TIMER1) {
0776  1D4C  	BTFSS gbl_cTask,2
0777  2FC7  	GOTO	label137
07C7        label137

                if (gcSetMode == 0) {
0778  08CF  	MOVF gbl_gcSetMode, F
0779  1D03  	BTFSS STATUS,Z
077A  2F91  	GOTO	label132

                    ds3231ReadDateTime();
077B  26C6  	CALL ds3231Read_0001D

                    if ((gBcdSecond == 0x29) || (gBcdSecond == 0x59)) {
077C  0835  	MOVF gbl_gBcdSecond, W
077D  3A29  	XORLW 0x29
077E  1903  	BTFSC STATUS,Z
077F  2F84  	GOTO	label129
0780  0835  	MOVF gbl_gBcdSecond, W
0781  3A59  	XORLW 0x59
0782  1D03  	BTFSS STATUS,Z
0783  2F87  	GOTO	label130
0784        label129
0787        label130

                        // Ask to convert for temperature reading at 29 seconds or 59 seconds past the minute
                        oneWireBusReset();
0784  2676  	CALL oneWireBus_00017

                        startTemp();
0785  25FD  	CALL startTemp_00000

                    } else if ((gBcdSecond == 0) || (gBcdSecond == 0x30)) {
0786  2F91  	GOTO	label132
0787  08B5  	MOVF gbl_gBcdSecond, F
0788  1903  	BTFSC STATUS,Z
0789  2F8E  	GOTO	label131
078A  0835  	MOVF gbl_gBcdSecond, W
078B  3A30  	XORLW 0x30
078C  1D03  	BTFSS STATUS,Z
078D  2F91  	GOTO	label132
078E        label131
0791        label132
07DD  2F72  	GOTO	label128

                        // 1 second later, read the converted temperature
                        oneWireBusReset();
078E  2676  	CALL oneWireBus_00017

                        readTemp(); 
078F  2605  	CALL readTemp_00000

                        // store it in the array, next display refresh will pick it up
                        convertTemp();
0790  26F0  	CALL convertTem_0002B

                    }
                }
                // Trigger white led
                if ((gBcdHour == gBcdWhiteOnHour) && (gBcdMinute == gBcdWhiteOnMinute)) {
0791  0852  	MOVF gbl_gBcdWhiteOnHour, W
0792  0637  	XORWF gbl_gBcdHour, W
0793  1D03  	BTFSS STATUS,Z
0794  2F99  	GOTO	label133
0795  0851  	MOVF gbl_gBcdWhiteOnMinute, W
0796  0636  	XORWF gbl_gBcdMinute, W
0797  1903  	BTFSC STATUS,Z

                    WHITE_LED = 1;
0798  1487  	BSF gbl_portc,1
0799        label133

                }
                if ((gBcdHour == gBcdWhiteOffHour) && (gBcdMinute == gBcdWhiteOffMinute)) {
0799  0854  	MOVF gbl_gBcdWhiteOffHour, W
079A  0637  	XORWF gbl_gBcdHour, W
079B  1D03  	BTFSS STATUS,Z
079C  2FA1  	GOTO	label134
079D  0853  	MOVF gbl_gBcdWhiteOffMinute, W
079E  0636  	XORWF gbl_gBcdMinute, W
079F  1903  	BTFSC STATUS,Z

                    WHITE_LED = 0;
07A0  1087  	BCF gbl_portc,1
07A1        label134

                }
                // Trigger blue led
                if ((gBcdHour == gBcdBlueOnHour) && (gBcdMinute == gBcdBlueOnMinute)) {
07A1  0856  	MOVF gbl_gBcdBlueOnHour, W
07A2  0637  	XORWF gbl_gBcdHour, W
07A3  1D03  	BTFSS STATUS,Z
07A4  2FA9  	GOTO	label135
07A5  0855  	MOVF gbl_gBcdBlueOnMinute, W
07A6  0636  	XORWF gbl_gBcdMinute, W
07A7  1903  	BTFSC STATUS,Z

                    BLUE_LED = 1;
07A8  1507  	BSF gbl_portc,2
07A9        label135

                }
                if ((gBcdHour == gBcdBlueOffHour) && (gBcdMinute == gBcdBlueOffMinute)) {
07A9  0858  	MOVF gbl_gBcdBlueOffHour, W
07AA  0637  	XORWF gbl_gBcdHour, W
07AB  1D03  	BTFSS STATUS,Z
07AC  2FB1  	GOTO	label136
07AD  0857  	MOVF gbl_gBcdBlueOffMinute, W
07AE  0636  	XORWF gbl_gBcdMinute, W
07AF  1903  	BTFSC STATUS,Z

                    BLUE_LED = 0;
07B0  1107  	BCF gbl_portc,2
07B1        label136

                }
                // Trigger fan
                char cTempTruncated = giDS3231ValueBCD >> 8;
07B1  0834  	MOVF gbl_giDS3231ValueBCD+D'1', W
07B2  00EC  	MOVWF main_6_cTempTruncated

                if (cTempTruncated >= gBcdFanOnTemp) {
07B3  0859  	MOVF gbl_gBcdFanOnTemp, W
07B4  026C  	SUBWF main_6_cTempTruncated, W
07B5  1803  	BTFSC STATUS,C

                    FAN = 1;
07B6  1485  	BSF gbl_porta,1

                }
                if (cTempTruncated <= gBcdFanOffTemp) {
07B7  086C  	MOVF main_6_cTempTruncated, W
07B8  025A  	SUBWF gbl_gBcdFanOffTemp, W
07B9  1803  	BTFSC STATUS,C

                    FAN = 0;
07BA  1085  	BCF gbl_porta,1

                }
                // Forced on
                if (gbFanOn)
07BB  194D  	BTFSC gbl_gbFanOn,2

					FAN = 1;
07BC  1485  	BSF gbl_porta,1

                // Trigger heater
                if (cTempTruncated <= gBcdHeaterOnTemp) {
07BD  086C  	MOVF main_6_cTempTruncated, W
07BE  025B  	SUBWF gbl_gBcdHeaterOnTemp, W
07BF  1803  	BTFSC STATUS,C

                    HEATER = 1;
07C0  1405  	BSF gbl_porta,0

                }
                if (cTempTruncated >= gBcdHeaterOffTemp) {
07C1  085C  	MOVF gbl_gBcdHeaterOffTemp, W
07C2  026C  	SUBWF main_6_cTempTruncated, W
07C3  1803  	BTFSC STATUS,C

                    HEATER = 0;
07C4  1005  	BCF gbl_porta,0

                }
                // Display time and temp or date on TM1638
                tm1638UpdateDisplay();
07C5  221C  	CALL tm1638Upda_00022

                
                cTask.TASK_TIMER1 = 0;
07C6  114C  	BCF gbl_cTask,2

            }
            if (cTask.TASK_TIMER0) {
07C7  1CCC  	BTFSS gbl_cTask,1
07C8  2F72  	GOTO	label128

				// ~half second count
				if (iTimer0Counts > 9) {
07C9  083E  	MOVF gbl_iTimer0Counts, W
07CA  3C09  	SUBLW 0x09
07CB  1803  	BTFSC STATUS,C
07CC  2FD3  	GOTO	label138

					iFlashDigitOff++;
07CD  0ABF  	INCF gbl_iFlashDigitOff, F

					iTimer0Counts = 0;					
07CE  01BE  	CLRF gbl_iTimer0Counts

					// If in set mode, update the display every ~half second to flash a digit
					if (gcSetMode > 0)
07CF  084F  	MOVF gbl_gcSetMode, W
07D0  3C00  	SUBLW 0x00
07D1  1C03  	BTFSS STATUS,C

						tm1638UpdateDisplay();
07D2  221C  	CALL tm1638Upda_00022
07D3        label138

				}
				// Poll keys every 50ms
				tm1638ReadKeys();
07D3  25DA  	CALL tm1638Read_00024

				if (tm1638Keys != tm1638KeysOld) {
07D4  0866  	MOVF gbl_tm1638KeysOld, W
07D5  0665  	XORWF gbl_tm1638Keys, W
07D6  1903  	BTFSC STATUS,Z
07D7  2FDC  	GOTO	label139
07DC        label139

					//if (tm1638Keys != 0) {
						processKeys();
07D8  2613  	CALL processKey_00028

						tm1638UpdateDisplay();
07D9  221C  	CALL tm1638Upda_00022

					//}
					tm1638KeysOld = tm1638Keys;
07DA  0865  	MOVF gbl_tm1638Keys, W
07DB  00E6  	MOVWF gbl_tm1638KeysOld

				}
                cTask.TASK_TIMER0 = 0;
07DC  10CC  	BCF gbl_cTask,1

            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
// I2C Communications Library for I2C MASTER
////////////////////////////////////////////////////////////////////////////
// Author(s): Andrew Smallridge
// Date 15 November 2004
//
// Copyright(C) 2004-2006 Andrew Smallridge
// Copyright(C) 2004-2010 Pavel Baranov
// Copyright(C) 2004-2010 David Hobday
// Existing constants predefined for i2c hardware driver and i2s software
// emulation for the PIC 18F2xx and 18F4xx processors. For hardware support
// on other PICs the constants must be mapped to the corresponding register
// map of the target device
////////////////////////////////////////////////////////////////////////////

/*
////////////////////////////////////////////////////////////////////////////
//	The following three sections should be copied to the user's program:
//		i2c master hardware / software mode definition
//		i2c software implementation template arguments and variables
// 		i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////
// i2c master hardware / software mode definition
//
// For i2c hardware support comment out the #define use_ic2_SW line
////////////////////////////////////////////////////////////////////////////
//#define use_i2c_SW

#if defined use_i2c_SW
////////////////////////////////////////////////////////////////////////////
// i2c software implementation template arguments and variables
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)

// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and software emalated i2c RAM locations. These constants are
// then used by the templated functions. When changing the address of an emulated
// register the corresponding constant mapping must also be changed.
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3					

#else
////////////////////////////////////////////////////////////////////////////
// i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP |i2c_HW)

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and PIC's i2c register locations. These constants are
// then used by the templated functions. 
#define PORTC		0x0f82
#define TRISC		0x0f94
#define e_SSPCON1	0xfc6
#define e_SSPCON2	0xfc5
#define e_SSPSTAT	0xfc7
#define e_SSPADD	0xfc8
#define e_SSPBUF	0xfc9
#define e_SSPIF_PIR	0xf9e
#define e_BCLIF_PIR	0xfa1
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3

#endif

*/


////////////////////////////////////////////////////////////////////////////
// Define the common i2c template structure
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL	template <unsigned char T_SCL_BIT, unsigned short T_SCL_PORT,	\
					unsigned short T_SCL_TRIS, unsigned char T_SDA_BIT, 			\
					unsigned short T_SDA_PORT, unsigned short T_SDA_TRIS,			\
					unsigned short T_i2c_SSPCON1, unsigned short T_i2c_SSPCON2, 	\
					unsigned short T_i2c_SSPSTAT, unsigned short T_i2c_SSPBUF, 		\
					unsigned char T_i2c_SSPIF_BIT, unsigned short T_i2c_SSPIF_PIR,	\
					unsigned char T_i2c_BCLIF_BIT, unsigned short T_i2c_BCLIF_PIR,	\
					unsigned char T_i2c_SMP_BIT, unsigned short T_i2c_SSPADD, 		\
					unsigned char T_MODE>

////////////////////////////////////////////////////////////////////////////
// Define the common i2c template parameters
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL_ARGS	T_SCL_BIT, T_SCL_PORT, T_SCL_TRIS, T_SDA_BIT, 			\
						T_SDA_PORT, T_SDA_TRIS, T_i2c_SSPCON1, T_i2c_SSPCON2, 	\
						T_i2c_SSPSTAT, T_i2c_SSPBUF, T_i2c_SSPIF_BIT, 			\
						T_i2c_SSPIF_PIR, T_i2c_BCLIF_BIT, T_i2c_BCLIF_PIR,		\
						T_i2c_SMP_BIT, T_i2c_SSPADD, T_MODE

////////////////////////////////////////////////////////////////////////////
// Helpers that hide template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_init	i2c_INIT<i2c_ARGS>
#define i2c_start	i2c_START<i2c_ARGS>
#define i2c_restart	i2c_RESTART<i2c_ARGS>
#define i2c_stop	i2c_STOP<i2c_ARGS>
#define i2c_read	i2c_READ<i2c_ARGS>
#define i2c_write	i2c_WRITE<i2c_ARGS>


////////////////////////////////////////////////////////////////////////////
// I2C Control Status Bits - Emulates the PIC18F hardware I2C implementation
////////////////////////////////////////////////////////////////////////////
// define I2C i2C_SSPCON1 control bits
#define	i2c_WCOL	7
#define	i2c_SSPOV	6
#define	i2c_SSPEN	5
#define	i2c_CKP		4
#define	i2c_SSPM3	3
#define	i2c_SSPM2	2
#define	i2c_SSPM1	1
#define	i2c_SSPM0	0

// define I2C SSPCON2 control bits
#define	i2c_GCEN 	7
#define	i2c_ACKSTAT	6
#define	i2c_ACKDT	5
#define	i2c_ACKEN	4
#define	i2c_RCEN	3
#define	i2c_PEN		2
#define	i2c_RSEN	1
#define	i2c_SEN		0

// define I2C SSPSTAT status bits
#define	i2c_DA		5
#define	i2c_P		4
#define	i2c_S		3
#define	i2c_RW		2
#define	i2c_UA		1
#define	i2c_BF		0


////////////////////////////////////////////////////////////////////////////
// I2C Control Flag Bits
////////////////////////////////////////////////////////////////////////////
// define I2C Mode bits
#define	i2c_HW			0x01
#define	i2c_400KHz		0x02	// 100KHz or 400KHz I2C clock (set = 400KHz)
#define	i2c_reset_wdt	0x04
#define i2c_SMP			0x80	


////////////////////////////////////////////////////////////////////////////
// I2C software constants
////////////////////////////////////////////////////////////////////////////
#define	dly 10	// number of 1us delay increments



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Start Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL 
void i2c_START(void)

{
	// Initiate the I2C START condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	delay_us(dly);
0126  300A  	MOVLW 0x0A
0127  1283  	BCF STATUS, RP0
0128  1303  	BCF STATUS, RP1
0129  00F2  	MOVWF delay_us_00000_arg_del
012A  2010  	CALL delay_us_00000

	l_bclif = 0; // initialise the collision flag for this command
012B  11C6  	BCF i2c_START_00000_1_l_bclif,3

	l_sspif = 0;
012C  11C5  	BCF i2c_START_00000_1_l_sspif,3

		
	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
			
		l_sen = 1; // initiate START condition	

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation			
		l_sen = 1; // initiate START condition
012D  1441  	BSF i2c_START_00000_1_l_sen,0

		l_scl_tris = 1; // ensure the SCL line is high
012E  1683  	BSF STATUS, RP0
012F  1587  	BSF i2c_START_00000_1_l_scl_tris,3

		l_sda_tris = 1; // ensure the SDA line is high	
0130  1607  	BSF i2c_START_00000_1_l_sda_tris,4

		l_scl = 0; // prepare to set SCL line low
0131  1283  	BCF STATUS, RP0
0132  1187  	BCF i2c_START_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low
0133  1207  	BCF i2c_START_00000_1_l_sda,4

		
		if (l_scl && l_sda)
0134  1D87  	BTFSS i2c_START_00000_1_l_scl,3
0135  2953  	GOTO	label24
0136  1E07  	BTFSS i2c_START_00000_1_l_sda,4
0137  2953  	GOTO	label24
0153        label24

		{
			// good sign - no collision detected
			delay_us(dly);
0138  300A  	MOVLW 0x0A
0139  00F2  	MOVWF delay_us_00000_arg_del
013A  2010  	CALL delay_us_00000

			
			if (!l_scl) // ensure the clock is still high
013B  1987  	BTFSC i2c_START_00000_1_l_scl,3
013C  2941  	GOTO	label23
0141        label23

			{
				l_bclif = 1;
013D  15C6  	BSF i2c_START_00000_1_l_bclif,3

				l_s = 1;
013E  15C2  	BSF i2c_START_00000_1_l_s,3

				l_sen = 0;
013F  1041  	BCF i2c_START_00000_1_l_sen,0

				return;
			}
					
			l_sda = 0; // prepare to set SDA line low
0141  1207  	BCF i2c_START_00000_1_l_sda,4

			l_sda_tris = 0; // SDA to output (driven low)
0142  1683  	BSF STATUS, RP0
0143  1207  	BCF i2c_START_00000_1_l_sda_tris,4


			delay_us(dly);					
0144  300A  	MOVLW 0x0A
0145  1283  	BCF STATUS, RP0
0146  00F2  	MOVWF delay_us_00000_arg_del
0147  2010  	CALL delay_us_00000

			l_scl = 0; // prepare to set SCL line low
0148  1187  	BCF i2c_START_00000_1_l_scl,3

			l_scl_tris = 0; // SCL to output (driven low)
0149  1683  	BSF STATUS, RP0
014A  1187  	BCF i2c_START_00000_1_l_scl_tris,3


			delay_us(dly);					
014B  300A  	MOVLW 0x0A
014C  1283  	BCF STATUS, RP0
014D  00F2  	MOVWF delay_us_00000_arg_del
014E  2010  	CALL delay_us_00000

			l_s = 1; // set 'S' bit flag (start bit detected)
014F  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0; // clear flag
0150  1041  	BCF i2c_START_00000_1_l_sen,0

			l_sspif = 1; // flag end of start condition interrupt	
0151  15C5  	BSF i2c_START_00000_1_l_sspif,3

		}
		else
		{
			// here is SDA or SCL are low at the start - indicates a bus collision
			l_bclif = 1;
0153  15C6  	BSF i2c_START_00000_1_l_bclif,3

			l_s = 1; // set 'S' bit flag (start bit detected)
0154  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0;
0155  1041  	BCF i2c_START_00000_1_l_sen,0

			l_rsen = 0;
0156  10C1  	BCF i2c_START_00000_1_l_rsen,1

			l_pen = 0;
0157  1141  	BCF i2c_START_00000_1_l_pen,2

			l_rcen = 0;								
0158  11C1  	BCF i2c_START_00000_1_l_rcen,3

			l_acken = 0;			
0159  1241  	BCF i2c_START_00000_1_l_acken,4

		}
	}
}
0140  0008  	RETURN
0152  0008  	RETURN
015A  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Restart Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_RESTART(void)
{
	// Initiate the I2C RESTART condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
			
	delay_us(dly);
	l_bclif = 0; // initialise the collision flag for this command
	l_sspif = 0;

	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_rsen = 1; // initiate RESTART condition
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation	
		l_rsen = 1;
		l_scl = 0;
		l_sda = 0;
		
		if (!l_scl)
		{
			// good sign - no other I2C activity in progress
			l_sda_tris = 1; // float SDA line high	(should already be in this condition)	
			delay_us(dly);
		
			// about to float the clock line
			// ensure the data line is still high
			if (!l_sda)
			{
				// problem - SDA is low, a bus collision has occurred				
				l_bclif = 1; // set the bus collision flag	
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_scl_tris = 1; // float SCL line (high)	
				return;
			}
												
			l_scl_tris = 1; // float SCL line (high)

			// wait until any clock stretching has finished
			while (!l_scl)
				if (T_MODE & i2c_reset_wdt)
					clear_wdt();	
			delay_us(dly);
			
			// here we are about to drive SDA low
			// first ensure SCL is still high
			if (!l_scl)
			{
				// problem - SCL is low, a bus collision has occurred
				l_bclif = 1; // set the bus collision flag
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_sda_tris = 1; // float SDA line (high)
				return;
			}
				
			l_sda_tris = 0; // drive SDA low
			l_s = 1; // set 'S' bit flag (start bit detected)

			delay_us(dly);
			l_scl_tris = 0; // drive SCL low
			l_rsen = 0;
			l_pen = 0;
			l_sen = 0;			
			l_rcen = 0;								
			l_acken = 0;			
			l_sspif = 1; // flag end of start condition interrupt
		}
		else
		{
			// SCL is high at the start
			// some other I2C activity in progress		
			l_rsen = 0; // clear flag
			// exit without further action
		}
	}
}



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Stop Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_STOP(void)

{ 
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_p@T_i2c_SSPSTAT.i2c_P; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;

	l_bclif = 0; // initialise the collision flag for this command
00F6  1283  	BCF STATUS, RP0
00F7  1303  	BCF STATUS, RP1
00F8  11C6  	BCF i2c_STOP_00000_1_l_bclif,3

	l_sspif = 0;
00F9  11C5  	BCF i2c_STOP_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_pen = 1; // initiate STOP condition on the I2C bus	
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
		
	}
	else
	{
		//	Software I2C implementation
		l_pen = 1; // initiate STOP condition on the I2C bus
00FA  1541  	BSF i2c_STOP_00000_1_l_pen,2

		delay_us(dly);
00FB  300A  	MOVLW 0x0A
00FC  00F2  	MOVWF delay_us_00000_arg_del
00FD  2010  	CALL delay_us_00000

		
		l_scl = 0; // prepare to set SCL line low
00FE  1187  	BCF i2c_STOP_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low
00FF  1207  	BCF i2c_STOP_00000_1_l_sda,4

		l_scl_tris = 0; // drive SCL line low (should already be low)
0100  1683  	BSF STATUS, RP0
0101  1187  	BCF i2c_STOP_00000_1_l_scl_tris,3

		l_sda_tris = 0; // drive SDA line low
0102  1207  	BCF i2c_STOP_00000_1_l_sda_tris,4


		delay_us(dly);		
0103  300A  	MOVLW 0x0A
0104  1283  	BCF STATUS, RP0
0105  00F2  	MOVWF delay_us_00000_arg_del
0106  2010  	CALL delay_us_00000

		l_scl_tris = 1; // float SCL line (high)
0107  1683  	BSF STATUS, RP0
0108  1587  	BSF i2c_STOP_00000_1_l_scl_tris,3

		
		// wait until any clock stretching has finished
		while (!l_scl)
0109        label19
0109  1283  	BCF STATUS, RP0
010A  1987  	BTFSC i2c_STOP_00000_1_l_scl,3
010B  290E  	GOTO	label20
010D  2909  	GOTO	label19
010E        label20

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
010C  0064  	CLRWDT

						
		delay_us(dly);
010E  300A  	MOVLW 0x0A
010F  00F2  	MOVWF delay_us_00000_arg_del
0110  2010  	CALL delay_us_00000

		l_sda_tris = 1; // float SDA line
0111  1683  	BSF STATUS, RP0
0112  1607  	BSF i2c_STOP_00000_1_l_sda_tris,4

		delay_us(dly);		
0113  300A  	MOVLW 0x0A
0114  1283  	BCF STATUS, RP0
0115  00F2  	MOVWF delay_us_00000_arg_del
0116  2010  	CALL delay_us_00000

		
		// here the SDA line should be high - if not a collision has occurred				
		if (!l_sda || !l_scl)
0117  1E07  	BTFSS i2c_STOP_00000_1_l_sda,4
0118  291B  	GOTO	label21
0119  1987  	BTFSC i2c_STOP_00000_1_l_scl,3
011A  291F  	GOTO	label22
011B        label21
011F        label22

		{
			// problem - SDA or SCL is low, a bus collision has occurred
			l_bclif = 1; // set the bus collision flag	
011B  15C6  	BSF i2c_STOP_00000_1_l_bclif,3

			l_s = 0; // clear 'S' bit flag
011C  11C2  	BCF i2c_STOP_00000_1_l_s,3

			l_pen = 0; // clear flag
011D  1141  	BCF i2c_STOP_00000_1_l_pen,2

		}
		else
		{		
			l_p = 1;
011F  1642  	BSF i2c_STOP_00000_1_l_p,4

			l_pen = 0;
0120  1141  	BCF i2c_STOP_00000_1_l_pen,2

			l_sen = 0;
0121  1041  	BCF i2c_STOP_00000_1_l_sen,0

			l_rsen = 0;			
0122  10C1  	BCF i2c_STOP_00000_1_l_rsen,1

			l_rcen = 0;								
0123  11C1  	BCF i2c_STOP_00000_1_l_rcen,3

			l_acken = 0;
0124  1241  	BCF i2c_STOP_00000_1_l_acken,4

		}
	}
}
011E  0008  	RETURN
0125  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Write Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_WRITE(unsigned char i2c_data)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;	
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
	
	char BitMask;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
00A5  11C6  	BCF i2c_WRITE_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
00A6  11C5  	BCF i2c_WRITE_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
				
		l_wcol = 0; // clear write collision flag	
		i2c_SSPBUF = i2c_data;

		// test if a write collision occurred
		if (l_wcol)
			return (1); // error exit	

		// wait until MSSP Tx register is empty
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
								
		return (0); // successful exit
	}

	// here for i2c software driver
	l_wcol = 0; // clear write collision flag	
00A7  13C0  	BCF i2c_WRITE_00000_1_l_wcol,7

	i2c_SSPBUF = i2c_data;
00A8  086F  	MOVF i2c_WRITE_00000_arg_i2c_data, W
00A9  00C4  	MOVWF i2c_WRITE_00000_1_i2c_SSPBUF

	
	l_scl = 0; // prepare to set SCL line low
00AA  1187  	BCF i2c_WRITE_00000_1_l_scl,3

	l_sda = 0; // prepare to set SDA line low
00AB  1207  	BCF i2c_WRITE_00000_1_l_sda,4

	l_rw = 0; // signal we are doing a write
00AC  1142  	BCF i2c_WRITE_00000_1_l_rw,2


	for (BitMask = 0x80; BitMask; BitMask>>=1)
00AD  3080  	MOVLW 0x80
00AE  00F0  	MOVWF i2c_WRITE_00000_1_BitMask
00AF        label11
00AF  08F0  	MOVF i2c_WRITE_00000_1_BitMask, F
00B0  1903  	BTFSC STATUS,Z
00B1  28D2  	GOTO	label16
00CF  1003  	BCF STATUS,C
00D0  0CF0  	RRF i2c_WRITE_00000_1_BitMask, F
00D1  28AF  	GOTO	label11
00D2        label16

	{
		if (i2c_data & BitMask)
00B2  0870  	MOVF i2c_WRITE_00000_1_BitMask, W
00B3  056F  	ANDWF i2c_WRITE_00000_arg_i2c_data, W
00B4  1903  	BTFSC STATUS,Z
00B5  28B9  	GOTO	label12
00B9        label12

			l_sda_tris = 1; // float SDA high	
00B6  1683  	BSF STATUS, RP0
00B7  1607  	BSF i2c_WRITE_00000_1_l_sda_tris,4

		else
00B8  28BB  	GOTO	label13
00BB        label13

			l_sda_tris = 0; // drive SDA low
00B9  1683  	BSF STATUS, RP0
00BA  1207  	BCF i2c_WRITE_00000_1_l_sda_tris,4

		delay_us(dly);
00BB  300A  	MOVLW 0x0A
00BC  1283  	BCF STATUS, RP0
00BD  00F2  	MOVWF delay_us_00000_arg_del
00BE  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
00BF  1683  	BSF STATUS, RP0
00C0  1587  	BSF i2c_WRITE_00000_1_l_scl_tris,3


		// wait until any clock stretching has finished
		while (!l_scl)
00C1        label14
00C1  1283  	BCF STATUS, RP0
00C2  1987  	BTFSC i2c_WRITE_00000_1_l_scl,3
00C3  28C6  	GOTO	label15
00C5  28C1  	GOTO	label14
00C6        label15

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
00C4  0064  	CLRWDT

		delay_us(dly);
00C6  300A  	MOVLW 0x0A
00C7  00F2  	MOVWF delay_us_00000_arg_del
00C8  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low	
00C9  1683  	BSF STATUS, RP0
00CA  1187  	BCF i2c_WRITE_00000_1_l_scl_tris,3

		delay_us(dly);
00CB  300A  	MOVLW 0x0A
00CC  1283  	BCF STATUS, RP0
00CD  00F2  	MOVWF delay_us_00000_arg_del
00CE  2010  	CALL delay_us_00000

	}
	// serialized out the data
	// now get the status		
	// set SSPIF
	l_sspif = 1;
00D2  15C5  	BSF i2c_WRITE_00000_1_l_sspif,3

	l_acken = 1;
00D3  1641  	BSF i2c_WRITE_00000_1_l_acken,4

	l_ackdt = 0;
00D4  12C1  	BCF i2c_WRITE_00000_1_l_ackdt,5

	l_sda_tris = 1; // float SDA high
00D5  1683  	BSF STATUS, RP0
00D6  1607  	BSF i2c_WRITE_00000_1_l_sda_tris,4

	
	delay_us(dly);
00D7  300A  	MOVLW 0x0A
00D8  1283  	BCF STATUS, RP0
00D9  00F2  	MOVWF delay_us_00000_arg_del
00DA  2010  	CALL delay_us_00000

	
	l_scl_tris = 1; // float SCL high
00DB  1683  	BSF STATUS, RP0
00DC  1587  	BSF i2c_WRITE_00000_1_l_scl_tris,3

	
	// wait until any clock stretching has finished
	while (!l_scl)
00DD        label17
00DD  1283  	BCF STATUS, RP0
00DE  1987  	BTFSC i2c_WRITE_00000_1_l_scl,3
00DF  28E2  	GOTO	label18
00E1  28DD  	GOTO	label17
00E2        label18

		if (T_MODE & i2c_reset_wdt)
			clear_wdt();	
00E0  0064  	CLRWDT

	delay_us(dly);
00E2  300A  	MOVLW 0x0A
00E3  00F2  	MOVWF delay_us_00000_arg_del
00E4  2010  	CALL delay_us_00000


	// get the status bit
	local_ack = l_sda;
00E5  1071  	BCF i2c_WRITE_00000_1_local_ack,0
00E6  1A07  	BTFSC i2c_WRITE_00000_1_l_sda,4
00E7  1471  	BSF i2c_WRITE_00000_1_local_ack,0

	delay_us(dly);
00E8  300A  	MOVLW 0x0A
00E9  00F2  	MOVWF delay_us_00000_arg_del
00EA  2010  	CALL delay_us_00000


	l_scl_tris = 0; // drive SCL low	
00EB  1683  	BSF STATUS, RP0
00EC  1187  	BCF i2c_WRITE_00000_1_l_scl_tris,3

	l_acken = 0;
00ED  1283  	BCF STATUS, RP0
00EE  1241  	BCF i2c_WRITE_00000_1_l_acken,4

	delay_us(dly);
00EF  300A  	MOVLW 0x0A
00F0  00F2  	MOVWF delay_us_00000_arg_del
00F1  2010  	CALL delay_us_00000

	return(local_ack);
00F2  01F2  	CLRF CompTempVarRet552
00F3  1871  	BTFSC i2c_WRITE_00000_1_local_ack,0
00F4  0AF2  	INCF CompTempVarRet552, F

}
00F5  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Read Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_READ(char ack_status)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	char BitMask;
	char i2c_data;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
018A  11C6  	BCF i2c_READ_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
018B  11C5  	BCF i2c_READ_00000_1_l_sspif,3

	l_wcol = 0; // clear write collision flag	
018C  13C0  	BCF i2c_READ_00000_1_l_wcol,7


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// enable master for 1 byte reception	
		l_rcen = 1;

		// wait until byte received
		while(!l_sspif || !l_bf)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// read the byte from the Rx register
		i2c_data = i2c_SSPBUF;			
			
		// wait until the bus is idle		
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		if (ack_status)
			l_ackdt = 1; // preset ack bit
		else
			l_ackdt = 0; // preset ack bit

		l_sspif = 0;
		l_acken = 1; // acknowledge sequence enable

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();								
	}
	else
	{
		// here for i2c software driver
		l_rcen = 1;
018D  15C1  	BSF i2c_READ_00000_1_l_rcen,3

		l_ackdt = ack_status;
018E  186F  	BTFSC i2c_READ_00000_arg_ack_status,0
018F  16C1  	BSF i2c_READ_00000_1_l_ackdt,5
0190  1C6F  	BTFSS i2c_READ_00000_arg_ack_status,0
0191  12C1  	BCF i2c_READ_00000_1_l_ackdt,5

		l_rw = 1;
0192  1542  	BSF i2c_READ_00000_1_l_rw,2

		l_scl = 0; // prepare to set SCL line low
0193  1187  	BCF i2c_READ_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low	
0194  1207  	BCF i2c_READ_00000_1_l_sda,4


		// prepare to serialize in the byte
		l_sda_tris = 1; // float SDA
0195  1683  	BSF STATUS, RP0
0196  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

		delay_us(dly);
0197  300A  	MOVLW 0x0A
0198  1283  	BCF STATUS, RP0
0199  00F2  	MOVWF delay_us_00000_arg_del
019A  2010  	CALL delay_us_00000

		i2c_data = 0;
019B  01F1  	CLRF i2c_READ_00000_1_i2c_data

		for (BitMask = 0x80; BitMask; BitMask>>=1)
019C  3080  	MOVLW 0x80
019D  00F0  	MOVWF i2c_READ_00000_1_BitMask
019E        label28
019E  08F0  	MOVF i2c_READ_00000_1_BitMask, F
019F  1903  	BTFSC STATUS,Z
01A0  29BB  	GOTO	label32
01B8  1003  	BCF STATUS,C
01B9  0CF0  	RRF i2c_READ_00000_1_BitMask, F
01BA  299E  	GOTO	label28
01BB        label32

		{
			l_scl_tris = 1; // float SCL high
01A1  1683  	BSF STATUS, RP0
01A2  1587  	BSF i2c_READ_00000_1_l_scl_tris,3

			// wait until any clock stretching has finished
			while (!l_scl)
01A3        label29
01A3  1283  	BCF STATUS, RP0
01A4  1987  	BTFSC i2c_READ_00000_1_l_scl,3
01A5  29A8  	GOTO	label30
01A7  29A3  	GOTO	label29
01A8        label30

				if (T_MODE & i2c_reset_wdt)
					clear_wdt();		
01A6  0064  	CLRWDT

			delay_us(dly);
01A8  300A  	MOVLW 0x0A
01A9  00F2  	MOVWF delay_us_00000_arg_del
01AA  2010  	CALL delay_us_00000


			// read the current bit
			l_sda_tris = 1; // float SDA
01AB  1683  	BSF STATUS, RP0
01AC  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

			if (l_sda)
01AD  1283  	BCF STATUS, RP0
01AE  1E07  	BTFSS i2c_READ_00000_1_l_sda,4
01AF  29B2  	GOTO	label31
01B2        label31

				i2c_data |= BitMask;
01B0  0870  	MOVF i2c_READ_00000_1_BitMask, W
01B1  04F1  	IORWF i2c_READ_00000_1_i2c_data, F

			l_scl_tris = 0; // drive SCL low
01B2  1683  	BSF STATUS, RP0
01B3  1187  	BCF i2c_READ_00000_1_l_scl_tris,3

			delay_us(dly);
01B4  300A  	MOVLW 0x0A
01B5  1283  	BCF STATUS, RP0
01B6  00F2  	MOVWF delay_us_00000_arg_del
01B7  2010  	CALL delay_us_00000

		}
		// flag receive complete			
		l_sspif = 1;
01BB  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		l_rcen = 0;
01BC  11C1  	BCF i2c_READ_00000_1_l_rcen,3

		
		// set the ACK state
		if (ack_status)	
01BD  08EF  	MOVF i2c_READ_00000_arg_ack_status, F
01BE  1903  	BTFSC STATUS,Z
01BF  29C3  	GOTO	label33
01C3        label33

			l_sda_tris = 1; // float SDA high
01C0  1683  	BSF STATUS, RP0
01C1  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

		else
01C2  29C5  	GOTO	label34
01C5        label34

			l_sda_tris = 0; // drive SDA low
01C3  1683  	BSF STATUS, RP0
01C4  1207  	BCF i2c_READ_00000_1_l_sda_tris,4

		delay_us(dly);
01C5  300A  	MOVLW 0x0A
01C6  1283  	BCF STATUS, RP0
01C7  00F2  	MOVWF delay_us_00000_arg_del
01C8  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
01C9  1683  	BSF STATUS, RP0
01CA  1587  	BSF i2c_READ_00000_1_l_scl_tris,3


		// wait until any clock stretching has finished
		while (!l_scl)
01CB        label35
01CB  1283  	BCF STATUS, RP0
01CC  1987  	BTFSC i2c_READ_00000_1_l_scl,3
01CD  29D0  	GOTO	label36
01CF  29CB  	GOTO	label35
01D0        label36

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
01CE  0064  	CLRWDT

	
		l_sspif = 0; // clear SSPIF
01D0  11C5  	BCF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
01D1  300A  	MOVLW 0x0A
01D2  00F2  	MOVWF delay_us_00000_arg_del
01D3  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low		
01D4  1683  	BSF STATUS, RP0
01D5  1187  	BCF i2c_READ_00000_1_l_scl_tris,3

		l_sspif = 1;
01D6  1283  	BCF STATUS, RP0
01D7  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
01D8  300A  	MOVLW 0x0A
01D9  00F2  	MOVWF delay_us_00000_arg_del
01DA  2010  	CALL delay_us_00000

	}
	return(i2c_data);
01DB  0871  	MOVF i2c_READ_00000_1_i2c_data, W
01DC  00F2  	MOVWF CompTempVarRet553

}
01DD  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Initialization
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_INIT(unsigned char i2c_divisor)

{
	volatile unsigned char i2c_SSPADD@T_i2c_SSPADD, i2c_SSPSTAT@T_i2c_SSPSTAT;
	volatile unsigned char i2c_SSPCON1@T_i2c_SSPCON1,i2c_SSPCON2@T_i2c_SSPCON2;

	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_sspen@T_i2c_SSPCON1.i2c_SSPEN, l_smp@T_i2c_SSPSTAT.T_i2c_SMP_BIT;

	l_sda_tris = 1;
03D0  1683  	BSF STATUS, RP0
03D1  1607  	BSF i2c_INIT_00000_1_l_sda_tris,4

	l_scl_tris = 1;
03D2  1587  	BSF i2c_INIT_00000_1_l_scl_tris,3

	
	i2c_SSPCON1 = 0x00; // initialise the I2C control register (mirrors HW SSPCON1)	
03D3  1283  	BCF STATUS, RP0
03D4  01C0  	CLRF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPADD = i2c_divisor; // get the I2C baud rate divisor
03D5  086D  	MOVF i2c_INIT_00000_arg_i2c_divisor, W
03D6  00C3  	MOVWF i2c_INIT_00000_1_i2c_SSPADD

	i2c_SSPCON1 = 0x08; // initialise the I2C control register (mirrors HW SSPCON1)	
03D7  3008  	MOVLW 0x08
03D8  00C0  	MOVWF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPCON2 = 0x00; // initialise the I2C control register (mirrors HW SSPCON2)	
03D9  01C1  	CLRF i2c_INIT_00000_1_i2c_SSPCON2

	
	i2c_SSPSTAT = 0x00; // initialise the I2C status register (mirrors HW SSPSTAT)
03DA  01C2  	CLRF i2c_INIT_00000_1_i2c_SSPSTAT

	
	if (T_MODE & i2c_SMP)
		l_smp = 1;
03DB  17C2  	BSF i2c_INIT_00000_1_l_smp,7


	l_sspif = 0; // initialise the I2C SSP interrupt status
03DC  11C5  	BCF i2c_INIT_00000_1_l_sspif,3

	l_bclif = 0; // initialise the I2C BCL interrupt status
03DD  11C6  	BCF i2c_INIT_00000_1_l_bclif,3

	l_sda = 0;
03DE  1207  	BCF i2c_INIT_00000_1_l_sda,4

	l_scl = 0;
03DF  1187  	BCF i2c_INIT_00000_1_l_scl,3

	l_sspen = 1; // enable I2C
03E0  16C0  	BSF i2c_INIT_00000_1_l_sspen,5

	
	i2c_STOP<_I2C_TEMPL_ARGS>();
03E1  20F6  	CALL i2c_STOP_00000

}
03E2  0008  	RETURN







////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  2FDE  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B0  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00B1  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00B2  	MOVWF Int1BContext+D'2'
000D  158A  	BSF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2840  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010  3003  	MOVLW 0x03
0011  07F2  	ADDWF delay_us_00000_arg_del, F
0012  0CF2  	RRF delay_us_00000_arg_del, F
0013  0CF2  	RRF delay_us_00000_arg_del, F
0014  307F  	MOVLW 0x7F
0015  05F2  	ANDWF delay_us_00000_arg_del, F
0016        label1
0016  0000  	NOP
0017  0BF2  	DECFSZ delay_us_00000_arg_del, F
0018  2816  	GOTO	label1
0019  0008  	RETURN
001A        ; } delay_us function end

001A        __rom_get_00000
001A        ; { __rom_get ; function begin
001A  0874  	MOVF __rom_get_00000_arg_objNumb, W
001B  00F7  	MOVWF __rom_get_00000_1_romAddr+D'1'
001C  01F6  	CLRF __rom_get_00000_1_romAddr
001D  1003  	BCF STATUS,C
001E  0DF7  	RLF __rom_get_00000_1_romAddr+D'1', F
001F  0DF6  	RLF __rom_get_00000_1_romAddr, F
0020  0DF7  	RLF __rom_get_00000_1_romAddr+D'1', F
0021  0DF6  	RLF __rom_get_00000_1_romAddr, F
0022  07F7  	ADDWF __rom_get_00000_1_romAddr+D'1', F
0023  1803  	BTFSC STATUS,C
0024  0AF6  	INCF __rom_get_00000_1_romAddr, F
0025  07F7  	ADDWF __rom_get_00000_1_romAddr+D'1', F
0026  1803  	BTFSC STATUS,C
0027  0AF6  	INCF __rom_get_00000_1_romAddr, F
0028  3033  	MOVLW	LOW( label2 )
0029  07F7  	ADDWF __rom_get_00000_1_romAddr+D'1', F
002A  1803  	BTFSC STATUS,C
002B  0AF6  	INCF __rom_get_00000_1_romAddr, F
002C  3000  	MOVLW	HIGH( label2 )
002D  0776  	ADDWF __rom_get_00000_1_romAddr, W
002E  008A  	MOVWF PCLATH
002F  0875  	MOVF __rom_get_00000_arg_idx, W
0030  00F6  	MOVWF __rom_get_00000_1_romAddr
0031  0877  	MOVF __rom_get_00000_1_romAddr+D'1', W
0032  0082  	MOVWF PCL
0033        label2
0033  3000  	MOVLW	HIGH( label3 )
0034  008A  	MOVWF PCLATH
0035  3000  	MOVLW	HIGH( label4 )
0036  00F7  	MOVWF __rom_get_00000_1_romAddr+D'1'
0037  3049  	MOVLW	LOW( label4 )
0038  2842  	GOTO	label3
0039  3000  	MOVLW	HIGH( label3 )
003A  008A  	MOVWF PCLATH
003B  3000  	MOVLW	HIGH( label5 )
003C  00F7  	MOVWF __rom_get_00000_1_romAddr+D'1'
003D  3055  	MOVLW	LOW( label5 )
003E  2842  	GOTO	label3
003F  3000  	MOVLW	HIGH( label6 )
0040  00F7  	MOVWF __rom_get_00000_1_romAddr+D'1'
0041  306D  	MOVLW	LOW( label6 )
0042        label3
0042  07F6  	ADDWF __rom_get_00000_1_romAddr, F
0043  1803  	BTFSC STATUS,C
0044  0AF7  	INCF __rom_get_00000_1_romAddr+D'1', F
0045  0877  	MOVF __rom_get_00000_1_romAddr+D'1', W
0046  008A  	MOVWF PCLATH
0047  0876  	MOVF __rom_get_00000_1_romAddr, W
0048  0082  	MOVWF PCL
0049        label4
0049  3431  	RETLW 0x31
004A  3428  	RETLW 0x28
004B  3431  	RETLW 0x31
004C  3430  	RETLW 0x30
004D  3431  	RETLW 0x31
004E  3430  	RETLW 0x30
004F  3431  	RETLW 0x31
0050  3431  	RETLW 0x31
0051  3430  	RETLW 0x30
0052  3431  	RETLW 0x31
0053  3430  	RETLW 0x30
0054  3431  	RETLW 0x31
0055        label5
0055  3404  	RETLW 0x04
0056  3408  	RETLW 0x08
0057  3412  	RETLW 0x12
0058  3416  	RETLW 0x16
0059  3420  	RETLW 0x20
005A  3424  	RETLW 0x24
005B  3428  	RETLW 0x28
005C  3432  	RETLW 0x32
005D  3436  	RETLW 0x36
005E  3440  	RETLW 0x40
005F  3444  	RETLW 0x44
0060  3448  	RETLW 0x48
0061  3452  	RETLW 0x52
0062  3456  	RETLW 0x56
0063  3460  	RETLW 0x60
0064  3464  	RETLW 0x64
0065  3468  	RETLW 0x68
0066  3472  	RETLW 0x72
0067  3476  	RETLW 0x76
0068  3480  	RETLW 0x80
0069  3484  	RETLW 0x84
006A  3488  	RETLW 0x88
006B  3492  	RETLW 0x92
006C  3496  	RETLW 0x96
006D        label6
006D  343F  	RETLW 0x3F
006E  3406  	RETLW 0x06
006F  345B  	RETLW 0x5B
0070  344F  	RETLW 0x4F
0071  3466  	RETLW 0x66
0072  346D  	RETLW 0x6D
0073  347D  	RETLW 0x7D
0074  3407  	RETLW 0x07
0075  347F  	RETLW 0x7F
0076  346F  	RETLW 0x6F
0077        ; } __rom_get function end

0077        delay_10us_00000
0077        ; { delay_10us ; function begin
0077        label7
0077  0000  	NOP
0078  0000  	NOP
0079  0000  	NOP
007A  0000  	NOP
007B  0000  	NOP
007C  0000  	NOP
007D  0000  	NOP
007E  0BF2  	DECFSZ delay_10us_00000_arg_del, F
007F  2877  	GOTO	label7
0080  0008  	RETURN
0081        ; } delay_10us function end

0081        delay_ms_00000
0081        ; { delay_ms ; function begin
0081  08EC  	MOVF delay_ms_00000_arg_del, F
0082  1D03  	BTFSS STATUS,Z
0083  2885  	GOTO	label8
0084  0008  	RETURN
0085        label8
0085  30F9  	MOVLW 0xF9
0086        label9
0086  3EFF  	ADDLW 0xFF
0087  1D03  	BTFSS STATUS,Z
0088  2886  	GOTO	label9
0089  0000  	NOP
008A  0BEC  	DECFSZ delay_ms_00000_arg_del, F
008B  2885  	GOTO	label8
008C  0008  	RETURN
008D        ; } delay_ms function end





















05B1        __mul_16s__0000F
05B1        ; { __mul_16s_16s__16 ; function begin
05B1  01F7  	CLRF __mul_16s__0000F_1_i
05B2  01FA  	CLRF CompTempVarRet389
05B3  01FB  	CLRF CompTempVarRet389+D'1'
05B4  0873  	MOVF __mul_16s__0000F_arg_a, W
05B5  00F8  	MOVWF __mul_16s__0000F_1_t
05B6  0874  	MOVF __mul_16s__0000F_arg_a+D'1', W
05B7  00F9  	MOVWF __mul_16s__0000F_1_t+D'1'
05B8  1FF6  	BTFSS __mul_16s__0000F_arg_b+D'1',7
05B9  2DC0  	GOTO	label103
05BA  17F7  	BSF __mul_16s__0000F_1_i,7
05BB  09F5  	COMF __mul_16s__0000F_arg_b, F
05BC  09F6  	COMF __mul_16s__0000F_arg_b+D'1', F
05BD  0AF5  	INCF __mul_16s__0000F_arg_b, F
05BE  1903  	BTFSC gbl_status,2
05BF  0AF6  	INCF __mul_16s__0000F_arg_b+D'1', F
05C0        label103
05C0  1A77  	BTFSC __mul_16s__0000F_1_i,4
05C1  2DD2  	GOTO	label105
05C2  1C75  	BTFSS __mul_16s__0000F_arg_b,0
05C3  2DCA  	GOTO	label104
05C4  0878  	MOVF __mul_16s__0000F_1_t, W
05C5  07FA  	ADDWF CompTempVarRet389, F
05C6  0879  	MOVF __mul_16s__0000F_1_t+D'1', W
05C7  1803  	BTFSC gbl_status,0
05C8  0F79  	INCFSZ __mul_16s__0000F_1_t+D'1', W
05C9  07FB  	ADDWF CompTempVarRet389+D'1', F
05CA        label104
05CA  1003  	BCF gbl_status,0
05CB  0CF6  	RRF __mul_16s__0000F_arg_b+D'1', F
05CC  0CF5  	RRF __mul_16s__0000F_arg_b, F
05CD  1003  	BCF gbl_status,0
05CE  0DF8  	RLF __mul_16s__0000F_1_t, F
05CF  0DF9  	RLF __mul_16s__0000F_1_t+D'1', F
05D0  0AF7  	INCF __mul_16s__0000F_1_i, F
05D1  2DC0  	GOTO	label103
05D2        label105
05D2  1FF7  	BTFSS __mul_16s__0000F_1_i,7
05D3  0008  	RETURN
05D4  09FA  	COMF CompTempVarRet389, F
05D5  09FB  	COMF CompTempVarRet389+D'1', F
05D6  0AFA  	INCF CompTempVarRet389, F
05D7  1903  	BTFSC gbl_status,2
05D8  0AFB  	INCF CompTempVarRet389+D'1', F
05D9  0008  	RETURN
05DA        ; } __mul_16s_16s__16 function end























07DE        _startup

083D  118A  	BCF PCLATH,3
083E  120A  	BCF PCLATH,4
083F  2F71  	GOTO	main

2007  3FB1  	DW 0x3FB1
