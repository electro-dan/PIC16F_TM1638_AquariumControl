;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 8.01
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

#ifndef _PIC16F_TM1638_AquariumControl_H_
#define _PIC16F_TM1638_AquariumControl_H_

#define TASK_TIMER0 1
#define TASK_TIMER1 2

#define oneWireBus (portc.5)
#define oneWireTris (trisc.5)
#define tm1638dio (portb.1)
#define tm1638dioTris (trisb.1)
#define tm1638clk (portb.2)
#define tm1638strobe (portb.3)
#define WHITE_LED (portc.1)
#define BLUE_LED (portc.2)
#define FAN (porta.1)
#define HEATER (porta.0)

// Timer 0 preload

#define TMR0PRELOAD 61
// This means timer 1 will overflow when 1 cycle completes, generating the interrupt
#define TMR1HV 0xFF
#define TMR1LV 0xFF

// i2c options
#define use_i2c_SW
// clock SCL on RA3, data SDA on RA4
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)
// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3

#define ds3231Addr 0xD0 // Left shifted 7 bit address 0x68
#define at24c32Addr 0xAE // Left shifted 7 bit address 0x57

// Time and date variables
char gBcdSecond = 0; // 0 to 0x59
09A5  1283  	BCF STATUS, RP0
09A6  1303  	BCF STATUS, RP1
09A7  01B5  	CLRF gbl_gBcdSecond

char gBcdMinute = 0; // 0 to 0x59
09A8  01B6  	CLRF gbl_gBcdMinute

char gBcdHour = 0; // 0 to 0x23 or 1 to 0x12. Also contains 12/24 setting at bit 6. If 12 hour, AM/PM uses bit 5
09A9  01B7  	CLRF gbl_gBcdHour

char gDayOfWeek = 1; // 1 to 7
09AA  3001  	MOVLW 0x01
09AB  00B8  	MOVWF gbl_gDayOfWeek

char gBcdDayOfMonth = 1; // 1 to 0x31
09AC  3001  	MOVLW 0x01
09AD  00B9  	MOVWF gbl_gBcdDayOfMonth

char gBcdMonth = 1; // 1 to 0x12 + century at bit 7
09AE  3001  	MOVLW 0x01
09AF  00BA  	MOVWF gbl_gBcdMonth

char gBcdYear = 0x23; // Init to 0x23
09B0  3023  	MOVLW 0x23
09B1  00BB  	MOVWF gbl_gBcdYear

rom char *gDaysInMonth = {0x31, 0x28, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31}; // Days in each month
09B2  3000  	MOVLW 0x00
09B3  00BC  	MOVWF gbl_gDaysInMonth

rom char *gLeapYears = {0x04, 0x08, 0x12, 0x16, 0x20, 0x24, 0x28, 0x32, 0x36, 0x40, 0x44, 0x48, 0x52, 0x56, 0x60, 0x64, 0x68, 0x72, 0x76, 0x80, 0x84, 0x88, 0x92, 0x96}; // List of leap years
09B4  3001  	MOVLW 0x01
09B5  00BD  	MOVWF gbl_gLeapYears


// Timer variables
char iTimer0Counts = 0;
09B6  01BE  	CLRF gbl_iTimer0Counts

char iFlashDigitOff = 0;
09B7  01BF  	CLRF gbl_iFlashDigitOff

char iDigitToFlash = 8; // 8 = no digit to flash
09B8  3008  	MOVLW 0x08
09B9  00C8  	MOVWF gbl_iDigitToFlash


// Hold the upper and lower bytes from the ds18b20
char cTempH = 1;
09BA  3001  	MOVLW 0x01
09BB  00C9  	MOVWF gbl_cTempH

char cTempL = 70;
09BC  3046  	MOVLW 0x46
09BD  00CA  	MOVWF gbl_cTempL

//char iDecimalPosition = 2;

int giDS3231ValueBCD = 0x0000;
09BE  01B3  	CLRF gbl_giDS3231ValueBCD
09BF  01B4  	CLRF gbl_giDS3231ValueBCD+D'1'

char giDS3231ValueTruncCBCD = 0x00;
09C0  01CB  	CLRF gbl_giDS3231ValueTruncCBCD

char gbDS3231IsMinus = 0;
09C1  01CC  	CLRF gbl_gbDS3231IsMinus


char cTask = 0; // Used for task scheduler
09C2  01CD  	CLRF gbl_cTask


// States
bool gbWhiteOn = 0;
09C3  104E  	BCF gbl_gbWhiteOn,0

bool gbBlueOn = 0;
09C4  10CE  	BCF gbl_gbBlueOn,1

bool gbFanOn = 0;
09C5  114E  	BCF gbl_gbFanOn,2

bool gbHeaterOn = 0;
09C6  11CE  	BCF gbl_gbHeaterOn,3

bool gbFlashOff = 0;
09C7  124E  	BCF gbl_gbFlashOff,4

char gcDisplayMode = 0;
09C8  01CF  	CLRF gbl_gcDisplayMode

char gcSetMode = 0;
09C9  01D0  	CLRF gbl_gcSetMode

char gcHourMode = 0;
09CA  01D1  	CLRF gbl_gcHourMode

char gcTriggerMode = 0;
09CB  01D2  	CLRF gbl_gcTriggerMode


// Triggers
char gBcdWhiteOnMinute = 0; // 0 to 59
09CC  01D3  	CLRF gbl_gBcdWhiteOnMinute

char gBcdWhiteOnHour = 0; // 0 to 23
09CD  01D4  	CLRF gbl_gBcdWhiteOnHour

char gBcdWhiteOffMinute = 0; // 0 to 59
09CE  01D5  	CLRF gbl_gBcdWhiteOffMinute

char gBcdWhiteOffHour = 0; // 0 to 23
09CF  01D6  	CLRF gbl_gBcdWhiteOffHour


char gBcdBlueOnMinute = 0; // 0 to 59
09D0  01D7  	CLRF gbl_gBcdBlueOnMinute

char gBcdBlueOnHour = 0; // 0 to 23
09D1  01D8  	CLRF gbl_gBcdBlueOnHour

char gBcdBlueOffMinute = 0; // 0 to 59
09D2  01D9  	CLRF gbl_gBcdBlueOffMinute

char gBcdBlueOffHour = 0; // 0 to 23
09D3  01DA  	CLRF gbl_gBcdBlueOffHour


char gBcdBlue2OnMinute = 0; // 0 to 59
09D4  01DB  	CLRF gbl_gBcdBlue2OnMinute

char gBcdBlue2OnHour = 0; // 0 to 23
09D5  01DC  	CLRF gbl_gBcdBlue2OnHour

char gBcdBlue2OffMinute = 0; // 0 to 59
09D6  01DD  	CLRF gbl_gBcdBlue2OffMinute

char gBcdBlue2OffHour = 0; // 0 to 23
09D7  01DE  	CLRF gbl_gBcdBlue2OffHour


char gBcdFanOnTemp = 0x28; // Degrees C
09D8  3028  	MOVLW 0x28
09D9  00DF  	MOVWF gbl_gBcdFanOnTemp

char gBcdFanOffTemp = 0x27; // Degrees C
09DA  3027  	MOVLW 0x27
09DB  00E0  	MOVWF gbl_gBcdFanOffTemp


char gBcdHeaterOnTemp = 0x24; // Degrees C
09DC  3024  	MOVLW 0x24
09DD  00E1  	MOVWF gbl_gBcdHeaterOnTemp

char gBcdHeaterOffTemp = 0x25; // Degrees C
09DE  3025  	MOVLW 0x25
09DF  00E2  	MOVWF gbl_gBcdHeaterOffTemp


// Used to output the segments from numbers
char tm1638MaxDigits = 8;
09E0  3008  	MOVLW 0x08
09E1  00E3  	MOVWF gbl_tm1638MaxDigits

rom char *tm1638DisplayNumtoSeg = {0x3f, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F};
09E2  3002  	MOVLW 0x02
09E3  00E4  	MOVWF gbl_tm1638DisplayNumtoSeg

char tm1638Dot = 0x80;
09E4  3080  	MOVLW 0x80
09E5  00E5  	MOVWF gbl_tm1638Dot

char tm1638Brightness = 7; // 0 to 7
09E6  3007  	MOVLW 0x07
09E7  00E6  	MOVWF gbl_tm1638Brightness

// 0x40 [01000000] = indicate command to display data
char tm1638ByteSetData = 0x40;
09E8  3040  	MOVLW 0x40
09E9  00E7  	MOVWF gbl_tm1638ByteSetData

// 0x42 [01000010] = indicate command to read data
char tm1638ByteReadData = 0x42;
09EA  3042  	MOVLW 0x42
09EB  00E8  	MOVWF gbl_tm1638ByteReadData

// 0xC0 [11000000] = write out all bytes
char tm1638ByteSetAddr = 0xC0;
09EC  30C0  	MOVLW 0xC0
09ED  00E9  	MOVWF gbl_tm1638ByteSetAddr

// 0x88 [10001000] - Display ON, plus brightness
char tm1638ByteSetOn = 0x88;
09EE  3088  	MOVLW 0x88
09EF  00EA  	MOVWF gbl_tm1638ByteSetOn


// Copy of the data to write / on the display
char tm1638Data[] = {0, 0, 0, 0, 0, 0, 0, 0};
09F0  01A0  	CLRF gbl_tm1638Data
09F1  01A1  	CLRF gbl_tm1638Data+D'1'
09F2  01A2  	CLRF gbl_tm1638Data+D'2'
09F3  01A3  	CLRF gbl_tm1638Data+D'3'
09F4  01A4  	CLRF gbl_tm1638Data+D'4'
09F5  01A5  	CLRF gbl_tm1638Data+D'5'
09F6  01A6  	CLRF gbl_tm1638Data+D'6'
09F7  01A7  	CLRF gbl_tm1638Data+D'7'

// Copy of the LED status
char tm1638LEDs[] = {0, 0, 0, 0, 0, 0, 0, 0};
09F8  01A8  	CLRF gbl_tm1638LEDs
09F9  01A9  	CLRF gbl_tm1638LEDs+D'1'
09FA  01AA  	CLRF gbl_tm1638LEDs+D'2'
09FB  01AB  	CLRF gbl_tm1638LEDs+D'3'
09FC  01AC  	CLRF gbl_tm1638LEDs+D'4'
09FD  01AD  	CLRF gbl_tm1638LEDs+D'5'
09FE  01AE  	CLRF gbl_tm1638LEDs+D'6'
09FF  01AF  	CLRF gbl_tm1638LEDs+D'7'

// Copy of the keys
char tm1638Keys = 0;
0A00  01EB  	CLRF gbl_tm1638Keys

char tm1638KeysOld = 0;
0A01  01EC  	CLRF gbl_tm1638KeysOld

// For printing
char iPrintStartDigit = 0;
0A02  01ED  	CLRF gbl_iPrintStartDigit

char iPrintDotDigit = 8;
0A03  3008  	MOVLW 0x08
0A04  00EE  	MOVWF gbl_iPrintDotDigit

// For adjusting bcd numbers up 1 or down !1
char iBcdAdjustment = 1;
0A05  3001  	MOVLW 0x01
0A06  00EF  	MOVWF gbl_iBcdAdjustment


// DS18B20 functions
char oneWireIsPresent = 0;
0A07  01F0  	CLRF gbl_oneWireIsPresent

char oneWireResetStage = 0;
0A08  01F1  	CLRF gbl_oneWireResetStage

void oneWireBusReset();
void oneWireTxByte(char data);
void oneWireTxBytes(char data, char data2);
char oneWireRxByte();

// EEPROM functions
void eepromWriteAll();
char eepromWrite(char address, char data);
void eepromReadAll();
char eepromRead(char address);

// DS3231 functions
void ds3231Write(char ds3231Reg, char bWrite);
void ds3231Init();
void ds3231Start();
void ds3231Stop();
void ds3231WriteDateTime();
void ds3231ReadDateTime();
char ds3231ReadRegister(char cRegAddress);

// TM1638 functions
void tm1638ByteWrite(char bWrite);
void bcdTo7Seg(char iBcdIn);
void tm1638DisplayOn();
void tm1638UpdateDisplay();
void tm1638ReadKeys();

// General functions
int binToBcd(int iBin);
void startTemp();
void readTemp();

char bcdAdjust(char bcd, char bcdMax, char bcdMin);
void adjustDateTime();
void adjustTrigger();
void processKeys();

#endif

#include <system.h>
#include <i2c_driver.h>
#include "PIC16F_TM1638_AquariumControl.h"

//Target PIC16F628A configuration word
#pragma DATA _CONFIG, _BODEN_OFF & _PWRTE_ON & _WDT_OFF & _CP_OFF & _XT_OSC // Brown out reset off, Power-up Timer on, Watchdog timer off, Code Protection off, XT oscillator

//Set clock frequency (for software delays) - 4MHz
#pragma CLOCK_FREQ	4000000

    
/*********************************************************************************************
  void oneWireBusReset()
  First part of the reset routine - drive the bus low for 500us
*********************************************************************************************/
void oneWireBusReset() {

    char isPresent;
    oneWireTris = 1; // start with high
084D  1683  	BSF STATUS, RP0
084E  1303  	BCF STATUS, RP1
084F  1687  	BSF gbl_trisc,5

    isPresent = 0;
0850  1283  	BCF STATUS, RP0
0851  01F2  	CLRF oneWireBus_00017_1_isPresent

    // Send the reset pulse - drive low for 500us
    oneWireBus = 0;      
0852  1287  	BCF gbl_portc,5

    oneWireTris = 0;
0853  1683  	BSF STATUS, RP0
0854  1287  	BCF gbl_trisc,5

    delay_10us(50);
0855  3032  	MOVLW 0x32
0856  1283  	BCF STATUS, RP0
0857  00F7  	MOVWF delay_10us_00000_arg_del
0858  118A  	BCF PCLATH,3
0859  2077  	CALL delay_10us_00000

    // Release line and wait 70us for PD Pulse
    oneWireTris = 1;
085A  1683  	BSF STATUS, RP0
085B  1687  	BSF gbl_trisc,5

    delay_10us(7);
085C  3007  	MOVLW 0x07
085D  1283  	BCF STATUS, RP0
085E  00F7  	MOVWF delay_10us_00000_arg_del
085F  2077  	CALL delay_10us_00000

    // Now sample, if there is a sensor on the bus, the line should be low
    if (oneWireBus) {
0860  1A87  	BTFSC gbl_portc,5

        oneWireIsPresent = 0; // no devices
0861  01F0  	CLRF gbl_oneWireIsPresent

    }
    delay_10us(50);
0862  3032  	MOVLW 0x32
0863  00F7  	MOVWF delay_10us_00000_arg_del
0864  2077  	CALL delay_10us_00000

}
0865  0008  	RETURN


/*********************************************************************************************
  void oneWireTxByte(char data)
  Transmits a single byte from the bus
*********************************************************************************************/
void oneWireTxByte(char cData) {

    char cTemp = 1;
016E  3001  	MOVLW 0x01
016F  00F5  	MOVWF oneWireTxB_00018_1_cTemp

    // Loop through the eight bits in the byte
    for (char i = 0; i < 8; i++) {
0170  01F6  	CLRF oneWireTxB_00018_2_i
0171        label26
0171  3008  	MOVLW 0x08
0172  0276  	SUBWF oneWireTxB_00018_2_i, W
0173  1803  	BTFSC STATUS,C
0188  0AF6  	INCF oneWireTxB_00018_2_i, F
0189  2971  	GOTO	label26

        // Send the LSB first

        // Drive the line low initially for 3us
        oneWireTris = 0;
0175  1683  	BSF STATUS, RP0
0176  1287  	BCF gbl_trisc,5

        oneWireBus = 0;
0177  1283  	BCF STATUS, RP0
0178  1287  	BCF gbl_portc,5


        // Delay not needed for 4MHz PIC
        //delay_us(3); // Delay 3us
        
        if (cData & cTemp) {
0179  0875  	MOVF oneWireTxB_00018_1_cTemp, W
017A  0574  	ANDWF oneWireTxB_00018_arg_cData, W
017B  1903  	BTFSC STATUS,Z
017C  297F  	GOTO	label27

            oneWireTris = 1; // Release the bus
017D  1683  	BSF STATUS, RP0
017E  1687  	BSF gbl_trisc,5

        }
        
        delay_10us(5); // Delay 60us - 50us works fine with code delays
017F  3005  	MOVLW 0x05
0180  1283  	BCF STATUS, RP0
0181  00F7  	MOVWF delay_10us_00000_arg_del
0182  2077  	CALL delay_10us_00000

        oneWireTris = 1; // Release the bus
0183  1683  	BSF STATUS, RP0
0184  1687  	BSF gbl_trisc,5

        
        // move the test bit
        cTemp <<= 1;
0185  1003  	BCF STATUS,C
0186  1283  	BCF STATUS, RP0
0187  0DF5  	RLF oneWireTxB_00018_1_cTemp, F

    }
}
0174  0008  	RETURN


/*********************************************************************************************
  void oneWireTxBytes(char data, char data2)
  Transmits a 2 bytes from the bus
*********************************************************************************************/
void oneWireTxBytes(char cData, char cData2) {

    // Reset first - done in main
    //oneWireBusReset();
    // Send first byte
    oneWireTxByte(cData);
04BC  0872  	MOVF oneWireTxB_00019_arg_cData, W
04BD  00F4  	MOVWF oneWireTxB_00018_arg_cData
04BE  216E  	CALL oneWireTxB_00018

    // Send second byte
    oneWireTxByte(cData2);
04BF  0873  	MOVF oneWireTxB_00019_arg_cData2, W
04C0  00F4  	MOVWF oneWireTxB_00018_arg_cData
04C1  216E  	CALL oneWireTxB_00018

}
04C2  0008  	RETURN


/*********************************************************************************************
  char oneWireRxByte()
  Receives a single byte from the bus
*********************************************************************************************/
char oneWireRxByte() {

    char cDataIn = 0;
04C3  1283  	BCF STATUS, RP0
04C4  1303  	BCF STATUS, RP1
04C5  01F2  	CLRF oneWireRxB_0001A_1_cDataIn

    // Loop through the eight bits in the byte
    for(char i = 0; i < 8; i++) {
04C6  01F3  	CLRF oneWireRxB_0001A_2_i
04C7        label101
04C7  3008  	MOVLW 0x08
04C8  0273  	SUBWF oneWireRxB_0001A_2_i, W
04C9  1803  	BTFSC STATUS,C
04CA  2CDE  	GOTO	label102
04DC  0AF3  	INCF oneWireRxB_0001A_2_i, F
04DD  2CC7  	GOTO	label101
04DE        label102

        // Bring bus low for 15us
        oneWireTris = 0;
04CB  1683  	BSF STATUS, RP0
04CC  1287  	BCF gbl_trisc,5

        oneWireBus = 0;
04CD  1283  	BCF STATUS, RP0
04CE  1287  	BCF gbl_portc,5


        // Delay not needed for 4MHz PIC
        //delay_us(15); // Delay 15us

        // Release bus for 6us, this is enough time for the slave to respond
        oneWireTris = 1;
04CF  1683  	BSF STATUS, RP0
04D0  1687  	BSF gbl_trisc,5

        delay_us(3); // Delay 6us
04D1  3003  	MOVLW 0x03
04D2  1283  	BCF STATUS, RP0
04D3  00F8  	MOVWF delay_us_00000_arg_del
04D4  2010  	CALL delay_us_00000

        
        // Shift data already received left
        cDataIn >>= 1;
04D5  1003  	BCF STATUS,C
04D6  0CF2  	RRF oneWireRxB_0001A_1_cDataIn, F

        
        // Check the value of the onewire bus - set the MSB of cDataIn if so
        if (oneWireBus)
04D7  1A87  	BTFSC gbl_portc,5

            cDataIn.7 = 1;
04D8  17F2  	BSF oneWireRxB_0001A_1_cDataIn,7


        // To finish time slot
        delay_10us(6); // 60us
04D9  3006  	MOVLW 0x06
04DA  00F7  	MOVWF delay_10us_00000_arg_del
04DB  2077  	CALL delay_10us_00000

    } 
    
    return cDataIn;
04DE  0872  	MOVF oneWireRxB_0001A_1_cDataIn, W
04DF  00F3  	MOVWF CompTempVarRet551

}
04E0  0008  	RETURN


/*********************************************************************************************
  void at24c32WriteAll()
  Write multiple bytes
*********************************************************************************************/
void at24c32WriteAll() {

	// https://www.instructables.com/The-Most-Comprehensive-Guide-to-Programming-the-AT/
	i2c_start();
05AD  2126  	CALL i2c_START_00000

	i2c_write(at24c32Addr); // address + write
05AE  30AE  	MOVLW 0xAE
05AF  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05B0  20A5  	CALL i2c_WRITE_00000

	// start at address 0
	i2c_write(0); // First word address (only 4 bits of the 12 bit byte address)
05B1  01F5  	CLRF i2c_WRITE_00000_arg_i2c_data
05B2  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // Second word address 
05B3  01F5  	CLRF i2c_WRITE_00000_arg_i2c_data
05B4  20A5  	CALL i2c_WRITE_00000

	// Write data bytes
	// We're only writing 18 bytes here, so no need to worry about row rollover after 32 bytes
	i2c_write(0x44); // To indicate AT24C32 has been written to
05B5  3044  	MOVLW 0x44
05B6  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05B7  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdWhiteOnMinute);
05B8  0853  	MOVF gbl_gBcdWhiteOnMinute, W
05B9  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05BA  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOnHour);
05BB  0854  	MOVF gbl_gBcdWhiteOnHour, W
05BC  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05BD  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOffMinute);
05BE  0855  	MOVF gbl_gBcdWhiteOffMinute, W
05BF  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05C0  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOffHour);
05C1  0856  	MOVF gbl_gBcdWhiteOffHour, W
05C2  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05C3  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOnMinute);
05C4  0857  	MOVF gbl_gBcdBlueOnMinute, W
05C5  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05C6  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOnHour);
05C7  0858  	MOVF gbl_gBcdBlueOnHour, W
05C8  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05C9  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOffMinute);
05CA  0859  	MOVF gbl_gBcdBlueOffMinute, W
05CB  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05CC  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOffHour);
05CD  085A  	MOVF gbl_gBcdBlueOffHour, W
05CE  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05CF  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdFanOnTemp);
05D0  085F  	MOVF gbl_gBcdFanOnTemp, W
05D1  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05D2  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdFanOffTemp);
05D3  0860  	MOVF gbl_gBcdFanOffTemp, W
05D4  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05D5  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdHeaterOnTemp);
05D6  0861  	MOVF gbl_gBcdHeaterOnTemp, W
05D7  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05D8  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdHeaterOffTemp);
05D9  0862  	MOVF gbl_gBcdHeaterOffTemp, W
05DA  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05DB  20A5  	CALL i2c_WRITE_00000

    i2c_write(gcHourMode);
05DC  0851  	MOVF gbl_gcHourMode, W
05DD  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05DE  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlue2OnMinute);
05DF  085B  	MOVF gbl_gBcdBlue2OnMinute, W
05E0  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05E1  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlue2OnHour);
05E2  085C  	MOVF gbl_gBcdBlue2OnHour, W
05E3  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05E4  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlue2OffMinute);
05E5  085D  	MOVF gbl_gBcdBlue2OffMinute, W
05E6  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05E7  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlue2OffHour);
05E8  085E  	MOVF gbl_gBcdBlue2OffHour, W
05E9  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05EA  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
05EB  20F6  	CALL i2c_STOP_00000

	delay_ms(10); // Write Cycle Time
05EC  300A  	MOVLW 0x0A
05ED  00F2  	MOVWF delay_ms_00000_arg_del
05EE  2081  	CALL delay_ms_00000

}
05EF  0008  	RETURN


/*********************************************************************************************
  void at24c32ReadAll()
  Read all bytes
*********************************************************************************************/
void at24c32ReadAll() {

	i2c_start();
05F0  2126  	CALL i2c_START_00000

	i2c_write(at24c32Addr); // address + write
05F1  30AE  	MOVLW 0xAE
05F2  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05F3  20A5  	CALL i2c_WRITE_00000

	// start at address 0
	i2c_write(0); // First word address (only 4 bits of the 12 bit byte address)
05F4  01F5  	CLRF i2c_WRITE_00000_arg_i2c_data
05F5  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // Second word address 
05F6  01F5  	CLRF i2c_WRITE_00000_arg_i2c_data
05F7  20A5  	CALL i2c_WRITE_00000

	i2c_stop(); // Don't actually write a byte, just stop
05F8  20F6  	CALL i2c_STOP_00000

	
	i2c_start();
05F9  2126  	CALL i2c_START_00000

	i2c_write(at24c32Addr + 1); // address + read
05FA  30AF  	MOVLW 0xAF
05FB  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
05FC  20A5  	CALL i2c_WRITE_00000

	char hasWritten = i2c_read(0); // ack
05FD  01F5  	CLRF i2c_READ_00000_arg_ack_status
05FE  21CD  	CALL i2c_READ_00000
05FF  0878  	MOVF CompTempVarRet553, W
0600  00F3  	MOVWF at24c32Rea_0002C_1_hasWritten

	if (hasWritten != 0x44) {
0601  0873  	MOVF at24c32Rea_0002C_1_hasWritten, W
0602  3A44  	XORLW 0x44
0603  1903  	BTFSC STATUS,Z
0604  2E09  	GOTO	label105
0609        label105

		i2c_read(1); // nack
0605  3001  	MOVLW 0x01
0606  00F5  	MOVWF i2c_READ_00000_arg_ack_status
0607  21CD  	CALL i2c_READ_00000

	} else {
0608  2E4E  	GOTO	label106
064E        label106

		gBcdWhiteOnMinute = i2c_read(0); // ack
0609  01F5  	CLRF i2c_READ_00000_arg_ack_status
060A  21CD  	CALL i2c_READ_00000
060B  0878  	MOVF CompTempVarRet553, W
060C  00D3  	MOVWF gbl_gBcdWhiteOnMinute

		gBcdWhiteOnHour = i2c_read(0); // ack
060D  01F5  	CLRF i2c_READ_00000_arg_ack_status
060E  21CD  	CALL i2c_READ_00000
060F  0878  	MOVF CompTempVarRet553, W
0610  00D4  	MOVWF gbl_gBcdWhiteOnHour

		gBcdWhiteOffMinute = i2c_read(0); // ack
0611  01F5  	CLRF i2c_READ_00000_arg_ack_status
0612  21CD  	CALL i2c_READ_00000
0613  0878  	MOVF CompTempVarRet553, W
0614  00D5  	MOVWF gbl_gBcdWhiteOffMinute

		gBcdWhiteOffHour = i2c_read(0); // ack
0615  01F5  	CLRF i2c_READ_00000_arg_ack_status
0616  21CD  	CALL i2c_READ_00000
0617  0878  	MOVF CompTempVarRet553, W
0618  00D6  	MOVWF gbl_gBcdWhiteOffHour

		gBcdBlueOnMinute = i2c_read(0); // ack
0619  01F5  	CLRF i2c_READ_00000_arg_ack_status
061A  21CD  	CALL i2c_READ_00000
061B  0878  	MOVF CompTempVarRet553, W
061C  00D7  	MOVWF gbl_gBcdBlueOnMinute

		gBcdBlueOnHour = i2c_read(0); // ack
061D  01F5  	CLRF i2c_READ_00000_arg_ack_status
061E  21CD  	CALL i2c_READ_00000
061F  0878  	MOVF CompTempVarRet553, W
0620  00D8  	MOVWF gbl_gBcdBlueOnHour

		gBcdBlueOffMinute = i2c_read(0); // ack
0621  01F5  	CLRF i2c_READ_00000_arg_ack_status
0622  21CD  	CALL i2c_READ_00000
0623  0878  	MOVF CompTempVarRet553, W
0624  00D9  	MOVWF gbl_gBcdBlueOffMinute

		gBcdBlueOffHour = i2c_read(0); // ack
0625  01F5  	CLRF i2c_READ_00000_arg_ack_status
0626  21CD  	CALL i2c_READ_00000
0627  0878  	MOVF CompTempVarRet553, W
0628  00DA  	MOVWF gbl_gBcdBlueOffHour

		gBcdFanOnTemp = i2c_read(0); // ack
0629  01F5  	CLRF i2c_READ_00000_arg_ack_status
062A  21CD  	CALL i2c_READ_00000
062B  0878  	MOVF CompTempVarRet553, W
062C  00DF  	MOVWF gbl_gBcdFanOnTemp

		gBcdFanOffTemp = i2c_read(0); // ack
062D  01F5  	CLRF i2c_READ_00000_arg_ack_status
062E  21CD  	CALL i2c_READ_00000
062F  0878  	MOVF CompTempVarRet553, W
0630  00E0  	MOVWF gbl_gBcdFanOffTemp

		gBcdHeaterOnTemp = i2c_read(0); // ack
0631  01F5  	CLRF i2c_READ_00000_arg_ack_status
0632  21CD  	CALL i2c_READ_00000
0633  0878  	MOVF CompTempVarRet553, W
0634  00E1  	MOVWF gbl_gBcdHeaterOnTemp

		gBcdHeaterOffTemp = i2c_read(0); // ack
0635  01F5  	CLRF i2c_READ_00000_arg_ack_status
0636  21CD  	CALL i2c_READ_00000
0637  0878  	MOVF CompTempVarRet553, W
0638  00E2  	MOVWF gbl_gBcdHeaterOffTemp

		gcHourMode = i2c_read(0); // ack
0639  01F5  	CLRF i2c_READ_00000_arg_ack_status
063A  21CD  	CALL i2c_READ_00000
063B  0878  	MOVF CompTempVarRet553, W
063C  00D1  	MOVWF gbl_gcHourMode

		gBcdBlue2OnMinute = i2c_read(0); // ack
063D  01F5  	CLRF i2c_READ_00000_arg_ack_status
063E  21CD  	CALL i2c_READ_00000
063F  0878  	MOVF CompTempVarRet553, W
0640  00DB  	MOVWF gbl_gBcdBlue2OnMinute

		gBcdBlue2OnHour = i2c_read(0); // ack
0641  01F5  	CLRF i2c_READ_00000_arg_ack_status
0642  21CD  	CALL i2c_READ_00000
0643  0878  	MOVF CompTempVarRet553, W
0644  00DC  	MOVWF gbl_gBcdBlue2OnHour

		gBcdBlue2OffMinute = i2c_read(0); // ack
0645  01F5  	CLRF i2c_READ_00000_arg_ack_status
0646  21CD  	CALL i2c_READ_00000
0647  0878  	MOVF CompTempVarRet553, W
0648  00DD  	MOVWF gbl_gBcdBlue2OffMinute

		gBcdBlue2OffHour = i2c_read(1); // nack
0649  3001  	MOVLW 0x01
064A  00F5  	MOVWF i2c_READ_00000_arg_ack_status
064B  21CD  	CALL i2c_READ_00000
064C  0878  	MOVF CompTempVarRet553, W
064D  00DE  	MOVWF gbl_gBcdBlue2OffHour

	}
	i2c_stop();
064E  20F6  	CALL i2c_STOP_00000

}
064F  0008  	RETURN



/*********************************************************************************************
  void ds3231Write(char ds3231Reg, char bWrite)
  Write one byte
*********************************************************************************************/
void ds3231Write(char ds3231Reg, char bWrite) {

	i2c_start();
0221  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
0222  30D0  	MOVLW 0xD0
0223  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
0224  20A5  	CALL i2c_WRITE_00000

	i2c_write(ds3231Reg); // start at address
0225  0873  	MOVF ds3231Writ_0001B_arg_ds3231Reg, W
0226  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
0227  20A5  	CALL i2c_WRITE_00000

	i2c_write(bWrite); // start at address
0228  0874  	MOVF ds3231Writ_0001B_arg_bWrite, W
0229  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
022A  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
022B  20F6  	CALL i2c_STOP_00000

}
022C  0008  	RETURN


/*********************************************************************************************
  void ds3231Init()
  Initialise the DS3231
*********************************************************************************************/
void ds3231Init() {

	/* control register 0Eh
    bit7 EOSC   Enable Oscillator (1 if oscillator must be stopped when on battery)
    bit6 BBSQW  Battery Backed Square Wave - 0 means square wave disabled when VCC falls below VPF (power fail voltage)
    bit5 CONV   Convert temperature (1 forces a conversion)
    bit4 RS2    Rate select - frequency of square wave output - NA for DS3231M
    bit3 RS1    Rate select - NA for DS3231M
    bit2 INTCN  Interrupt control (1 for use of the alarms and to disable square wave)
    bit1 A2IE   Alarm2 interrupt enable (1 to enable)
    bit0 A1IE   Alarm1 interrupt enable (1 to enable)
    */
	ds3231Write(0x0E, 0x00);
0525  300E  	MOVLW 0x0E
0526  1283  	BCF STATUS, RP0
0527  1303  	BCF STATUS, RP1
0528  00F3  	MOVWF ds3231Writ_0001B_arg_ds3231Reg
0529  01F4  	CLRF ds3231Writ_0001B_arg_bWrite
052A  2221  	CALL ds3231Writ_0001B

	/* Status Register 0Fh
    bit7 OSF     Oscillator stopped flag - clear oscillator stop flag at init
    bit3 EN32kHz Enable 32kHz Output - 0 for disabled
    bit2 BSY     Busy
    bit1 A2F     Alarm 2 Flag
    bit0 A1F     Alarm 1 Flag
    */
	ds3231Write(0x0F, 0x00);
052B  300F  	MOVLW 0x0F
052C  00F3  	MOVWF ds3231Writ_0001B_arg_ds3231Reg
052D  01F4  	CLRF ds3231Writ_0001B_arg_bWrite
052E  2221  	CALL ds3231Writ_0001B

}
052F  0008  	RETURN


/*********************************************************************************************
  void ds3231WriteDateTime()
  Write the date to the DS3231
*********************************************************************************************/
void ds3231WriteDateTime() {

	i2c_start();
04F4  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
04F5  30D0  	MOVLW 0xD0
04F6  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
04F7  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
04F8  01F5  	CLRF i2c_WRITE_00000_arg_i2c_data
04F9  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // seconds
04FA  01F5  	CLRF i2c_WRITE_00000_arg_i2c_data
04FB  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdMinute); // minutes
04FC  0836  	MOVF gbl_gBcdMinute, W
04FD  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
04FE  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdHour); // hours
04FF  0837  	MOVF gbl_gBcdHour, W
0500  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
0501  20A5  	CALL i2c_WRITE_00000

	i2c_write(gDayOfWeek); // day of week
0502  0838  	MOVF gbl_gDayOfWeek, W
0503  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
0504  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdDayOfMonth); // day of month
0505  0839  	MOVF gbl_gBcdDayOfMonth, W
0506  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
0507  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdMonth); // month + century
0508  083A  	MOVF gbl_gBcdMonth, W
0509  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
050A  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdYear); // year
050B  083B  	MOVF gbl_gBcdYear, W
050C  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
050D  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
050E  20F6  	CALL i2c_STOP_00000

}
050F  0008  	RETURN


/*********************************************************************************************
  void ds3231ReadDateTime()
  Write the date to the DS3231
*********************************************************************************************/
void ds3231ReadDateTime() {

	i2c_start();
08A2  118A  	BCF PCLATH,3
08A3  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
08A4  30D0  	MOVLW 0xD0
08A5  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
08A6  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
08A7  01F5  	CLRF i2c_WRITE_00000_arg_i2c_data
08A8  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
08A9  20F6  	CALL i2c_STOP_00000

	
	i2c_start();
08AA  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr + 1); // address + read
08AB  30D1  	MOVLW 0xD1
08AC  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
08AD  20A5  	CALL i2c_WRITE_00000

	gBcdSecond = i2c_read(0); // ack
08AE  01F5  	CLRF i2c_READ_00000_arg_ack_status
08AF  21CD  	CALL i2c_READ_00000
08B0  0878  	MOVF CompTempVarRet553, W
08B1  00B5  	MOVWF gbl_gBcdSecond

	gBcdMinute = i2c_read(0); // ack
08B2  01F5  	CLRF i2c_READ_00000_arg_ack_status
08B3  21CD  	CALL i2c_READ_00000
08B4  0878  	MOVF CompTempVarRet553, W
08B5  00B6  	MOVWF gbl_gBcdMinute

	gBcdHour = i2c_read(0); // ack
08B6  01F5  	CLRF i2c_READ_00000_arg_ack_status
08B7  21CD  	CALL i2c_READ_00000
08B8  0878  	MOVF CompTempVarRet553, W
08B9  00B7  	MOVWF gbl_gBcdHour

	gDayOfWeek = i2c_read(0); // ack
08BA  01F5  	CLRF i2c_READ_00000_arg_ack_status
08BB  21CD  	CALL i2c_READ_00000
08BC  0878  	MOVF CompTempVarRet553, W
08BD  00B8  	MOVWF gbl_gDayOfWeek

	gBcdDayOfMonth = i2c_read(0); // ack
08BE  01F5  	CLRF i2c_READ_00000_arg_ack_status
08BF  21CD  	CALL i2c_READ_00000
08C0  0878  	MOVF CompTempVarRet553, W
08C1  00B9  	MOVWF gbl_gBcdDayOfMonth

	gBcdMonth = i2c_read(0); // ack
08C2  01F5  	CLRF i2c_READ_00000_arg_ack_status
08C3  21CD  	CALL i2c_READ_00000
08C4  0878  	MOVF CompTempVarRet553, W
08C5  00BA  	MOVWF gbl_gBcdMonth

	gBcdYear = i2c_read(1); // nack
08C6  3001  	MOVLW 0x01
08C7  00F5  	MOVWF i2c_READ_00000_arg_ack_status
08C8  21CD  	CALL i2c_READ_00000
08C9  0878  	MOVF CompTempVarRet553, W
08CA  00BB  	MOVWF gbl_gBcdYear

	i2c_stop();
08CB  20F6  	CALL i2c_STOP_00000

}
08CC  0008  	RETURN


/*********************************************************************************************
  char ds3231ReadRegister(char cRegAddress)
  Read one byte from a given DS3231 register address
*********************************************************************************************/
char ds3231ReadRegister(char cRegAddress) {

	char cStatus;
	i2c_start();
0510  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
0511  30D0  	MOVLW 0xD0
0512  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
0513  20A5  	CALL i2c_WRITE_00000

	i2c_write(cRegAddress); // start at requested address
0514  0873  	MOVF ds3231Read_0001E_arg_cRegAddress, W
0515  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
0516  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
0517  20F6  	CALL i2c_STOP_00000

	
	i2c_start();
0518  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr + 1); // address + read
0519  30D1  	MOVLW 0xD1
051A  00F5  	MOVWF i2c_WRITE_00000_arg_i2c_data
051B  20A5  	CALL i2c_WRITE_00000

	cStatus = i2c_read(1); // read the byte, then nack
051C  3001  	MOVLW 0x01
051D  00F5  	MOVWF i2c_READ_00000_arg_ack_status
051E  21CD  	CALL i2c_READ_00000
051F  0878  	MOVF CompTempVarRet553, W
0520  00F4  	MOVWF ds3231Read_0001E_1_cStatus

    i2c_stop();
0521  20F6  	CALL i2c_STOP_00000

    return cStatus;
0522  0874  	MOVF ds3231Read_0001E_1_cStatus, W
0523  00F5  	MOVWF CompTempVarRet554

}
0524  0008  	RETURN


/*********************************************************************************************
  void tm1638ByteWrite(char bWrite)
  Write one byte
*********************************************************************************************/
void tm1638ByteWrite(char bWrite) {

    for (char i = 0; i < 8; i++) {
015B  01F7  	CLRF tm1638Byte_0001F_2_i
015C        label25
015C  3008  	MOVLW 0x08
015D  0277  	SUBWF tm1638Byte_0001F_2_i, W
015E  1803  	BTFSC STATUS,C
016C  0AF7  	INCF tm1638Byte_0001F_2_i, F
016D  295C  	GOTO	label25

        tm1638dio = (bWrite & 0x01);
0160  3001  	MOVLW 0x01
0161  0576  	ANDWF tm1638Byte_0001F_arg_bWrite, W
0162  00F8  	MOVWF CompTempVar555
0163  1878  	BTFSC CompTempVar555,0
0164  1486  	BSF gbl_portb,1
0165  1C78  	BTFSS CompTempVar555,0
0166  1086  	BCF gbl_portb,1

        tm1638clk = 0;
0167  1106  	BCF gbl_portb,2

        bWrite = (bWrite >> 1);
0168  08F6  	MOVF tm1638Byte_0001F_arg_bWrite, F
0169  1003  	BCF STATUS,C
016A  0CF6  	RRF tm1638Byte_0001F_arg_bWrite, F

        tm1638clk = 1;
016B  1506  	BSF gbl_portb,2

    }
}
015F  0008  	RETURN


/*********************************************************************************************
  void tm1638DisplayOn()
  Turns the display on, with defined brightness
*********************************************************************************************/
void tm1638DisplayOn() {

    // Write 0x8F [10001000] to set display ON with pulse width 14/16
    tm1638strobe = 0;
04B4  1283  	BCF STATUS, RP0
04B5  1303  	BCF STATUS, RP1
04B6  1186  	BCF gbl_portb,3

    tm1638ByteWrite(0x88);
04B7  3088  	MOVLW 0x88
04B8  00F6  	MOVWF tm1638Byte_0001F_arg_bWrite
04B9  215B  	CALL tm1638Byte_0001F

    tm1638strobe = 1;
04BA  1586  	BSF gbl_portb,3

}
04BB  0008  	RETURN


/*********************************************************************************************
  void nibbleTo7Seg(char iNibble)
  Convert a single nibble into the 7-segment representation (two digits)
  7-segment digit to be written will be iPrintStartDigit, which is auto-incremented after
  If iPrintDotDigit matches, the dot on the display digit will be added
*********************************************************************************************/
void nibbleTo7Seg(char bNibble) {

	char s7SegDisplay = tm1638DisplayNumtoSeg[bNibble & 0x0F];
008D  0864  	MOVF gbl_tm1638DisplayNumtoSeg, W
008E  00FB  	MOVWF __rom_get_00000_arg_objNumb
008F  300F  	MOVLW 0x0F
0090  0579  	ANDWF nibbleTo7S_00020_arg_bNibble, W
0091  00FC  	MOVWF __rom_get_00000_arg_idx
0092  201A  	CALL __rom_get_00000
0093  00FA  	MOVWF nibbleTo7S_00020_1_s7SegDisplay

	if (iPrintStartDigit == iPrintDotDigit)
0094  086E  	MOVF gbl_iPrintDotDigit, W
0095  066D  	XORWF gbl_iPrintStartDigit, W
0096  118A  	BCF PCLATH,3
0097  120A  	BCF PCLATH,4
0098  1D03  	BTFSS STATUS,Z
0099  289C  	GOTO	label10
009C        label10

        s7SegDisplay |= tm1638Dot;
009A  0865  	MOVF gbl_tm1638Dot, W
009B  04FA  	IORWF nibbleTo7S_00020_1_s7SegDisplay, F

    tm1638Data[iPrintStartDigit] = s7SegDisplay;
009C  1383  	BCF	STATUS,IRP
009D  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
009E  0084  	MOVWF FSR
009F  086D  	MOVF gbl_iPrintStartDigit, W
00A0  0784  	ADDWF FSR, F
00A1  087A  	MOVF nibbleTo7S_00020_1_s7SegDisplay, W
00A2  0080  	MOVWF INDF

    iPrintStartDigit++;
00A3  0AED  	INCF gbl_iPrintStartDigit, F

}
00A4  0008  	RETURN


/*********************************************************************************************
  void bcdTo7Seg(char iBcdIn)
  Convert a single bcd byte into the 7-segment representation (two digits)
*********************************************************************************************/
void bcdTo7Seg(char iBcdIn) {

    nibbleTo7Seg(iBcdIn >> 4);
022D  0E78  	SWAPF bcdTo7Seg_00000_arg_iBcdIn, W
022E  390F  	ANDLW 0x0F
022F  00F9  	MOVWF nibbleTo7S_00020_arg_bNibble
0230  208D  	CALL nibbleTo7S_00020

    nibbleTo7Seg(iBcdIn);
0231  0878  	MOVF bcdTo7Seg_00000_arg_iBcdIn, W
0232  00F9  	MOVWF nibbleTo7S_00020_arg_bNibble
0233  208D  	CALL nibbleTo7S_00020

}
0234  0008  	RETURN


/*********************************************************************************************
  void tm1638UpdateDisplay()
  Publish the tm1638Data and tm1638LEDs arrays to the display
*********************************************************************************************/
void tm1638UpdateDisplay() {

    
    // Display current temperature unless set, trigger or alt display mode is active
    if ((gcDisplayMode == 2) | gcSetMode | gcTriggerMode) {
0293  1283  	BCF STATUS, RP0
0294  1303  	BCF STATUS, RP1
0295  01F3  	CLRF CompTempVar559
0296  3002  	MOVLW 0x02
0297  024F  	SUBWF gbl_gcDisplayMode, W
0298  1903  	BTFSC STATUS,Z
0299  0AF3  	INCF CompTempVar559, F
029A  0850  	MOVF gbl_gcSetMode, W
029B  04F3  	IORWF CompTempVar559, F
029C  0852  	MOVF gbl_gcTriggerMode, W
029D  0473  	IORWF CompTempVar559, W
029E  1903  	BTFSC STATUS,Z
029F  2BFB  	GOTO	label83
03FB        label83

        if (gcSetMode == 1) {
02A0  0350  	DECF gbl_gcSetMode, W
02A1  1D03  	BTFSS STATUS,Z
02A2  2AAF  	GOTO	label53
02AF        label53

            iDigitToFlash = 3;
02A3  3003  	MOVLW 0x03
02A4  00C8  	MOVWF gbl_iDigitToFlash

            // Display year
            // Start printing from digit 0
            iPrintStartDigit = 0;
02A5  01ED  	CLRF gbl_iPrintStartDigit

            iPrintDotDigit = 3;
02A6  3003  	MOVLW 0x03
02A7  00EE  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(0x20); // Display 20 in digits 0 and 1 (no dot)
02A8  3020  	MOVLW 0x20
02A9  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02AA  222D  	CALL bcdTo7Seg_00000

            bcdTo7Seg(gBcdYear); // Display year in digits 2 and 3 (+dot on 3)
02AB  083B  	MOVF gbl_gBcdYear, W
02AC  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02AD  222D  	CALL bcdTo7Seg_00000

        } else if (gcSetMode == 4) {
02AE  2C2B  	GOTO	label86
02AF  0850  	MOVF gbl_gcSetMode, W
02B0  3A04  	XORLW 0x04
02B1  1D03  	BTFSS STATUS,Z
02B2  2AC5  	GOTO	label54
02C5        label54

            iDigitToFlash = 3;
02B3  3003  	MOVLW 0x03
02B4  00C8  	MOVWF gbl_iDigitToFlash

            // Display day of week
            tm1638Data[0] = 0x5E; // d
02B5  305E  	MOVLW 0x5E
02B6  00A0  	MOVWF gbl_tm1638Data

            tm1638Data[1] = 0x5F; // a
02B7  305F  	MOVLW 0x5F
02B8  00A1  	MOVWF gbl_tm1638Data+D'1'

            tm1638Data[2] = 0x6E; // y
02B9  306E  	MOVLW 0x6E
02BA  00A2  	MOVWF gbl_tm1638Data+D'2'

            tm1638Data[3] = tm1638DisplayNumtoSeg[gDayOfWeek] + tm1638Dot;
02BB  0864  	MOVF gbl_tm1638DisplayNumtoSeg, W
02BC  00FB  	MOVWF __rom_get_00000_arg_objNumb
02BD  0838  	MOVF gbl_gDayOfWeek, W
02BE  00FC  	MOVWF __rom_get_00000_arg_idx
02BF  201A  	CALL __rom_get_00000
02C0  0765  	ADDWF gbl_tm1638Dot, W
02C1  00A3  	MOVWF gbl_tm1638Data+D'3'

        } else if (gcSetMode == 5) {
02C2  118A  	BCF PCLATH,3
02C3  120A  	BCF PCLATH,4
02C4  2C2B  	GOTO	label86
02C5  0850  	MOVF gbl_gcSetMode, W
02C6  3A05  	XORLW 0x05
02C7  1D03  	BTFSS STATUS,Z
02C8  2ADB  	GOTO	label57
02DB        label57

            iDigitToFlash = 1;
02C9  3001  	MOVLW 0x01
02CA  00C8  	MOVWF gbl_iDigitToFlash

            // Display day of week
            if (gcHourMode) {
02CB  08D1  	MOVF gbl_gcHourMode, F
02CC  1903  	BTFSC STATUS,Z
02CD  2AD3  	GOTO	label55
02D3        label55

				tm1638Data[0] = 0x06; // 1
02CE  3006  	MOVLW 0x06
02CF  00A0  	MOVWF gbl_tm1638Data

				tm1638Data[1] = 0x5b; // 2
02D0  305B  	MOVLW 0x5B
02D1  00A1  	MOVWF gbl_tm1638Data+D'1'

			} else {
02D2  2AD7  	GOTO	label56
02D7        label56

				tm1638Data[0] = 0x5b; // 2
02D3  305B  	MOVLW 0x5B
02D4  00A0  	MOVWF gbl_tm1638Data

				tm1638Data[1] = 0x66; // 4
02D5  3066  	MOVLW 0x66
02D6  00A1  	MOVWF gbl_tm1638Data+D'1'

			}
            tm1638Data[2] = 0x74; // h
02D7  3074  	MOVLW 0x74
02D8  00A2  	MOVWF gbl_tm1638Data+D'2'

            tm1638Data[3] = 0x00; // blank
02D9  01A3  	CLRF gbl_tm1638Data+D'3'

        } else if (gcTriggerMode) {
02DA  2C2B  	GOTO	label86
02DB  08D2  	MOVF gbl_gcTriggerMode, F
02DC  1903  	BTFSC STATUS,Z
02DD  2BD3  	GOTO	label76
03D3        label76

            iPrintDotDigit = 5;
02DE  3005  	MOVLW 0x05
02DF  00EE  	MOVWF gbl_iPrintDotDigit

            switch (gcTriggerMode) {
0311  2C2B  	GOTO	label86

                case 1:
02E0  0852  	MOVF gbl_gcTriggerMode, W
02E1  3A01  	XORLW 0x01
02E2  1903  	BTFSC STATUS,Z
02E3  2B12  	GOTO	label58
0312        label58

                    // White LED on hour
                    tm1638Data[0] = 0x38; // L
0312  3038  	MOVLW 0x38
0313  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x00; // space
0314  01A1  	CLRF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x3f; // O
0315  303F  	MOVLW 0x3F
0316  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x54; // n
0317  3054  	MOVLW 0x54
0318  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
0319  3005  	MOVLW 0x05
031A  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
031B  3004  	MOVLW 0x04
031C  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOnHour); // Display hour in digits 4 and 5 (dot on 5)
031D  0854  	MOVF gbl_gBcdWhiteOnHour, W
031E  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
031F  222D  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdWhiteOnMinute); // Display minute in digits 6 and 7 (no dot)
0320  0853  	MOVF gbl_gBcdWhiteOnMinute, W
0321  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0322  222D  	CALL bcdTo7Seg_00000

                    break;
0323  2C2B  	GOTO	label86

                case 2:
02E4  3A03  	XORLW 0x03
02E5  1903  	BTFSC STATUS,Z
02E6  2B24  	GOTO	label59
0324        label59

                    // White LED on minute
                    iDigitToFlash = 7;
0324  3007  	MOVLW 0x07
0325  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0326  3006  	MOVLW 0x06
0327  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOnMinute); // Display minute in digits 6 and 7 (no dot)
0328  0853  	MOVF gbl_gBcdWhiteOnMinute, W
0329  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
032A  222D  	CALL bcdTo7Seg_00000

                    break;
032B  2C2B  	GOTO	label86

                case 3:
02E7  3A01  	XORLW 0x01
02E8  1903  	BTFSC STATUS,Z
02E9  2B2C  	GOTO	label60
032C        label60

                    // White LED off hour
                    tm1638Data[3] = 0x71; // F
032C  3071  	MOVLW 0x71
032D  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
032E  3005  	MOVLW 0x05
032F  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
0330  3004  	MOVLW 0x04
0331  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOffHour); 
0332  0856  	MOVF gbl_gBcdWhiteOffHour, W
0333  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0334  222D  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdWhiteOffMinute); // Display minute in digits 6 and 7 (no dot)
0335  0855  	MOVF gbl_gBcdWhiteOffMinute, W
0336  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0337  222D  	CALL bcdTo7Seg_00000

                    break;
0338  2C2B  	GOTO	label86

                case 4:
02EA  3A07  	XORLW 0x07
02EB  1903  	BTFSC STATUS,Z
02EC  2B39  	GOTO	label61
0339        label61

                    // White LED off minute
                    iDigitToFlash = 7;
0339  3007  	MOVLW 0x07
033A  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
033B  3006  	MOVLW 0x06
033C  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOffMinute); // Display minute in digits 6 and 7 (no dot)
033D  0855  	MOVF gbl_gBcdWhiteOffMinute, W
033E  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
033F  222D  	CALL bcdTo7Seg_00000

                    break;
0340  2C2B  	GOTO	label86

                case 5:
02ED  3A01  	XORLW 0x01
02EE  1903  	BTFSC STATUS,Z
02EF  2B41  	GOTO	label62
0341        label62

                case 9:
02F0  3A0C  	XORLW 0x0C
02F1  1903  	BTFSC STATUS,Z
02F2  2B41  	GOTO	label62

                    // Blue LED on hour
                    tm1638Data[0] = 0x7C; // b
0341  307C  	MOVLW 0x7C
0342  00A0  	MOVWF gbl_tm1638Data

                    if (gcTriggerMode == 5)
0343  0852  	MOVF gbl_gcTriggerMode, W
0344  3A05  	XORLW 0x05
0345  1D03  	BTFSS STATUS,Z
0346  2B4A  	GOTO	label63
034A        label63

                        tm1638Data[1] = 0x06; // 1
0347  3006  	MOVLW 0x06
0348  00A1  	MOVWF gbl_tm1638Data+D'1'

                    else
0349  2B4C  	GOTO	label64
034C        label64

                        tm1638Data[1] = 0x5B; // 2
034A  305B  	MOVLW 0x5B
034B  00A1  	MOVWF gbl_tm1638Data+D'1'

                    //tm1638Data[2] = 0x3f; // O
                    tm1638Data[3] = 0x54; // n
034C  3054  	MOVLW 0x54
034D  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
034E  3005  	MOVLW 0x05
034F  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
0350  3004  	MOVLW 0x04
0351  00ED  	MOVWF gbl_iPrintStartDigit

                    if (gcTriggerMode == 5) {
0352  0852  	MOVF gbl_gcTriggerMode, W
0353  3A05  	XORLW 0x05
0354  1D03  	BTFSS STATUS,Z
0355  2B5D  	GOTO	label65
035D        label65

                        bcdTo7Seg(gBcdBlueOnHour); // Display hour in digits 4 and 5 (dot on 5)
0356  0858  	MOVF gbl_gBcdBlueOnHour, W
0357  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0358  222D  	CALL bcdTo7Seg_00000

                        bcdTo7Seg(gBcdBlueOnMinute); // Display minute in digits 6 and 7 (no dot)
0359  0857  	MOVF gbl_gBcdBlueOnMinute, W
035A  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
035B  222D  	CALL bcdTo7Seg_00000

                    } else {
035C  2C2B  	GOTO	label86

                        bcdTo7Seg(gBcdBlue2OnHour); // Display hour in digits 4 and 5 (dot on 5)
035D  085C  	MOVF gbl_gBcdBlue2OnHour, W
035E  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
035F  222D  	CALL bcdTo7Seg_00000

                        bcdTo7Seg(gBcdBlue2OnMinute); // Display minute in digits 6 and 7 (no dot)
0360  085B  	MOVF gbl_gBcdBlue2OnMinute, W
0361  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0362  222D  	CALL bcdTo7Seg_00000

                    }
                    break;
0363  2C2B  	GOTO	label86

                case 6:
02F3  3A0F  	XORLW 0x0F
02F4  1903  	BTFSC STATUS,Z
02F5  2B64  	GOTO	label66
0364        label66

                case 10:
02F6  3A0C  	XORLW 0x0C
02F7  1903  	BTFSC STATUS,Z
02F8  2B64  	GOTO	label66

                    // Blue LED on minute
                    iDigitToFlash = 7;
0364  3007  	MOVLW 0x07
0365  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0366  3006  	MOVLW 0x06
0367  00ED  	MOVWF gbl_iPrintStartDigit

                    if (gcTriggerMode == 5)
0368  0852  	MOVF gbl_gcTriggerMode, W
0369  3A05  	XORLW 0x05
036A  1D03  	BTFSS STATUS,Z
036B  2B70  	GOTO	label67
0370        label67

                        bcdTo7Seg(gBcdBlueOnMinute); // Display minute in digits 6 and 7 (no dot)
036C  0857  	MOVF gbl_gBcdBlueOnMinute, W
036D  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
036E  222D  	CALL bcdTo7Seg_00000

                    else
036F  2C2B  	GOTO	label86

                        bcdTo7Seg(gBcdBlue2OnMinute); // Display minute in digits 6 and 7 (no dot)
0370  085B  	MOVF gbl_gBcdBlue2OnMinute, W
0371  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0372  222D  	CALL bcdTo7Seg_00000

                    break;
0373  2C2B  	GOTO	label86

                case 7:
02F9  3A0D  	XORLW 0x0D
02FA  1903  	BTFSC STATUS,Z
02FB  2B74  	GOTO	label68
0374        label68

                case 11:
02FC  3A0C  	XORLW 0x0C
02FD  1903  	BTFSC STATUS,Z
02FE  2B74  	GOTO	label68

                    // Blue LED off hour
                    tm1638Data[3] = 0x71; // F
0374  3071  	MOVLW 0x71
0375  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
0376  3005  	MOVLW 0x05
0377  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
0378  3004  	MOVLW 0x04
0379  00ED  	MOVWF gbl_iPrintStartDigit

                    if (gcTriggerMode == 5) {
037A  0852  	MOVF gbl_gcTriggerMode, W
037B  3A05  	XORLW 0x05
037C  1D03  	BTFSS STATUS,Z
037D  2B85  	GOTO	label69
0385        label69

                        bcdTo7Seg(gBcdBlueOffHour); // Display hour in digits 4 and 5 (dot on 5)
037E  085A  	MOVF gbl_gBcdBlueOffHour, W
037F  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0380  222D  	CALL bcdTo7Seg_00000

                        bcdTo7Seg(gBcdBlueOffMinute); // Display minute in digits 6 and 7 (no dot)
0381  0859  	MOVF gbl_gBcdBlueOffMinute, W
0382  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0383  222D  	CALL bcdTo7Seg_00000

                    } else {
0384  2C2B  	GOTO	label86

                        bcdTo7Seg(gBcdBlue2OffHour); // Display hour in digits 4 and 5 (dot on 5)
0385  085E  	MOVF gbl_gBcdBlue2OffHour, W
0386  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0387  222D  	CALL bcdTo7Seg_00000

                        bcdTo7Seg(gBcdBlue2OffMinute); // Display minute in digits 6 and 7 (no dot)
0388  085D  	MOVF gbl_gBcdBlue2OffMinute, W
0389  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
038A  222D  	CALL bcdTo7Seg_00000

                    }
                    break;
038B  2C2B  	GOTO	label86

                case 8:
02FF  3A03  	XORLW 0x03
0300  1903  	BTFSC STATUS,Z
0301  2B8C  	GOTO	label70
038C        label70

                case 12:
0302  3A04  	XORLW 0x04
0303  1903  	BTFSC STATUS,Z
0304  2B8C  	GOTO	label70

                    // Blue LED off minute
                    iDigitToFlash = 7;
038C  3007  	MOVLW 0x07
038D  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
038E  3006  	MOVLW 0x06
038F  00ED  	MOVWF gbl_iPrintStartDigit

                    if (gcTriggerMode == 5)
0390  0852  	MOVF gbl_gcTriggerMode, W
0391  3A05  	XORLW 0x05
0392  1D03  	BTFSS STATUS,Z
0393  2B98  	GOTO	label71
0398        label71

                        bcdTo7Seg(gBcdBlueOffMinute); // Display minute in digits 6 and 7 (no dot)
0394  0859  	MOVF gbl_gBcdBlueOffMinute, W
0395  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0396  222D  	CALL bcdTo7Seg_00000

                    else
0397  2C2B  	GOTO	label86

                        bcdTo7Seg(gBcdBlue2OffMinute); // Display minute in digits 6 and 7 (no dot)
0398  085D  	MOVF gbl_gBcdBlue2OffMinute, W
0399  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
039A  222D  	CALL bcdTo7Seg_00000

                    break;
039B  2C2B  	GOTO	label86

                case 13:
0305  3A01  	XORLW 0x01
0306  1903  	BTFSC STATUS,Z
0307  2B9C  	GOTO	label72
039C        label72

                    // Fan on temperature
                    tm1638Data[0] = 0x71; // F
039C  3071  	MOVLW 0x71
039D  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x5F; // a
039E  305F  	MOVLW 0x5F
039F  00A1  	MOVWF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x54; // n
03A0  3054  	MOVLW 0x54
03A1  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x00; // space
03A2  01A3  	CLRF gbl_tm1638Data+D'3'

                    tm1638Data[4] = 0x3f; // O
03A3  303F  	MOVLW 0x3F
03A4  00A4  	MOVWF gbl_tm1638Data+D'4'

                    tm1638Data[5] = 0x54; // n
03A5  3054  	MOVLW 0x54
03A6  00A5  	MOVWF gbl_tm1638Data+D'5'

                    iDigitToFlash = 7;
03A7  3007  	MOVLW 0x07
03A8  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
03A9  3006  	MOVLW 0x06
03AA  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdFanOnTemp); // Display celcius in digits 6 and 7 (no dot)
03AB  085F  	MOVF gbl_gBcdFanOnTemp, W
03AC  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03AD  222D  	CALL bcdTo7Seg_00000

                    break;
03AE  2C2B  	GOTO	label86

                case 14:
0308  3A03  	XORLW 0x03
0309  1903  	BTFSC STATUS,Z
030A  2BAF  	GOTO	label73
03AF        label73

                    // Fan off temperature
                    tm1638Data[5] = 0x71; // f
03AF  3071  	MOVLW 0x71
03B0  00A5  	MOVWF gbl_tm1638Data+D'5'

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
03B1  3006  	MOVLW 0x06
03B2  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdFanOffTemp); // Display celcius in digits 6 and 7 (no dot)
03B3  0860  	MOVF gbl_gBcdFanOffTemp, W
03B4  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03B5  222D  	CALL bcdTo7Seg_00000

                    break;
03B6  2C2B  	GOTO	label86

                case 15:
030B  3A01  	XORLW 0x01
030C  1903  	BTFSC STATUS,Z
030D  2BB7  	GOTO	label74
03B7        label74

                    // Heater on temperature
                    tm1638Data[0] = 0x76; // H
03B7  3076  	MOVLW 0x76
03B8  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x7B; // e
03B9  307B  	MOVLW 0x7B
03BA  00A1  	MOVWF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x5F; // a
03BB  305F  	MOVLW 0x5F
03BC  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x78; // t
03BD  3078  	MOVLW 0x78
03BE  00A3  	MOVWF gbl_tm1638Data+D'3'

                    tm1638Data[4] = 0x3f; // O
03BF  303F  	MOVLW 0x3F
03C0  00A4  	MOVWF gbl_tm1638Data+D'4'

                    tm1638Data[5] = 0x54; // n
03C1  3054  	MOVLW 0x54
03C2  00A5  	MOVWF gbl_tm1638Data+D'5'

                    iDigitToFlash = 7;
03C3  3007  	MOVLW 0x07
03C4  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
03C5  3006  	MOVLW 0x06
03C6  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdHeaterOnTemp); // Display celcius in digits 6 and 7 (no dot)
03C7  0861  	MOVF gbl_gBcdHeaterOnTemp, W
03C8  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03C9  222D  	CALL bcdTo7Seg_00000

                    break;
03CA  2C2B  	GOTO	label86

                case 16:
030E  3A1F  	XORLW 0x1F
030F  1903  	BTFSC STATUS,Z
0310  2BCB  	GOTO	label75
03CB        label75

                    // Heater off temperature
                    tm1638Data[5] = 0x71; // f
03CB  3071  	MOVLW 0x71
03CC  00A5  	MOVWF gbl_tm1638Data+D'5'

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
03CD  3006  	MOVLW 0x06
03CE  00ED  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdHeaterOffTemp); // Display celcius in digits 6 and 7 (no dot)
03CF  0862  	MOVF gbl_gBcdHeaterOffTemp, W
03D0  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03D1  222D  	CALL bcdTo7Seg_00000

                    break;
            }
        } else {
03D2  2C2B  	GOTO	label86

            switch (gcSetMode) {
03EF        label82

                case 2:
03D3  0850  	MOVF gbl_gcSetMode, W
03D4  3A02  	XORLW 0x02
03D5  1903  	BTFSC STATUS,Z
03D6  2BE1  	GOTO	label77
03E1        label77

                    iDigitToFlash = 3;
03E1  3003  	MOVLW 0x03
03E2  00C8  	MOVWF gbl_iDigitToFlash

                    break;
03E3  2BEF  	GOTO	label82

                case 3:
03D7  3A01  	XORLW 0x01
03D8  1903  	BTFSC STATUS,Z
03D9  2BE4  	GOTO	label78
03E4        label78

                    iDigitToFlash = 1;
03E4  3001  	MOVLW 0x01
03E5  00C8  	MOVWF gbl_iDigitToFlash

                    break;
03E6  2BEF  	GOTO	label82

                case 6:
03DA  3A05  	XORLW 0x05
03DB  1903  	BTFSC STATUS,Z
03DC  2BE7  	GOTO	label79
03E7        label79

                    iDigitToFlash = 5;
03E7  3005  	MOVLW 0x05
03E8  00C8  	MOVWF gbl_iDigitToFlash

                    break;
03E9  2BEF  	GOTO	label82

                case 7:
03DD  3A01  	XORLW 0x01
03DE  1903  	BTFSC STATUS,Z
03DF  2BEA  	GOTO	label80
03EA        label80

                    iDigitToFlash = 7;
03EA  3007  	MOVLW 0x07
03EB  00C8  	MOVWF gbl_iDigitToFlash

                    break;
03EC  2BEF  	GOTO	label82

                default:
03E0  2BED  	GOTO	label81
03ED        label81

                    iDigitToFlash = 8;
03ED  3008  	MOVLW 0x08
03EE  00C8  	MOVWF gbl_iDigitToFlash

            }
            // Display date DD.MM
            iPrintStartDigit = 0;
03EF  01ED  	CLRF gbl_iPrintStartDigit

            iPrintDotDigit = 1;
03F0  3001  	MOVLW 0x01
03F1  00EE  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(gBcdDayOfMonth); // Display day of month in digits 0 and 1 (+dot on 1)
03F2  0839  	MOVF gbl_gBcdDayOfMonth, W
03F3  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03F4  222D  	CALL bcdTo7Seg_00000

            iPrintDotDigit = 3;
03F5  3003  	MOVLW 0x03
03F6  00EE  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(gBcdMonth); // Display month in digits 2 and 3 (+dot on 3)
03F7  083A  	MOVF gbl_gBcdMonth, W
03F8  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
03F9  222D  	CALL bcdTo7Seg_00000

        }
    } else {
03FA  2C2B  	GOTO	label86

        iDigitToFlash = 8; // No flashing digit in this mode
03FB  3008  	MOVLW 0x08
03FC  00C8  	MOVWF gbl_iDigitToFlash

        // translate DS3231 temperature to digit values
        iPrintDotDigit = 1;
03FD  3001  	MOVLW 0x01
03FE  00EE  	MOVWF gbl_iPrintDotDigit

        if (gcDisplayMode == 1) // no dot on the first two digits for fahrenheit
03FF  034F  	DECF gbl_gcDisplayMode, W
0400  1D03  	BTFSS STATUS,Z
0401  2C04  	GOTO	label84
0404        label84

			iPrintDotDigit = 2;
0402  3002  	MOVLW 0x02
0403  00EE  	MOVWF gbl_iPrintDotDigit

        // For -10 or below, shift digits right
        if (gbDS3231IsMinus && (giDS3231ValueBCD & 0xF000)) {
0404  08CC  	MOVF gbl_gbDS3231IsMinus, F
0405  1903  	BTFSC STATUS,Z
0406  2C19  	GOTO	label85
0407  30F0  	MOVLW 0xF0
0408  0534  	ANDWF gbl_giDS3231ValueBCD+D'1', W
0409  1903  	BTFSC STATUS,Z
040A  2C19  	GOTO	label85
0419        label85

            giDS3231ValueBCD >>= 4;
040B  0D34  	RLF gbl_giDS3231ValueBCD+D'1', W
040C  0CB4  	RRF gbl_giDS3231ValueBCD+D'1', F
040D  0CB3  	RRF gbl_giDS3231ValueBCD, F
040E  0D34  	RLF gbl_giDS3231ValueBCD+D'1', W
040F  0CB4  	RRF gbl_giDS3231ValueBCD+D'1', F
0410  0CB3  	RRF gbl_giDS3231ValueBCD, F
0411  0D34  	RLF gbl_giDS3231ValueBCD+D'1', W
0412  0CB4  	RRF gbl_giDS3231ValueBCD+D'1', F
0413  0CB3  	RRF gbl_giDS3231ValueBCD, F
0414  0D34  	RLF gbl_giDS3231ValueBCD+D'1', W
0415  0CB4  	RRF gbl_giDS3231ValueBCD+D'1', F
0416  0CB3  	RRF gbl_giDS3231ValueBCD, F

            iPrintDotDigit = 2;
0417  3002  	MOVLW 0x02
0418  00EE  	MOVWF gbl_iPrintDotDigit

        }
        // Display current temperature in digits 0 to 3 (+dot on digit 1 and 3)
        iPrintStartDigit = 0;
0419  01ED  	CLRF gbl_iPrintStartDigit

        bcdTo7Seg(giDS3231ValueBCD >> 8);
041A  0834  	MOVF gbl_giDS3231ValueBCD+D'1', W
041B  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
041C  222D  	CALL bcdTo7Seg_00000

        bcdTo7Seg(giDS3231ValueBCD);
041D  0833  	MOVF gbl_giDS3231ValueBCD, W
041E  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
041F  222D  	CALL bcdTo7Seg_00000

        // Also display dot on 4th digit (always)
		//tm1638Data[3] = tm1638Data[3] + tm1638Dot;
		tm1638Data[3] |= tm1638Dot;
0420  0865  	MOVF gbl_tm1638Dot, W
0421  04A3  	IORWF gbl_tm1638Data+D'3', F


        // left fill zero with blank
        if (tm1638Data[0] == 0x3f)
0422  0820  	MOVF gbl_tm1638Data, W
0423  3A3F  	XORLW 0x3F
0424  1903  	BTFSC STATUS,Z

            tm1638Data[0] = 0;
0425  01A0  	CLRF gbl_tm1638Data

        // If minus, overwrite left most digit with minus sign
        if (gbDS3231IsMinus)
0426  08CC  	MOVF gbl_gbDS3231IsMinus, F
0427  1903  	BTFSC STATUS,Z
0428  2C2B  	GOTO	label86
042B        label86

            tm1638Data[0] = 0x40;
0429  3040  	MOVLW 0x40
042A  00A0  	MOVWF gbl_tm1638Data

    }

    // HH.MM in last 4 digits of TM1638
    if (!gcTriggerMode) {
042B  08D2  	MOVF gbl_gcTriggerMode, F
042C  1D03  	BTFSS STATUS,Z
042D  2C66  	GOTO	label92
0466        label92

        iPrintStartDigit = 4;
042E  3004  	MOVLW 0x04
042F  00ED  	MOVWF gbl_iPrintStartDigit

        // Flash dot every second
        if (gBcdSecond.0)
0430  1C35  	BTFSS gbl_gBcdSecond,0
0431  2C35  	GOTO	label87
0435        label87

			iPrintDotDigit = 5;
0432  3005  	MOVLW 0x05
0433  00EE  	MOVWF gbl_iPrintDotDigit

		else
0434  2C37  	GOTO	label88
0437        label88

			iPrintDotDigit = 8;
0435  3008  	MOVLW 0x08
0436  00EE  	MOVWF gbl_iPrintDotDigit

        char cBcdHourDisp = gBcdHour;
0437  0837  	MOVF gbl_gBcdHour, W
0438  00F7  	MOVWF tm1638Upda_00022_183_cBcdH_00024

        if (gcHourMode && (gBcdHour > 0x12)) {
0439  08D1  	MOVF gbl_gcHourMode, F
043A  1903  	BTFSC STATUS,Z
043B  2C4B  	GOTO	label89
043C  0837  	MOVF gbl_gBcdHour, W
043D  3C12  	SUBLW 0x12
043E  1803  	BTFSC STATUS,C
043F  2C4B  	GOTO	label89

			// convert to 12h
			cBcdHourDisp -= 0x12;
0440  3012  	MOVLW 0x12
0441  02F7  	SUBWF tm1638Upda_00022_183_cBcdH_00024, F

			// For 8 and 9pm, take off another 6
			if ((cBcdHourDisp & 0x0F) > 7)
0442  300F  	MOVLW 0x0F
0443  0577  	ANDWF tm1638Upda_00022_183_cBcdH_00024, W
0444  00F8  	MOVWF CompTempVar599
0445  0878  	MOVF CompTempVar599, W
0446  3C07  	SUBLW 0x07
0447  1803  	BTFSC STATUS,C
0448  2C4B  	GOTO	label89
044B        label89

                cBcdHourDisp -= 6;
0449  3006  	MOVLW 0x06
044A  02F7  	SUBWF tm1638Upda_00022_183_cBcdH_00024, F

        }
        if (gcHourMode && gBcdHour == 0) {
044B  08D1  	MOVF gbl_gcHourMode, F
044C  1903  	BTFSC STATUS,Z
044D  2C53  	GOTO	label90
044E  08B7  	MOVF gbl_gBcdHour, F
044F  1D03  	BTFSS STATUS,Z
0450  2C53  	GOTO	label90
0453        label90

			cBcdHourDisp = 0x12; // 12am
0451  3012  	MOVLW 0x12
0452  00F7  	MOVWF tm1638Upda_00022_183_cBcdH_00024

        }
        bcdTo7Seg(cBcdHourDisp); // Display hour in digits 4 and 5 (dot on 5)
0453  0877  	MOVF tm1638Upda_00022_183_cBcdH_00024, W
0454  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0455  222D  	CALL bcdTo7Seg_00000

        // left fill zero with blank
        if (tm1638Data[4] == 0x3f)
0456  0824  	MOVF gbl_tm1638Data+D'4', W
0457  3A3F  	XORLW 0x3F
0458  1903  	BTFSC STATUS,Z

            tm1638Data[4] = 0;
0459  01A4  	CLRF gbl_tm1638Data+D'4'

        if (gcHourMode && (gBcdHour > 0x11)) {
045A  08D1  	MOVF gbl_gcHourMode, F
045B  1903  	BTFSC STATUS,Z
045C  2C63  	GOTO	label91
045D  0837  	MOVF gbl_gBcdHour, W
045E  3C11  	SUBLW 0x11
045F  1803  	BTFSC STATUS,C
0460  2C63  	GOTO	label91
0463        label91

			// PM dot
			iPrintDotDigit = 7;
0461  3007  	MOVLW 0x07
0462  00EE  	MOVWF gbl_iPrintDotDigit

        }
        bcdTo7Seg(gBcdMinute); // Display minute in digits 6 and 7 (no dot)
0463  0836  	MOVF gbl_gBcdMinute, W
0464  00F8  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0465  222D  	CALL bcdTo7Seg_00000

    }

    // Light LED for set mode
    char cCompareSetMode = gcSetMode;
0466  0850  	MOVF gbl_gcSetMode, W
0467  00F4  	MOVWF tm1638Upda_00022_1_cCompar_00023

    for (char i = 2; i < 8; i++) {
0468  3002  	MOVLW 0x02
0469  00F6  	MOVWF tm1638Upda_00022_3_i
046A        label93
046A  3008  	MOVLW 0x08
046B  0276  	SUBWF tm1638Upda_00022_3_i, W
046C  1803  	BTFSC STATUS,C
046D  2C83  	GOTO	label96
0481  0AF6  	INCF tm1638Upda_00022_3_i, F
0482  2C6A  	GOTO	label93
0483        label96

        if (i == cCompareSetMode)
046E  0874  	MOVF tm1638Upda_00022_1_cCompar_00023, W
046F  0676  	XORWF tm1638Upda_00022_3_i, W
0470  1D03  	BTFSS STATUS,Z
0471  2C7A  	GOTO	label94
047A        label94

            tm1638LEDs[i] = 1;
0472  1383  	BCF	STATUS,IRP
0473  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
0474  0084  	MOVWF FSR
0475  0876  	MOVF tm1638Upda_00022_3_i, W
0476  0784  	ADDWF FSR, F
0477  3001  	MOVLW 0x01
0478  0080  	MOVWF INDF

        else
0479  2C81  	GOTO	label95
0481        label95

            tm1638LEDs[i] = 0;
047A  1383  	BCF	STATUS,IRP
047B  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
047C  0084  	MOVWF FSR
047D  0876  	MOVF tm1638Upda_00022_3_i, W
047E  0784  	ADDWF FSR, F
047F  3000  	MOVLW 0x00
0480  0080  	MOVWF INDF

    }
    tm1638LEDs[0] = HEATER;
0483  01A8  	CLRF gbl_tm1638LEDs
0484  1805  	BTFSC gbl_porta,0
0485  0AA8  	INCF gbl_tm1638LEDs, F

    tm1638LEDs[1] = FAN;
0486  01A9  	CLRF gbl_tm1638LEDs+D'1'
0487  1885  	BTFSC gbl_porta,1
0488  0AA9  	INCF gbl_tm1638LEDs+D'1', F


    // Write 0x40 [01000000] (table 5.1) to indicate command to display data - [Write data to display register]
    tm1638strobe = 0;
0489  1186  	BCF gbl_portb,3

    tm1638ByteWrite(tm1638ByteSetData);
048A  0867  	MOVF gbl_tm1638ByteSetData, W
048B  00F6  	MOVWF tm1638Byte_0001F_arg_bWrite
048C  215B  	CALL tm1638Byte_0001F

    tm1638strobe = 1;
048D  1586  	BSF gbl_portb,3

    
    tm1638strobe = 0;
048E  1186  	BCF gbl_portb,3

    // Specify the display address 0xC0 [11000000] (table 5.2) [Display address 00H] then write out all 16 bytes
    tm1638ByteWrite(tm1638ByteSetAddr);
048F  0869  	MOVF gbl_tm1638ByteSetAddr, W
0490  00F6  	MOVWF tm1638Byte_0001F_arg_bWrite
0491  215B  	CALL tm1638Byte_0001F

    for (char i = 0; i < tm1638MaxDigits; i++) {
0492  01F5  	CLRF tm1638Upda_00022_2_i
0493        label97
0493  0863  	MOVF gbl_tm1638MaxDigits, W
0494  0275  	SUBWF tm1638Upda_00022_2_i, W
0495  1803  	BTFSC STATUS,C
0496  2CB2  	GOTO	label100
04B0  0AF5  	INCF tm1638Upda_00022_2_i, F
04B1  2C93  	GOTO	label97
04B2        label100

        // display digit first
        if (iFlashDigitOff.0 && (i == iDigitToFlash))
0497  1C3F  	BTFSS gbl_iFlashDigitOff,0
0498  2CA0  	GOTO	label98
0499  0848  	MOVF gbl_iDigitToFlash, W
049A  0675  	XORWF tm1638Upda_00022_2_i, W
049B  1D03  	BTFSS STATUS,Z
049C  2CA0  	GOTO	label98
04A0        label98

            tm1638ByteWrite(0);
049D  01F6  	CLRF tm1638Byte_0001F_arg_bWrite
049E  215B  	CALL tm1638Byte_0001F

        else
049F  2CA8  	GOTO	label99
04A8        label99

            tm1638ByteWrite(tm1638Data[i]);
04A0  1383  	BCF	STATUS,IRP
04A1  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
04A2  0084  	MOVWF FSR
04A3  0875  	MOVF tm1638Upda_00022_2_i, W
04A4  0784  	ADDWF FSR, F
04A5  0800  	MOVF INDF, W
04A6  00F6  	MOVWF tm1638Byte_0001F_arg_bWrite
04A7  215B  	CALL tm1638Byte_0001F

        // then LED
        tm1638ByteWrite(tm1638LEDs[i]);
04A8  1383  	BCF	STATUS,IRP
04A9  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
04AA  0084  	MOVWF FSR
04AB  0875  	MOVF tm1638Upda_00022_2_i, W
04AC  0784  	ADDWF FSR, F
04AD  0800  	MOVF INDF, W
04AE  00F6  	MOVWF tm1638Byte_0001F_arg_bWrite
04AF  215B  	CALL tm1638Byte_0001F

    }
    tm1638strobe = 1;
04B2  1586  	BSF gbl_portb,3

}
04B3  0008  	RETURN


/*********************************************************************************************
  void tm1638ReadKeys()
  Reads the keys status into tm1638Keys
*********************************************************************************************/
void tm1638ReadKeys() {

    // Write 0x42 [01000010] to indicate command to read data
    tm1638strobe = 0;
07A8  1283  	BCF STATUS, RP0
07A9  1303  	BCF STATUS, RP1
07AA  1186  	BCF gbl_portb,3

    tm1638ByteWrite(tm1638ByteReadData);
07AB  0868  	MOVF gbl_tm1638ByteReadData, W
07AC  00F6  	MOVWF tm1638Byte_0001F_arg_bWrite
07AD  215B  	CALL tm1638Byte_0001F

    
    tm1638dioTris = 1; // Set data pin to input
07AE  1683  	BSF STATUS, RP0
07AF  1486  	BSF gbl_trisb,1

    char tm1638KeysTemp = 32;
07B0  3020  	MOVLW 0x20
07B1  1283  	BCF STATUS, RP0
07B2  00F2  	MOVWF tm1638Read_00025_1_tm1638K_00026

    // Read 4 bytes
    for (char i = 0; i < 32; i++) {
07B3  01F3  	CLRF tm1638Read_00025_2_i
07B4        label136
07B4  3020  	MOVLW 0x20
07B5  0273  	SUBWF tm1638Read_00025_2_i, W
07B6  1803  	BTFSC STATUS,C
07B7  2FC4  	GOTO	label138
07C2  0AF3  	INCF tm1638Read_00025_2_i, F
07C3  2FB4  	GOTO	label136
07C4        label138

        tm1638KeysTemp--;
07B8  03F2  	DECF tm1638Read_00025_1_tm1638K_00026, F

        tm1638clk = 0;
07B9  1106  	BCF gbl_portb,2

        delay_us(1);
07BA  3001  	MOVLW 0x01
07BB  00F8  	MOVWF delay_us_00000_arg_del
07BC  2010  	CALL delay_us_00000

        if(tm1638dio)
07BD  1C86  	BTFSS gbl_portb,1
07BE  2FC1  	GOTO	label137
07C1        label137

            tm1638KeysTemp <<= 1;
07BF  1003  	BCF STATUS,C
07C0  0DF2  	RLF tm1638Read_00025_1_tm1638K_00026, F

        tm1638clk = 1;
07C1  1506  	BSF gbl_portb,2

    }
    tm1638dioTris = 0; // Set data pin to output
07C4  1683  	BSF STATUS, RP0
07C5  1086  	BCF gbl_trisb,1

    tm1638strobe = 1;
07C6  1283  	BCF STATUS, RP0
07C7  1586  	BSF gbl_portb,3


    tm1638Keys = tm1638KeysTemp;
07C8  0872  	MOVF tm1638Read_00025_1_tm1638K_00026, W
07C9  00EB  	MOVWF gbl_tm1638Keys

    /*
    1F = 0001 1111
	17 = 0001 0111
	0F = 0000 1111
	07 = 0000 0111
	1B = 0001 1011
	13 = 0001 0011
	0B = 0000 1011
	03 = 0000 0111
	*/
}
07CA  0008  	RETURN


/*********************************************************************************************
  int intToBcd(int iValue)
  Used to split the 16 bit integer into bcd parts (max 9999)
*********************************************************************************************/
int intToBcd(int iValue) {

    int iBcdOut = 0;
018A  01FC  	CLRF intToBcd_00000_1_iBcdOut
018B  01FD  	CLRF intToBcd_00000_1_iBcdOut+D'1'

    // simple way, but more program memory needed for PIC12 or PIC16 (more than 100 words more)
    //iBcdOut = iValue / 1000;
    //iOutput += (iValue / 100) % 10;
    //iBcdOut += (iValue / 10) % 10;
    //iBcdOut += iValue % 10;
    
    // Double Dabble
    // Less program memory needed - may be slower executing
    // https://www.electro-tech-online.com/threads/32bit-bin2bcd-casting.126235/#post-1047937
    // Init the 16-bit BCD value to zero - output only supporting an input value up to 9999 in this implementation
    /*iBcdOut = 0;
    int iMask;
    // 48 loops
    // Shift 12 times
    for(char i = 0; i < 12; i++){
        // Check if any nibble is 5 or greater
        // Start with the right most nibble (digit), shifting 4 bits each time
        //for(; iMask != 0; iMask >>= 4){
        iMask = 0xF000; // Start checking the thousands digit 10^3
        for (char j = 0; j < 4; j++) {
            // For the digit we're checking, if bcd value is greater than or equal to 5, add 3
            if ((iMask & iBcdOut) >= (iMask & 0x5555))
                iBcdOut += (iMask & 0x3333); // Add 3
            iMask = iMask >> 4; // Shift the mask byte 4 bits (one nibble) right
        }
        // Shift bcd value
        iBcdOut <<= 1;
        // Increment bcd value (right most bit) if left most bit is set in the input byte
        if (iValue & 0x8000)
            iBcdOut++;
        // Shift input value
        iValue <<= 1;
    }*/
    
    // less program memory needed - may be slower executing
    // https://electronics.stackexchange.com/questions/158563/how-to-split-a-floating-point-number-into-individual-digits
    iBcdOut = 0;
018C  01FC  	CLRF intToBcd_00000_1_iBcdOut
018D  01FD  	CLRF intToBcd_00000_1_iBcdOut+D'1'


    // incrementing variables for each digit
    // determine to thousands digit
    while (iValue >= 1000) {
018E        label28
018E  3003  	MOVLW 0x03
018F  027B  	SUBWF intToBcd_00000_arg_iValue+D'1', W
0190  1D03  	BTFSS STATUS,Z
0191  2994  	GOTO	label29
0192  30E8  	MOVLW 0xE8
0193  027A  	SUBWF intToBcd_00000_arg_iValue, W
0194        label29
0194  1C03  	BTFSS STATUS,C
0195  29A1  	GOTO	label30
0196  1BFB  	BTFSC intToBcd_00000_arg_iValue+D'1',7
0197  29A1  	GOTO	label30
01A0  298E  	GOTO	label28
01A1        label30

        iValue -= 1000;
0198  30E8  	MOVLW 0xE8
0199  02FA  	SUBWF intToBcd_00000_arg_iValue, F
019A  3003  	MOVLW 0x03
019B  1C03  	BTFSS STATUS,C
019C  03FB  	DECF intToBcd_00000_arg_iValue+D'1', F
019D  02FB  	SUBWF intToBcd_00000_arg_iValue+D'1', F

        // each time we take off 1000, the digit is incremented
        iBcdOut += 0x1000;
019E  3010  	MOVLW 0x10
019F  07FD  	ADDWF intToBcd_00000_1_iBcdOut+D'1', F

    }

    // determine to hundreds digit
    while (iValue >= 100) {
01A1  087B  	MOVF intToBcd_00000_arg_iValue+D'1', W
01A2  3A80  	XORLW 0x80
01A3  00FE  	MOVWF CompTempVar648
01A4  3080  	MOVLW 0x80
01A5  027E  	SUBWF CompTempVar648, W
01A6  1D03  	BTFSS STATUS,Z
01A7  29AA  	GOTO	label31
01A8  3064  	MOVLW 0x64
01A9  027A  	SUBWF intToBcd_00000_arg_iValue, W
01AA        label31
01AA  1C03  	BTFSS STATUS,C
01AB  29B2  	GOTO	label32
01B1  29A1  	GOTO	label30
01B2        label32

        iValue -= 100;
01AC  3064  	MOVLW 0x64
01AD  02FA  	SUBWF intToBcd_00000_arg_iValue, F
01AE  1C03  	BTFSS STATUS,C
01AF  03FB  	DECF intToBcd_00000_arg_iValue+D'1', F

        // each time we take off 100, the digit is incremented
        iBcdOut += 0x100;
01B0  0AFD  	INCF intToBcd_00000_1_iBcdOut+D'1', F

    }

    // determine to tens digit
    while (iValue >= 10) {
01B2  087B  	MOVF intToBcd_00000_arg_iValue+D'1', W
01B3  3A80  	XORLW 0x80
01B4  00FE  	MOVWF CompTempVar649
01B5  3080  	MOVLW 0x80
01B6  027E  	SUBWF CompTempVar649, W
01B7  1D03  	BTFSS STATUS,Z
01B8  29BB  	GOTO	label33
01B9  300A  	MOVLW 0x0A
01BA  027A  	SUBWF intToBcd_00000_arg_iValue, W
01BB        label33
01BB  1C03  	BTFSS STATUS,C
01BC  29C6  	GOTO	label34
01C5  29B2  	GOTO	label32
01C6        label34

        iValue -= 10;
01BD  300A  	MOVLW 0x0A
01BE  02FA  	SUBWF intToBcd_00000_arg_iValue, F
01BF  1C03  	BTFSS STATUS,C
01C0  03FB  	DECF intToBcd_00000_arg_iValue+D'1', F

        // each time we take off 10, the left most digit is incremented
        iBcdOut += 0x10;
01C1  3010  	MOVLW 0x10
01C2  07FC  	ADDWF intToBcd_00000_1_iBcdOut, F
01C3  1803  	BTFSC STATUS,C
01C4  0AFD  	INCF intToBcd_00000_1_iBcdOut+D'1', F

    }

    // the last digit is what's left on iValue
    iBcdOut += iValue;
01C6  087A  	MOVF intToBcd_00000_arg_iValue, W
01C7  07FC  	ADDWF intToBcd_00000_1_iBcdOut, F
01C8  087B  	MOVF intToBcd_00000_arg_iValue+D'1', W
01C9  1803  	BTFSC STATUS,C
01CA  0AFD  	INCF intToBcd_00000_1_iBcdOut+D'1', F
01CB  07FD  	ADDWF intToBcd_00000_1_iBcdOut+D'1', F

}
01CC  0008  	RETURN


/*********************************************************************************************
  void convertTemp()
  Used to convert the ds18b20 temperature to display values
*********************************************************************************************/
void convertTemp() {

    // convert both bytes to a 16bit int - e.g. 0000 0001 0100 0110 (1 and 70, gives 326)
    signed int iTemp = (cTempH << 8) | cTempL;
0530  1283  	BCF STATUS, RP0
0531  1303  	BCF STATUS, RP1
0532  01F2  	CLRF convertTem_0002A_1_iTemp
0533  0849  	MOVF gbl_cTempH, W
0534  00F3  	MOVWF convertTem_0002A_1_iTemp+D'1'
0535  084A  	MOVF gbl_cTempL, W
0536  04F2  	IORWF convertTem_0002A_1_iTemp, F

    signed int iTemp2 = iTemp;
0537  0872  	MOVF convertTem_0002A_1_iTemp, W
0538  00F4  	MOVWF convertTem_0002A_1_iTemp2
0539  0873  	MOVF convertTem_0002A_1_iTemp+D'1', W
053A  00F5  	MOVWF convertTem_0002A_1_iTemp2+D'1'

    
    // this gets celcius * 100 - https://www.phanderson.com/PIC/PICC/sourceboost/ds18b20_1.html
    // Celcius value is always required for triggering
	gbDS3231IsMinus = (iTemp2 < 0);
053B  01CC  	CLRF gbl_gbDS3231IsMinus
053C  1BF5  	BTFSC convertTem_0002A_1_iTemp2+D'1',7
053D  0ACC  	INCF gbl_gbDS3231IsMinus, F

	if (gbDS3231IsMinus) {
053E  08CC  	MOVF gbl_gbDS3231IsMinus, F
053F  1903  	BTFSC STATUS,Z
0540  2D46  	GOTO	label103

		iTemp2 = ~iTemp2 + 1;
0541  09F4  	COMF convertTem_0002A_1_iTemp2, F
0542  09F5  	COMF convertTem_0002A_1_iTemp2+D'1', F
0543  0AF4  	INCF convertTem_0002A_1_iTemp2, F
0544  1903  	BTFSC STATUS,Z
0545  0AF5  	INCF convertTem_0002A_1_iTemp2+D'1', F
0546        label103

	}
    int iValueC = (6 * iTemp2) + (iTemp2 / 4);
0546  3006  	MOVLW 0x06
0547  00FA  	MOVWF __mul_16s__0000F_arg_a
0548  01FB  	CLRF __mul_16s__0000F_arg_a+D'1'
0549  0874  	MOVF convertTem_0002A_1_iTemp2, W
054A  00FC  	MOVWF __mul_16s__0000F_arg_b
054B  0875  	MOVF convertTem_0002A_1_iTemp2+D'1', W
054C  00FD  	MOVWF __mul_16s__0000F_arg_b+D'1'
054D  225F  	CALL __mul_16s__0000F
054E  1683  	BSF STATUS, RP0
054F  0822  	MOVF CompTempVarRet389, W
0550  1283  	BCF STATUS, RP0
0551  00F6  	MOVWF convertTem_0002A_1_iValueC
0552  1683  	BSF STATUS, RP0
0553  0823  	MOVF CompTempVarRet389+D'1', W
0554  1283  	BCF STATUS, RP0
0555  00F9  	MOVWF CompTempVar626
0556  0874  	MOVF convertTem_0002A_1_iTemp2, W
0557  00F8  	MOVWF CompTempVar623
0558  0875  	MOVF convertTem_0002A_1_iTemp2+D'1', W
0559  00F7  	MOVWF convertTem_0002A_1_iValueC+D'1'
055A  0D75  	RLF convertTem_0002A_1_iTemp2+D'1', W
055B  0CF7  	RRF convertTem_0002A_1_iValueC+D'1', F
055C  0CF8  	RRF CompTempVar623, F
055D  0D75  	RLF convertTem_0002A_1_iTemp2+D'1', W
055E  0CF7  	RRF convertTem_0002A_1_iValueC+D'1', F
055F  0CF8  	RRF CompTempVar623, F
0560  0878  	MOVF CompTempVar623, W
0561  07F6  	ADDWF convertTem_0002A_1_iValueC, F
0562  0879  	MOVF CompTempVar626, W
0563  1803  	BTFSC STATUS,C
0564  0AF7  	INCF convertTem_0002A_1_iValueC+D'1', F
0565  07F7  	ADDWF convertTem_0002A_1_iValueC+D'1', F

    // Split the temperature reading into digits
    giDS3231ValueBCD = intToBcd(iValueC);
0566  0876  	MOVF convertTem_0002A_1_iValueC, W
0567  00FA  	MOVWF intToBcd_00000_arg_iValue
0568  0877  	MOVF convertTem_0002A_1_iValueC+D'1', W
0569  00FB  	MOVWF intToBcd_00000_arg_iValue+D'1'
056A  218A  	CALL intToBcd_00000
056B  087C  	MOVF CompTempVarRet647, W
056C  00B3  	MOVWF gbl_giDS3231ValueBCD
056D  087D  	MOVF CompTempVarRet647+D'1', W
056E  00B4  	MOVWF gbl_giDS3231ValueBCD+D'1'

    // Truncated value for triggering heater/fans
    giDS3231ValueTruncCBCD = giDS3231ValueBCD >> 8;
056F  0834  	MOVF gbl_giDS3231ValueBCD+D'1', W
0570  00CB  	MOVWF gbl_giDS3231ValueTruncCBCD

    
    if (gcDisplayMode == 1) {
0571  034F  	DECF gbl_gcDisplayMode, W
0572  1D03  	BTFSS STATUS,Z

		// -17.8125 (-285/65251) results in minus fahrenheit (-0.125), -17.75 (-284/65250) results in positive fahrenheit (1)
        // this gets Fahrenheit * 10 - https://www.electro-tech-online.com/threads/temperature-sensor-ds18b20-display-fahrenhiet.117377/
        iTemp2 = ((iTemp + 4) / 8) + iTemp + 320;
0574  3004  	MOVLW 0x04
0575  0772  	ADDWF convertTem_0002A_1_iTemp, W
0576  00FB  	MOVWF CompTempVar638
0577  0873  	MOVF convertTem_0002A_1_iTemp+D'1', W
0578  00FD  	MOVWF CompTempVar641
0579  1803  	BTFSC STATUS,C
057A  0AFD  	INCF CompTempVar641, F
057B  087D  	MOVF CompTempVar641, W
057C  00FA  	MOVWF CompTempVar635
057D  0D7D  	RLF CompTempVar641, W
057E  0CFA  	RRF CompTempVar635, F
057F  0CFB  	RRF CompTempVar638, F
0580  0D7D  	RLF CompTempVar641, W
0581  0CFA  	RRF CompTempVar635, F
0582  0CFB  	RRF CompTempVar638, F
0583  0D7D  	RLF CompTempVar641, W
0584  0CFA  	RRF CompTempVar635, F
0585  0CFB  	RRF CompTempVar638, F
0586  0872  	MOVF convertTem_0002A_1_iTemp, W
0587  07FB  	ADDWF CompTempVar638, F
0588  0873  	MOVF convertTem_0002A_1_iTemp+D'1', W
0589  00FC  	MOVWF CompTempVar639
058A  087A  	MOVF CompTempVar635, W
058B  1803  	BTFSC STATUS,C
058C  0AFC  	INCF CompTempVar639, F
058D  07FC  	ADDWF CompTempVar639, F
058E  3040  	MOVLW 0x40
058F  07FB  	ADDWF CompTempVar638, F
0590  3001  	MOVLW 0x01
0591  1803  	BTFSC STATUS,C
0592  0AFC  	INCF CompTempVar639, F
0593  07FC  	ADDWF CompTempVar639, F
0594  087B  	MOVF CompTempVar638, W
0595  00F4  	MOVWF convertTem_0002A_1_iTemp2
0596  087C  	MOVF CompTempVar639, W
0597  00F5  	MOVWF convertTem_0002A_1_iTemp2+D'1'

        // convert to absolute value
        gbDS3231IsMinus = (iTemp2 < 0);
0598  01CC  	CLRF gbl_gbDS3231IsMinus
0599  1BF5  	BTFSC convertTem_0002A_1_iTemp2+D'1',7
059A  0ACC  	INCF gbl_gbDS3231IsMinus, F

        if (gbDS3231IsMinus) {
059B  08CC  	MOVF gbl_gbDS3231IsMinus, F
059C  1903  	BTFSC STATUS,Z
059D  2DA3  	GOTO	label104

            iTemp2 = ~iTemp2 + 1;
059E  09F4  	COMF convertTem_0002A_1_iTemp2, F
059F  09F5  	COMF convertTem_0002A_1_iTemp2+D'1', F
05A0  0AF4  	INCF convertTem_0002A_1_iTemp2, F
05A1  1903  	BTFSC STATUS,Z
05A2  0AF5  	INCF convertTem_0002A_1_iTemp2+D'1', F
05A3        label104

        }
        // Split the temperature reading into digits
        giDS3231ValueBCD = intToBcd(iTemp2);
05A3  0874  	MOVF convertTem_0002A_1_iTemp2, W
05A4  00FA  	MOVWF intToBcd_00000_arg_iValue
05A5  0875  	MOVF convertTem_0002A_1_iTemp2+D'1', W
05A6  00FB  	MOVWF intToBcd_00000_arg_iValue+D'1'
05A7  218A  	CALL intToBcd_00000
05A8  087C  	MOVF CompTempVarRet647, W
05A9  00B3  	MOVWF gbl_giDS3231ValueBCD
05AA  087D  	MOVF CompTempVarRet647+D'1', W
05AB  00B4  	MOVWF gbl_giDS3231ValueBCD+D'1'

	}
}
0573  0008  	RETURN
05AC  0008  	RETURN


/*********************************************************************************************
  void startTemp()
  Sends the Convert T [44h] function command to the ds18b20
*********************************************************************************************/
void startTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // 44 is the convert function
    oneWireTxBytes(0xCC, 0x44);
07CB  30CC  	MOVLW 0xCC
07CC  1283  	BCF STATUS, RP0
07CD  1303  	BCF STATUS, RP1
07CE  00F2  	MOVWF oneWireTxB_00019_arg_cData
07CF  3044  	MOVLW 0x44
07D0  00F3  	MOVWF oneWireTxB_00019_arg_cData2
07D1  24BC  	CALL oneWireTxB_00019

}
07D2  0008  	RETURN


/*********************************************************************************************
  void startTemp()
  Sends the Read Scratchpad [BEh] function command to the ds18b20
*********************************************************************************************/
void readTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // BE indicates to read scratchpad
    oneWireTxBytes(0xCC, 0xBE);
07D3  30CC  	MOVLW 0xCC
07D4  1283  	BCF STATUS, RP0
07D5  1303  	BCF STATUS, RP1
07D6  00F2  	MOVWF oneWireTxB_00019_arg_cData
07D7  30BE  	MOVLW 0xBE
07D8  00F3  	MOVWF oneWireTxB_00019_arg_cData2
07D9  24BC  	CALL oneWireTxB_00019

    // Now get the temperature from the scratchpad
    // This is in the first two bytes - so get those only and ignore the rest
    cTempL = oneWireRxByte();
07DA  24C3  	CALL oneWireRxB_0001A
07DB  0873  	MOVF CompTempVarRet551, W
07DC  00CA  	MOVWF gbl_cTempL

    cTempH = oneWireRxByte();
07DD  24C3  	CALL oneWireRxB_0001A
07DE  0873  	MOVF CompTempVarRet551, W
07DF  00C9  	MOVWF gbl_cTempH

}
07E0  0008  	RETURN


/*********************************************************************************************
  char bcdAdjust(char bcd, char bcdMax, char bcdMin)
  Increment or Decrement a BCD variable for sending to the DS3231, within a given range
  Must set iBcdAdjustment first
*********************************************************************************************/
char bcdAdjust(char bcd, char bcdMax, char bcdMin) {

    if (iBcdAdjustment == 1) {
0235  036F  	DECF gbl_iBcdAdjustment, W
0236  1D03  	BTFSS STATUS,Z
0237  2A4B  	GOTO	label46
024B        label46

        // Increment
        // if at maximum, reset to minimum
        if (bcd == bcdMax)
0238  0875  	MOVF bcdAdjust_00000_arg_bcdMax, W
0239  0674  	XORWF bcdAdjust_00000_arg_bcd, W
023A  1D03  	BTFSS STATUS,Z
023B  2A3F  	GOTO	label44
023F        label44

            bcd = bcdMin;
023C  0876  	MOVF bcdAdjust_00000_arg_bcdMin, W
023D  00F4  	MOVWF bcdAdjust_00000_arg_bcd

        else if ((bcd & 0x0F) == 9)
023E  2A5C  	GOTO	label49
023F  300F  	MOVLW 0x0F
0240  0574  	ANDWF bcdAdjust_00000_arg_bcd, W
0241  00F7  	MOVWF CompTempVar612
0242  0877  	MOVF CompTempVar612, W
0243  3A09  	XORLW 0x09
0244  1D03  	BTFSS STATUS,Z
0245  2A49  	GOTO	label45
0249        label45

            bcd += 0x07; // add 0x10 (16), minus 9
0246  3007  	MOVLW 0x07
0247  07F4  	ADDWF bcdAdjust_00000_arg_bcd, F

        else
0248  2A5C  	GOTO	label49

            bcd++;
0249  0AF4  	INCF bcdAdjust_00000_arg_bcd, F

    } else {
024A  2A5C  	GOTO	label49

        // Decrement
        // if at minimum, reset to maximum
        if (bcd == bcdMin)
024B  0876  	MOVF bcdAdjust_00000_arg_bcdMin, W
024C  0674  	XORWF bcdAdjust_00000_arg_bcd, W
024D  1D03  	BTFSS STATUS,Z
024E  2A52  	GOTO	label47
0252        label47

            bcd = bcdMax;
024F  0875  	MOVF bcdAdjust_00000_arg_bcdMax, W
0250  00F4  	MOVWF bcdAdjust_00000_arg_bcd

        else if ((bcd & 0x0F) == 0)
0251  2A5C  	GOTO	label49
0252  300F  	MOVLW 0x0F
0253  0574  	ANDWF bcdAdjust_00000_arg_bcd, W
0254  00F7  	MOVWF CompTempVar613
0255  08F7  	MOVF CompTempVar613, F
0256  1D03  	BTFSS STATUS,Z
0257  2A5B  	GOTO	label48
025B        label48

            bcd -= 0x07; // minus 0x10 (16), add 9
0258  3007  	MOVLW 0x07
0259  02F4  	SUBWF bcdAdjust_00000_arg_bcd, F

        else
025A  2A5C  	GOTO	label49
025C        label49

            bcd--;
025B  03F4  	DECF bcdAdjust_00000_arg_bcd, F

    }
    return bcd;
025C  0874  	MOVF bcdAdjust_00000_arg_bcd, W
025D  00F7  	MOVWF CompTempVarRet611

}
025E  0008  	RETURN


/*********************************************************************************************
  void adjustDateTime()
  Increment or Decrement a BCD variable for sending to the DS3231, within a given range
  Must set iBcdAdjustment first
*********************************************************************************************/
void adjustDateTime() {

    switch (gcSetMode) {

        case 1:
0723  1283  	BCF STATUS, RP0
0724  1303  	BCF STATUS, RP1
0725  0850  	MOVF gbl_gcSetMode, W
0726  3A01  	XORLW 0x01
0727  1903  	BTFSC STATUS,Z
0728  2F3C  	GOTO	label125
073C        label125

            // Setting year
            gBcdYear = bcdAdjust(gBcdYear, 0x99, 0x00);
073C  083B  	MOVF gbl_gBcdYear, W
073D  00F4  	MOVWF bcdAdjust_00000_arg_bcd
073E  3099  	MOVLW 0x99
073F  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
0740  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
0741  2235  	CALL bcdAdjust_00000
0742  0877  	MOVF CompTempVarRet611, W
0743  00BB  	MOVWF gbl_gBcdYear

            break;
        case 2:
0729  3A03  	XORLW 0x03
072A  1903  	BTFSC STATUS,Z
072B  2F45  	GOTO	label126
0745        label126

            // Setting month
            gBcdMonth = bcdAdjust(gBcdMonth, 0x12, 0x01);
0745  083A  	MOVF gbl_gBcdMonth, W
0746  00F4  	MOVWF bcdAdjust_00000_arg_bcd
0747  3012  	MOVLW 0x12
0748  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
0749  3001  	MOVLW 0x01
074A  00F6  	MOVWF bcdAdjust_00000_arg_bcdMin
074B  2235  	CALL bcdAdjust_00000
074C  0877  	MOVF CompTempVarRet611, W
074D  00BA  	MOVWF gbl_gBcdMonth

            break;
        case 3:
072C  3A01  	XORLW 0x01
072D  1903  	BTFSC STATUS,Z
072E  2F4F  	GOTO	label127
074F        label127

            // Setting day of month
            char iMonth = gBcdMonth;
074F  083A  	MOVF gbl_gBcdMonth, W
0750  00F2  	MOVWF adjustDate_00027_1_iMonth

            if (iMonth & 0xF0)
0751  30F0  	MOVLW 0xF0
0752  0572  	ANDWF adjustDate_00027_1_iMonth, W
0753  1903  	BTFSC STATUS,Z
0754  2F5A  	GOTO	label128
075A        label128

                iMonth += (gBcdMonth >> 4);
0755  0E3A  	SWAPF gbl_gBcdMonth, W
0756  390F  	ANDLW 0x0F
0757  00F4  	MOVWF CompTempVar614
0758  0874  	MOVF CompTempVar614, W
0759  07F2  	ADDWF adjustDate_00027_1_iMonth, F

            iMonth--; // Make 0 to 11 index based
075A  03F2  	DECF adjustDate_00027_1_iMonth, F

            char bcdMaxDay = gDaysInMonth[iMonth]; 
075B  083C  	MOVF gbl_gDaysInMonth, W
075C  00FB  	MOVWF __rom_get_00000_arg_objNumb
075D  0872  	MOVF adjustDate_00027_1_iMonth, W
075E  00FC  	MOVWF __rom_get_00000_arg_idx
075F  201A  	CALL __rom_get_00000
0760  00F3  	MOVWF adjustDate_00027_1_bcdMaxDay

            // If February, adjust max days for leap years
            if (iMonth == 1) {
0761  0372  	DECF adjustDate_00027_1_iMonth, W
0762  118A  	BCF PCLATH,3
0763  120A  	BCF PCLATH,4
0764  1D03  	BTFSS STATUS,Z
0765  2F7C  	GOTO	label131

                // See if the 24 leap years since 2000 match the current year
                for (char i = 0; i < 24; i++) {
0766  01F4  	CLRF adjustDate_00027_16_i
0767        label129
0767  3018  	MOVLW 0x18
0768  0274  	SUBWF adjustDate_00027_16_i, W
0769  1803  	BTFSC STATUS,C
076A  2F7C  	GOTO	label131
077A  0AF4  	INCF adjustDate_00027_16_i, F
077B  2F67  	GOTO	label129
077C        label131

                    if (gLeapYears[i] == gBcdYear) {
076B  083D  	MOVF gbl_gLeapYears, W
076C  00FB  	MOVWF __rom_get_00000_arg_objNumb
076D  0874  	MOVF adjustDate_00027_16_i, W
076E  00FC  	MOVWF __rom_get_00000_arg_idx
076F  201A  	CALL __rom_get_00000
0770  00F5  	MOVWF CompTempVar615
0771  083B  	MOVF gbl_gBcdYear, W
0772  0675  	XORWF CompTempVar615, W
0773  118A  	BCF PCLATH,3
0774  120A  	BCF PCLATH,4
0775  1D03  	BTFSS STATUS,Z
0776  2F7A  	GOTO	label130
077A        label130

                        bcdMaxDay = 0x29;
0777  3029  	MOVLW 0x29
0778  00F3  	MOVWF adjustDate_00027_1_bcdMaxDay

                        break;
0779  2F7C  	GOTO	label131

                    }
                }
            }
            gBcdDayOfMonth = bcdAdjust(gBcdDayOfMonth, bcdMaxDay, 0x01);
077C  0839  	MOVF gbl_gBcdDayOfMonth, W
077D  00F4  	MOVWF bcdAdjust_00000_arg_bcd
077E  0873  	MOVF adjustDate_00027_1_bcdMaxDay, W
077F  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
0780  3001  	MOVLW 0x01
0781  00F6  	MOVWF bcdAdjust_00000_arg_bcdMin
0782  2235  	CALL bcdAdjust_00000
0783  0877  	MOVF CompTempVarRet611, W
0784  00B9  	MOVWF gbl_gBcdDayOfMonth

            break;
        case 4:
072F  3A07  	XORLW 0x07
0730  1903  	BTFSC STATUS,Z
0731  2F86  	GOTO	label132
0786        label132

            // Setting day of week
            gDayOfWeek = bcdAdjust(gDayOfWeek, 0x07, 0x01);
0786  0838  	MOVF gbl_gDayOfWeek, W
0787  00F4  	MOVWF bcdAdjust_00000_arg_bcd
0788  3007  	MOVLW 0x07
0789  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
078A  3001  	MOVLW 0x01
078B  00F6  	MOVWF bcdAdjust_00000_arg_bcdMin
078C  2235  	CALL bcdAdjust_00000
078D  0877  	MOVF CompTempVarRet611, W
078E  00B8  	MOVWF gbl_gDayOfWeek

            break;
        case 5:
0732  3A01  	XORLW 0x01
0733  1903  	BTFSC STATUS,Z
0734  2F90  	GOTO	label133
0790        label133

            // Setting 12h/24h
            gcHourMode++;
0790  0AD1  	INCF gbl_gcHourMode, F

            if (gcHourMode > 2)
0791  0851  	MOVF gbl_gcHourMode, W
0792  3C02  	SUBLW 0x02
0793  1C03  	BTFSS STATUS,C

				gcHourMode = 0;
0794  01D1  	CLRF gbl_gcHourMode

            break;
        case 6:
0735  3A03  	XORLW 0x03
0736  1903  	BTFSC STATUS,Z
0737  2F96  	GOTO	label134
0796        label134

            // Setting hour
            gBcdHour = bcdAdjust(gBcdHour, 0x23, 0x00);
0796  0837  	MOVF gbl_gBcdHour, W
0797  00F4  	MOVWF bcdAdjust_00000_arg_bcd
0798  3023  	MOVLW 0x23
0799  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
079A  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
079B  2235  	CALL bcdAdjust_00000
079C  0877  	MOVF CompTempVarRet611, W
079D  00B7  	MOVWF gbl_gBcdHour

            break;
        case 7:
0738  3A01  	XORLW 0x01
0739  1903  	BTFSC STATUS,Z
073A  2F9F  	GOTO	label135
079F        label135

            // Setting minute
            gBcdMinute = bcdAdjust(gBcdMinute, 0x59, 0x00);
079F  0836  	MOVF gbl_gBcdMinute, W
07A0  00F4  	MOVWF bcdAdjust_00000_arg_bcd
07A1  3059  	MOVLW 0x59
07A2  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
07A3  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
07A4  2235  	CALL bcdAdjust_00000
07A5  0877  	MOVF CompTempVarRet611, W
07A6  00B6  	MOVWF gbl_gBcdMinute

            break;
    }
}
073B  0008  	RETURN
0744  0008  	RETURN
074E  0008  	RETURN
0785  0008  	RETURN
078F  0008  	RETURN
0795  0008  	RETURN
079E  0008  	RETURN
07A7  0008  	RETURN


/*********************************************************************************************
  void adjustTrigger()
  Increment or Decrement a trigger time or temperate
  Must set iBcdAdjustment first
*********************************************************************************************/
void adjustTrigger() {

    switch (gcTriggerMode) {

        case 1:
0650  1283  	BCF STATUS, RP0
0651  1303  	BCF STATUS, RP1
0652  0852  	MOVF gbl_gcTriggerMode, W
0653  3A01  	XORLW 0x01
0654  1903  	BTFSC STATUS,Z
0655  2E84  	GOTO	label107
0684        label107

            // White LED on hour
            gBcdWhiteOnHour = bcdAdjust(gBcdWhiteOnHour, 0x23, 0x00);
0684  0854  	MOVF gbl_gBcdWhiteOnHour, W
0685  00F4  	MOVWF bcdAdjust_00000_arg_bcd
0686  3023  	MOVLW 0x23
0687  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
0688  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
0689  2235  	CALL bcdAdjust_00000
068A  0877  	MOVF CompTempVarRet611, W
068B  00D4  	MOVWF gbl_gBcdWhiteOnHour

            break;
        case 2:
0656  3A03  	XORLW 0x03
0657  1903  	BTFSC STATUS,Z
0658  2E8D  	GOTO	label108
068D        label108

            // White LED on minute
            gBcdWhiteOnMinute = bcdAdjust(gBcdWhiteOnMinute, 0x59, 0x00);
068D  0853  	MOVF gbl_gBcdWhiteOnMinute, W
068E  00F4  	MOVWF bcdAdjust_00000_arg_bcd
068F  3059  	MOVLW 0x59
0690  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
0691  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
0692  2235  	CALL bcdAdjust_00000
0693  0877  	MOVF CompTempVarRet611, W
0694  00D3  	MOVWF gbl_gBcdWhiteOnMinute

            break;
        case 3:
0659  3A01  	XORLW 0x01
065A  1903  	BTFSC STATUS,Z
065B  2E96  	GOTO	label109
0696        label109

            // White LED off hour
            gBcdWhiteOffHour = bcdAdjust(gBcdWhiteOffHour, 0x23, 0x00);
0696  0856  	MOVF gbl_gBcdWhiteOffHour, W
0697  00F4  	MOVWF bcdAdjust_00000_arg_bcd
0698  3023  	MOVLW 0x23
0699  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
069A  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
069B  2235  	CALL bcdAdjust_00000
069C  0877  	MOVF CompTempVarRet611, W
069D  00D6  	MOVWF gbl_gBcdWhiteOffHour

            break;
        case 4:
065C  3A07  	XORLW 0x07
065D  1903  	BTFSC STATUS,Z
065E  2E9F  	GOTO	label110
069F        label110

            // White LED off minute
            gBcdWhiteOffMinute = bcdAdjust(gBcdWhiteOffMinute, 0x59, 0x00);
069F  0855  	MOVF gbl_gBcdWhiteOffMinute, W
06A0  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06A1  3059  	MOVLW 0x59
06A2  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06A3  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06A4  2235  	CALL bcdAdjust_00000
06A5  0877  	MOVF CompTempVarRet611, W
06A6  00D5  	MOVWF gbl_gBcdWhiteOffMinute

            break;
        case 5:
065F  3A01  	XORLW 0x01
0660  1903  	BTFSC STATUS,Z
0661  2EA8  	GOTO	label111
06A8        label111

            // Blue LED on hour
            gBcdBlueOnHour = bcdAdjust(gBcdBlueOnHour, 0x23, 0x00);
06A8  0858  	MOVF gbl_gBcdBlueOnHour, W
06A9  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06AA  3023  	MOVLW 0x23
06AB  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06AC  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06AD  2235  	CALL bcdAdjust_00000
06AE  0877  	MOVF CompTempVarRet611, W
06AF  00D8  	MOVWF gbl_gBcdBlueOnHour

            break;
        case 6:
0662  3A03  	XORLW 0x03
0663  1903  	BTFSC STATUS,Z
0664  2EB1  	GOTO	label112
06B1        label112

            // Blue LED on minute
            gBcdBlueOnMinute = bcdAdjust(gBcdBlueOnMinute, 0x59, 0x00);
06B1  0857  	MOVF gbl_gBcdBlueOnMinute, W
06B2  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06B3  3059  	MOVLW 0x59
06B4  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06B5  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06B6  2235  	CALL bcdAdjust_00000
06B7  0877  	MOVF CompTempVarRet611, W
06B8  00D7  	MOVWF gbl_gBcdBlueOnMinute

            break;
        case 7:
0665  3A01  	XORLW 0x01
0666  1903  	BTFSC STATUS,Z
0667  2EBA  	GOTO	label113
06BA        label113

            // Blue LED off hour
            gBcdBlueOffHour = bcdAdjust(gBcdBlueOffHour, 0x23, 0x00);
06BA  085A  	MOVF gbl_gBcdBlueOffHour, W
06BB  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06BC  3023  	MOVLW 0x23
06BD  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06BE  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06BF  2235  	CALL bcdAdjust_00000
06C0  0877  	MOVF CompTempVarRet611, W
06C1  00DA  	MOVWF gbl_gBcdBlueOffHour

            break;
        case 8:
0668  3A0F  	XORLW 0x0F
0669  1903  	BTFSC STATUS,Z
066A  2EC3  	GOTO	label114
06C3        label114

            // Blue LED off minute
            gBcdBlueOffMinute = bcdAdjust(gBcdBlueOffMinute, 0x59, 0x00);
06C3  0859  	MOVF gbl_gBcdBlueOffMinute, W
06C4  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06C5  3059  	MOVLW 0x59
06C6  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06C7  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06C8  2235  	CALL bcdAdjust_00000
06C9  0877  	MOVF CompTempVarRet611, W
06CA  00D9  	MOVWF gbl_gBcdBlueOffMinute

            break;
        case 9:
066B  3A01  	XORLW 0x01
066C  1903  	BTFSC STATUS,Z
066D  2ECC  	GOTO	label115
06CC        label115

            // Blue LED on hour
            gBcdBlue2OnHour = bcdAdjust(gBcdBlue2OnHour, 0x23, 0x00);
06CC  085C  	MOVF gbl_gBcdBlue2OnHour, W
06CD  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06CE  3023  	MOVLW 0x23
06CF  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06D0  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06D1  2235  	CALL bcdAdjust_00000
06D2  0877  	MOVF CompTempVarRet611, W
06D3  00DC  	MOVWF gbl_gBcdBlue2OnHour

            break;
        case 10:
066E  3A03  	XORLW 0x03
066F  1903  	BTFSC STATUS,Z
0670  2ED5  	GOTO	label116
06D5        label116

            // Blue LED on minute
            gBcdBlue2OnMinute = bcdAdjust(gBcdBlue2OnMinute, 0x59, 0x00);
06D5  085B  	MOVF gbl_gBcdBlue2OnMinute, W
06D6  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06D7  3059  	MOVLW 0x59
06D8  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06D9  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06DA  2235  	CALL bcdAdjust_00000
06DB  0877  	MOVF CompTempVarRet611, W
06DC  00DB  	MOVWF gbl_gBcdBlue2OnMinute

            break;
        case 11:
0671  3A01  	XORLW 0x01
0672  1903  	BTFSC STATUS,Z
0673  2EDE  	GOTO	label117
06DE        label117

            // Blue LED off hour
            gBcdBlue2OffHour = bcdAdjust(gBcdBlue2OffHour, 0x23, 0x00);
06DE  085E  	MOVF gbl_gBcdBlue2OffHour, W
06DF  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06E0  3023  	MOVLW 0x23
06E1  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06E2  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06E3  2235  	CALL bcdAdjust_00000
06E4  0877  	MOVF CompTempVarRet611, W
06E5  00DE  	MOVWF gbl_gBcdBlue2OffHour

            break;
        case 12:
0674  3A07  	XORLW 0x07
0675  1903  	BTFSC STATUS,Z
0676  2EE7  	GOTO	label118
06E7        label118

            // Blue LED off minute
            gBcdBlue2OffMinute = bcdAdjust(gBcdBlue2OffMinute, 0x59, 0x00);
06E7  085D  	MOVF gbl_gBcdBlue2OffMinute, W
06E8  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06E9  3059  	MOVLW 0x59
06EA  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06EB  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
06EC  2235  	CALL bcdAdjust_00000
06ED  0877  	MOVF CompTempVarRet611, W
06EE  00DD  	MOVWF gbl_gBcdBlue2OffMinute

            break;
        case 13:
0677  3A01  	XORLW 0x01
0678  1903  	BTFSC STATUS,Z
0679  2EF0  	GOTO	label119
06F0        label119

            // Fan on temp - between 20 and 40 degrees C
            gBcdFanOnTemp = bcdAdjust(gBcdFanOnTemp, 0x40, 0x20);
06F0  085F  	MOVF gbl_gBcdFanOnTemp, W
06F1  00F4  	MOVWF bcdAdjust_00000_arg_bcd
06F2  3040  	MOVLW 0x40
06F3  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
06F4  3020  	MOVLW 0x20
06F5  00F6  	MOVWF bcdAdjust_00000_arg_bcdMin
06F6  2235  	CALL bcdAdjust_00000
06F7  0877  	MOVF CompTempVarRet611, W
06F8  00DF  	MOVWF gbl_gBcdFanOnTemp

            break;
        case 14:
067A  3A03  	XORLW 0x03
067B  1903  	BTFSC STATUS,Z
067C  2EFA  	GOTO	label120
06FA        label120

            // Fan off temp - off must be lower than on, min 20 degrees C
            if (gBcdFanOffTemp > gBcdFanOnTemp)
06FA  0860  	MOVF gbl_gBcdFanOffTemp, W
06FB  025F  	SUBWF gbl_gBcdFanOnTemp, W
06FC  1803  	BTFSC STATUS,C
06FD  2F00  	GOTO	label121
0700        label121

				gBcdFanOffTemp = gBcdFanOnTemp;
06FE  085F  	MOVF gbl_gBcdFanOnTemp, W
06FF  00E0  	MOVWF gbl_gBcdFanOffTemp

            gBcdFanOffTemp = bcdAdjust(gBcdFanOffTemp, gBcdFanOnTemp, 0x20);
0700  0860  	MOVF gbl_gBcdFanOffTemp, W
0701  00F4  	MOVWF bcdAdjust_00000_arg_bcd
0702  085F  	MOVF gbl_gBcdFanOnTemp, W
0703  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
0704  3020  	MOVLW 0x20
0705  00F6  	MOVWF bcdAdjust_00000_arg_bcdMin
0706  2235  	CALL bcdAdjust_00000
0707  0877  	MOVF CompTempVarRet611, W
0708  00E0  	MOVWF gbl_gBcdFanOffTemp

            break;
        case 15:
067D  3A01  	XORLW 0x01
067E  1903  	BTFSC STATUS,Z
067F  2F0A  	GOTO	label122
070A        label122

            // Heater on temp - between 0 and 40 degrees C
            gBcdHeaterOnTemp = bcdAdjust(gBcdHeaterOnTemp, 0x40, 0);
070A  0861  	MOVF gbl_gBcdHeaterOnTemp, W
070B  00F4  	MOVWF bcdAdjust_00000_arg_bcd
070C  3040  	MOVLW 0x40
070D  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
070E  01F6  	CLRF bcdAdjust_00000_arg_bcdMin
070F  2235  	CALL bcdAdjust_00000
0710  0877  	MOVF CompTempVarRet611, W
0711  00E1  	MOVWF gbl_gBcdHeaterOnTemp

            break;
        case 16:
0680  3A1F  	XORLW 0x1F
0681  1903  	BTFSC STATUS,Z
0682  2F13  	GOTO	label123
0713        label123

            // Heater off temp - off must be equal or higher than on - max 40 degrees C
            if (gBcdHeaterOffTemp < gBcdHeaterOnTemp)
0713  0861  	MOVF gbl_gBcdHeaterOnTemp, W
0714  0262  	SUBWF gbl_gBcdHeaterOffTemp, W
0715  1803  	BTFSC STATUS,C
0716  2F19  	GOTO	label124
0719        label124

				gBcdHeaterOffTemp = gBcdHeaterOnTemp;
0717  0861  	MOVF gbl_gBcdHeaterOnTemp, W
0718  00E2  	MOVWF gbl_gBcdHeaterOffTemp

            gBcdHeaterOffTemp = bcdAdjust(gBcdHeaterOffTemp, 0x40, gBcdHeaterOnTemp);
0719  0862  	MOVF gbl_gBcdHeaterOffTemp, W
071A  00F4  	MOVWF bcdAdjust_00000_arg_bcd
071B  3040  	MOVLW 0x40
071C  00F5  	MOVWF bcdAdjust_00000_arg_bcdMax
071D  0861  	MOVF gbl_gBcdHeaterOnTemp, W
071E  00F6  	MOVWF bcdAdjust_00000_arg_bcdMin
071F  2235  	CALL bcdAdjust_00000
0720  0877  	MOVF CompTempVarRet611, W
0721  00E2  	MOVWF gbl_gBcdHeaterOffTemp

            break;
    }
}
0683  0008  	RETURN
068C  0008  	RETURN
0695  0008  	RETURN
069E  0008  	RETURN
06A7  0008  	RETURN
06B0  0008  	RETURN
06B9  0008  	RETURN
06C2  0008  	RETURN
06CB  0008  	RETURN
06D4  0008  	RETURN
06DD  0008  	RETURN
06E6  0008  	RETURN
06EF  0008  	RETURN
06F9  0008  	RETURN
0709  0008  	RETURN
0712  0008  	RETURN
0722  0008  	RETURN


/*********************************************************************************************
  void processKeys()
  Action a key press
*********************************************************************************************/
void processKeys() {

    switch (tm1638Keys) {

        case 0x1F:
07E1  1283  	BCF STATUS, RP0
07E2  1303  	BCF STATUS, RP1
07E3  086B  	MOVF gbl_tm1638Keys, W
07E4  3A1F  	XORLW 0x1F
07E5  1903  	BTFSC STATUS,Z
07E6  2FFE  	GOTO	label139
07FE        label139

            // Toggle white light on/off
            WHITE_LED = !WHITE_LED;
07FE  01F2  	CLRF CompTempVar616
07FF  1C87  	BTFSS gbl_portc,1
0800  0AF2  	INCF CompTempVar616, F
0801  1872  	BTFSC CompTempVar616,0
0802  1487  	BSF gbl_portc,1
0803  1C72  	BTFSS CompTempVar616,0
0804  1087  	BCF gbl_portc,1

            break;
        case 0x17:
07E7  3A08  	XORLW 0x08
07E8  158A  	BSF PCLATH,3
07E9  1903  	BTFSC STATUS,Z
07EA  2806  	GOTO	label140
0806        label140

            // Toggle blue light on/off
            BLUE_LED = !BLUE_LED;
0806  01F2  	CLRF CompTempVar617
0807  1D07  	BTFSS gbl_portc,2
0808  0AF2  	INCF CompTempVar617, F
0809  1872  	BTFSC CompTempVar617,0
080A  1507  	BSF gbl_portc,2
080B  1C72  	BTFSS CompTempVar617,0
080C  1107  	BCF gbl_portc,2

            break;
        case 0x0F:
07EB  3A18  	XORLW 0x18
07EC  1903  	BTFSC STATUS,Z
07ED  280E  	GOTO	label141
080E        label141

            // Toggle fan on/off
            gbFanOn = !gbFanOn;
080E  01F2  	CLRF CompTempVar618
080F  1D4E  	BTFSS gbl_gbFanOn,2
0810  0AF2  	INCF CompTempVar618, F
0811  114E  	BCF gbl_gbFanOn,2
0812  0872  	MOVF CompTempVar618, W
0813  1D03  	BTFSS STATUS,Z
0814  154E  	BSF gbl_gbFanOn,2

            break;
        case 0x07:
07EE  3A08  	XORLW 0x08
07EF  1903  	BTFSC STATUS,Z
07F0  2816  	GOTO	label142
0816        label142

            // Exit other modes
            gcSetMode = 0;
0816  01D0  	CLRF gbl_gcSetMode

            gcTriggerMode = 0;
0817  01D2  	CLRF gbl_gcTriggerMode

            // Display temp C/temp F/date
            gcDisplayMode++;
0818  0ACF  	INCF gbl_gcDisplayMode, F

            if (gcDisplayMode > 3)
0819  084F  	MOVF gbl_gcDisplayMode, W
081A  3C03  	SUBLW 0x03
081B  1C03  	BTFSS STATUS,C

                gcDisplayMode = 0;
081C  01CF  	CLRF gbl_gcDisplayMode

            convertTemp(); // force conversion (no read)
081D  118A  	BCF PCLATH,3
081E  2530  	CALL convertTem_0002A

            break;
        case 0x1B:
07F1  3A1C  	XORLW 0x1C
07F2  1903  	BTFSC STATUS,Z
07F3  2820  	GOTO	label143
0820        label143

            // Exit other modes
            gcTriggerMode = 0;
0820  01D2  	CLRF gbl_gcTriggerMode

            // Adjust set mode
            gcSetMode++;
0821  0AD0  	INCF gbl_gcSetMode, F

            if (gcSetMode > 7) {
0822  0850  	MOVF gbl_gcSetMode, W
0823  3C07  	SUBLW 0x07
0824  1803  	BTFSC STATUS,C

                ds3231WriteDateTime();
0826  118A  	BCF PCLATH,3
0827  24F4  	CALL ds3231Writ_0001C

                gcSetMode = 0;
0828  01D0  	CLRF gbl_gcSetMode

            }
            break;
        case 0x13:
07F4  3A08  	XORLW 0x08
07F5  1903  	BTFSC STATUS,Z
07F6  282A  	GOTO	label144
082A        label144

            // Adjust down
            iBcdAdjustment = 0;
082A  01EF  	CLRF gbl_iBcdAdjustment

            if (gcSetMode) {
082B  08D0  	MOVF gbl_gcSetMode, F
082C  1903  	BTFSC STATUS,Z
082D  2831  	GOTO	label145
0831        label145

                adjustDateTime();
082E  118A  	BCF PCLATH,3
082F  2723  	CALL adjustDate_00027

            } else if (gcTriggerMode) {
0831  08D2  	MOVF gbl_gcTriggerMode, F
0833  1D03  	BTFSS STATUS,Z

                adjustTrigger();
0832  118A  	BCF PCLATH,3
0834  2650  	CALL adjustTrig_00028

            }
            break;
        case 0x0B:
07F7  3A18  	XORLW 0x18
07F8  1903  	BTFSC STATUS,Z
07F9  2836  	GOTO	label146
0836        label146

            iBcdAdjustment = 1;
0836  3001  	MOVLW 0x01
0837  00EF  	MOVWF gbl_iBcdAdjustment

            // Adjust up
            if (gcSetMode) {
0838  08D0  	MOVF gbl_gcSetMode, F
0839  1903  	BTFSC STATUS,Z
083A  283E  	GOTO	label147
083E        label147

                adjustDateTime();
083B  118A  	BCF PCLATH,3
083C  2723  	CALL adjustDate_00027

            } else if (gcTriggerMode) {
083E  08D2  	MOVF gbl_gcTriggerMode, F
0840  1D03  	BTFSS STATUS,Z

                adjustTrigger();
083F  118A  	BCF PCLATH,3
0841  2650  	CALL adjustTrig_00028

            }
            break;
        case 0x03:
07FA  3A08  	XORLW 0x08
07FB  1903  	BTFSC STATUS,Z
07FC  2843  	GOTO	label148
0843        label148

            // Exit set mode
            gcSetMode = 0;
0843  01D0  	CLRF gbl_gcSetMode

            // Adjust timer mode
            gcTriggerMode++;
0844  0AD2  	INCF gbl_gcTriggerMode, F

            if (gcTriggerMode > 12) {
0845  0852  	MOVF gbl_gcTriggerMode, W
0846  3C0C  	SUBLW 0x0C
0847  1803  	BTFSC STATUS,C

                gcTriggerMode = 0;
0849  01D2  	CLRF gbl_gcTriggerMode

                at24c32WriteAll(); // Exiting trigger mode, save the new triggers to EEPROM chip
084A  118A  	BCF PCLATH,3
084B  25AD  	CALL at24c32Wri_0002B

            }
            break;
    }
}
07FD  0008  	RETURN
0805  0008  	RETURN
080D  0008  	RETURN
0815  0008  	RETURN
081F  0008  	RETURN
0825  0008  	RETURN
0829  0008  	RETURN
0830  0008  	RETURN
0835  0008  	RETURN
083D  0008  	RETURN
0842  0008  	RETURN
0848  0008  	RETURN
084C  0008  	RETURN


/*********************************************************************************************
  void interrupt()
  Interrupt handler
*********************************************************************************************/
void interrupt() {

    // Interrupt on timer0 - flash digit delay
    if (intcon.T0IF) {
0A0C  1D0B  	BTFSS gbl_intcon,2
0A0D  2A15  	GOTO	label175
0A15        label175

        iTimer0Counts++;
0A0E  1283  	BCF STATUS, RP0
0A0F  1303  	BCF STATUS, RP1
0A10  0ABE  	INCF gbl_iTimer0Counts, F

        tmr0 = TMR0PRELOAD;
0A11  303D  	MOVLW 0x3D
0A12  0081  	MOVWF gbl_tmr0

        cTask.TASK_TIMER0 = 1;
0A13  14CD  	BSF gbl_cTask,1

        // Clear interrupt flag
        intcon.T0IF = 0; 
0A14  110B  	BCF gbl_intcon,2

    }
    // Handle timer1 interrupt - delay counter from DS3231
    if (pir1.TMR1IF) {
0A15  1283  	BCF STATUS, RP0
0A16  1303  	BCF STATUS, RP1
0A17  1C0C  	BTFSS gbl_pir1,0
0A18  2A1E  	GOTO	label176
0A1E        label176

        tmr1h = TMR1HV;      // preset for timer1 MSB register
0A19  30FF  	MOVLW 0xFF
0A1A  008F  	MOVWF gbl_tmr1h

        tmr1l = TMR1LV;      // preset for timer1 LSB register
0A1B  008E  	MOVWF gbl_tmr1l


        pir1.TMR1IF = 0;     // Clear interrupt flag
0A1C  100C  	BCF gbl_pir1,0

        cTask.TASK_TIMER1 = 1;
0A1D  154D  	BSF gbl_cTask,2

    }
}
0A1E  0E32  	SWAPF Int1BContext+D'2', W
0A1F  0084  	MOVWF FSR
0A20  0E31  	SWAPF Int1BContext+D'1', W
0A21  008A  	MOVWF PCLATH
0A22  0E30  	SWAPF Int1BContext, W
0A23  0083  	MOVWF STATUS
0A24  0EFF  	SWAPF Int1Context, F
0A25  0E7F  	SWAPF Int1Context, W
0A26  0009  	RETFIE


/*********************************************************************************************
  void initialise()
  Function called once only to initialise variables and
  setup the PIC registers
*********************************************************************************************/
void initialise() {

    //PIC16F73 doesn't have an internal oscillator
    //pcon.OSCF = 1; // 4MHz internal osc

    // Configure port A
    /*
    RA7     Doesn't exist
    RA6     Doesn't exist
    RA5     
    RA4     
    RA3     
    RA2     
    RA1     OUT FANS
    RA0     OUT HEATER
    */
    trisa = 0x00; // all outputs
0866  1683  	BSF STATUS, RP0
0867  1303  	BCF STATUS, RP1
0868  0185  	CLRF gbl_trisa

    porta = 0x00; // All off
0869  1283  	BCF STATUS, RP0
086A  0185  	CLRF gbl_porta

    
    // Configure port B
    /*      
    RB7     ICSP PGD
    RB6     ICSP PGC
    RB5     
    RB4     
    RB3     OUT TM1638 STB
    RB2     OUT TM1638 CLK
    RB1     IN/OUT TM1638 DIO
    RB0     
    */
    trisb = 0x00; // all outputs by default
086B  1683  	BSF STATUS, RP0
086C  0186  	CLRF gbl_trisb

    portb = 0x0E; // default TM1638 pins high
086D  300E  	MOVLW 0x0E
086E  1283  	BCF STATUS, RP0
086F  0086  	MOVWF gbl_portb


    // Configure port C
    /*      
    RC7     
    RC6     
    RC5     IN/OUT DS18B20
    RC4     IN/OUT DS3231M I2C SDA
    RC3     IN/OUT DS3231M I2C CLK
    RC2     OUT BLUE LIGHT PWM
    RC1     OUT WHITE LIGHT PWM
    RC0     IN SQW DS3231M
    */
    trisc = 0x21; // RC0 and RC5 inputs
0870  3021  	MOVLW 0x21
0871  1683  	BSF STATUS, RP0
0872  0087  	MOVWF gbl_trisc

    portc = 0x38; // default DS18B20 and DS3231 pins high
0873  3038  	MOVLW 0x38
0874  1283  	BCF STATUS, RP0
0875  0087  	MOVWF gbl_portc


    option_reg = 0;
0876  1683  	BSF STATUS, RP0
0877  0181  	CLRF gbl_option_reg

    option_reg.NOT_RBPU = 1; // disable port b pull ups
0878  1781  	BSF gbl_option_reg,7


    // ADC setup
    // PIC16F73 doesn't have comparators
    //cmcon = 7; // disable all comparators so port a is usable as digital io
    adcon1 = 7; // Set RA0,RA1,RA2,RA5,RA3 all to digital I/O
0879  3007  	MOVLW 0x07
087A  009F  	MOVWF gbl_adcon1



    // Setup timer 0, used for flashing display
    // Timer calculator: http://eng-serve.com/pic/pic_timer.html
    // Timer0 Registers Prescaler= 256 - TMR0 Preset = 61 - Freq = 20.03 Hz - Period = 0.049920 seconds
    //option_reg.T0CS = 0; // bit 5  TMR0 Clock Source Select bit...0 = Internal Clock (CLKO) 1 = Transition on T0CKI pin
    //option_reg.T0SE = 0; // bit 4 TMR0 Source Edge Select bit 0 = low/high 1 = high/low
    //option_reg.PSA = 0; // bit 3  Prescaler Assignment bit...0 = Prescaler is assigned to the Timer0
    option_reg.PS2 = 1; // bits 2-0  PS2:PS0: Prescaler Rate Select bits
087B  1501  	BSF gbl_option_reg,2

    option_reg.PS1 = 1;
087C  1481  	BSF gbl_option_reg,1

    option_reg.PS0 = 1;
087D  1401  	BSF gbl_option_reg,0

    tmr0 = TMR0PRELOAD; // preset for timer register (61)
087E  303D  	MOVLW 0x3D
087F  1283  	BCF STATUS, RP0
0880  0081  	MOVWF gbl_tmr0

    intcon.T0IF = 0; // Clear timer 1 interrupt flag bit
0881  110B  	BCF gbl_intcon,2

    intcon.T0IE = 1; // Timer 1 interrupt enabled
0882  168B  	BSF gbl_intcon,5


    // Setup timer 1, used to update clock display and periodically ask for a temperature reading
    // Timer 1 setup - interrupt on DS3231 SQW 1Hz
    // Timer1 Registers Prescaler= 1 - TMR1 Preset = 65535 - Freq = 1 Hz
    // Bits 5-4 T1CKPS1:T1CKPS0 = 00: Prescaler Rate Select bits, 00 = 1:1 prescaler
    // Bit 3 T1OSCEN = 0: Timer1 LP Oscillator Enable Control bit, 0 = off
    // Bit 2 NOT_T1SYNC = 1: Timer1 External Clock Input Synchronization Control bit, 1 = Do not synchronize external clock input
    // Bit 1 TMR1CS = 1: Timer1 Clock Source Select bit, 1 = External clock from T1OSO/T1CKI pin (on the rising edge)
    // Bit 0 TMR1ON = 0: Timer1 On Bit, 0 = off
    t1con = 0b00000111;
0883  3007  	MOVLW 0x07
0884  0090  	MOVWF gbl_t1con

    tmr1h = TMR1HV;      // preset for timer1 MSB register
0885  30FF  	MOVLW 0xFF
0886  008F  	MOVWF gbl_tmr1h

    tmr1l = TMR1LV;      // preset for timer1 LSB register
0887  008E  	MOVWF gbl_tmr1l

    pie1.TMR1IE = 1;     // Timer 1 interrupt
0888  1683  	BSF STATUS, RP0
0889  140C  	BSF gbl_pie1,0

    
    // No task at initialisation
    cTask = 0;
088A  1283  	BCF STATUS, RP0
088B  01CD  	CLRF gbl_cTask

    
    // Enable interrupts
    intcon.GIE = 1;
088C  178B  	BSF gbl_intcon,7

    intcon.PEIE = 1;
088D  170B  	BSF gbl_intcon,6


	// I2C Bus initialisation - baud rate divisor not applicable for software implementation
	i2c_init(1); 
088E  3001  	MOVLW 0x01
088F  00F3  	MOVWF i2c_INIT_00000_arg_i2c_divisor
0890  118A  	BCF PCLATH,3
0891  24E1  	CALL i2c_INIT_00000


    // Read in variables from EEPROM
    at24c32ReadAll();
0892  25F0  	CALL at24c32Rea_0002C


    // Check if the DS3231 needs initilising
    char cStatus = ds3231ReadRegister(0x0F); // Read the status register
0893  300F  	MOVLW 0x0F
0894  00F3  	MOVWF ds3231Read_0001E_arg_cRegAddress
0895  2510  	CALL ds3231Read_0001E
0896  0875  	MOVF CompTempVarRet554, W
0897  00F2  	MOVWF initialise_00000_1_cStatus

    // If the oscillator (OSF bit in status register) has stopped, then init and write a default date/time
    if (cStatus.7) {
0898  158A  	BSF PCLATH,3
0899  1FF2  	BTFSS initialise_00000_1_cStatus,7
089A  289E  	GOTO	label149
089E        label149

        ds3231Init();
089B  118A  	BCF PCLATH,3
089C  2525  	CALL ds3231Init_00000

        ds3231WriteDateTime();
089D  24F4  	CALL ds3231Writ_0001C

    }
    
	tm1638DisplayOn();
089E  118A  	BCF PCLATH,3
089F  24B4  	CALL tm1638Disp_00021

    tm1638UpdateDisplay();
08A0  2293  	CALL tm1638Upda_00022

}
08A1  0008  	RETURN


/*********************************************************************************************
  void main()
  Entry method. Loops infinitely with a simple task scheduler.
*********************************************************************************************/
void main() {

    initialise();
08CD  2066  	CALL initialise_00000

    
    // Endless loop
    while(1) {
08CE        label150

        // Task scheduler
        // If there are tasks to be performed, find out the
        // most recent task from the array and execute it
        while (cTask > 0) {
08CE  084D  	MOVF gbl_cTask, W
08CF  3C00  	SUBLW 0x00
08D0  158A  	BSF PCLATH,3
08D1  1803  	BTFSC STATUS,C
08D2  28CE  	GOTO	label150

            if (cTask.TASK_TIMER1) {
08D3  1D4D  	BTFSS gbl_cTask,2
08D4  2984  	GOTO	label170
0984        label170

                if (!gcSetMode) {
08D5  08D0  	MOVF gbl_gcSetMode, F
08D6  1D03  	BTFSS STATUS,Z
08D7  2912  	GOTO	label156

                    // Don't read date/time when in set mode
                    ds3231ReadDateTime();
08D8  20A2  	CALL ds3231Read_0001D

                    if ((gBcdSecond == 0x29) || (gBcdSecond == 0x59)) {
08D9  0835  	MOVF gbl_gBcdSecond, W
08DA  3A29  	XORLW 0x29
08DB  158A  	BSF PCLATH,3
08DC  1903  	BTFSC STATUS,Z
08DD  28E2  	GOTO	label151
08DE  0835  	MOVF gbl_gBcdSecond, W
08DF  3A59  	XORLW 0x59
08E0  1D03  	BTFSS STATUS,Z
08E1  28E6  	GOTO	label152
08E2        label151
08E6        label152

                        // Ask to convert for temperature reading at 29 seconds or 59 seconds past the minute
                        oneWireBusReset();
08E2  204D  	CALL oneWireBus_00017

                        startTemp();
08E3  27CB  	CALL startTemp_00000

                    } else if ((gBcdSecond == 0) || (gBcdSecond == 0x30)) {
08E4  158A  	BSF PCLATH,3
08E5  28F0  	GOTO	label154
08E6  08B5  	MOVF gbl_gBcdSecond, F
08E7  1903  	BTFSC STATUS,Z
08E8  28ED  	GOTO	label153
08E9  0835  	MOVF gbl_gBcdSecond, W
08EA  3A30  	XORLW 0x30
08EB  1D03  	BTFSS STATUS,Z
08EC  28F0  	GOTO	label154
08ED        label153
08F0        label154
09A3  158A  	BSF PCLATH,3
09A4  28CE  	GOTO	label150

                        // 1 second later, read the converted temperature
                        oneWireBusReset();
08ED  204D  	CALL oneWireBus_00017

                        readTemp(); 
08EE  27D3  	CALL readTemp_00000

                        // store it in the array, next display refresh will pick it up
                        convertTemp();
08EF  2530  	CALL convertTem_0002A

                    }
                    // daylight savings time handling (UK/europe) - last sunday of March or October (this can fall between the 25th and the 31st)
                    if ((gBcdSecond == 0) && (gDayOfWeek == 7) && (gBcdDayOfMonth > 0x24)) {
08F0  08B5  	MOVF gbl_gBcdSecond, F
08F1  158A  	BSF PCLATH,3
08F2  1D03  	BTFSS STATUS,Z
08F3  2912  	GOTO	label156
08F4  0838  	MOVF gbl_gDayOfWeek, W
08F5  3A07  	XORLW 0x07
08F6  1D03  	BTFSS STATUS,Z
08F7  2912  	GOTO	label156
08F8  0839  	MOVF gbl_gBcdDayOfMonth, W
08F9  3C24  	SUBLW 0x24
08FA  1803  	BTFSC STATUS,C
08FB  2912  	GOTO	label156

						// In March, at 1AM, apply daylight savings time if appropriate 
						if ((gBcdHour == 1) && (gBcdMonth == 3)) {
08FC  0337  	DECF gbl_gBcdHour, W
08FD  1D03  	BTFSS STATUS,Z
08FE  2906  	GOTO	label155
08FF  083A  	MOVF gbl_gBcdMonth, W
0900  3A03  	XORLW 0x03
0901  1D03  	BTFSS STATUS,Z
0902  2906  	GOTO	label155
0906        label155

							gBcdHour++; // one hour forwards
0903  0AB7  	INCF gbl_gBcdHour, F

							ds3231WriteDateTime();
0904  118A  	BCF PCLATH,3
0905  24F4  	CALL ds3231Writ_0001C

						}
						// In October, at 2AM, remove daylight savings time if appropriate (UK/europe) daylight savings time if appropriate (UK/europe) - last sunday of October
						if ((gBcdHour == 2) && (gBcdMonth == 0x10)) {
0906  0837  	MOVF gbl_gBcdHour, W
0907  3A02  	XORLW 0x02
0908  158A  	BSF PCLATH,3
0909  1D03  	BTFSS STATUS,Z
090A  2912  	GOTO	label156
090B  083A  	MOVF gbl_gBcdMonth, W
090C  3A10  	XORLW 0x10
090D  1D03  	BTFSS STATUS,Z
090E  2912  	GOTO	label156
0912        label156

							gBcdHour--; // one hour back
090F  03B7  	DECF gbl_gBcdHour, F

							ds3231WriteDateTime();
0910  118A  	BCF PCLATH,3
0911  24F4  	CALL ds3231Writ_0001C

						}
					}
                }
                if (!gcTriggerMode) {
0912  08D2  	MOVF gbl_gcTriggerMode, F
0913  158A  	BSF PCLATH,3
0914  1D03  	BTFSS STATUS,Z
0915  297B  	GOTO	label168

					// Don't activate triggers when in trigger set mode
					// Trigger white led
					// Don't activate/deactivate if on and off set hour/min are the same
					if ((gBcdWhiteOnHour != gBcdWhiteOffHour) || (gBcdWhiteOnMinute != gBcdWhiteOffMinute)) {
0916  0856  	MOVF gbl_gBcdWhiteOffHour, W
0917  0654  	XORWF gbl_gBcdWhiteOnHour, W
0918  1D03  	BTFSS STATUS,Z
0919  291E  	GOTO	label157
091A  0855  	MOVF gbl_gBcdWhiteOffMinute, W
091B  0653  	XORWF gbl_gBcdWhiteOnMinute, W
091C  1903  	BTFSC STATUS,Z
091D  292E  	GOTO	label159
091E        label157

						if ((gBcdHour == gBcdWhiteOnHour) && (gBcdMinute == gBcdWhiteOnMinute)) {
091E  0854  	MOVF gbl_gBcdWhiteOnHour, W
091F  0637  	XORWF gbl_gBcdHour, W
0920  1D03  	BTFSS STATUS,Z
0921  2926  	GOTO	label158
0922  0853  	MOVF gbl_gBcdWhiteOnMinute, W
0923  0636  	XORWF gbl_gBcdMinute, W
0924  1903  	BTFSC STATUS,Z

							WHITE_LED = 1;
0925  1487  	BSF gbl_portc,1
0926        label158

						}
						if ((gBcdHour == gBcdWhiteOffHour) && (gBcdMinute == gBcdWhiteOffMinute)) {
0926  0856  	MOVF gbl_gBcdWhiteOffHour, W
0927  0637  	XORWF gbl_gBcdHour, W
0928  1D03  	BTFSS STATUS,Z
0929  292E  	GOTO	label159
092A  0855  	MOVF gbl_gBcdWhiteOffMinute, W
092B  0636  	XORWF gbl_gBcdMinute, W
092C  1903  	BTFSC STATUS,Z

							WHITE_LED = 0;
092D  1087  	BCF gbl_portc,1
092E        label159

						}
					}
					// Trigger blue led
					// Don't activate/deactivate if on and off set hour/min are the same
					if ((gBcdBlueOnHour != gBcdBlueOffHour) || (gBcdBlueOnMinute != gBcdBlueOffMinute)) {
092E  085A  	MOVF gbl_gBcdBlueOffHour, W
092F  0658  	XORWF gbl_gBcdBlueOnHour, W
0930  1D03  	BTFSS STATUS,Z
0931  2936  	GOTO	label160
0932  0859  	MOVF gbl_gBcdBlueOffMinute, W
0933  0657  	XORWF gbl_gBcdBlueOnMinute, W
0934  1903  	BTFSC STATUS,Z
0935  2946  	GOTO	label162
0936        label160

						if ((gBcdHour == gBcdBlueOnHour) && (gBcdMinute == gBcdBlueOnMinute)) {
0936  0858  	MOVF gbl_gBcdBlueOnHour, W
0937  0637  	XORWF gbl_gBcdHour, W
0938  1D03  	BTFSS STATUS,Z
0939  293E  	GOTO	label161
093A  0857  	MOVF gbl_gBcdBlueOnMinute, W
093B  0636  	XORWF gbl_gBcdMinute, W
093C  1903  	BTFSC STATUS,Z

							BLUE_LED = 1;
093D  1507  	BSF gbl_portc,2
093E        label161

						}
						if ((gBcdHour == gBcdBlueOffHour) && (gBcdMinute == gBcdBlueOffMinute)) {
093E  085A  	MOVF gbl_gBcdBlueOffHour, W
093F  0637  	XORWF gbl_gBcdHour, W
0940  1D03  	BTFSS STATUS,Z
0941  2946  	GOTO	label162
0942  0859  	MOVF gbl_gBcdBlueOffMinute, W
0943  0636  	XORWF gbl_gBcdMinute, W
0944  1903  	BTFSC STATUS,Z

							BLUE_LED = 0;
0945  1107  	BCF gbl_portc,2
0946        label162

						}
					}
					// 2nd Trigger blue led
					// Don't activate/deactivate if on and off set hour/min are the same
					if ((gBcdBlue2OnHour != gBcdBlue2OffHour) || (gBcdBlue2OnMinute != gBcdBlue2OffMinute)) {
0946  085E  	MOVF gbl_gBcdBlue2OffHour, W
0947  065C  	XORWF gbl_gBcdBlue2OnHour, W
0948  1D03  	BTFSS STATUS,Z
0949  294E  	GOTO	label163
094A  085D  	MOVF gbl_gBcdBlue2OffMinute, W
094B  065B  	XORWF gbl_gBcdBlue2OnMinute, W
094C  1903  	BTFSC STATUS,Z
094D  295E  	GOTO	label165
094E        label163

						if ((gBcdHour == gBcdBlue2OnHour) && (gBcdMinute == gBcdBlue2OnMinute)) {
094E  085C  	MOVF gbl_gBcdBlue2OnHour, W
094F  0637  	XORWF gbl_gBcdHour, W
0950  1D03  	BTFSS STATUS,Z
0951  2956  	GOTO	label164
0952  085B  	MOVF gbl_gBcdBlue2OnMinute, W
0953  0636  	XORWF gbl_gBcdMinute, W
0954  1903  	BTFSC STATUS,Z

							BLUE_LED = 1;
0955  1507  	BSF gbl_portc,2
0956        label164

						}
						if ((gBcdHour == gBcdBlue2OffHour) && (gBcdMinute == gBcdBlue2OffMinute)) {
0956  085E  	MOVF gbl_gBcdBlue2OffHour, W
0957  0637  	XORWF gbl_gBcdHour, W
0958  1D03  	BTFSS STATUS,Z
0959  295E  	GOTO	label165
095A  085D  	MOVF gbl_gBcdBlue2OffMinute, W
095B  0636  	XORWF gbl_gBcdMinute, W
095C  1903  	BTFSC STATUS,Z

							BLUE_LED = 0;
095D  1107  	BCF gbl_portc,2
095E        label165

						}
					}
					// Trigger fan
					// Don't activate/deactivate if on and off temperature are the same
					if (gBcdFanOnTemp != gBcdFanOffTemp) {
095E  0860  	MOVF gbl_gBcdFanOffTemp, W
095F  065F  	XORWF gbl_gBcdFanOnTemp, W
0960  1903  	BTFSC STATUS,Z
0961  296A  	GOTO	label166

						if (giDS3231ValueTruncCBCD >= gBcdFanOnTemp) {
0962  085F  	MOVF gbl_gBcdFanOnTemp, W
0963  024B  	SUBWF gbl_giDS3231ValueTruncCBCD, W
0964  1803  	BTFSC STATUS,C

							FAN = 1;
0965  1485  	BSF gbl_porta,1

						}
						if (giDS3231ValueTruncCBCD <= gBcdFanOffTemp) {
0966  084B  	MOVF gbl_giDS3231ValueTruncCBCD, W
0967  0260  	SUBWF gbl_gBcdFanOffTemp, W
0968  1803  	BTFSC STATUS,C

							FAN = 0;
0969  1085  	BCF gbl_porta,1
096A        label166

						}
					}
					// Forced on
					if (gbFanOn)
096A  194E  	BTFSC gbl_gbFanOn,2

						FAN = 1;
096B  1485  	BSF gbl_porta,1

					// Trigger heater
					// Don't activate/deactivate if on and off temperature are the same
					if (gBcdHeaterOnTemp != gBcdHeaterOffTemp) {
096C  0862  	MOVF gbl_gBcdHeaterOffTemp, W
096D  0661  	XORWF gbl_gBcdHeaterOnTemp, W
096E  1903  	BTFSC STATUS,Z
096F  2978  	GOTO	label167

						if (giDS3231ValueTruncCBCD <= gBcdHeaterOnTemp) {
0970  084B  	MOVF gbl_giDS3231ValueTruncCBCD, W
0971  0261  	SUBWF gbl_gBcdHeaterOnTemp, W
0972  1803  	BTFSC STATUS,C

							HEATER = 1;
0973  1405  	BSF gbl_porta,0

						}
						if (giDS3231ValueTruncCBCD >= gBcdHeaterOffTemp) {
0974  0862  	MOVF gbl_gBcdHeaterOffTemp, W
0975  024B  	SUBWF gbl_giDS3231ValueTruncCBCD, W
0976  1803  	BTFSC STATUS,C

							HEATER = 0;
0977  1005  	BCF gbl_porta,0
0978        label167

						}
					}
					// If temperature is minus, always trigger heater
					if (gbDS3231IsMinus)
0978  08CC  	MOVF gbl_gbDS3231IsMinus, F
0979  1D03  	BTFSS STATUS,Z

						HEATER = 1;
097A  1405  	BSF gbl_porta,0
097B        label168

				}
				// Display time and temperature or date on TM1638 after clock tick
				if (!gcTriggerMode && !gcSetMode) {
097B  08D2  	MOVF gbl_gcTriggerMode, F
097C  1D03  	BTFSS STATUS,Z
097D  2983  	GOTO	label169
097E  08D0  	MOVF gbl_gcSetMode, F
097F  1D03  	BTFSS STATUS,Z
0980  2983  	GOTO	label169
0983        label169

					tm1638UpdateDisplay();
0981  118A  	BCF PCLATH,3
0982  2293  	CALL tm1638Upda_00022

                }
                
                cTask.TASK_TIMER1 = 0;
0983  114D  	BCF gbl_cTask,2

            }
            if (cTask.TASK_TIMER0) {
0984  158A  	BSF PCLATH,3
0985  1CCD  	BTFSS gbl_cTask,1
0986  28CE  	GOTO	label150

				// ~half second count
				if (iTimer0Counts > 9) {
0987  083E  	MOVF gbl_iTimer0Counts, W
0988  3C09  	SUBLW 0x09
0989  1803  	BTFSC STATUS,C
098A  2995  	GOTO	label172

					iFlashDigitOff++;
098B  0ABF  	INCF gbl_iFlashDigitOff, F

					iTimer0Counts = 0;					
098C  01BE  	CLRF gbl_iTimer0Counts

					// If in set or trigger mode, update the display every ~half second to flash a digit
					if (gcSetMode || gcTriggerMode)
098D  08D0  	MOVF gbl_gcSetMode, F
098E  1D03  	BTFSS STATUS,Z
098F  2993  	GOTO	label171
0990  08D2  	MOVF gbl_gcTriggerMode, F
0991  1903  	BTFSC STATUS,Z
0992  2995  	GOTO	label172
0993        label171

						tm1638UpdateDisplay();
0993  118A  	BCF PCLATH,3
0994  2293  	CALL tm1638Upda_00022

				}
				// Poll keys every 50ms
				tm1638ReadKeys();
0995  118A  	BCF PCLATH,3
0996  27A8  	CALL tm1638Read_00025

				if (tm1638Keys != tm1638KeysOld) {
0997  086C  	MOVF gbl_tm1638KeysOld, W
0998  066B  	XORWF gbl_tm1638Keys, W
0999  158A  	BSF PCLATH,3
099A  1903  	BTFSC STATUS,Z
099B  29A2  	GOTO	label173
09A2        label173

					//if (tm1638Keys != 0) {
						processKeys();
099C  118A  	BCF PCLATH,3
099D  27E1  	CALL processKey_00029

						tm1638UpdateDisplay();
099E  118A  	BCF PCLATH,3
099F  2293  	CALL tm1638Upda_00022

					//}
					tm1638KeysOld = tm1638Keys;
09A0  086B  	MOVF gbl_tm1638Keys, W
09A1  00EC  	MOVWF gbl_tm1638KeysOld

				}
                cTask.TASK_TIMER0 = 0;
09A2  10CD  	BCF gbl_cTask,1

            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
// I2C Communications Library for I2C MASTER
////////////////////////////////////////////////////////////////////////////
// Author(s): Andrew Smallridge
// Date 15 November 2004
//
// Copyright(C) 2004-2006 Andrew Smallridge
// Copyright(C) 2004-2010 Pavel Baranov
// Copyright(C) 2004-2010 David Hobday
// Existing constants predefined for i2c hardware driver and i2s software
// emulation for the PIC 18F2xx and 18F4xx processors. For hardware support
// on other PICs the constants must be mapped to the corresponding register
// map of the target device
////////////////////////////////////////////////////////////////////////////

/*
////////////////////////////////////////////////////////////////////////////
//	The following three sections should be copied to the user's program:
//		i2c master hardware / software mode definition
//		i2c software implementation template arguments and variables
// 		i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////
// i2c master hardware / software mode definition
//
// For i2c hardware support comment out the #define use_ic2_SW line
////////////////////////////////////////////////////////////////////////////
//#define use_i2c_SW

#if defined use_i2c_SW
////////////////////////////////////////////////////////////////////////////
// i2c software implementation template arguments and variables
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)

// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and software emalated i2c RAM locations. These constants are
// then used by the templated functions. When changing the address of an emulated
// register the corresponding constant mapping must also be changed.
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3					

#else
////////////////////////////////////////////////////////////////////////////
// i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP |i2c_HW)

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and PIC's i2c register locations. These constants are
// then used by the templated functions. 
#define PORTC		0x0f82
#define TRISC		0x0f94
#define e_SSPCON1	0xfc6
#define e_SSPCON2	0xfc5
#define e_SSPSTAT	0xfc7
#define e_SSPADD	0xfc8
#define e_SSPBUF	0xfc9
#define e_SSPIF_PIR	0xf9e
#define e_BCLIF_PIR	0xfa1
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3

#endif

*/


////////////////////////////////////////////////////////////////////////////
// Define the common i2c template structure
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL	template <unsigned char T_SCL_BIT, unsigned short T_SCL_PORT,	\
					unsigned short T_SCL_TRIS, unsigned char T_SDA_BIT, 			\
					unsigned short T_SDA_PORT, unsigned short T_SDA_TRIS,			\
					unsigned short T_i2c_SSPCON1, unsigned short T_i2c_SSPCON2, 	\
					unsigned short T_i2c_SSPSTAT, unsigned short T_i2c_SSPBUF, 		\
					unsigned char T_i2c_SSPIF_BIT, unsigned short T_i2c_SSPIF_PIR,	\
					unsigned char T_i2c_BCLIF_BIT, unsigned short T_i2c_BCLIF_PIR,	\
					unsigned char T_i2c_SMP_BIT, unsigned short T_i2c_SSPADD, 		\
					unsigned char T_MODE>

////////////////////////////////////////////////////////////////////////////
// Define the common i2c template parameters
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL_ARGS	T_SCL_BIT, T_SCL_PORT, T_SCL_TRIS, T_SDA_BIT, 			\
						T_SDA_PORT, T_SDA_TRIS, T_i2c_SSPCON1, T_i2c_SSPCON2, 	\
						T_i2c_SSPSTAT, T_i2c_SSPBUF, T_i2c_SSPIF_BIT, 			\
						T_i2c_SSPIF_PIR, T_i2c_BCLIF_BIT, T_i2c_BCLIF_PIR,		\
						T_i2c_SMP_BIT, T_i2c_SSPADD, T_MODE

////////////////////////////////////////////////////////////////////////////
// Helpers that hide template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_init	i2c_INIT<i2c_ARGS>
#define i2c_start	i2c_START<i2c_ARGS>
#define i2c_restart	i2c_RESTART<i2c_ARGS>
#define i2c_stop	i2c_STOP<i2c_ARGS>
#define i2c_read	i2c_READ<i2c_ARGS>
#define i2c_write	i2c_WRITE<i2c_ARGS>


////////////////////////////////////////////////////////////////////////////
// I2C Control Status Bits - Emulates the PIC18F hardware I2C implementation
////////////////////////////////////////////////////////////////////////////
// define I2C i2C_SSPCON1 control bits
#define	i2c_WCOL	7
#define	i2c_SSPOV	6
#define	i2c_SSPEN	5
#define	i2c_CKP		4
#define	i2c_SSPM3	3
#define	i2c_SSPM2	2
#define	i2c_SSPM1	1
#define	i2c_SSPM0	0

// define I2C SSPCON2 control bits
#define	i2c_GCEN 	7
#define	i2c_ACKSTAT	6
#define	i2c_ACKDT	5
#define	i2c_ACKEN	4
#define	i2c_RCEN	3
#define	i2c_PEN		2
#define	i2c_RSEN	1
#define	i2c_SEN		0

// define I2C SSPSTAT status bits
#define	i2c_DA		5
#define	i2c_P		4
#define	i2c_S		3
#define	i2c_RW		2
#define	i2c_UA		1
#define	i2c_BF		0


////////////////////////////////////////////////////////////////////////////
// I2C Control Flag Bits
////////////////////////////////////////////////////////////////////////////
// define I2C Mode bits
#define	i2c_HW			0x01
#define	i2c_400KHz		0x02	// 100KHz or 400KHz I2C clock (set = 400KHz)
#define	i2c_reset_wdt	0x04
#define i2c_SMP			0x80	


////////////////////////////////////////////////////////////////////////////
// I2C software constants
////////////////////////////////////////////////////////////////////////////
#define	dly 10	// number of 1us delay increments



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Start Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL 
void i2c_START(void)

{
	// Initiate the I2C START condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	delay_us(dly);
0126  300A  	MOVLW 0x0A
0127  1283  	BCF STATUS, RP0
0128  1303  	BCF STATUS, RP1
0129  00F8  	MOVWF delay_us_00000_arg_del
012A  2010  	CALL delay_us_00000

	l_bclif = 0; // initialise the collision flag for this command
012B  11C6  	BCF i2c_START_00000_1_l_bclif,3

	l_sspif = 0;
012C  11C5  	BCF i2c_START_00000_1_l_sspif,3

		
	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
			
		l_sen = 1; // initiate START condition	

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation			
		l_sen = 1; // initiate START condition
012D  1441  	BSF i2c_START_00000_1_l_sen,0

		l_scl_tris = 1; // ensure the SCL line is high
012E  1683  	BSF STATUS, RP0
012F  1587  	BSF i2c_START_00000_1_l_scl_tris,3

		l_sda_tris = 1; // ensure the SDA line is high	
0130  1607  	BSF i2c_START_00000_1_l_sda_tris,4

		l_scl = 0; // prepare to set SCL line low
0131  1283  	BCF STATUS, RP0
0132  1187  	BCF i2c_START_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low
0133  1207  	BCF i2c_START_00000_1_l_sda,4

		
		if (l_scl && l_sda)
0134  1D87  	BTFSS i2c_START_00000_1_l_scl,3
0135  2953  	GOTO	label24
0136  1E07  	BTFSS i2c_START_00000_1_l_sda,4
0137  2953  	GOTO	label24
0153        label24

		{
			// good sign - no collision detected
			delay_us(dly);
0138  300A  	MOVLW 0x0A
0139  00F8  	MOVWF delay_us_00000_arg_del
013A  2010  	CALL delay_us_00000

			
			if (!l_scl) // ensure the clock is still high
013B  1987  	BTFSC i2c_START_00000_1_l_scl,3
013C  2941  	GOTO	label23
0141        label23

			{
				l_bclif = 1;
013D  15C6  	BSF i2c_START_00000_1_l_bclif,3

				l_s = 1;
013E  15C2  	BSF i2c_START_00000_1_l_s,3

				l_sen = 0;
013F  1041  	BCF i2c_START_00000_1_l_sen,0

				return;
			}
					
			l_sda = 0; // prepare to set SDA line low
0141  1207  	BCF i2c_START_00000_1_l_sda,4

			l_sda_tris = 0; // SDA to output (driven low)
0142  1683  	BSF STATUS, RP0
0143  1207  	BCF i2c_START_00000_1_l_sda_tris,4


			delay_us(dly);					
0144  300A  	MOVLW 0x0A
0145  1283  	BCF STATUS, RP0
0146  00F8  	MOVWF delay_us_00000_arg_del
0147  2010  	CALL delay_us_00000

			l_scl = 0; // prepare to set SCL line low
0148  1187  	BCF i2c_START_00000_1_l_scl,3

			l_scl_tris = 0; // SCL to output (driven low)
0149  1683  	BSF STATUS, RP0
014A  1187  	BCF i2c_START_00000_1_l_scl_tris,3


			delay_us(dly);					
014B  300A  	MOVLW 0x0A
014C  1283  	BCF STATUS, RP0
014D  00F8  	MOVWF delay_us_00000_arg_del
014E  2010  	CALL delay_us_00000

			l_s = 1; // set 'S' bit flag (start bit detected)
014F  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0; // clear flag
0150  1041  	BCF i2c_START_00000_1_l_sen,0

			l_sspif = 1; // flag end of start condition interrupt	
0151  15C5  	BSF i2c_START_00000_1_l_sspif,3

		}
		else
		{
			// here is SDA or SCL are low at the start - indicates a bus collision
			l_bclif = 1;
0153  15C6  	BSF i2c_START_00000_1_l_bclif,3

			l_s = 1; // set 'S' bit flag (start bit detected)
0154  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0;
0155  1041  	BCF i2c_START_00000_1_l_sen,0

			l_rsen = 0;
0156  10C1  	BCF i2c_START_00000_1_l_rsen,1

			l_pen = 0;
0157  1141  	BCF i2c_START_00000_1_l_pen,2

			l_rcen = 0;								
0158  11C1  	BCF i2c_START_00000_1_l_rcen,3

			l_acken = 0;			
0159  1241  	BCF i2c_START_00000_1_l_acken,4

		}
	}
}
0140  0008  	RETURN
0152  0008  	RETURN
015A  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Restart Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_RESTART(void)
{
	// Initiate the I2C RESTART condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
			
	delay_us(dly);
	l_bclif = 0; // initialise the collision flag for this command
	l_sspif = 0;

	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_rsen = 1; // initiate RESTART condition
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation	
		l_rsen = 1;
		l_scl = 0;
		l_sda = 0;
		
		if (!l_scl)
		{
			// good sign - no other I2C activity in progress
			l_sda_tris = 1; // float SDA line high	(should already be in this condition)	
			delay_us(dly);
		
			// about to float the clock line
			// ensure the data line is still high
			if (!l_sda)
			{
				// problem - SDA is low, a bus collision has occurred				
				l_bclif = 1; // set the bus collision flag	
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_scl_tris = 1; // float SCL line (high)	
				return;
			}
												
			l_scl_tris = 1; // float SCL line (high)

			// wait until any clock stretching has finished
			while (!l_scl)
				if (T_MODE & i2c_reset_wdt)
					clear_wdt();	
			delay_us(dly);
			
			// here we are about to drive SDA low
			// first ensure SCL is still high
			if (!l_scl)
			{
				// problem - SCL is low, a bus collision has occurred
				l_bclif = 1; // set the bus collision flag
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_sda_tris = 1; // float SDA line (high)
				return;
			}
				
			l_sda_tris = 0; // drive SDA low
			l_s = 1; // set 'S' bit flag (start bit detected)

			delay_us(dly);
			l_scl_tris = 0; // drive SCL low
			l_rsen = 0;
			l_pen = 0;
			l_sen = 0;			
			l_rcen = 0;								
			l_acken = 0;			
			l_sspif = 1; // flag end of start condition interrupt
		}
		else
		{
			// SCL is high at the start
			// some other I2C activity in progress		
			l_rsen = 0; // clear flag
			// exit without further action
		}
	}
}



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Stop Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_STOP(void)

{ 
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_p@T_i2c_SSPSTAT.i2c_P; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;

	l_bclif = 0; // initialise the collision flag for this command
00F6  1283  	BCF STATUS, RP0
00F7  1303  	BCF STATUS, RP1
00F8  11C6  	BCF i2c_STOP_00000_1_l_bclif,3

	l_sspif = 0;
00F9  11C5  	BCF i2c_STOP_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_pen = 1; // initiate STOP condition on the I2C bus	
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
		
	}
	else
	{
		//	Software I2C implementation
		l_pen = 1; // initiate STOP condition on the I2C bus
00FA  1541  	BSF i2c_STOP_00000_1_l_pen,2

		delay_us(dly);
00FB  300A  	MOVLW 0x0A
00FC  00F8  	MOVWF delay_us_00000_arg_del
00FD  2010  	CALL delay_us_00000

		
		l_scl = 0; // prepare to set SCL line low
00FE  1187  	BCF i2c_STOP_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low
00FF  1207  	BCF i2c_STOP_00000_1_l_sda,4

		l_scl_tris = 0; // drive SCL line low (should already be low)
0100  1683  	BSF STATUS, RP0
0101  1187  	BCF i2c_STOP_00000_1_l_scl_tris,3

		l_sda_tris = 0; // drive SDA line low
0102  1207  	BCF i2c_STOP_00000_1_l_sda_tris,4


		delay_us(dly);		
0103  300A  	MOVLW 0x0A
0104  1283  	BCF STATUS, RP0
0105  00F8  	MOVWF delay_us_00000_arg_del
0106  2010  	CALL delay_us_00000

		l_scl_tris = 1; // float SCL line (high)
0107  1683  	BSF STATUS, RP0
0108  1587  	BSF i2c_STOP_00000_1_l_scl_tris,3

		
		// wait until any clock stretching has finished
		while (!l_scl)
0109        label19
0109  1283  	BCF STATUS, RP0
010A  1987  	BTFSC i2c_STOP_00000_1_l_scl,3
010B  290E  	GOTO	label20
010D  2909  	GOTO	label19
010E        label20

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
010C  0064  	CLRWDT

						
		delay_us(dly);
010E  300A  	MOVLW 0x0A
010F  00F8  	MOVWF delay_us_00000_arg_del
0110  2010  	CALL delay_us_00000

		l_sda_tris = 1; // float SDA line
0111  1683  	BSF STATUS, RP0
0112  1607  	BSF i2c_STOP_00000_1_l_sda_tris,4

		delay_us(dly);		
0113  300A  	MOVLW 0x0A
0114  1283  	BCF STATUS, RP0
0115  00F8  	MOVWF delay_us_00000_arg_del
0116  2010  	CALL delay_us_00000

		
		// here the SDA line should be high - if not a collision has occurred				
		if (!l_sda || !l_scl)
0117  1E07  	BTFSS i2c_STOP_00000_1_l_sda,4
0118  291B  	GOTO	label21
0119  1987  	BTFSC i2c_STOP_00000_1_l_scl,3
011A  291F  	GOTO	label22
011B        label21
011F        label22

		{
			// problem - SDA or SCL is low, a bus collision has occurred
			l_bclif = 1; // set the bus collision flag	
011B  15C6  	BSF i2c_STOP_00000_1_l_bclif,3

			l_s = 0; // clear 'S' bit flag
011C  11C2  	BCF i2c_STOP_00000_1_l_s,3

			l_pen = 0; // clear flag
011D  1141  	BCF i2c_STOP_00000_1_l_pen,2

		}
		else
		{		
			l_p = 1;
011F  1642  	BSF i2c_STOP_00000_1_l_p,4

			l_pen = 0;
0120  1141  	BCF i2c_STOP_00000_1_l_pen,2

			l_sen = 0;
0121  1041  	BCF i2c_STOP_00000_1_l_sen,0

			l_rsen = 0;			
0122  10C1  	BCF i2c_STOP_00000_1_l_rsen,1

			l_rcen = 0;								
0123  11C1  	BCF i2c_STOP_00000_1_l_rcen,3

			l_acken = 0;
0124  1241  	BCF i2c_STOP_00000_1_l_acken,4

		}
	}
}
011E  0008  	RETURN
0125  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Write Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_WRITE(unsigned char i2c_data)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;	
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
	
	char BitMask;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
00A5  11C6  	BCF i2c_WRITE_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
00A6  11C5  	BCF i2c_WRITE_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
				
		l_wcol = 0; // clear write collision flag	
		i2c_SSPBUF = i2c_data;

		// test if a write collision occurred
		if (l_wcol)
			return (1); // error exit	

		// wait until MSSP Tx register is empty
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
								
		return (0); // successful exit
	}

	// here for i2c software driver
	l_wcol = 0; // clear write collision flag	
00A7  13C0  	BCF i2c_WRITE_00000_1_l_wcol,7

	i2c_SSPBUF = i2c_data;
00A8  0875  	MOVF i2c_WRITE_00000_arg_i2c_data, W
00A9  00C4  	MOVWF i2c_WRITE_00000_1_i2c_SSPBUF

	
	l_scl = 0; // prepare to set SCL line low
00AA  1187  	BCF i2c_WRITE_00000_1_l_scl,3

	l_sda = 0; // prepare to set SDA line low
00AB  1207  	BCF i2c_WRITE_00000_1_l_sda,4

	l_rw = 0; // signal we are doing a write
00AC  1142  	BCF i2c_WRITE_00000_1_l_rw,2


	for (BitMask = 0x80; BitMask; BitMask>>=1)
00AD  3080  	MOVLW 0x80
00AE  00F6  	MOVWF i2c_WRITE_00000_1_BitMask
00AF        label11
00AF  08F6  	MOVF i2c_WRITE_00000_1_BitMask, F
00B0  1903  	BTFSC STATUS,Z
00B1  28D2  	GOTO	label16
00CF  1003  	BCF STATUS,C
00D0  0CF6  	RRF i2c_WRITE_00000_1_BitMask, F
00D1  28AF  	GOTO	label11
00D2        label16

	{
		if (i2c_data & BitMask)
00B2  0876  	MOVF i2c_WRITE_00000_1_BitMask, W
00B3  0575  	ANDWF i2c_WRITE_00000_arg_i2c_data, W
00B4  1903  	BTFSC STATUS,Z
00B5  28B9  	GOTO	label12
00B9        label12

			l_sda_tris = 1; // float SDA high	
00B6  1683  	BSF STATUS, RP0
00B7  1607  	BSF i2c_WRITE_00000_1_l_sda_tris,4

		else
00B8  28BB  	GOTO	label13
00BB        label13

			l_sda_tris = 0; // drive SDA low
00B9  1683  	BSF STATUS, RP0
00BA  1207  	BCF i2c_WRITE_00000_1_l_sda_tris,4

		delay_us(dly);
00BB  300A  	MOVLW 0x0A
00BC  1283  	BCF STATUS, RP0
00BD  00F8  	MOVWF delay_us_00000_arg_del
00BE  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
00BF  1683  	BSF STATUS, RP0
00C0  1587  	BSF i2c_WRITE_00000_1_l_scl_tris,3


		// wait until any clock stretching has finished
		while (!l_scl)
00C1        label14
00C1  1283  	BCF STATUS, RP0
00C2  1987  	BTFSC i2c_WRITE_00000_1_l_scl,3
00C3  28C6  	GOTO	label15
00C5  28C1  	GOTO	label14
00C6        label15

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
00C4  0064  	CLRWDT

		delay_us(dly);
00C6  300A  	MOVLW 0x0A
00C7  00F8  	MOVWF delay_us_00000_arg_del
00C8  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low	
00C9  1683  	BSF STATUS, RP0
00CA  1187  	BCF i2c_WRITE_00000_1_l_scl_tris,3

		delay_us(dly);
00CB  300A  	MOVLW 0x0A
00CC  1283  	BCF STATUS, RP0
00CD  00F8  	MOVWF delay_us_00000_arg_del
00CE  2010  	CALL delay_us_00000

	}
	// serialized out the data
	// now get the status		
	// set SSPIF
	l_sspif = 1;
00D2  15C5  	BSF i2c_WRITE_00000_1_l_sspif,3

	l_acken = 1;
00D3  1641  	BSF i2c_WRITE_00000_1_l_acken,4

	l_ackdt = 0;
00D4  12C1  	BCF i2c_WRITE_00000_1_l_ackdt,5

	l_sda_tris = 1; // float SDA high
00D5  1683  	BSF STATUS, RP0
00D6  1607  	BSF i2c_WRITE_00000_1_l_sda_tris,4

	
	delay_us(dly);
00D7  300A  	MOVLW 0x0A
00D8  1283  	BCF STATUS, RP0
00D9  00F8  	MOVWF delay_us_00000_arg_del
00DA  2010  	CALL delay_us_00000

	
	l_scl_tris = 1; // float SCL high
00DB  1683  	BSF STATUS, RP0
00DC  1587  	BSF i2c_WRITE_00000_1_l_scl_tris,3

	
	// wait until any clock stretching has finished
	while (!l_scl)
00DD        label17
00DD  1283  	BCF STATUS, RP0
00DE  1987  	BTFSC i2c_WRITE_00000_1_l_scl,3
00DF  28E2  	GOTO	label18
00E1  28DD  	GOTO	label17
00E2        label18

		if (T_MODE & i2c_reset_wdt)
			clear_wdt();	
00E0  0064  	CLRWDT

	delay_us(dly);
00E2  300A  	MOVLW 0x0A
00E3  00F8  	MOVWF delay_us_00000_arg_del
00E4  2010  	CALL delay_us_00000


	// get the status bit
	local_ack = l_sda;
00E5  1077  	BCF i2c_WRITE_00000_1_local_ack,0
00E6  1A07  	BTFSC i2c_WRITE_00000_1_l_sda,4
00E7  1477  	BSF i2c_WRITE_00000_1_local_ack,0

	delay_us(dly);
00E8  300A  	MOVLW 0x0A
00E9  00F8  	MOVWF delay_us_00000_arg_del
00EA  2010  	CALL delay_us_00000


	l_scl_tris = 0; // drive SCL low	
00EB  1683  	BSF STATUS, RP0
00EC  1187  	BCF i2c_WRITE_00000_1_l_scl_tris,3

	l_acken = 0;
00ED  1283  	BCF STATUS, RP0
00EE  1241  	BCF i2c_WRITE_00000_1_l_acken,4

	delay_us(dly);
00EF  300A  	MOVLW 0x0A
00F0  00F8  	MOVWF delay_us_00000_arg_del
00F1  2010  	CALL delay_us_00000

	return(local_ack);
00F2  01F8  	CLRF CompTempVarRet552
00F3  1877  	BTFSC i2c_WRITE_00000_1_local_ack,0
00F4  0AF8  	INCF CompTempVarRet552, F

}
00F5  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Read Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_READ(char ack_status)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	char BitMask;
	char i2c_data;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
01CD  11C6  	BCF i2c_READ_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
01CE  11C5  	BCF i2c_READ_00000_1_l_sspif,3

	l_wcol = 0; // clear write collision flag	
01CF  13C0  	BCF i2c_READ_00000_1_l_wcol,7


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// enable master for 1 byte reception	
		l_rcen = 1;

		// wait until byte received
		while(!l_sspif || !l_bf)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// read the byte from the Rx register
		i2c_data = i2c_SSPBUF;			
			
		// wait until the bus is idle		
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		if (ack_status)
			l_ackdt = 1; // preset ack bit
		else
			l_ackdt = 0; // preset ack bit

		l_sspif = 0;
		l_acken = 1; // acknowledge sequence enable

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();								
	}
	else
	{
		// here for i2c software driver
		l_rcen = 1;
01D0  15C1  	BSF i2c_READ_00000_1_l_rcen,3

		l_ackdt = ack_status;
01D1  1875  	BTFSC i2c_READ_00000_arg_ack_status,0
01D2  16C1  	BSF i2c_READ_00000_1_l_ackdt,5
01D3  1C75  	BTFSS i2c_READ_00000_arg_ack_status,0
01D4  12C1  	BCF i2c_READ_00000_1_l_ackdt,5

		l_rw = 1;
01D5  1542  	BSF i2c_READ_00000_1_l_rw,2

		l_scl = 0; // prepare to set SCL line low
01D6  1187  	BCF i2c_READ_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low	
01D7  1207  	BCF i2c_READ_00000_1_l_sda,4


		// prepare to serialize in the byte
		l_sda_tris = 1; // float SDA
01D8  1683  	BSF STATUS, RP0
01D9  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

		delay_us(dly);
01DA  300A  	MOVLW 0x0A
01DB  1283  	BCF STATUS, RP0
01DC  00F8  	MOVWF delay_us_00000_arg_del
01DD  2010  	CALL delay_us_00000

		i2c_data = 0;
01DE  01F7  	CLRF i2c_READ_00000_1_i2c_data

		for (BitMask = 0x80; BitMask; BitMask>>=1)
01DF  3080  	MOVLW 0x80
01E0  00F6  	MOVWF i2c_READ_00000_1_BitMask
01E1        label35
01E1  08F6  	MOVF i2c_READ_00000_1_BitMask, F
01E2  1903  	BTFSC STATUS,Z
01E3  29FE  	GOTO	label39
01FB  1003  	BCF STATUS,C
01FC  0CF6  	RRF i2c_READ_00000_1_BitMask, F
01FD  29E1  	GOTO	label35
01FE        label39

		{
			l_scl_tris = 1; // float SCL high
01E4  1683  	BSF STATUS, RP0
01E5  1587  	BSF i2c_READ_00000_1_l_scl_tris,3

			// wait until any clock stretching has finished
			while (!l_scl)
01E6        label36
01E6  1283  	BCF STATUS, RP0
01E7  1987  	BTFSC i2c_READ_00000_1_l_scl,3
01E8  29EB  	GOTO	label37
01EA  29E6  	GOTO	label36
01EB        label37

				if (T_MODE & i2c_reset_wdt)
					clear_wdt();		
01E9  0064  	CLRWDT

			delay_us(dly);
01EB  300A  	MOVLW 0x0A
01EC  00F8  	MOVWF delay_us_00000_arg_del
01ED  2010  	CALL delay_us_00000


			// read the current bit
			l_sda_tris = 1; // float SDA
01EE  1683  	BSF STATUS, RP0
01EF  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

			if (l_sda)
01F0  1283  	BCF STATUS, RP0
01F1  1E07  	BTFSS i2c_READ_00000_1_l_sda,4
01F2  29F5  	GOTO	label38
01F5        label38

				i2c_data |= BitMask;
01F3  0876  	MOVF i2c_READ_00000_1_BitMask, W
01F4  04F7  	IORWF i2c_READ_00000_1_i2c_data, F

			l_scl_tris = 0; // drive SCL low
01F5  1683  	BSF STATUS, RP0
01F6  1187  	BCF i2c_READ_00000_1_l_scl_tris,3

			delay_us(dly);
01F7  300A  	MOVLW 0x0A
01F8  1283  	BCF STATUS, RP0
01F9  00F8  	MOVWF delay_us_00000_arg_del
01FA  2010  	CALL delay_us_00000

		}
		// flag receive complete			
		l_sspif = 1;
01FE  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		l_rcen = 0;
01FF  11C1  	BCF i2c_READ_00000_1_l_rcen,3

		
		// set the ACK state
		if (ack_status)	
0200  08F5  	MOVF i2c_READ_00000_arg_ack_status, F
0201  1903  	BTFSC STATUS,Z
0202  2A06  	GOTO	label40
0206        label40

			l_sda_tris = 1; // float SDA high
0203  1683  	BSF STATUS, RP0
0204  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

		else
0205  2A08  	GOTO	label41
0208        label41

			l_sda_tris = 0; // drive SDA low
0206  1683  	BSF STATUS, RP0
0207  1207  	BCF i2c_READ_00000_1_l_sda_tris,4

		delay_us(dly);
0208  300A  	MOVLW 0x0A
0209  1283  	BCF STATUS, RP0
020A  00F8  	MOVWF delay_us_00000_arg_del
020B  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
020C  1683  	BSF STATUS, RP0
020D  1587  	BSF i2c_READ_00000_1_l_scl_tris,3


		// wait until any clock stretching has finished
		while (!l_scl)
020E        label42
020E  1283  	BCF STATUS, RP0
020F  1987  	BTFSC i2c_READ_00000_1_l_scl,3
0210  2A13  	GOTO	label43
0212  2A0E  	GOTO	label42
0213        label43

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
0211  0064  	CLRWDT

	
		l_sspif = 0; // clear SSPIF
0213  11C5  	BCF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
0214  300A  	MOVLW 0x0A
0215  00F8  	MOVWF delay_us_00000_arg_del
0216  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low		
0217  1683  	BSF STATUS, RP0
0218  1187  	BCF i2c_READ_00000_1_l_scl_tris,3

		l_sspif = 1;
0219  1283  	BCF STATUS, RP0
021A  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
021B  300A  	MOVLW 0x0A
021C  00F8  	MOVWF delay_us_00000_arg_del
021D  2010  	CALL delay_us_00000

	}
	return(i2c_data);
021E  0877  	MOVF i2c_READ_00000_1_i2c_data, W
021F  00F8  	MOVWF CompTempVarRet553

}
0220  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Initialization
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_INIT(unsigned char i2c_divisor)

{
	volatile unsigned char i2c_SSPADD@T_i2c_SSPADD, i2c_SSPSTAT@T_i2c_SSPSTAT;
	volatile unsigned char i2c_SSPCON1@T_i2c_SSPCON1,i2c_SSPCON2@T_i2c_SSPCON2;

	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_sspen@T_i2c_SSPCON1.i2c_SSPEN, l_smp@T_i2c_SSPSTAT.T_i2c_SMP_BIT;

	l_sda_tris = 1;
04E1  1683  	BSF STATUS, RP0
04E2  1607  	BSF i2c_INIT_00000_1_l_sda_tris,4

	l_scl_tris = 1;
04E3  1587  	BSF i2c_INIT_00000_1_l_scl_tris,3

	
	i2c_SSPCON1 = 0x00; // initialise the I2C control register (mirrors HW SSPCON1)	
04E4  1283  	BCF STATUS, RP0
04E5  01C0  	CLRF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPADD = i2c_divisor; // get the I2C baud rate divisor
04E6  0873  	MOVF i2c_INIT_00000_arg_i2c_divisor, W
04E7  00C3  	MOVWF i2c_INIT_00000_1_i2c_SSPADD

	i2c_SSPCON1 = 0x08; // initialise the I2C control register (mirrors HW SSPCON1)	
04E8  3008  	MOVLW 0x08
04E9  00C0  	MOVWF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPCON2 = 0x00; // initialise the I2C control register (mirrors HW SSPCON2)	
04EA  01C1  	CLRF i2c_INIT_00000_1_i2c_SSPCON2

	
	i2c_SSPSTAT = 0x00; // initialise the I2C status register (mirrors HW SSPSTAT)
04EB  01C2  	CLRF i2c_INIT_00000_1_i2c_SSPSTAT

	
	if (T_MODE & i2c_SMP)
		l_smp = 1;
04EC  17C2  	BSF i2c_INIT_00000_1_l_smp,7


	l_sspif = 0; // initialise the I2C SSP interrupt status
04ED  11C5  	BCF i2c_INIT_00000_1_l_sspif,3

	l_bclif = 0; // initialise the I2C BCL interrupt status
04EE  11C6  	BCF i2c_INIT_00000_1_l_bclif,3

	l_sda = 0;
04EF  1207  	BCF i2c_INIT_00000_1_l_sda,4

	l_scl = 0;
04F0  1187  	BCF i2c_INIT_00000_1_l_scl,3

	l_sspen = 1; // enable I2C
04F1  16C0  	BSF i2c_INIT_00000_1_l_sspen,5

	
	i2c_STOP<_I2C_TEMPL_ARGS>();
04F2  20F6  	CALL i2c_STOP_00000

}
04F3  0008  	RETURN







////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  158A  	BSF PCLATH,3
0001  29A5  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B0  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00B1  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00B2  	MOVWF Int1BContext+D'2'
000D  158A  	BSF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2A0C  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010  3003  	MOVLW 0x03
0011  07F8  	ADDWF delay_us_00000_arg_del, F
0012  0CF8  	RRF delay_us_00000_arg_del, F
0013  0CF8  	RRF delay_us_00000_arg_del, F
0014  307F  	MOVLW 0x7F
0015  05F8  	ANDWF delay_us_00000_arg_del, F
0016        label1
0016  0000  	NOP
0017  0BF8  	DECFSZ delay_us_00000_arg_del, F
0018  2816  	GOTO	label1
0019  0008  	RETURN
001A        ; } delay_us function end

001A        __rom_get_00000
001A        ; { __rom_get ; function begin
001A  087B  	MOVF __rom_get_00000_arg_objNumb, W
001B  00FE  	MOVWF __rom_get_00000_1_romAddr+D'1'
001C  01FD  	CLRF __rom_get_00000_1_romAddr
001D  1003  	BCF STATUS,C
001E  0DFE  	RLF __rom_get_00000_1_romAddr+D'1', F
001F  0DFD  	RLF __rom_get_00000_1_romAddr, F
0020  0DFE  	RLF __rom_get_00000_1_romAddr+D'1', F
0021  0DFD  	RLF __rom_get_00000_1_romAddr, F
0022  07FE  	ADDWF __rom_get_00000_1_romAddr+D'1', F
0023  1803  	BTFSC STATUS,C
0024  0AFD  	INCF __rom_get_00000_1_romAddr, F
0025  07FE  	ADDWF __rom_get_00000_1_romAddr+D'1', F
0026  1803  	BTFSC STATUS,C
0027  0AFD  	INCF __rom_get_00000_1_romAddr, F
0028  3033  	MOVLW	LOW( label2 )
0029  07FE  	ADDWF __rom_get_00000_1_romAddr+D'1', F
002A  1803  	BTFSC STATUS,C
002B  0AFD  	INCF __rom_get_00000_1_romAddr, F
002C  3000  	MOVLW	HIGH( label2 )
002D  077D  	ADDWF __rom_get_00000_1_romAddr, W
002E  008A  	MOVWF PCLATH
002F  087C  	MOVF __rom_get_00000_arg_idx, W
0030  00FD  	MOVWF __rom_get_00000_1_romAddr
0031  087E  	MOVF __rom_get_00000_1_romAddr+D'1', W
0032  0082  	MOVWF PCL
0033        label2
0033  3000  	MOVLW	HIGH( label3 )
0034  008A  	MOVWF PCLATH
0035  3000  	MOVLW	HIGH( label4 )
0036  00FE  	MOVWF __rom_get_00000_1_romAddr+D'1'
0037  3049  	MOVLW	LOW( label4 )
0038  2842  	GOTO	label3
0039  3000  	MOVLW	HIGH( label3 )
003A  008A  	MOVWF PCLATH
003B  3000  	MOVLW	HIGH( label5 )
003C  00FE  	MOVWF __rom_get_00000_1_romAddr+D'1'
003D  3055  	MOVLW	LOW( label5 )
003E  2842  	GOTO	label3
003F  3000  	MOVLW	HIGH( label6 )
0040  00FE  	MOVWF __rom_get_00000_1_romAddr+D'1'
0041  306D  	MOVLW	LOW( label6 )
0042        label3
0042  07FD  	ADDWF __rom_get_00000_1_romAddr, F
0043  1803  	BTFSC STATUS,C
0044  0AFE  	INCF __rom_get_00000_1_romAddr+D'1', F
0045  087E  	MOVF __rom_get_00000_1_romAddr+D'1', W
0046  008A  	MOVWF PCLATH
0047  087D  	MOVF __rom_get_00000_1_romAddr, W
0048  0082  	MOVWF PCL
0049        label4
0049  3431  	RETLW 0x31
004A  3428  	RETLW 0x28
004B  3431  	RETLW 0x31
004C  3430  	RETLW 0x30
004D  3431  	RETLW 0x31
004E  3430  	RETLW 0x30
004F  3431  	RETLW 0x31
0050  3431  	RETLW 0x31
0051  3430  	RETLW 0x30
0052  3431  	RETLW 0x31
0053  3430  	RETLW 0x30
0054  3431  	RETLW 0x31
0055        label5
0055  3404  	RETLW 0x04
0056  3408  	RETLW 0x08
0057  3412  	RETLW 0x12
0058  3416  	RETLW 0x16
0059  3420  	RETLW 0x20
005A  3424  	RETLW 0x24
005B  3428  	RETLW 0x28
005C  3432  	RETLW 0x32
005D  3436  	RETLW 0x36
005E  3440  	RETLW 0x40
005F  3444  	RETLW 0x44
0060  3448  	RETLW 0x48
0061  3452  	RETLW 0x52
0062  3456  	RETLW 0x56
0063  3460  	RETLW 0x60
0064  3464  	RETLW 0x64
0065  3468  	RETLW 0x68
0066  3472  	RETLW 0x72
0067  3476  	RETLW 0x76
0068  3480  	RETLW 0x80
0069  3484  	RETLW 0x84
006A  3488  	RETLW 0x88
006B  3492  	RETLW 0x92
006C  3496  	RETLW 0x96
006D        label6
006D  343F  	RETLW 0x3F
006E  3406  	RETLW 0x06
006F  345B  	RETLW 0x5B
0070  344F  	RETLW 0x4F
0071  3466  	RETLW 0x66
0072  346D  	RETLW 0x6D
0073  347D  	RETLW 0x7D
0074  3407  	RETLW 0x07
0075  347F  	RETLW 0x7F
0076  346F  	RETLW 0x6F
0077        ; } __rom_get function end

0077        delay_10us_00000
0077        ; { delay_10us ; function begin
0077        label7
0077  0000  	NOP
0078  0000  	NOP
0079  0000  	NOP
007A  0000  	NOP
007B  0000  	NOP
007C  0000  	NOP
007D  0000  	NOP
007E  0BF7  	DECFSZ delay_10us_00000_arg_del, F
007F  2877  	GOTO	label7
0080  0008  	RETURN
0081        ; } delay_10us function end

0081        delay_ms_00000
0081        ; { delay_ms ; function begin
0081  08F2  	MOVF delay_ms_00000_arg_del, F
0082  1D03  	BTFSS STATUS,Z
0083  2885  	GOTO	label8
0084  0008  	RETURN
0085        label8
0085  30F9  	MOVLW 0xF9
0086        label9
0086  3EFF  	ADDLW 0xFF
0087  1D03  	BTFSS STATUS,Z
0088  2886  	GOTO	label9
0089  0000  	NOP
008A  0BF2  	DECFSZ delay_ms_00000_arg_del, F
008B  2885  	GOTO	label8
008C  0008  	RETURN
008D        ; } delay_ms function end











025F        __mul_16s__0000F
025F        ; { __mul_16s_16s__16 ; function begin
025F  01FE  	CLRF __mul_16s__0000F_1_i
0260  1683  	BSF STATUS, RP0
0261  01A2  	CLRF CompTempVarRet389
0262  01A3  	CLRF CompTempVarRet389+D'1'
0263  1283  	BCF STATUS, RP0
0264  087A  	MOVF __mul_16s__0000F_arg_a, W
0265  1683  	BSF STATUS, RP0
0266  00A0  	MOVWF __mul_16s__0000F_1_t
0267  1283  	BCF STATUS, RP0
0268  087B  	MOVF __mul_16s__0000F_arg_a+D'1', W
0269  1683  	BSF STATUS, RP0
026A  00A1  	MOVWF __mul_16s__0000F_1_t+D'1'
026B  1283  	BCF STATUS, RP0
026C  1FFD  	BTFSS __mul_16s__0000F_arg_b+D'1',7
026D  2A74  	GOTO	label50
026E  17FE  	BSF __mul_16s__0000F_1_i,7
026F  09FC  	COMF __mul_16s__0000F_arg_b, F
0270  09FD  	COMF __mul_16s__0000F_arg_b+D'1', F
0271  0AFC  	INCF __mul_16s__0000F_arg_b, F
0272  1903  	BTFSC gbl_status,2
0273  0AFD  	INCF __mul_16s__0000F_arg_b+D'1', F
0274        label50
0274  1A7E  	BTFSC __mul_16s__0000F_1_i,4
0275  2A8A  	GOTO	label52
0276  1C7C  	BTFSS __mul_16s__0000F_arg_b,0
0277  2A7F  	GOTO	label51
0278  1683  	BSF STATUS, RP0
0279  0820  	MOVF __mul_16s__0000F_1_t, W
027A  07A2  	ADDWF CompTempVarRet389, F
027B  0821  	MOVF __mul_16s__0000F_1_t+D'1', W
027C  1803  	BTFSC gbl_status,0
027D  0F21  	INCFSZ __mul_16s__0000F_1_t+D'1', W
027E  07A3  	ADDWF CompTempVarRet389+D'1', F
027F        label51
027F  1003  	BCF gbl_status,0
0280  1283  	BCF STATUS, RP0
0281  0CFD  	RRF __mul_16s__0000F_arg_b+D'1', F
0282  0CFC  	RRF __mul_16s__0000F_arg_b, F
0283  1003  	BCF gbl_status,0
0284  1683  	BSF STATUS, RP0
0285  0DA0  	RLF __mul_16s__0000F_1_t, F
0286  0DA1  	RLF __mul_16s__0000F_1_t+D'1', F
0287  1283  	BCF STATUS, RP0
0288  0AFE  	INCF __mul_16s__0000F_1_i, F
0289  2A74  	GOTO	label50
028A        label52
028A  1FFE  	BTFSS __mul_16s__0000F_1_i,7
028B  0008  	RETURN
028C  1683  	BSF STATUS, RP0
028D  09A2  	COMF CompTempVarRet389, F
028E  09A3  	COMF CompTempVarRet389+D'1', F
028F  0AA2  	INCF CompTempVarRet389, F
0290  1903  	BTFSC gbl_status,2
0291  0AA3  	INCF CompTempVarRet389+D'1', F
0292  0008  	RETURN
0293        ; } __mul_16s_16s__16 function end





































09A5        _startup

0A09  158A  	BSF PCLATH,3
0A0A  120A  	BCF PCLATH,4
0A0B  28CD  	GOTO	main

2007  3FB1  	DW 0x3FB1
