;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 8.01
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

#ifndef _PIC16F_TM1638_AquariumControl_H_
#define _PIC16F_TM1638_AquariumControl_H_

#define TASK_TIMER0 1
#define TASK_TIMER1 2

#define oneWireBus (portc.5)
#define oneWireTris (trisc.5)
#define tm1638dio (portb.1)
#define tm1638dioTris (trisb.1)
#define tm1638clk (portb.2)
#define tm1638strobe (portb.3)
#define WHITE_LED (portc.1)
#define BLUE_LED (portc.2)
#define FAN (porta.1)
#define HEATER (porta.0)

// Timer 0 preload

#define TMR0PRELOAD 61
// This means timer 1 will overflow when 1 cycle completes, generating the interrupt
#define TMR1HV 0xFF
#define TMR1LV 0xFF

// i2c options
#define use_i2c_SW
// clock SCL on RA3, data SDA on RA4
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)
// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3

#define ds3231Addr 0xD0 // Left shifted 7 bit address 0x68
#define at24c32Addr 0xAE // Left shifted 7 bit address 0x57

// Time and date variables
char gBcdSecond = 0; // 0 to 59
07FF  1283  	BCF STATUS, RP0
0800  1303  	BCF STATUS, RP1
0801  01B5  	CLRF gbl_gBcdSecond

char gBcdMinute = 0; // 0 to 59
0802  01B6  	CLRF gbl_gBcdMinute

char gBcdHour = 0; // 0 to 23 or 1 to 12. Also contains 12/24 setting at bit 6. If 12 hour, AM/PM uses bit 5
0803  01B7  	CLRF gbl_gBcdHour

char gDayOfWeek = 1; // 1 to 7
0804  3001  	MOVLW 0x01
0805  00B8  	MOVWF gbl_gDayOfWeek

char gBcdDayOfMonth = 1; // 1 to 31
0806  3001  	MOVLW 0x01
0807  00B9  	MOVWF gbl_gBcdDayOfMonth

char gBcdMonth = 1; // 1 to 12 + century at bit 7
0808  3001  	MOVLW 0x01
0809  00BA  	MOVWF gbl_gBcdMonth

char gBcdYear = 0x23; // Init to 0x23
080A  3023  	MOVLW 0x23
080B  00BB  	MOVWF gbl_gBcdYear

rom char *gDaysInMonth = {0x31, 0x28, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31}; // Days in each month
080C  3000  	MOVLW 0x00
080D  00BC  	MOVWF gbl_gDaysInMonth

rom char *gLeapYears = {0x04, 0x08, 0x12, 0x16, 0x20, 0x24, 0x28, 0x32, 0x36, 0x40, 0x44, 0x48, 0x52, 0x56, 0x60, 0x64, 0x68, 0x72, 0x76, 0x80, 0x84, 0x88, 0x92, 0x96}; // List of leap years
080E  3001  	MOVLW 0x01
080F  00BD  	MOVWF gbl_gLeapYears


// Timer variables
char iTimer0Counts = 0;
0810  01BE  	CLRF gbl_iTimer0Counts

char iFlashDigitOff = 0;
0811  01BF  	CLRF gbl_iFlashDigitOff

char iDigitToFlash = 8; // 8 = no digit to flash
0812  3008  	MOVLW 0x08
0813  00C8  	MOVWF gbl_iDigitToFlash


// Hold the upper and lower bytes from the ds18b20
char cTempH = 1;
0814  3001  	MOVLW 0x01
0815  00C9  	MOVWF gbl_cTempH

char cTempL = 70;
0816  3046  	MOVLW 0x46
0817  00CA  	MOVWF gbl_cTempL

//char iDecimalPosition = 2;

int giDS3231ValueBCD = 0x2000;
0818  01B3  	CLRF gbl_giDS3231ValueBCD
0819  3020  	MOVLW 0x20
081A  00B4  	MOVWF gbl_giDS3231ValueBCD+D'1'

char gbDS3231IsMinus = 0;
081B  01CB  	CLRF gbl_gbDS3231IsMinus


char cTask = 0; // Used for task scheduler
081C  01CC  	CLRF gbl_cTask


// States
bool gbWhiteOn = 0;
081D  104D  	BCF gbl_gbWhiteOn,0

bool gbBlueOn = 0;
081E  10CD  	BCF gbl_gbBlueOn,1

bool gbFanOn = 0;
081F  114D  	BCF gbl_gbFanOn,2

bool gbHeaterOn = 0;
0820  11CD  	BCF gbl_gbHeaterOn,3

bool gbFlashOff = 0;
0821  124D  	BCF gbl_gbFlashOff,4

char gcDisplayMode = 0;
0822  01CE  	CLRF gbl_gcDisplayMode

char gcSetMode = 0;
0823  01CF  	CLRF gbl_gcSetMode

char gcTriggerMode = 0;
0824  01D0  	CLRF gbl_gcTriggerMode


// Triggers
char gBcdWhiteOnMinute = 0; // 0 to 59
0825  01D1  	CLRF gbl_gBcdWhiteOnMinute

char gBcdWhiteOnHour = 0; // 0 to 23
0826  01D2  	CLRF gbl_gBcdWhiteOnHour

char gBcdWhiteOffMinute = 0; // 0 to 59
0827  01D3  	CLRF gbl_gBcdWhiteOffMinute

char gBcdWhiteOffHour = 0; // 0 to 23
0828  01D4  	CLRF gbl_gBcdWhiteOffHour


char gBcdBlueOnMinute = 0; // 0 to 59
0829  01D5  	CLRF gbl_gBcdBlueOnMinute

char gBcdBlueOnHour = 0; // 0 to 23
082A  01D6  	CLRF gbl_gBcdBlueOnHour

char gBcdBlueOffMinute = 0; // 0 to 59
082B  01D7  	CLRF gbl_gBcdBlueOffMinute

char gBcdBlueOffHour = 0; // 0 to 23
082C  01D8  	CLRF gbl_gBcdBlueOffHour


char gBcdFanOnTemp = 0x28; // Degrees C
082D  3028  	MOVLW 0x28
082E  00D9  	MOVWF gbl_gBcdFanOnTemp

char gBcdFanOffTemp = 0x27; // Degrees C
082F  3027  	MOVLW 0x27
0830  00DA  	MOVWF gbl_gBcdFanOffTemp


char gBcdHeaterOnTemp = 0x24; // Degrees C
0831  3024  	MOVLW 0x24
0832  00DB  	MOVWF gbl_gBcdHeaterOnTemp

char gBcdHeaterOffTemp = 0x25; // Degrees C
0833  3025  	MOVLW 0x25
0834  00DC  	MOVWF gbl_gBcdHeaterOffTemp


// Used to output the segments from numbers
char tm1638MaxDigits = 8;
0835  3008  	MOVLW 0x08
0836  00DD  	MOVWF gbl_tm1638MaxDigits

rom char *tm1638DisplayNumtoSeg = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f};
0837  3002  	MOVLW 0x02
0838  00DE  	MOVWF gbl_tm1638DisplayNumtoSeg

char tm1638Dot = 0x80;
0839  3080  	MOVLW 0x80
083A  00DF  	MOVWF gbl_tm1638Dot

char tm1638Brightness = 7; // 0 to 7
083B  3007  	MOVLW 0x07
083C  00E0  	MOVWF gbl_tm1638Brightness

// 0x40 [01000000] = indicate command to display data
char tm1638ByteSetData = 0x40;
083D  3040  	MOVLW 0x40
083E  00E1  	MOVWF gbl_tm1638ByteSetData

// 0x42 [01000010] = indicate command to read data
char tm1638ByteReadData = 0x42;
083F  3042  	MOVLW 0x42
0840  00E2  	MOVWF gbl_tm1638ByteReadData

// 0xC0 [11000000] = write out all bytes
char tm1638ByteSetAddr = 0xC0;
0841  30C0  	MOVLW 0xC0
0842  00E3  	MOVWF gbl_tm1638ByteSetAddr

// 0x88 [10001000] - Display ON, plus brightness
char tm1638ByteSetOn = 0x88;
0843  3088  	MOVLW 0x88
0844  00E4  	MOVWF gbl_tm1638ByteSetOn


// Copy of the data to write / on the display
char tm1638Data[] = {0, 0, 0, 0, 0, 0, 0, 0};
0845  01A0  	CLRF gbl_tm1638Data
0846  01A1  	CLRF gbl_tm1638Data+D'1'
0847  01A2  	CLRF gbl_tm1638Data+D'2'
0848  01A3  	CLRF gbl_tm1638Data+D'3'
0849  01A4  	CLRF gbl_tm1638Data+D'4'
084A  01A5  	CLRF gbl_tm1638Data+D'5'
084B  01A6  	CLRF gbl_tm1638Data+D'6'
084C  01A7  	CLRF gbl_tm1638Data+D'7'

// Copy of the LED status
char tm1638LEDs[] = {0, 0, 0, 0, 0, 0, 0, 0};
084D  01A8  	CLRF gbl_tm1638LEDs
084E  01A9  	CLRF gbl_tm1638LEDs+D'1'
084F  01AA  	CLRF gbl_tm1638LEDs+D'2'
0850  01AB  	CLRF gbl_tm1638LEDs+D'3'
0851  01AC  	CLRF gbl_tm1638LEDs+D'4'
0852  01AD  	CLRF gbl_tm1638LEDs+D'5'
0853  01AE  	CLRF gbl_tm1638LEDs+D'6'
0854  01AF  	CLRF gbl_tm1638LEDs+D'7'

// Copy of the keys
char tm1638Keys = 0;
0855  01E5  	CLRF gbl_tm1638Keys

char tm1638KeysOld = 0;
0856  01E6  	CLRF gbl_tm1638KeysOld

// For printing
char iPrintStartDigit = 0;
0857  01E7  	CLRF gbl_iPrintStartDigit

char iPrintDotDigit = 8;
0858  3008  	MOVLW 0x08
0859  00E8  	MOVWF gbl_iPrintDotDigit

// For adjusting bcd numbers up 1 or down !1
char iBcdAdjustment = 1;
085A  3001  	MOVLW 0x01
085B  00E9  	MOVWF gbl_iBcdAdjustment


// DS18B20 functions
char oneWireIsPresent = 0;
085C  01EA  	CLRF gbl_oneWireIsPresent

char oneWireResetStage = 0;
085D  01EB  	CLRF gbl_oneWireResetStage

void oneWireBusReset();
void oneWireTxByte(char data);
void oneWireTxBytes(char data, char data2);
char oneWireRxByte();

// EEPROM functions
void eepromWriteAll();
char eepromWrite(char address, char data);
void eepromReadAll();
char eepromRead(char address);

// DS3231 functions
void ds3231Write(char ds3231Reg, char bWrite);
void ds3231Init();
void ds3231Start();
void ds3231Stop();
void ds3231WriteDateTime();
void ds3231ReadDateTime();
char ds3231ReadRegister(char cRegAddress);

// TM1638 functions
void tm1638ByteWrite(char bWrite);
void bcdTo7Seg(char iBcdIn);
void tm1638DisplayOn();
void tm1638UpdateDisplay();
void tm1638ReadKeys();

// General functions
int binToBcd(int iBin);
void startTemp();
void readTemp();

char bcdAdjust(char bcd, char bcdMax, char bcdMin);
void adjustDateTime();
void adjustTrigger();
void processKeys();

#endif

#include <system.h>
#include <i2c_driver.h>
#include "PIC16F_TM1638_AquariumControl.h"

//Target PIC16F628A configuration word
#pragma DATA _CONFIG, _BODEN_OFF & _PWRTE_ON & _WDT_OFF & _CP_OFF & _XT_OSC // Brown out reset off, Power-up Timer on, Watchdog timer off, Code Protection off, XT oscillator

//Set clock frequency (for software delays) - 4MHz
#pragma CLOCK_FREQ	4000000

    
/*********************************************************************************************
  void oneWireBusReset()
  First part of the reset routine - drive the bus low for 500us
*********************************************************************************************/
void oneWireBusReset() {

    char isPresent;
    oneWireTris = 1; // start with high
0686  1683  	BSF STATUS, RP0
0687  1303  	BCF STATUS, RP1
0688  1687  	BSF gbl_trisc,5

    isPresent = 0;
0689  1283  	BCF STATUS, RP0
068A  01EC  	CLRF oneWireBus_00017_1_isPresent

    // Send the reset pulse - drive low for 500us
    oneWireBus = 0;      
068B  1287  	BCF gbl_portc,5

    oneWireTris = 0;
068C  1683  	BSF STATUS, RP0
068D  1287  	BCF gbl_trisc,5

    delay_10us(50);
068E  3032  	MOVLW 0x32
068F  1283  	BCF STATUS, RP0
0690  00F1  	MOVWF delay_10us_00000_arg_del
0691  2077  	CALL delay_10us_00000

    // Release line and wait 70us for PD Pulse
    oneWireTris = 1;
0692  1683  	BSF STATUS, RP0
0693  1687  	BSF gbl_trisc,5

    delay_10us(7);
0694  3007  	MOVLW 0x07
0695  1283  	BCF STATUS, RP0
0696  00F1  	MOVWF delay_10us_00000_arg_del
0697  2077  	CALL delay_10us_00000

    // Now sample, if there is a sensor on the bus, the line should be low
    if (oneWireBus) {
0698  1A87  	BTFSC gbl_portc,5

        oneWireIsPresent = 0; // no devices
0699  01EA  	CLRF gbl_oneWireIsPresent

    }
    delay_10us(50);
069A  3032  	MOVLW 0x32
069B  00F1  	MOVWF delay_10us_00000_arg_del
069C  2077  	CALL delay_10us_00000

}
069D  0008  	RETURN


/*********************************************************************************************
  void oneWireTxByte(char data)
  Transmits a single byte from the bus
*********************************************************************************************/
void oneWireTxByte(char cData) {

    char cTemp = 1;
016E  3001  	MOVLW 0x01
016F  00EF  	MOVWF oneWireTxB_00018_1_cTemp

    // Loop through the eight bits in the byte
    for (char i = 0; i < 8; i++) {
0170  01F0  	CLRF oneWireTxB_00018_2_i
0171        label26
0171  3008  	MOVLW 0x08
0172  0270  	SUBWF oneWireTxB_00018_2_i, W
0173  1803  	BTFSC STATUS,C
0188  0AF0  	INCF oneWireTxB_00018_2_i, F
0189  2971  	GOTO	label26

        // Send the LSB first

        // Drive the line low initially for 3us
        oneWireTris = 0;
0175  1683  	BSF STATUS, RP0
0176  1287  	BCF gbl_trisc,5

        oneWireBus = 0;
0177  1283  	BCF STATUS, RP0
0178  1287  	BCF gbl_portc,5


        // Delay not needed for 4MHz PIC
        //delay_us(3); // Delay 3us
        
        if (cData & cTemp) {
0179  086F  	MOVF oneWireTxB_00018_1_cTemp, W
017A  056E  	ANDWF oneWireTxB_00018_arg_cData, W
017B  1903  	BTFSC STATUS,Z
017C  297F  	GOTO	label27

            oneWireTris = 1; // Release the bus
017D  1683  	BSF STATUS, RP0
017E  1687  	BSF gbl_trisc,5

        }
        
        delay_10us(5); // Delay 60us - 50us works fine with code delays
017F  3005  	MOVLW 0x05
0180  1283  	BCF STATUS, RP0
0181  00F1  	MOVWF delay_10us_00000_arg_del
0182  2077  	CALL delay_10us_00000

        oneWireTris = 1; // Release the bus
0183  1683  	BSF STATUS, RP0
0184  1687  	BSF gbl_trisc,5

        
        // move the test bit
        cTemp <<= 1;
0185  1003  	BCF STATUS,C
0186  1283  	BCF STATUS, RP0
0187  0DEF  	RLF oneWireTxB_00018_1_cTemp, F

    }
}
0174  0008  	RETURN


/*********************************************************************************************
  void oneWireTxBytes(char data, char data2)
  Transmits a 2 bytes from the bus
*********************************************************************************************/
void oneWireTxBytes(char cData, char cData2) {

    // Reset first - done in main
    //oneWireBusReset();
    // Send first byte
    oneWireTxByte(cData);
03AD  086C  	MOVF oneWireTxB_00019_arg_cData, W
03AE  00EE  	MOVWF oneWireTxB_00018_arg_cData
03AF  216E  	CALL oneWireTxB_00018

    // Send second byte
    oneWireTxByte(cData2);
03B0  086D  	MOVF oneWireTxB_00019_arg_cData2, W
03B1  00EE  	MOVWF oneWireTxB_00018_arg_cData
03B2  216E  	CALL oneWireTxB_00018

}
03B3  0008  	RETURN


/*********************************************************************************************
  char oneWireRxByte()
  Receives a single byte from the bus
*********************************************************************************************/
char oneWireRxByte() {

    char cDataIn = 0;
03B4  1283  	BCF STATUS, RP0
03B5  1303  	BCF STATUS, RP1
03B6  01EC  	CLRF oneWireRxB_0001A_1_cDataIn

    // Loop through the eight bits in the byte
    for(char i = 0; i < 8; i++) {
03B7  01ED  	CLRF oneWireRxB_0001A_2_i
03B8        label77
03B8  3008  	MOVLW 0x08
03B9  026D  	SUBWF oneWireRxB_0001A_2_i, W
03BA  1803  	BTFSC STATUS,C
03BB  2BCF  	GOTO	label78
03CD  0AED  	INCF oneWireRxB_0001A_2_i, F
03CE  2BB8  	GOTO	label77
03CF        label78

        // Bring bus low for 15us
        oneWireTris = 0;
03BC  1683  	BSF STATUS, RP0
03BD  1287  	BCF gbl_trisc,5

        oneWireBus = 0;
03BE  1283  	BCF STATUS, RP0
03BF  1287  	BCF gbl_portc,5


        // Delay not needed for 4MHz PIC
        //delay_us(15); // Delay 15us

        // Release bus for 6us, this is enough time for the slave to respond
        oneWireTris = 1;
03C0  1683  	BSF STATUS, RP0
03C1  1687  	BSF gbl_trisc,5

        delay_us(3); // Delay 6us
03C2  3003  	MOVLW 0x03
03C3  1283  	BCF STATUS, RP0
03C4  00F2  	MOVWF delay_us_00000_arg_del
03C5  2010  	CALL delay_us_00000

        
        // Shift data already received left
        cDataIn >>= 1;
03C6  1003  	BCF STATUS,C
03C7  0CEC  	RRF oneWireRxB_0001A_1_cDataIn, F

        
        // Check the value of the onewire bus - set the MSB of cDataIn if so
        if (oneWireBus)
03C8  1A87  	BTFSC gbl_portc,5

            cDataIn.7 = 1;
03C9  17EC  	BSF oneWireRxB_0001A_1_cDataIn,7


        // To finish time slot
        delay_10us(6); // 60us
03CA  3006  	MOVLW 0x06
03CB  00F1  	MOVWF delay_10us_00000_arg_del
03CC  2077  	CALL delay_10us_00000

    } 
    
    return cDataIn;
03CF  086C  	MOVF oneWireRxB_0001A_1_cDataIn, W
03D0  00ED  	MOVWF CompTempVarRet551

}
03D1  0008  	RETURN


/*********************************************************************************************
  void at24c32WriteAll()
  Write multiple bytes
*********************************************************************************************/
void at24c32WriteAll() {

	// https://www.instructables.com/The-Most-Comprehensive-Guide-to-Programming-the-AT/
	i2c_start();
0421  2126  	CALL i2c_START_00000

	i2c_write(at24c32Addr); // address + write
0422  30AE  	MOVLW 0xAE
0423  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0424  20A5  	CALL i2c_WRITE_00000

	// start at address 0
	i2c_write(0); // First word address (only 4 bits of the 12 bit byte address)
0425  01EF  	CLRF i2c_WRITE_00000_arg_i2c_data
0426  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // Second word address 
0427  01EF  	CLRF i2c_WRITE_00000_arg_i2c_data
0428  20A5  	CALL i2c_WRITE_00000

	// Write data bytes
	// We're only writing 13 bytes here, so no need to worry about row rollover after 32 bytes
	i2c_write(0x44); // To indicate AT24C32 has been written to
0429  3044  	MOVLW 0x44
042A  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
042B  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdWhiteOnMinute);
042C  0851  	MOVF gbl_gBcdWhiteOnMinute, W
042D  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
042E  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOnHour);
042F  0852  	MOVF gbl_gBcdWhiteOnHour, W
0430  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0431  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOffMinute);
0432  0853  	MOVF gbl_gBcdWhiteOffMinute, W
0433  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0434  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdWhiteOffHour);
0435  0854  	MOVF gbl_gBcdWhiteOffHour, W
0436  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0437  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOnMinute);
0438  0855  	MOVF gbl_gBcdBlueOnMinute, W
0439  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
043A  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOnHour);
043B  0856  	MOVF gbl_gBcdBlueOnHour, W
043C  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
043D  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOffMinute);
043E  0857  	MOVF gbl_gBcdBlueOffMinute, W
043F  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0440  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdBlueOffHour);
0441  0858  	MOVF gbl_gBcdBlueOffHour, W
0442  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0443  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdFanOnTemp);
0444  0859  	MOVF gbl_gBcdFanOnTemp, W
0445  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0446  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdFanOffTemp);
0447  085A  	MOVF gbl_gBcdFanOffTemp, W
0448  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0449  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdHeaterOnTemp);
044A  085B  	MOVF gbl_gBcdHeaterOnTemp, W
044B  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
044C  20A5  	CALL i2c_WRITE_00000

    i2c_write(gBcdHeaterOffTemp);
044D  085C  	MOVF gbl_gBcdHeaterOffTemp, W
044E  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
044F  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
0450  20F6  	CALL i2c_STOP_00000

	delay_ms(10); // Write Cycle Time
0451  300A  	MOVLW 0x0A
0452  00EC  	MOVWF delay_ms_00000_arg_del
0453  2081  	CALL delay_ms_00000

}
0454  0008  	RETURN


/*********************************************************************************************
  void at24c32ReadAll()
  Read all bytes
*********************************************************************************************/
void at24c32ReadAll() {

	i2c_start();
0455  2126  	CALL i2c_START_00000

	i2c_write(at24c32Addr); // address + write
0456  30AE  	MOVLW 0xAE
0457  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0458  20A5  	CALL i2c_WRITE_00000

	// start at address 0
	i2c_write(0); // First word address (only 4 bits of the 12 bit byte address)
0459  01EF  	CLRF i2c_WRITE_00000_arg_i2c_data
045A  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // Second word address 
045B  01EF  	CLRF i2c_WRITE_00000_arg_i2c_data
045C  20A5  	CALL i2c_WRITE_00000

	i2c_stop(); // Don't actually write a byte, just stop
045D  20F6  	CALL i2c_STOP_00000

	
	i2c_start();
045E  2126  	CALL i2c_START_00000

	i2c_write(at24c32Addr + 1); // address + read
045F  30AF  	MOVLW 0xAF
0460  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0461  20A5  	CALL i2c_WRITE_00000

	char hasWritten = i2c_read(0); // ack
0462  01EF  	CLRF i2c_READ_00000_arg_ack_status
0463  218A  	CALL i2c_READ_00000
0464  0872  	MOVF CompTempVarRet553, W
0465  00ED  	MOVWF at24c32Rea_0002A_1_hasWritten

	if (hasWritten != 0x44) {
0466  086D  	MOVF at24c32Rea_0002A_1_hasWritten, W
0467  3A44  	XORLW 0x44
0468  1903  	BTFSC STATUS,Z
0469  2C6E  	GOTO	label79
046E        label79

		i2c_read(1); // nack
046A  3001  	MOVLW 0x01
046B  00EF  	MOVWF i2c_READ_00000_arg_ack_status
046C  218A  	CALL i2c_READ_00000

	} else {
046D  2C9F  	GOTO	label80
049F        label80

		gBcdWhiteOnMinute = i2c_read(0); // ack
046E  01EF  	CLRF i2c_READ_00000_arg_ack_status
046F  218A  	CALL i2c_READ_00000
0470  0872  	MOVF CompTempVarRet553, W
0471  00D1  	MOVWF gbl_gBcdWhiteOnMinute

		gBcdWhiteOnHour = i2c_read(0); // ack
0472  01EF  	CLRF i2c_READ_00000_arg_ack_status
0473  218A  	CALL i2c_READ_00000
0474  0872  	MOVF CompTempVarRet553, W
0475  00D2  	MOVWF gbl_gBcdWhiteOnHour

		gBcdWhiteOffMinute = i2c_read(0); // ack
0476  01EF  	CLRF i2c_READ_00000_arg_ack_status
0477  218A  	CALL i2c_READ_00000
0478  0872  	MOVF CompTempVarRet553, W
0479  00D3  	MOVWF gbl_gBcdWhiteOffMinute

		gBcdWhiteOffHour = i2c_read(0); // ack
047A  01EF  	CLRF i2c_READ_00000_arg_ack_status
047B  218A  	CALL i2c_READ_00000
047C  0872  	MOVF CompTempVarRet553, W
047D  00D4  	MOVWF gbl_gBcdWhiteOffHour

		gBcdBlueOnMinute = i2c_read(0); // ack
047E  01EF  	CLRF i2c_READ_00000_arg_ack_status
047F  218A  	CALL i2c_READ_00000
0480  0872  	MOVF CompTempVarRet553, W
0481  00D5  	MOVWF gbl_gBcdBlueOnMinute

		gBcdBlueOnHour = i2c_read(0); // ack
0482  01EF  	CLRF i2c_READ_00000_arg_ack_status
0483  218A  	CALL i2c_READ_00000
0484  0872  	MOVF CompTempVarRet553, W
0485  00D6  	MOVWF gbl_gBcdBlueOnHour

		gBcdBlueOffMinute = i2c_read(0); // ack
0486  01EF  	CLRF i2c_READ_00000_arg_ack_status
0487  218A  	CALL i2c_READ_00000
0488  0872  	MOVF CompTempVarRet553, W
0489  00D7  	MOVWF gbl_gBcdBlueOffMinute

		gBcdBlueOffHour = i2c_read(0); // ack
048A  01EF  	CLRF i2c_READ_00000_arg_ack_status
048B  218A  	CALL i2c_READ_00000
048C  0872  	MOVF CompTempVarRet553, W
048D  00D8  	MOVWF gbl_gBcdBlueOffHour

		gBcdFanOnTemp = i2c_read(0); // ack
048E  01EF  	CLRF i2c_READ_00000_arg_ack_status
048F  218A  	CALL i2c_READ_00000
0490  0872  	MOVF CompTempVarRet553, W
0491  00D9  	MOVWF gbl_gBcdFanOnTemp

		gBcdFanOffTemp = i2c_read(0); // ack
0492  01EF  	CLRF i2c_READ_00000_arg_ack_status
0493  218A  	CALL i2c_READ_00000
0494  0872  	MOVF CompTempVarRet553, W
0495  00DA  	MOVWF gbl_gBcdFanOffTemp

		gBcdHeaterOnTemp = i2c_read(0); // ack
0496  01EF  	CLRF i2c_READ_00000_arg_ack_status
0497  218A  	CALL i2c_READ_00000
0498  0872  	MOVF CompTempVarRet553, W
0499  00DB  	MOVWF gbl_gBcdHeaterOnTemp

		gBcdHeaterOffTemp = i2c_read(1); // nack
049A  3001  	MOVLW 0x01
049B  00EF  	MOVWF i2c_READ_00000_arg_ack_status
049C  218A  	CALL i2c_READ_00000
049D  0872  	MOVF CompTempVarRet553, W
049E  00DC  	MOVWF gbl_gBcdHeaterOffTemp

	}
	i2c_stop();
049F  20F6  	CALL i2c_STOP_00000

}
04A0  0008  	RETURN



/*********************************************************************************************
  void ds3231Write(char ds3231Reg, char bWrite)
  Write one byte
*********************************************************************************************/
void ds3231Write(char ds3231Reg, char bWrite) {

	i2c_start();
01DE  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
01DF  30D0  	MOVLW 0xD0
01E0  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
01E1  20A5  	CALL i2c_WRITE_00000

	i2c_write(ds3231Reg); // start at address
01E2  086D  	MOVF ds3231Writ_0001B_arg_ds3231Reg, W
01E3  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
01E4  20A5  	CALL i2c_WRITE_00000

	i2c_write(bWrite); // start at address
01E5  086E  	MOVF ds3231Writ_0001B_arg_bWrite, W
01E6  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
01E7  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
01E8  20F6  	CALL i2c_STOP_00000

}
01E9  0008  	RETURN


/*********************************************************************************************
  void ds3231Init()
  Initialise the DS3231
*********************************************************************************************/
void ds3231Init() {

	/* control register 0Eh
    bit7 EOSC   Enable Oscillator (1 if oscillator must be stopped when on battery)
    bit6 BBSQW  Battery Backed Square Wave - 0 means square wave disabled when VCC falls below VPF (power fail voltage)
    bit5 CONV   Convert temperature (1 forces a conversion)
    bit4 RS2    Rate select - frequency of square wave output - NA for DS3231M
    bit3 RS1    Rate select - NA for DS3231M
    bit2 INTCN  Interrupt control (1 for use of the alarms and to disable square wave)
    bit1 A2IE   Alarm2 interrupt enable (1 to enable)
    bit0 A1IE   Alarm1 interrupt enable (1 to enable)
    */
	ds3231Write(0x0E, 0x00);
0416  300E  	MOVLW 0x0E
0417  1283  	BCF STATUS, RP0
0418  1303  	BCF STATUS, RP1
0419  00ED  	MOVWF ds3231Writ_0001B_arg_ds3231Reg
041A  01EE  	CLRF ds3231Writ_0001B_arg_bWrite
041B  21DE  	CALL ds3231Writ_0001B

	/* Status Register 0Fh
    bit7 OSF     Oscillator stopped flag - clear oscillator stop flag at init
    bit3 EN32kHz Enable 32kHz Output - 0 for disabled
    bit2 BSY     Busy
    bit1 A2F     Alarm 2 Flag
    bit0 A1F     Alarm 1 Flag
    */
	ds3231Write(0x0F, 0x00);
041C  300F  	MOVLW 0x0F
041D  00ED  	MOVWF ds3231Writ_0001B_arg_ds3231Reg
041E  01EE  	CLRF ds3231Writ_0001B_arg_bWrite
041F  21DE  	CALL ds3231Writ_0001B

}
0420  0008  	RETURN


/*********************************************************************************************
  void ds3231WriteDateTime()
  Write the date to the DS3231
*********************************************************************************************/
void ds3231WriteDateTime() {

	i2c_start();
03E5  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
03E6  30D0  	MOVLW 0xD0
03E7  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
03E8  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
03E9  01EF  	CLRF i2c_WRITE_00000_arg_i2c_data
03EA  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // seconds
03EB  01EF  	CLRF i2c_WRITE_00000_arg_i2c_data
03EC  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdMinute); // minutes
03ED  0836  	MOVF gbl_gBcdMinute, W
03EE  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
03EF  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdHour); // hours
03F0  0837  	MOVF gbl_gBcdHour, W
03F1  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
03F2  20A5  	CALL i2c_WRITE_00000

	i2c_write(gDayOfWeek); // day of week
03F3  0838  	MOVF gbl_gDayOfWeek, W
03F4  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
03F5  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdDayOfMonth); // day of month
03F6  0839  	MOVF gbl_gBcdDayOfMonth, W
03F7  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
03F8  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdMonth); // month + century
03F9  083A  	MOVF gbl_gBcdMonth, W
03FA  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
03FB  20A5  	CALL i2c_WRITE_00000

	i2c_write(gBcdYear); // year
03FC  083B  	MOVF gbl_gBcdYear, W
03FD  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
03FE  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
03FF  20F6  	CALL i2c_STOP_00000

}
0400  0008  	RETURN


/*********************************************************************************************
  void ds3231ReadDateTime()
  Write the date to the DS3231
*********************************************************************************************/
void ds3231ReadDateTime() {

	i2c_start();
06D6  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
06D7  30D0  	MOVLW 0xD0
06D8  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
06D9  20A5  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
06DA  01EF  	CLRF i2c_WRITE_00000_arg_i2c_data
06DB  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
06DC  20F6  	CALL i2c_STOP_00000

	
	i2c_start();
06DD  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr + 1); // address + read
06DE  30D1  	MOVLW 0xD1
06DF  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
06E0  20A5  	CALL i2c_WRITE_00000

	gBcdSecond = i2c_read(0); // ack
06E1  01EF  	CLRF i2c_READ_00000_arg_ack_status
06E2  218A  	CALL i2c_READ_00000
06E3  0872  	MOVF CompTempVarRet553, W
06E4  00B5  	MOVWF gbl_gBcdSecond

	gBcdMinute = i2c_read(0); // ack
06E5  01EF  	CLRF i2c_READ_00000_arg_ack_status
06E6  218A  	CALL i2c_READ_00000
06E7  0872  	MOVF CompTempVarRet553, W
06E8  00B6  	MOVWF gbl_gBcdMinute

	gBcdHour = i2c_read(0); // ack
06E9  01EF  	CLRF i2c_READ_00000_arg_ack_status
06EA  218A  	CALL i2c_READ_00000
06EB  0872  	MOVF CompTempVarRet553, W
06EC  00B7  	MOVWF gbl_gBcdHour

	gDayOfWeek = i2c_read(0); // ack
06ED  01EF  	CLRF i2c_READ_00000_arg_ack_status
06EE  218A  	CALL i2c_READ_00000
06EF  0872  	MOVF CompTempVarRet553, W
06F0  00B8  	MOVWF gbl_gDayOfWeek

	gBcdDayOfMonth = i2c_read(0); // ack
06F1  01EF  	CLRF i2c_READ_00000_arg_ack_status
06F2  218A  	CALL i2c_READ_00000
06F3  0872  	MOVF CompTempVarRet553, W
06F4  00B9  	MOVWF gbl_gBcdDayOfMonth

	gBcdMonth = i2c_read(0); // ack
06F5  01EF  	CLRF i2c_READ_00000_arg_ack_status
06F6  218A  	CALL i2c_READ_00000
06F7  0872  	MOVF CompTempVarRet553, W
06F8  00BA  	MOVWF gbl_gBcdMonth

	gBcdYear = i2c_read(1); // nack
06F9  3001  	MOVLW 0x01
06FA  00EF  	MOVWF i2c_READ_00000_arg_ack_status
06FB  218A  	CALL i2c_READ_00000
06FC  0872  	MOVF CompTempVarRet553, W
06FD  00BB  	MOVWF gbl_gBcdYear

	i2c_stop();
06FE  20F6  	CALL i2c_STOP_00000

}
06FF  0008  	RETURN


/*********************************************************************************************
  char ds3231ReadRegister(char cRegAddress)
  Read one byte from a given DS3231 register address
*********************************************************************************************/
char ds3231ReadRegister(char cRegAddress) {

	char cStatus;
	i2c_start();
0401  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr); // address + write
0402  30D0  	MOVLW 0xD0
0403  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0404  20A5  	CALL i2c_WRITE_00000

	i2c_write(cRegAddress); // start at requested address
0405  086D  	MOVF ds3231Read_0001E_arg_cRegAddress, W
0406  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
0407  20A5  	CALL i2c_WRITE_00000

	i2c_stop();
0408  20F6  	CALL i2c_STOP_00000

	
	i2c_start();
0409  2126  	CALL i2c_START_00000

	i2c_write(ds3231Addr + 1); // address + read
040A  30D1  	MOVLW 0xD1
040B  00EF  	MOVWF i2c_WRITE_00000_arg_i2c_data
040C  20A5  	CALL i2c_WRITE_00000

	cStatus = i2c_read(1); // read the byte, then nack
040D  3001  	MOVLW 0x01
040E  00EF  	MOVWF i2c_READ_00000_arg_ack_status
040F  218A  	CALL i2c_READ_00000
0410  0872  	MOVF CompTempVarRet553, W
0411  00EE  	MOVWF ds3231Read_0001E_1_cStatus

    i2c_stop();
0412  20F6  	CALL i2c_STOP_00000

    return cStatus;
0413  086E  	MOVF ds3231Read_0001E_1_cStatus, W
0414  00EF  	MOVWF CompTempVarRet554

}
0415  0008  	RETURN


/*********************************************************************************************
  void tm1638ByteWrite(char bWrite)
  Write one byte
*********************************************************************************************/
void tm1638ByteWrite(char bWrite) {

    for (char i = 0; i < 8; i++) {
015B  01F1  	CLRF tm1638Byte_0001F_2_i
015C        label25
015C  3008  	MOVLW 0x08
015D  0271  	SUBWF tm1638Byte_0001F_2_i, W
015E  1803  	BTFSC STATUS,C
016C  0AF1  	INCF tm1638Byte_0001F_2_i, F
016D  295C  	GOTO	label25

        tm1638dio = (bWrite & 0x01);
0160  3001  	MOVLW 0x01
0161  0570  	ANDWF tm1638Byte_0001F_arg_bWrite, W
0162  00F2  	MOVWF CompTempVar555
0163  1872  	BTFSC CompTempVar555,0
0164  1486  	BSF gbl_portb,1
0165  1C72  	BTFSS CompTempVar555,0
0166  1086  	BCF gbl_portb,1

        tm1638clk = 0;
0167  1106  	BCF gbl_portb,2

        bWrite = (bWrite >> 1);
0168  08F0  	MOVF tm1638Byte_0001F_arg_bWrite, F
0169  1003  	BCF STATUS,C
016A  0CF0  	RRF tm1638Byte_0001F_arg_bWrite, F

        tm1638clk = 1;
016B  1506  	BSF gbl_portb,2

    }
}
015F  0008  	RETURN


/*********************************************************************************************
  void tm1638DisplayOn()
  Turns the display on, with defined brightness
*********************************************************************************************/
void tm1638DisplayOn() {

    // Write 0x8F [10001000] to set display ON with pulse width 14/16
    tm1638strobe = 0;
03A5  1283  	BCF STATUS, RP0
03A6  1303  	BCF STATUS, RP1
03A7  1186  	BCF gbl_portb,3

    tm1638ByteWrite(0x88);
03A8  3088  	MOVLW 0x88
03A9  00F0  	MOVWF tm1638Byte_0001F_arg_bWrite
03AA  215B  	CALL tm1638Byte_0001F

    tm1638strobe = 1;
03AB  1586  	BSF gbl_portb,3

}
03AC  0008  	RETURN


/*********************************************************************************************
  void nibbleTo7Seg(char iNibble)
  Convert a single nibble into the 7-segment representation (two digits)
  7-segment digit to be written will be iPrintStartDigit, which is auto-incremented after
  If iPrintDotDigit matches, the dot on the display digit will be added
*********************************************************************************************/
void nibbleTo7Seg(char bNibble) {

	char s7SegDisplay = tm1638DisplayNumtoSeg[bNibble & 0x0F];
008D  085E  	MOVF gbl_tm1638DisplayNumtoSeg, W
008E  00F4  	MOVWF __rom_get_00000_arg_objNumb
008F  300F  	MOVLW 0x0F
0090  0572  	ANDWF nibbleTo7S_00020_arg_bNibble, W
0091  00F5  	MOVWF __rom_get_00000_arg_idx
0092  201A  	CALL __rom_get_00000
0093  00F3  	MOVWF nibbleTo7S_00020_1_s7SegDisplay

	if (iPrintStartDigit == iPrintDotDigit)
0094  0868  	MOVF gbl_iPrintDotDigit, W
0095  0667  	XORWF gbl_iPrintStartDigit, W
0096  118A  	BCF PCLATH,3
0097  120A  	BCF PCLATH,4
0098  1D03  	BTFSS STATUS,Z
0099  289C  	GOTO	label10
009C        label10

        s7SegDisplay += tm1638Dot;
009A  085F  	MOVF gbl_tm1638Dot, W
009B  07F3  	ADDWF nibbleTo7S_00020_1_s7SegDisplay, F

    tm1638Data[iPrintStartDigit] = s7SegDisplay;
009C  1383  	BCF	STATUS,IRP
009D  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
009E  0084  	MOVWF FSR
009F  0867  	MOVF gbl_iPrintStartDigit, W
00A0  0784  	ADDWF FSR, F
00A1  0873  	MOVF nibbleTo7S_00020_1_s7SegDisplay, W
00A2  0080  	MOVWF INDF

    iPrintStartDigit++;
00A3  0AE7  	INCF gbl_iPrintStartDigit, F

}
00A4  0008  	RETURN


/*********************************************************************************************
  void bcdTo7Seg(char iBcdIn)
  Convert a single bcd byte into the 7-segment representation (two digits)
*********************************************************************************************/
void bcdTo7Seg(char iBcdIn) {

    nibbleTo7Seg(iBcdIn >> 4);
01EA  0E71  	SWAPF bcdTo7Seg_00000_arg_iBcdIn, W
01EB  390F  	ANDLW 0x0F
01EC  00F2  	MOVWF nibbleTo7S_00020_arg_bNibble
01ED  208D  	CALL nibbleTo7S_00020

    nibbleTo7Seg(iBcdIn);
01EE  0871  	MOVF bcdTo7Seg_00000_arg_iBcdIn, W
01EF  00F2  	MOVWF nibbleTo7S_00020_arg_bNibble
01F0  208D  	CALL nibbleTo7S_00020

}
01F1  0008  	RETURN


/*********************************************************************************************
  void tm1638UpdateDisplay()
  Publish the tm1638Data and tm1638LEDs arrays to the display
*********************************************************************************************/
void tm1638UpdateDisplay() {

    
    // Display current temperature unless set, trigger or alt display mode is active
    if (gcDisplayMode | gcSetMode | gcTriggerMode) {
021C  1283  	BCF STATUS, RP0
021D  1303  	BCF STATUS, RP1
021E  084F  	MOVF gbl_gcSetMode, W
021F  044E  	IORWF gbl_gcDisplayMode, W
0220  00ED  	MOVWF CompTempVar558
0221  0850  	MOVF gbl_gcTriggerMode, W
0222  046D  	IORWF CompTempVar558, W
0223  1903  	BTFSC STATUS,Z
0224  2B2F  	GOTO	label64
032F        label64

        if (gcSetMode == 1) {
0225  034F  	DECF gbl_gcSetMode, W
0226  1D03  	BTFSS STATUS,Z
0227  2A34  	GOTO	label43
0234        label43

            iDigitToFlash = 3;
0228  3003  	MOVLW 0x03
0229  00C8  	MOVWF gbl_iDigitToFlash

            // Display year
            // Start printing from digit 0
            iPrintStartDigit = 0;
022A  01E7  	CLRF gbl_iPrintStartDigit

            iPrintDotDigit = 3;
022B  3003  	MOVLW 0x03
022C  00E8  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(0x20); // Display 20 in digits 0 and 1 (no dot)
022D  3020  	MOVLW 0x20
022E  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
022F  21EA  	CALL bcdTo7Seg_00000

            bcdTo7Seg(gBcdYear); // Display year in digits 2 and 3 (+dot on 3)
0230  083B  	MOVF gbl_gBcdYear, W
0231  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0232  21EA  	CALL bcdTo7Seg_00000

        } else if (gcSetMode == 4) {
0233  2B45  	GOTO	label65
0234  084F  	MOVF gbl_gcSetMode, W
0235  3A04  	XORLW 0x04
0236  1D03  	BTFSS STATUS,Z
0237  2A4A  	GOTO	label44
024A        label44

            iDigitToFlash = 3;
0238  3003  	MOVLW 0x03
0239  00C8  	MOVWF gbl_iDigitToFlash

            // Display day of week
            tm1638Data[0] = 0x5E; // d
023A  305E  	MOVLW 0x5E
023B  00A0  	MOVWF gbl_tm1638Data

            tm1638Data[1] = 0x5F; // a
023C  305F  	MOVLW 0x5F
023D  00A1  	MOVWF gbl_tm1638Data+D'1'

            tm1638Data[2] = 0x6E; // y
023E  306E  	MOVLW 0x6E
023F  00A2  	MOVWF gbl_tm1638Data+D'2'

            tm1638Data[3] = tm1638DisplayNumtoSeg[gDayOfWeek] + tm1638Dot;
0240  085E  	MOVF gbl_tm1638DisplayNumtoSeg, W
0241  00F4  	MOVWF __rom_get_00000_arg_objNumb
0242  0838  	MOVF gbl_gDayOfWeek, W
0243  00F5  	MOVWF __rom_get_00000_arg_idx
0244  201A  	CALL __rom_get_00000
0245  075F  	ADDWF gbl_tm1638Dot, W
0246  00A3  	MOVWF gbl_tm1638Data+D'3'

        } else if (gcTriggerMode) {
0247  118A  	BCF PCLATH,3
0248  120A  	BCF PCLATH,4
0249  2B45  	GOTO	label65
024A  08D0  	MOVF gbl_gcTriggerMode, F
024B  1903  	BTFSC STATUS,Z
024C  2B07  	GOTO	label57
0307        label57

            iPrintDotDigit = 5;
024D  3005  	MOVLW 0x05
024E  00E8  	MOVWF gbl_iPrintDotDigit

            switch (gcTriggerMode) {
0274  2B45  	GOTO	label65

                case 1:
024F  0850  	MOVF gbl_gcTriggerMode, W
0250  3A01  	XORLW 0x01
0251  1903  	BTFSC STATUS,Z
0252  2A75  	GOTO	label45
0275        label45

                    // White LED on hour
                    tm1638Data[0] = 0x38; // L
0275  3038  	MOVLW 0x38
0276  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0; // 
0277  01A1  	CLRF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x3f; // O
0278  303F  	MOVLW 0x3F
0279  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x54; // n
027A  3054  	MOVLW 0x54
027B  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
027C  3005  	MOVLW 0x05
027D  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
027E  3004  	MOVLW 0x04
027F  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOnHour); // Display hour in digits 4 and 5 (dot on 5)
0280  0852  	MOVF gbl_gBcdWhiteOnHour, W
0281  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0282  21EA  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdWhiteOnMinute); // Display minute in digits 6 and 7 (no dot)
0283  0851  	MOVF gbl_gBcdWhiteOnMinute, W
0284  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0285  21EA  	CALL bcdTo7Seg_00000

                    break;
0286  2B45  	GOTO	label65

                case 2:
0253  3A03  	XORLW 0x03
0254  1903  	BTFSC STATUS,Z
0255  2A87  	GOTO	label46
0287        label46

                    // White LED on minute
                    iDigitToFlash = 7;
0287  3007  	MOVLW 0x07
0288  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0289  3006  	MOVLW 0x06
028A  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOnMinute); // Display minute in digits 6 and 7 (no dot)
028B  0851  	MOVF gbl_gBcdWhiteOnMinute, W
028C  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
028D  21EA  	CALL bcdTo7Seg_00000

                    break;
028E  2B45  	GOTO	label65

                case 3:
0256  3A01  	XORLW 0x01
0257  1903  	BTFSC STATUS,Z
0258  2A8F  	GOTO	label47
028F        label47

                    // White LED off hour
                    tm1638Data[3] = 0x71; // F
028F  3071  	MOVLW 0x71
0290  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
0291  3005  	MOVLW 0x05
0292  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
0293  3004  	MOVLW 0x04
0294  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOffHour); 
0295  0854  	MOVF gbl_gBcdWhiteOffHour, W
0296  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0297  21EA  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdWhiteOffMinute); // Display minute in digits 6 and 7 (no dot)
0298  0853  	MOVF gbl_gBcdWhiteOffMinute, W
0299  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
029A  21EA  	CALL bcdTo7Seg_00000

                    break;
029B  2B45  	GOTO	label65

                case 4:
0259  3A07  	XORLW 0x07
025A  1903  	BTFSC STATUS,Z
025B  2A9C  	GOTO	label48
029C        label48

                    // White LED off minute
                    iDigitToFlash = 7;
029C  3007  	MOVLW 0x07
029D  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
029E  3006  	MOVLW 0x06
029F  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdWhiteOffMinute); // Display minute in digits 6 and 7 (no dot)
02A0  0853  	MOVF gbl_gBcdWhiteOffMinute, W
02A1  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02A2  21EA  	CALL bcdTo7Seg_00000

                    break;
02A3  2B45  	GOTO	label65

                case 5:
025C  3A01  	XORLW 0x01
025D  1903  	BTFSC STATUS,Z
025E  2AA4  	GOTO	label49
02A4        label49

                    // Blue LED on hour
                    tm1638Data[0] = 0x7C; // b
02A4  307C  	MOVLW 0x7C
02A5  00A0  	MOVWF gbl_tm1638Data

                    //tm1638Data[1] = 0x30; // l
                    //tm1638Data[2] = 0x3f; // O
                    tm1638Data[3] = 0x54; // n
02A6  3054  	MOVLW 0x54
02A7  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
02A8  3005  	MOVLW 0x05
02A9  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
02AA  3004  	MOVLW 0x04
02AB  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOnHour); // Display hour in digits 4 and 5 (dot on 5)
02AC  0856  	MOVF gbl_gBcdBlueOnHour, W
02AD  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02AE  21EA  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlueOnMinute); // Display minute in digits 6 and 7 (no dot)
02AF  0855  	MOVF gbl_gBcdBlueOnMinute, W
02B0  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02B1  21EA  	CALL bcdTo7Seg_00000

                    break;
02B2  2B45  	GOTO	label65

                case 6:
025F  3A03  	XORLW 0x03
0260  1903  	BTFSC STATUS,Z
0261  2AB3  	GOTO	label50
02B3        label50

                    // Blue LED on minute
                    iDigitToFlash = 7;
02B3  3007  	MOVLW 0x07
02B4  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
02B5  3006  	MOVLW 0x06
02B6  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOnMinute); // Display minute in digits 6 and 7 (no dot)
02B7  0855  	MOVF gbl_gBcdBlueOnMinute, W
02B8  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02B9  21EA  	CALL bcdTo7Seg_00000

                    break;
02BA  2B45  	GOTO	label65

                case 7:
0262  3A01  	XORLW 0x01
0263  1903  	BTFSC STATUS,Z
0264  2ABB  	GOTO	label51
02BB        label51

                    // Blue LED off hour
                    tm1638Data[3] = 0x71; // F
02BB  3071  	MOVLW 0x71
02BC  00A3  	MOVWF gbl_tm1638Data+D'3'

                    iDigitToFlash = 5;
02BD  3005  	MOVLW 0x05
02BE  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 4
                    iPrintStartDigit = 4;
02BF  3004  	MOVLW 0x04
02C0  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOffHour); // Display hour in digits 4 and 5 (dot on 5)
02C1  0858  	MOVF gbl_gBcdBlueOffHour, W
02C2  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02C3  21EA  	CALL bcdTo7Seg_00000

                    bcdTo7Seg(gBcdBlueOffMinute); // Display minute in digits 6 and 7 (no dot)
02C4  0857  	MOVF gbl_gBcdBlueOffMinute, W
02C5  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02C6  21EA  	CALL bcdTo7Seg_00000

                    break;
02C7  2B45  	GOTO	label65

                case 8:
0265  3A0F  	XORLW 0x0F
0266  1903  	BTFSC STATUS,Z
0267  2AC8  	GOTO	label52
02C8        label52

                    // Blue LED off minute
                    iDigitToFlash = 7;
02C8  3007  	MOVLW 0x07
02C9  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
02CA  3006  	MOVLW 0x06
02CB  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdBlueOffMinute); // Display minute in digits 6 and 7 (no dot)
02CC  0857  	MOVF gbl_gBcdBlueOffMinute, W
02CD  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02CE  21EA  	CALL bcdTo7Seg_00000

                    break;
02CF  2B45  	GOTO	label65

                case 9:
0268  3A01  	XORLW 0x01
0269  1903  	BTFSC STATUS,Z
026A  2AD0  	GOTO	label53
02D0        label53

                    // Fan on temperature
                    tm1638Data[0] = 0x71; // F
02D0  3071  	MOVLW 0x71
02D1  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x5F; // a
02D2  305F  	MOVLW 0x5F
02D3  00A1  	MOVWF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x54; // n
02D4  3054  	MOVLW 0x54
02D5  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x00; // 
02D6  01A3  	CLRF gbl_tm1638Data+D'3'

                    tm1638Data[4] = 0x3f; // O
02D7  303F  	MOVLW 0x3F
02D8  00A4  	MOVWF gbl_tm1638Data+D'4'

                    tm1638Data[5] = 0x54; // n
02D9  3054  	MOVLW 0x54
02DA  00A5  	MOVWF gbl_tm1638Data+D'5'

                    iDigitToFlash = 7;
02DB  3007  	MOVLW 0x07
02DC  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
02DD  3006  	MOVLW 0x06
02DE  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdFanOnTemp); // Display celcius in digits 6 and 7 (no dot)
02DF  0859  	MOVF gbl_gBcdFanOnTemp, W
02E0  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02E1  21EA  	CALL bcdTo7Seg_00000

                    break;
02E2  2B45  	GOTO	label65

                case 10:
026B  3A03  	XORLW 0x03
026C  1903  	BTFSC STATUS,Z
026D  2AE3  	GOTO	label54
02E3        label54

                    // Fan off temperature
                    tm1638Data[5] = 0x71; // f
02E3  3071  	MOVLW 0x71
02E4  00A5  	MOVWF gbl_tm1638Data+D'5'

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
02E5  3006  	MOVLW 0x06
02E6  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdFanOffTemp); // Display celcius in digits 6 and 7 (no dot)
02E7  085A  	MOVF gbl_gBcdFanOffTemp, W
02E8  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02E9  21EA  	CALL bcdTo7Seg_00000

                    break;
02EA  2B45  	GOTO	label65

                case 11:
026E  3A01  	XORLW 0x01
026F  1903  	BTFSC STATUS,Z
0270  2AEB  	GOTO	label55
02EB        label55

                    // Heater on temperature
                    tm1638Data[0] = 0x76; // H
02EB  3076  	MOVLW 0x76
02EC  00A0  	MOVWF gbl_tm1638Data

                    tm1638Data[1] = 0x7B; // e
02ED  307B  	MOVLW 0x7B
02EE  00A1  	MOVWF gbl_tm1638Data+D'1'

                    tm1638Data[2] = 0x5F; // a
02EF  305F  	MOVLW 0x5F
02F0  00A2  	MOVWF gbl_tm1638Data+D'2'

                    tm1638Data[3] = 0x78; // t
02F1  3078  	MOVLW 0x78
02F2  00A3  	MOVWF gbl_tm1638Data+D'3'

                    tm1638Data[4] = 0x3f; // O
02F3  303F  	MOVLW 0x3F
02F4  00A4  	MOVWF gbl_tm1638Data+D'4'

                    tm1638Data[5] = 0x54; // n
02F5  3054  	MOVLW 0x54
02F6  00A5  	MOVWF gbl_tm1638Data+D'5'

                    iDigitToFlash = 7;
02F7  3007  	MOVLW 0x07
02F8  00C8  	MOVWF gbl_iDigitToFlash

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
02F9  3006  	MOVLW 0x06
02FA  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdHeaterOnTemp); // Display celcius in digits 6 and 7 (no dot)
02FB  085B  	MOVF gbl_gBcdHeaterOnTemp, W
02FC  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
02FD  21EA  	CALL bcdTo7Seg_00000

                    break;
02FE  2B45  	GOTO	label65

                case 12:
0271  3A07  	XORLW 0x07
0272  1903  	BTFSC STATUS,Z
0273  2AFF  	GOTO	label56
02FF        label56

                    // Heater off temperature
                    tm1638Data[5] = 0x71; // f
02FF  3071  	MOVLW 0x71
0300  00A5  	MOVWF gbl_tm1638Data+D'5'

                    // Start printing from digit 6
                    iPrintStartDigit = 6;
0301  3006  	MOVLW 0x06
0302  00E7  	MOVWF gbl_iPrintStartDigit

                    bcdTo7Seg(gBcdHeaterOffTemp); // Display celcius in digits 6 and 7 (no dot)
0303  085C  	MOVF gbl_gBcdHeaterOffTemp, W
0304  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0305  21EA  	CALL bcdTo7Seg_00000

                    break;
            }
        } else {
0306  2B45  	GOTO	label65

            switch (gcSetMode) {
0323        label63

                case 2:
0307  084F  	MOVF gbl_gcSetMode, W
0308  3A02  	XORLW 0x02
0309  1903  	BTFSC STATUS,Z
030A  2B15  	GOTO	label58
0315        label58

                    iDigitToFlash = 3;
0315  3003  	MOVLW 0x03
0316  00C8  	MOVWF gbl_iDigitToFlash

                    break;
0317  2B23  	GOTO	label63

                case 3:
030B  3A01  	XORLW 0x01
030C  1903  	BTFSC STATUS,Z
030D  2B18  	GOTO	label59
0318        label59

                    iDigitToFlash = 1;
0318  3001  	MOVLW 0x01
0319  00C8  	MOVWF gbl_iDigitToFlash

                    break;
031A  2B23  	GOTO	label63

                case 5:
030E  3A06  	XORLW 0x06
030F  1903  	BTFSC STATUS,Z
0310  2B1B  	GOTO	label60
031B        label60

                    iDigitToFlash = 5;
031B  3005  	MOVLW 0x05
031C  00C8  	MOVWF gbl_iDigitToFlash

                    break;
031D  2B23  	GOTO	label63

                case 6:
0311  3A03  	XORLW 0x03
0312  1903  	BTFSC STATUS,Z
0313  2B1E  	GOTO	label61
031E        label61

                    iDigitToFlash = 7;
031E  3007  	MOVLW 0x07
031F  00C8  	MOVWF gbl_iDigitToFlash

                    break;
0320  2B23  	GOTO	label63

                default:
0314  2B21  	GOTO	label62
0321        label62

                    iDigitToFlash = 8;
0321  3008  	MOVLW 0x08
0322  00C8  	MOVWF gbl_iDigitToFlash

            }
            // Display date DD.MM
            iPrintStartDigit = 0;
0323  01E7  	CLRF gbl_iPrintStartDigit

            iPrintDotDigit = 1;
0324  3001  	MOVLW 0x01
0325  00E8  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(gBcdDayOfMonth); // Display day of month in digits 0 and 1 (+dot on 1)
0326  0839  	MOVF gbl_gBcdDayOfMonth, W
0327  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0328  21EA  	CALL bcdTo7Seg_00000

            iPrintDotDigit = 3;
0329  3003  	MOVLW 0x03
032A  00E8  	MOVWF gbl_iPrintDotDigit

            bcdTo7Seg(gBcdMonth); // Display month in digits 2 and 3 (+dot on 3)
032B  083A  	MOVF gbl_gBcdMonth, W
032C  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
032D  21EA  	CALL bcdTo7Seg_00000

        }
    } else {
032E  2B45  	GOTO	label65

        iDigitToFlash = 8; // No flashing digit in this mode
032F  3008  	MOVLW 0x08
0330  00C8  	MOVWF gbl_iDigitToFlash

        // translate DS3231 temperature to digit values
        iPrintDotDigit = 1;
0331  3001  	MOVLW 0x01
0332  00E8  	MOVWF gbl_iPrintDotDigit

        /*
        No support for -10 or below - aquarium should never get that cold!
        if (gbDS3231IsMinus && (giDS3231ValueBCD & 0xF000)) {
            // If minus and value less than or equal -10 (checked as >1000), shift the digits right
            giDS3231ValueBCD >>= 4;
            iPrintDotDigit = 2;
        }*/
        // Display current temperature in digits 0 to 3 (+dot on digit 1 and 3)
        iPrintStartDigit = 0;
0333  01E7  	CLRF gbl_iPrintStartDigit

        bcdTo7Seg(giDS3231ValueBCD >> 8);
0334  0834  	MOVF gbl_giDS3231ValueBCD+D'1', W
0335  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0336  21EA  	CALL bcdTo7Seg_00000

        iPrintDotDigit = 3;
0337  3003  	MOVLW 0x03
0338  00E8  	MOVWF gbl_iPrintDotDigit

        bcdTo7Seg(giDS3231ValueBCD);
0339  0833  	MOVF gbl_giDS3231ValueBCD, W
033A  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
033B  21EA  	CALL bcdTo7Seg_00000


        // left fill zeroes with blanks up to the digit before the decimal place
        if (tm1638Data[0] == 0x3f)
033C  0820  	MOVF gbl_tm1638Data, W
033D  3A3F  	XORLW 0x3F
033E  1903  	BTFSC STATUS,Z

            tm1638Data[0] = 0;
033F  01A0  	CLRF gbl_tm1638Data

        // If minus, overwrite left most digit with minus sign
        if (gbDS3231IsMinus)
0340  08CB  	MOVF gbl_gbDS3231IsMinus, F
0341  1903  	BTFSC STATUS,Z
0342  2B45  	GOTO	label65
0345        label65

            tm1638Data[0] = 0x40;
0343  3040  	MOVLW 0x40
0344  00A0  	MOVWF gbl_tm1638Data

    }

    // HH.MM in last 4 digits of TM1638
    if (!gcTriggerMode) {
0345  08D0  	MOVF gbl_gcTriggerMode, F
0346  1D03  	BTFSS STATUS,Z
0347  2B57  	GOTO	label68
0357        label68

        iPrintStartDigit = 4;
0348  3004  	MOVLW 0x04
0349  00E7  	MOVWF gbl_iPrintStartDigit

        // Flash dot every second
        if (gBcdSecond.0)
034A  1C35  	BTFSS gbl_gBcdSecond,0
034B  2B4F  	GOTO	label66
034F        label66

			iPrintDotDigit = 5;
034C  3005  	MOVLW 0x05
034D  00E8  	MOVWF gbl_iPrintDotDigit

		else
034E  2B51  	GOTO	label67
0351        label67

			iPrintDotDigit = 8;
034F  3008  	MOVLW 0x08
0350  00E8  	MOVWF gbl_iPrintDotDigit

        bcdTo7Seg(gBcdHour); // Display hour in digits 4 and 5 (dot on 5)
0351  0837  	MOVF gbl_gBcdHour, W
0352  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0353  21EA  	CALL bcdTo7Seg_00000

        bcdTo7Seg(gBcdMinute); // Display minute in digits 6 and 7 (no dot)
0354  0836  	MOVF gbl_gBcdMinute, W
0355  00F1  	MOVWF bcdTo7Seg_00000_arg_iBcdIn
0356  21EA  	CALL bcdTo7Seg_00000

    }

    // Light LED for set mode
    char cCompareSetMode = gcSetMode + 1;
0357  0A4F  	INCF gbl_gcSetMode, W
0358  00EE  	MOVWF tm1638Upda_00022_1_cCompar_00023

    for (char i = 2; i < 8; i++) {
0359  3002  	MOVLW 0x02
035A  00F0  	MOVWF tm1638Upda_00022_3_i
035B        label69
035B  3008  	MOVLW 0x08
035C  0270  	SUBWF tm1638Upda_00022_3_i, W
035D  1803  	BTFSC STATUS,C
035E  2B74  	GOTO	label72
0372  0AF0  	INCF tm1638Upda_00022_3_i, F
0373  2B5B  	GOTO	label69
0374        label72

        if (i == cCompareSetMode)
035F  086E  	MOVF tm1638Upda_00022_1_cCompar_00023, W
0360  0670  	XORWF tm1638Upda_00022_3_i, W
0361  1D03  	BTFSS STATUS,Z
0362  2B6B  	GOTO	label70
036B        label70

            tm1638LEDs[i] = 1;
0363  1383  	BCF	STATUS,IRP
0364  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
0365  0084  	MOVWF FSR
0366  0870  	MOVF tm1638Upda_00022_3_i, W
0367  0784  	ADDWF FSR, F
0368  3001  	MOVLW 0x01
0369  0080  	MOVWF INDF

        else
036A  2B72  	GOTO	label71
0372        label71

            tm1638LEDs[i] = 0;
036B  1383  	BCF	STATUS,IRP
036C  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
036D  0084  	MOVWF FSR
036E  0870  	MOVF tm1638Upda_00022_3_i, W
036F  0784  	ADDWF FSR, F
0370  3000  	MOVLW 0x00
0371  0080  	MOVWF INDF

    }
    tm1638LEDs[0] = HEATER;
0374  01A8  	CLRF gbl_tm1638LEDs
0375  1805  	BTFSC gbl_porta,0
0376  0AA8  	INCF gbl_tm1638LEDs, F

    tm1638LEDs[1] = FAN;
0377  01A9  	CLRF gbl_tm1638LEDs+D'1'
0378  1885  	BTFSC gbl_porta,1
0379  0AA9  	INCF gbl_tm1638LEDs+D'1', F


    // Write 0x40 [01000000] (table 5.1) to indicate command to display data - [Write data to display register]
    tm1638strobe = 0;
037A  1186  	BCF gbl_portb,3

    tm1638ByteWrite(tm1638ByteSetData);
037B  0861  	MOVF gbl_tm1638ByteSetData, W
037C  00F0  	MOVWF tm1638Byte_0001F_arg_bWrite
037D  215B  	CALL tm1638Byte_0001F

    tm1638strobe = 1;
037E  1586  	BSF gbl_portb,3

    
    tm1638strobe = 0;
037F  1186  	BCF gbl_portb,3

    // Specify the display address 0xC0 [11000000] (table 5.2) [Display address 00H] then write out all 16 bytes
    tm1638ByteWrite(tm1638ByteSetAddr);
0380  0863  	MOVF gbl_tm1638ByteSetAddr, W
0381  00F0  	MOVWF tm1638Byte_0001F_arg_bWrite
0382  215B  	CALL tm1638Byte_0001F

    for (char i = 0; i < tm1638MaxDigits; i++) {
0383  01EF  	CLRF tm1638Upda_00022_2_i
0384        label73
0384  085D  	MOVF gbl_tm1638MaxDigits, W
0385  026F  	SUBWF tm1638Upda_00022_2_i, W
0386  1803  	BTFSC STATUS,C
0387  2BA3  	GOTO	label76
03A1  0AEF  	INCF tm1638Upda_00022_2_i, F
03A2  2B84  	GOTO	label73
03A3        label76

        // display digit first
        if (iFlashDigitOff.0 && (i == iDigitToFlash))
0388  1C3F  	BTFSS gbl_iFlashDigitOff,0
0389  2B91  	GOTO	label74
038A  0848  	MOVF gbl_iDigitToFlash, W
038B  066F  	XORWF tm1638Upda_00022_2_i, W
038C  1D03  	BTFSS STATUS,Z
038D  2B91  	GOTO	label74
0391        label74

            tm1638ByteWrite(0);
038E  01F0  	CLRF tm1638Byte_0001F_arg_bWrite
038F  215B  	CALL tm1638Byte_0001F

        else
0390  2B99  	GOTO	label75
0399        label75

            tm1638ByteWrite(tm1638Data[i]);
0391  1383  	BCF	STATUS,IRP
0392  3020  	MOVLW LOW(gbl_tm1638Data+D'0')
0393  0084  	MOVWF FSR
0394  086F  	MOVF tm1638Upda_00022_2_i, W
0395  0784  	ADDWF FSR, F
0396  0800  	MOVF INDF, W
0397  00F0  	MOVWF tm1638Byte_0001F_arg_bWrite
0398  215B  	CALL tm1638Byte_0001F

        // then LED
        tm1638ByteWrite(tm1638LEDs[i]);
0399  1383  	BCF	STATUS,IRP
039A  3028  	MOVLW LOW(gbl_tm1638LEDs+D'0')
039B  0084  	MOVWF FSR
039C  086F  	MOVF tm1638Upda_00022_2_i, W
039D  0784  	ADDWF FSR, F
039E  0800  	MOVF INDF, W
039F  00F0  	MOVWF tm1638Byte_0001F_arg_bWrite
03A0  215B  	CALL tm1638Byte_0001F

    }
    tm1638strobe = 1;
03A3  1586  	BSF gbl_portb,3

}
03A4  0008  	RETURN


/*********************************************************************************************
  void tm1638ReadKeys()
  Reads the keys status into tm1638Keys
*********************************************************************************************/
void tm1638ReadKeys() {

    // Write 0x42 [01000010] to indicate command to read data
    tm1638strobe = 0;
05EA  1283  	BCF STATUS, RP0
05EB  1303  	BCF STATUS, RP1
05EC  1186  	BCF gbl_portb,3

    tm1638ByteWrite(tm1638ByteReadData);
05ED  0862  	MOVF gbl_tm1638ByteReadData, W
05EE  00F0  	MOVWF tm1638Byte_0001F_arg_bWrite
05EF  215B  	CALL tm1638Byte_0001F

    
    tm1638dioTris = 1; // Set data pin to input
05F0  1683  	BSF STATUS, RP0
05F1  1486  	BSF gbl_trisb,1

    char tm1638KeysTemp = 32;
05F2  3020  	MOVLW 0x20
05F3  1283  	BCF STATUS, RP0
05F4  00EC  	MOVWF tm1638Read_00024_1_tm1638K_00025

    // Read 4 bytes
    for (char i = 0; i < 32; i++) {
05F5  01ED  	CLRF tm1638Read_00024_2_i
05F6        label108
05F6  3020  	MOVLW 0x20
05F7  026D  	SUBWF tm1638Read_00024_2_i, W
05F8  1803  	BTFSC STATUS,C
05F9  2E06  	GOTO	label110
0604  0AED  	INCF tm1638Read_00024_2_i, F
0605  2DF6  	GOTO	label108
0606        label110

        tm1638KeysTemp--;
05FA  03EC  	DECF tm1638Read_00024_1_tm1638K_00025, F

        tm1638clk = 0;
05FB  1106  	BCF gbl_portb,2

        delay_us(1);
05FC  3001  	MOVLW 0x01
05FD  00F2  	MOVWF delay_us_00000_arg_del
05FE  2010  	CALL delay_us_00000

        if(tm1638dio)
05FF  1C86  	BTFSS gbl_portb,1
0600  2E03  	GOTO	label109
0603        label109

            tm1638KeysTemp <<= 1;
0601  1003  	BCF STATUS,C
0602  0DEC  	RLF tm1638Read_00024_1_tm1638K_00025, F

        tm1638clk = 1;
0603  1506  	BSF gbl_portb,2

    }
    tm1638dioTris = 0; // Set data pin to output
0606  1683  	BSF STATUS, RP0
0607  1086  	BCF gbl_trisb,1

    tm1638strobe = 1;
0608  1283  	BCF STATUS, RP0
0609  1586  	BSF gbl_portb,3


    tm1638Keys = tm1638KeysTemp;
060A  086C  	MOVF tm1638Read_00024_1_tm1638K_00025, W
060B  00E5  	MOVWF gbl_tm1638Keys

    /*
    1F = 0001 1111
	17 = 0001 0111
	0F = 0000 1111
	07 = 0000 0111
	1B = 0001 1011
	13 = 0001 0011
	0B = 0000 1011
	03 = 0000 0111
	*/
}
060C  0008  	RETURN


/*********************************************************************************************
  void convertTemp()
  Used to split the 16 bit integer returned from the ds18b20 into parts for display
*********************************************************************************************/
void convertTemp() {

    // convert both bytes to a 16bit int - e.g. 0000 0001 0100 0110 (1 and 70, gives 326)
    signed int iTemp = (cTempH << 8) | cTempL;
0700  1283  	BCF STATUS, RP0
0701  1303  	BCF STATUS, RP1
0702  01EC  	CLRF convertTem_0002B_1_iTemp
0703  0849  	MOVF gbl_cTempH, W
0704  00ED  	MOVWF convertTem_0002B_1_iTemp+D'1'
0705  084A  	MOVF gbl_cTempL, W
0706  04EC  	IORWF convertTem_0002B_1_iTemp, F

    
    // Celcius
    gbDS3231IsMinus = (iTemp < 0);
0707  01CB  	CLRF gbl_gbDS3231IsMinus
0708  1BED  	BTFSC convertTem_0002B_1_iTemp+D'1',7
0709  0ACB  	INCF gbl_gbDS3231IsMinus, F

    if (gbDS3231IsMinus) {
070A  08CB  	MOVF gbl_gbDS3231IsMinus, F
070B  1903  	BTFSC STATUS,Z
070C  2F12  	GOTO	label122

        iTemp = ~iTemp + 1;
070D  09EC  	COMF convertTem_0002B_1_iTemp, F
070E  09ED  	COMF convertTem_0002B_1_iTemp+D'1', F
070F  0AEC  	INCF convertTem_0002B_1_iTemp, F
0710  1903  	BTFSC STATUS,Z
0711  0AED  	INCF convertTem_0002B_1_iTemp+D'1', F
0712        label122

    }
    // this gets celcius * 100 - https://www.phanderson.com/PIC/PICC/sourceboost/ds18b20_1.html
    int iValue = (6 * iTemp) + (iTemp / 4);
0712  3006  	MOVLW 0x06
0713  00F2  	MOVWF __mul_16s__0000F_arg_a
0714  01F3  	CLRF __mul_16s__0000F_arg_a+D'1'
0715  086C  	MOVF convertTem_0002B_1_iTemp, W
0716  00F4  	MOVWF __mul_16s__0000F_arg_b
0717  086D  	MOVF convertTem_0002B_1_iTemp+D'1', W
0718  00F5  	MOVWF __mul_16s__0000F_arg_b+D'1'
0719  25C1  	CALL __mul_16s__0000F
071A  0879  	MOVF CompTempVarRet389, W
071B  00EE  	MOVWF convertTem_0002B_1_iValue
071C  087A  	MOVF CompTempVarRet389+D'1', W
071D  00F1  	MOVWF CompTempVar613
071E  086C  	MOVF convertTem_0002B_1_iTemp, W
071F  00F0  	MOVWF CompTempVar610
0720  086D  	MOVF convertTem_0002B_1_iTemp+D'1', W
0721  00EF  	MOVWF convertTem_0002B_1_iValue+D'1'
0722  0D6D  	RLF convertTem_0002B_1_iTemp+D'1', W
0723  0CEF  	RRF convertTem_0002B_1_iValue+D'1', F
0724  0CF0  	RRF CompTempVar610, F
0725  0D6D  	RLF convertTem_0002B_1_iTemp+D'1', W
0726  0CEF  	RRF convertTem_0002B_1_iValue+D'1', F
0727  0CF0  	RRF CompTempVar610, F
0728  0870  	MOVF CompTempVar610, W
0729  07EE  	ADDWF convertTem_0002B_1_iValue, F
072A  0871  	MOVF CompTempVar613, W
072B  1803  	BTFSC STATUS,C
072C  0AEF  	INCF convertTem_0002B_1_iValue+D'1', F
072D  07EF  	ADDWF convertTem_0002B_1_iValue+D'1', F


    // Split the temperature reading into digits
    
    // simple way, but more program memory needed for PIC12 or PIC16 (more than 100 words more)
    //giDS3231ValueBCD = iValue / 1000;
    //giDS3231ValueBCD += (iValue / 100) % 10;
    //giDS3231ValueBCD += (iValue / 10) % 10;
    //giDS3231ValueBCD += iValue % 10;
    
    // Double Dabble
    // Less program memory needed - may be slower executing
    // https://www.electro-tech-online.com/threads/32bit-bin2bcd-casting.126235/#post-1047937
    // Init the 16-bit BCD value to zero - output only supporting an input value up to 9999 in this implementation
    /*giDS3231ValueBCD = 0;
    int iMask;
    // 48 loops
    // Shift 12 times
    for(char i = 0; i < 12; i++){
        // Check if any nibble is 5 or greater
        // Start with the right most nibble (digit), shifting 4 bits each time
        //for(; iMask != 0; iMask >>= 4){
        //iMask = 0xF000; // Start checking the thousands digit 10^3
        if ((giDS3231ValueBCD & 0xF000) > 0x4FFF)
			giDS3231ValueBCD += 0x3000;
        if ((giDS3231ValueBCD & 0xF00) > 0x4FF)
			giDS3231ValueBCD += 0x3000;
        if ((giDS3231ValueBCD & 0xF0) > 0x4F)
			giDS3231ValueBCD += 0x3000;
        if ((giDS3231ValueBCD & 0xF) > 4)
			giDS3231ValueBCD += 3;
        //for (char j = 0; j < 4; j++) {
            // For the digit we're checking, if bcd value is greater than or equal to 5, add 3
        //    if ((iMask & giDS3231ValueBCD) >= (iMask & 0x5555))
        //        giDS3231ValueBCD += (iMask & 0x3333); // Add 3
        //    iMask = iMask >> 4; // Shift the mask byte 4 bits (one nibble) right
        //}
        // Shift bcd value
        giDS3231ValueBCD <<= 1;
        // Increment bcd value (right most bit) if left most bit is set in the input byte
        if (iValue & 0x8000)
            giDS3231ValueBCD++;
        // Shift input value
        iValue <<= 1;
    }*/

    /*giDS3231ValueBCD = 0; // 16-bit BCD value - only supporting up to 9999
    int iTest = 32768; // Start testing from MSB
    // Loop through the 16 bits in the two bytes
    for (char i = 0; i < 16; i++) {
        // Shift one
        giDS3231ValueBCD <<= 1;
        // If the bit is set, add one
        if (iValue & iTest)
            giDS3231ValueBCD++;
        
        // Add 3 to any BCD column 5 or greater
        if ((giDS3231ValueBCD & 0x0F) > 0x04)
            giDS3231ValueBCD += 3;
        if ((giDS3231ValueBCD & 0xF0) > 0x49)
            giDS3231ValueBCD += 0x30;
        if ((giDS3231ValueBCD & 0xF00) > 0x499)
            giDS3231ValueBCD += 0x300;
        if ((giDS3231ValueBCD & 0xF000) > 0x4999)
            giDS3231ValueBCD += 0x3000;
        
        // move the test bit
        iTest >>= 1;
    }*/
    
    // less program memory needed - may be slower executing
    // https://electronics.stackexchange.com/questions/158563/how-to-split-a-floating-point-number-into-individual-digits
    giDS3231ValueBCD = 0;
072E  01B3  	CLRF gbl_giDS3231ValueBCD
072F  01B4  	CLRF gbl_giDS3231ValueBCD+D'1'


    // incrementing variables for each digit
    // determine to thousands digit
    while (iValue >= 1000) {
0730        label123
0730  3003  	MOVLW 0x03
0731  026F  	SUBWF convertTem_0002B_1_iValue+D'1', W
0732  1D03  	BTFSS STATUS,Z
0733  2F36  	GOTO	label124
0734  30E8  	MOVLW 0xE8
0735  026E  	SUBWF convertTem_0002B_1_iValue, W
0736        label124
0736  1C03  	BTFSS STATUS,C
0737  2F43  	GOTO	label125
0738  1BEF  	BTFSC convertTem_0002B_1_iValue+D'1',7
0739  2F43  	GOTO	label125
0742  2F30  	GOTO	label123
0743        label125

        iValue -= 1000;
073A  30E8  	MOVLW 0xE8
073B  02EE  	SUBWF convertTem_0002B_1_iValue, F
073C  3003  	MOVLW 0x03
073D  1C03  	BTFSS STATUS,C
073E  03EF  	DECF convertTem_0002B_1_iValue+D'1', F
073F  02EF  	SUBWF convertTem_0002B_1_iValue+D'1', F

        // each time we take off 1000, the digit is incremented
        giDS3231ValueBCD += 0x1000;
0740  3010  	MOVLW 0x10
0741  07B4  	ADDWF gbl_giDS3231ValueBCD+D'1', F

    }

    // determine to hundreds digit
    while (iValue >= 100) {
0743  086F  	MOVF convertTem_0002B_1_iValue+D'1', W
0744  3A80  	XORLW 0x80
0745  00F2  	MOVWF CompTempVar621
0746  3080  	MOVLW 0x80
0747  0272  	SUBWF CompTempVar621, W
0748  1D03  	BTFSS STATUS,Z
0749  2F4C  	GOTO	label126
074A  3064  	MOVLW 0x64
074B  026E  	SUBWF convertTem_0002B_1_iValue, W
074C        label126
074C  1C03  	BTFSS STATUS,C
074D  2F54  	GOTO	label127
0753  2F43  	GOTO	label125
0754        label127

        iValue -= 100;
074E  3064  	MOVLW 0x64
074F  02EE  	SUBWF convertTem_0002B_1_iValue, F
0750  1C03  	BTFSS STATUS,C
0751  03EF  	DECF convertTem_0002B_1_iValue+D'1', F

        // each time we take off 100, the digit is incremented
        giDS3231ValueBCD += 0x100;
0752  0AB4  	INCF gbl_giDS3231ValueBCD+D'1', F

    }

    // determine to tens digit
    while (iValue >= 10) {
0754  086F  	MOVF convertTem_0002B_1_iValue+D'1', W
0755  3A80  	XORLW 0x80
0756  00F2  	MOVWF CompTempVar622
0757  3080  	MOVLW 0x80
0758  0272  	SUBWF CompTempVar622, W
0759  1D03  	BTFSS STATUS,Z
075A  2F5D  	GOTO	label128
075B  300A  	MOVLW 0x0A
075C  026E  	SUBWF convertTem_0002B_1_iValue, W
075D        label128
075D  1C03  	BTFSS STATUS,C
075E  2F68  	GOTO	label129
0767  2F54  	GOTO	label127
0768        label129

        iValue -= 10;
075F  300A  	MOVLW 0x0A
0760  02EE  	SUBWF convertTem_0002B_1_iValue, F
0761  1C03  	BTFSS STATUS,C
0762  03EF  	DECF convertTem_0002B_1_iValue+D'1', F

        // each time we take off 10, the left most digit is incremented
        giDS3231ValueBCD += 0x10;
0763  3010  	MOVLW 0x10
0764  07B3  	ADDWF gbl_giDS3231ValueBCD, F
0765  1803  	BTFSC STATUS,C
0766  0AB4  	INCF gbl_giDS3231ValueBCD+D'1', F

    }

    // the last digit is what's left on iValue
    giDS3231ValueBCD += iValue;
0768  086E  	MOVF convertTem_0002B_1_iValue, W
0769  07B3  	ADDWF gbl_giDS3231ValueBCD, F
076A  086F  	MOVF convertTem_0002B_1_iValue+D'1', W
076B  1803  	BTFSC STATUS,C
076C  0AB4  	INCF gbl_giDS3231ValueBCD+D'1', F
076D  07B4  	ADDWF gbl_giDS3231ValueBCD+D'1', F

}
076E  0008  	RETURN


/*********************************************************************************************
  void startTemp()
  Sends the Convert T [44h] function command to the ds18b20
*********************************************************************************************/
void startTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // 44 is the convert function
    oneWireTxBytes(0xCC, 0x44);
060D  30CC  	MOVLW 0xCC
060E  1283  	BCF STATUS, RP0
060F  1303  	BCF STATUS, RP1
0610  00EC  	MOVWF oneWireTxB_00019_arg_cData
0611  3044  	MOVLW 0x44
0612  00ED  	MOVWF oneWireTxB_00019_arg_cData2
0613  23AD  	CALL oneWireTxB_00019

}
0614  0008  	RETURN


/*********************************************************************************************
  void startTemp()
  Sends the Read Scratchpad [BEh] function command to the ds18b20
*********************************************************************************************/
void readTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // BE indicates to read scratchpad
    oneWireTxBytes(0xCC, 0xBE);
0615  30CC  	MOVLW 0xCC
0616  1283  	BCF STATUS, RP0
0617  1303  	BCF STATUS, RP1
0618  00EC  	MOVWF oneWireTxB_00019_arg_cData
0619  30BE  	MOVLW 0xBE
061A  00ED  	MOVWF oneWireTxB_00019_arg_cData2
061B  23AD  	CALL oneWireTxB_00019

    // Now get the temperature from the scratchpad
    // This is in the first two bytes - so get those only and ignore the rest
    cTempL = oneWireRxByte();
061C  23B4  	CALL oneWireRxB_0001A
061D  086D  	MOVF CompTempVarRet551, W
061E  00CA  	MOVWF gbl_cTempL

    cTempH = oneWireRxByte();
061F  23B4  	CALL oneWireRxB_0001A
0620  086D  	MOVF CompTempVarRet551, W
0621  00C9  	MOVWF gbl_cTempH

}
0622  0008  	RETURN


/*********************************************************************************************
  char bcdAdjust(char bcd, char bcdMax, char bcdMin)
  Increment or Decrement a BCD variable for sending to the DS3231, within a given range
  Must set iBcdAdjustment first
*********************************************************************************************/
char bcdAdjust(char bcd, char bcdMax, char bcdMin) {

    if (iBcdAdjustment == 1) {
01F2  0369  	DECF gbl_iBcdAdjustment, W
01F3  1D03  	BTFSS STATUS,Z
01F4  2A08  	GOTO	label39
0208        label39

        // Increment
        // if at maximum, reset to minimum
        if (bcd == bcdMax)
01F5  086F  	MOVF bcdAdjust_00000_arg_bcdMax, W
01F6  066E  	XORWF bcdAdjust_00000_arg_bcd, W
01F7  1D03  	BTFSS STATUS,Z
01F8  29FC  	GOTO	label37
01FC        label37

            bcd = bcdMin;
01F9  0870  	MOVF bcdAdjust_00000_arg_bcdMin, W
01FA  00EE  	MOVWF bcdAdjust_00000_arg_bcd

        else if ((bcd & 0x0F) == 9)
01FB  2A19  	GOTO	label42
01FC  300F  	MOVLW 0x0F
01FD  056E  	ANDWF bcdAdjust_00000_arg_bcd, W
01FE  00F1  	MOVWF CompTempVar599
01FF  0871  	MOVF CompTempVar599, W
0200  3A09  	XORLW 0x09
0201  1D03  	BTFSS STATUS,Z
0202  2A06  	GOTO	label38
0206        label38

            bcd += 0x07; // add 0x10 (16), minus 9
0203  3007  	MOVLW 0x07
0204  07EE  	ADDWF bcdAdjust_00000_arg_bcd, F

        else
0205  2A19  	GOTO	label42

            bcd++;
0206  0AEE  	INCF bcdAdjust_00000_arg_bcd, F

    } else {
0207  2A19  	GOTO	label42

        // Decrement
        // if at minimum, reset to maximum
        if (bcd == bcdMin)
0208  0870  	MOVF bcdAdjust_00000_arg_bcdMin, W
0209  066E  	XORWF bcdAdjust_00000_arg_bcd, W
020A  1D03  	BTFSS STATUS,Z
020B  2A0F  	GOTO	label40
020F        label40

            bcd = bcdMax;
020C  086F  	MOVF bcdAdjust_00000_arg_bcdMax, W
020D  00EE  	MOVWF bcdAdjust_00000_arg_bcd

        else if ((bcd & 0x0F) == 0)
020E  2A19  	GOTO	label42
020F  300F  	MOVLW 0x0F
0210  056E  	ANDWF bcdAdjust_00000_arg_bcd, W
0211  00F1  	MOVWF CompTempVar600
0212  08F1  	MOVF CompTempVar600, F
0213  1D03  	BTFSS STATUS,Z
0214  2A18  	GOTO	label41
0218        label41

            bcd -= 0x07; // minus 0x10 (16), add 9
0215  3007  	MOVLW 0x07
0216  02EE  	SUBWF bcdAdjust_00000_arg_bcd, F

        else
0217  2A19  	GOTO	label42
0219        label42

            bcd--;
0218  03EE  	DECF bcdAdjust_00000_arg_bcd, F

    }
    return bcd;
0219  086E  	MOVF bcdAdjust_00000_arg_bcd, W
021A  00F1  	MOVWF CompTempVarRet598

}
021B  0008  	RETURN


/*********************************************************************************************
  void adjustDateTime()
  Increment or Decrement a BCD variable for sending to the DS3231, within a given range
  Must set iBcdAdjustment first
*********************************************************************************************/
void adjustDateTime() {

    switch (gcSetMode) {

        case 1:
0545  1283  	BCF STATUS, RP0
0546  1303  	BCF STATUS, RP1
0547  084F  	MOVF gbl_gcSetMode, W
0548  3A01  	XORLW 0x01
0549  1903  	BTFSC STATUS,Z
054A  2D5B  	GOTO	label95
055B        label95

            // Setting year
            gBcdYear = bcdAdjust(gBcdYear, 0x99, 0x00);
055B  083B  	MOVF gbl_gBcdYear, W
055C  00EE  	MOVWF bcdAdjust_00000_arg_bcd
055D  3099  	MOVLW 0x99
055E  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
055F  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
0560  21F2  	CALL bcdAdjust_00000
0561  0871  	MOVF CompTempVarRet598, W
0562  00BB  	MOVWF gbl_gBcdYear

            break;
        case 2:
054B  3A03  	XORLW 0x03
054C  1903  	BTFSC STATUS,Z
054D  2D64  	GOTO	label96
0564        label96

            // Setting month
            gBcdMonth = bcdAdjust(gBcdMonth, 0x12, 0x01);
0564  083A  	MOVF gbl_gBcdMonth, W
0565  00EE  	MOVWF bcdAdjust_00000_arg_bcd
0566  3012  	MOVLW 0x12
0567  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
0568  3001  	MOVLW 0x01
0569  00F0  	MOVWF bcdAdjust_00000_arg_bcdMin
056A  21F2  	CALL bcdAdjust_00000
056B  0871  	MOVF CompTempVarRet598, W
056C  00BA  	MOVWF gbl_gBcdMonth

            break;
        case 3:
054E  3A01  	XORLW 0x01
054F  1903  	BTFSC STATUS,Z
0550  2D6E  	GOTO	label97
056E        label97

            // Setting day of month
            char iMonth = gBcdMonth;
056E  083A  	MOVF gbl_gBcdMonth, W
056F  00EC  	MOVWF adjustDate_00026_1_iMonth

            if (iMonth & 0xF0)
0570  30F0  	MOVLW 0xF0
0571  056C  	ANDWF adjustDate_00026_1_iMonth, W
0572  1903  	BTFSC STATUS,Z
0573  2D79  	GOTO	label98
0579        label98

                iMonth += (gBcdMonth >> 4);
0574  0E3A  	SWAPF gbl_gBcdMonth, W
0575  390F  	ANDLW 0x0F
0576  00EE  	MOVWF CompTempVar601
0577  086E  	MOVF CompTempVar601, W
0578  07EC  	ADDWF adjustDate_00026_1_iMonth, F

            iMonth--; // Make 0 to 11 index based
0579  03EC  	DECF adjustDate_00026_1_iMonth, F

            char bcdMaxDay = gDaysInMonth[iMonth]; 
057A  083C  	MOVF gbl_gDaysInMonth, W
057B  00F4  	MOVWF __rom_get_00000_arg_objNumb
057C  086C  	MOVF adjustDate_00026_1_iMonth, W
057D  00F5  	MOVWF __rom_get_00000_arg_idx
057E  201A  	CALL __rom_get_00000
057F  00ED  	MOVWF adjustDate_00026_1_bcdMaxDay

            // If February, adjust max days for leap years
            if (iMonth == 1) {
0580  036C  	DECF adjustDate_00026_1_iMonth, W
0581  118A  	BCF PCLATH,3
0582  120A  	BCF PCLATH,4
0583  1D03  	BTFSS STATUS,Z
0584  2D9B  	GOTO	label101

                // See if the 24 leap years since 2000 match the current year
                for (char i = 0; i < 24; i++) {
0585  01EE  	CLRF adjustDate_00026_16_i
0586        label99
0586  3018  	MOVLW 0x18
0587  026E  	SUBWF adjustDate_00026_16_i, W
0588  1803  	BTFSC STATUS,C
0589  2D9B  	GOTO	label101
0599  0AEE  	INCF adjustDate_00026_16_i, F
059A  2D86  	GOTO	label99
059B        label101

                    if (gLeapYears[i] == gBcdYear) {
058A  083D  	MOVF gbl_gLeapYears, W
058B  00F4  	MOVWF __rom_get_00000_arg_objNumb
058C  086E  	MOVF adjustDate_00026_16_i, W
058D  00F5  	MOVWF __rom_get_00000_arg_idx
058E  201A  	CALL __rom_get_00000
058F  00EF  	MOVWF CompTempVar602
0590  083B  	MOVF gbl_gBcdYear, W
0591  066F  	XORWF CompTempVar602, W
0592  118A  	BCF PCLATH,3
0593  120A  	BCF PCLATH,4
0594  1D03  	BTFSS STATUS,Z
0595  2D99  	GOTO	label100
0599        label100

                        bcdMaxDay = 0x29;
0596  3029  	MOVLW 0x29
0597  00ED  	MOVWF adjustDate_00026_1_bcdMaxDay

                        break;
0598  2D9B  	GOTO	label101

                    }
                }
            }
            gBcdDayOfMonth = bcdAdjust(gBcdDayOfMonth, bcdMaxDay, 0x01);
059B  0839  	MOVF gbl_gBcdDayOfMonth, W
059C  00EE  	MOVWF bcdAdjust_00000_arg_bcd
059D  086D  	MOVF adjustDate_00026_1_bcdMaxDay, W
059E  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
059F  3001  	MOVLW 0x01
05A0  00F0  	MOVWF bcdAdjust_00000_arg_bcdMin
05A1  21F2  	CALL bcdAdjust_00000
05A2  0871  	MOVF CompTempVarRet598, W
05A3  00B9  	MOVWF gbl_gBcdDayOfMonth

            break;
        case 4:
0551  3A07  	XORLW 0x07
0552  1903  	BTFSC STATUS,Z
0553  2DA5  	GOTO	label102
05A5        label102

            // Setting day of week
            gDayOfWeek = bcdAdjust(gDayOfWeek, 0x07, 0x01);
05A5  0838  	MOVF gbl_gDayOfWeek, W
05A6  00EE  	MOVWF bcdAdjust_00000_arg_bcd
05A7  3007  	MOVLW 0x07
05A8  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
05A9  3001  	MOVLW 0x01
05AA  00F0  	MOVWF bcdAdjust_00000_arg_bcdMin
05AB  21F2  	CALL bcdAdjust_00000
05AC  0871  	MOVF CompTempVarRet598, W
05AD  00B8  	MOVWF gbl_gDayOfWeek

            break;
        case 5:
0554  3A01  	XORLW 0x01
0555  1903  	BTFSC STATUS,Z
0556  2DAF  	GOTO	label103
05AF        label103

            // Setting hour
            gBcdHour = bcdAdjust(gBcdHour, 0x23, 0x00);
05AF  0837  	MOVF gbl_gBcdHour, W
05B0  00EE  	MOVWF bcdAdjust_00000_arg_bcd
05B1  3023  	MOVLW 0x23
05B2  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
05B3  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
05B4  21F2  	CALL bcdAdjust_00000
05B5  0871  	MOVF CompTempVarRet598, W
05B6  00B7  	MOVWF gbl_gBcdHour

            break;
        case 6:
0557  3A03  	XORLW 0x03
0558  1903  	BTFSC STATUS,Z
0559  2DB8  	GOTO	label104
05B8        label104

            // Setting minute
            gBcdMinute = bcdAdjust(gBcdMinute, 0x59, 0x00);
05B8  0836  	MOVF gbl_gBcdMinute, W
05B9  00EE  	MOVWF bcdAdjust_00000_arg_bcd
05BA  3059  	MOVLW 0x59
05BB  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
05BC  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
05BD  21F2  	CALL bcdAdjust_00000
05BE  0871  	MOVF CompTempVarRet598, W
05BF  00B6  	MOVWF gbl_gBcdMinute

            break;
    }
}
055A  0008  	RETURN
0563  0008  	RETURN
056D  0008  	RETURN
05A4  0008  	RETURN
05AE  0008  	RETURN
05B7  0008  	RETURN
05C0  0008  	RETURN


/*********************************************************************************************
  void adjustTrigger()
  Increment or Decrement a trigger time or temperate
  Must set iBcdAdjustment first
*********************************************************************************************/
void adjustTrigger() {

    switch (gcTriggerMode) {

        case 1:
04A1  1283  	BCF STATUS, RP0
04A2  1303  	BCF STATUS, RP1
04A3  0850  	MOVF gbl_gcTriggerMode, W
04A4  3A01  	XORLW 0x01
04A5  1903  	BTFSC STATUS,Z
04A6  2CC9  	GOTO	label81
04C9        label81

            // White LED on hour
            gBcdWhiteOnHour = bcdAdjust(gBcdWhiteOnHour, 0x23, 0x00);
04C9  0852  	MOVF gbl_gBcdWhiteOnHour, W
04CA  00EE  	MOVWF bcdAdjust_00000_arg_bcd
04CB  3023  	MOVLW 0x23
04CC  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
04CD  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
04CE  21F2  	CALL bcdAdjust_00000
04CF  0871  	MOVF CompTempVarRet598, W
04D0  00D2  	MOVWF gbl_gBcdWhiteOnHour

            break;
        case 2:
04A7  3A03  	XORLW 0x03
04A8  1903  	BTFSC STATUS,Z
04A9  2CD2  	GOTO	label82
04D2        label82

            // White LED on minute
            gBcdWhiteOnMinute = bcdAdjust(gBcdWhiteOnMinute, 0x59, 0x00);
04D2  0851  	MOVF gbl_gBcdWhiteOnMinute, W
04D3  00EE  	MOVWF bcdAdjust_00000_arg_bcd
04D4  3059  	MOVLW 0x59
04D5  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
04D6  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
04D7  21F2  	CALL bcdAdjust_00000
04D8  0871  	MOVF CompTempVarRet598, W
04D9  00D1  	MOVWF gbl_gBcdWhiteOnMinute

            break;
        case 3:
04AA  3A01  	XORLW 0x01
04AB  1903  	BTFSC STATUS,Z
04AC  2CDB  	GOTO	label83
04DB        label83

            // White LED off hour
            gBcdWhiteOffHour = bcdAdjust(gBcdWhiteOffHour, 0x23, 0x00);
04DB  0854  	MOVF gbl_gBcdWhiteOffHour, W
04DC  00EE  	MOVWF bcdAdjust_00000_arg_bcd
04DD  3023  	MOVLW 0x23
04DE  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
04DF  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
04E0  21F2  	CALL bcdAdjust_00000
04E1  0871  	MOVF CompTempVarRet598, W
04E2  00D4  	MOVWF gbl_gBcdWhiteOffHour

            break;
        case 4:
04AD  3A07  	XORLW 0x07
04AE  1903  	BTFSC STATUS,Z
04AF  2CE4  	GOTO	label84
04E4        label84

            // White LED off minute
            gBcdWhiteOffMinute = bcdAdjust(gBcdWhiteOffMinute, 0x59, 0x00);
04E4  0853  	MOVF gbl_gBcdWhiteOffMinute, W
04E5  00EE  	MOVWF bcdAdjust_00000_arg_bcd
04E6  3059  	MOVLW 0x59
04E7  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
04E8  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
04E9  21F2  	CALL bcdAdjust_00000
04EA  0871  	MOVF CompTempVarRet598, W
04EB  00D3  	MOVWF gbl_gBcdWhiteOffMinute

            break;
        case 5:
04B0  3A01  	XORLW 0x01
04B1  1903  	BTFSC STATUS,Z
04B2  2CED  	GOTO	label85
04ED        label85

            // Blue LED on hour
            gBcdBlueOnHour = bcdAdjust(gBcdBlueOnHour, 0x23, 0x00);
04ED  0856  	MOVF gbl_gBcdBlueOnHour, W
04EE  00EE  	MOVWF bcdAdjust_00000_arg_bcd
04EF  3023  	MOVLW 0x23
04F0  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
04F1  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
04F2  21F2  	CALL bcdAdjust_00000
04F3  0871  	MOVF CompTempVarRet598, W
04F4  00D6  	MOVWF gbl_gBcdBlueOnHour

            break;
        case 6:
04B3  3A03  	XORLW 0x03
04B4  1903  	BTFSC STATUS,Z
04B5  2CF6  	GOTO	label86
04F6        label86

            // Blue LED on minute
            gBcdBlueOnMinute = bcdAdjust(gBcdBlueOnMinute, 0x59, 0x00);
04F6  0855  	MOVF gbl_gBcdBlueOnMinute, W
04F7  00EE  	MOVWF bcdAdjust_00000_arg_bcd
04F8  3059  	MOVLW 0x59
04F9  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
04FA  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
04FB  21F2  	CALL bcdAdjust_00000
04FC  0871  	MOVF CompTempVarRet598, W
04FD  00D5  	MOVWF gbl_gBcdBlueOnMinute

            break;
        case 7:
04B6  3A01  	XORLW 0x01
04B7  1903  	BTFSC STATUS,Z
04B8  2CFF  	GOTO	label87
04FF        label87

            // Blue LED off hour
            gBcdBlueOffHour = bcdAdjust(gBcdBlueOffHour, 0x23, 0x00);
04FF  0858  	MOVF gbl_gBcdBlueOffHour, W
0500  00EE  	MOVWF bcdAdjust_00000_arg_bcd
0501  3023  	MOVLW 0x23
0502  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
0503  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
0504  21F2  	CALL bcdAdjust_00000
0505  0871  	MOVF CompTempVarRet598, W
0506  00D8  	MOVWF gbl_gBcdBlueOffHour

            break;
        case 8:
04B9  3A0F  	XORLW 0x0F
04BA  1903  	BTFSC STATUS,Z
04BB  2D08  	GOTO	label88
0508        label88

            // Blue LED off minute
            gBcdBlueOffMinute = bcdAdjust(gBcdBlueOffMinute, 0x59, 0x00);
0508  0857  	MOVF gbl_gBcdBlueOffMinute, W
0509  00EE  	MOVWF bcdAdjust_00000_arg_bcd
050A  3059  	MOVLW 0x59
050B  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
050C  01F0  	CLRF bcdAdjust_00000_arg_bcdMin
050D  21F2  	CALL bcdAdjust_00000
050E  0871  	MOVF CompTempVarRet598, W
050F  00D7  	MOVWF gbl_gBcdBlueOffMinute

            break;
        case 9:
04BC  3A01  	XORLW 0x01
04BD  1903  	BTFSC STATUS,Z
04BE  2D11  	GOTO	label89
0511        label89

            // Fan on temp - between 20 and 40 degrees C
            gBcdFanOnTemp = bcdAdjust(gBcdFanOnTemp, 0x40, 0x20);
0511  0859  	MOVF gbl_gBcdFanOnTemp, W
0512  00EE  	MOVWF bcdAdjust_00000_arg_bcd
0513  3040  	MOVLW 0x40
0514  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
0515  3020  	MOVLW 0x20
0516  00F0  	MOVWF bcdAdjust_00000_arg_bcdMin
0517  21F2  	CALL bcdAdjust_00000
0518  0871  	MOVF CompTempVarRet598, W
0519  00D9  	MOVWF gbl_gBcdFanOnTemp

            break;
        case 10:
04BF  3A03  	XORLW 0x03
04C0  1903  	BTFSC STATUS,Z
04C1  2D1B  	GOTO	label90
051B        label90

            // Fan off temp - off must be lower than on, min 20 degrees C
            if (gBcdFanOffTemp > gBcdFanOnTemp)
051B  085A  	MOVF gbl_gBcdFanOffTemp, W
051C  0259  	SUBWF gbl_gBcdFanOnTemp, W
051D  1803  	BTFSC STATUS,C
051E  2D21  	GOTO	label91
0521        label91

				gBcdFanOffTemp = gBcdFanOnTemp;
051F  0859  	MOVF gbl_gBcdFanOnTemp, W
0520  00DA  	MOVWF gbl_gBcdFanOffTemp

            gBcdFanOffTemp = bcdAdjust(gBcdFanOffTemp, gBcdFanOnTemp, 0x20);
0521  085A  	MOVF gbl_gBcdFanOffTemp, W
0522  00EE  	MOVWF bcdAdjust_00000_arg_bcd
0523  0859  	MOVF gbl_gBcdFanOnTemp, W
0524  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
0525  3020  	MOVLW 0x20
0526  00F0  	MOVWF bcdAdjust_00000_arg_bcdMin
0527  21F2  	CALL bcdAdjust_00000
0528  0871  	MOVF CompTempVarRet598, W
0529  00DA  	MOVWF gbl_gBcdFanOffTemp

            break;
        case 11:
04C2  3A01  	XORLW 0x01
04C3  1903  	BTFSC STATUS,Z
04C4  2D2B  	GOTO	label92
052B        label92

            // Heater on temp - between 20 and 40 degrees C
            gBcdHeaterOnTemp = bcdAdjust(gBcdHeaterOnTemp, 0x40, 0x20);
052B  085B  	MOVF gbl_gBcdHeaterOnTemp, W
052C  00EE  	MOVWF bcdAdjust_00000_arg_bcd
052D  3040  	MOVLW 0x40
052E  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
052F  3020  	MOVLW 0x20
0530  00F0  	MOVWF bcdAdjust_00000_arg_bcdMin
0531  21F2  	CALL bcdAdjust_00000
0532  0871  	MOVF CompTempVarRet598, W
0533  00DB  	MOVWF gbl_gBcdHeaterOnTemp

            break;
        case 12:
04C5  3A07  	XORLW 0x07
04C6  1903  	BTFSC STATUS,Z
04C7  2D35  	GOTO	label93
0535        label93

            // Heater off temp - off must be higher than on - max 40 degrees C
            if (gBcdHeaterOnTemp < gBcdHeaterOffTemp)
0535  085C  	MOVF gbl_gBcdHeaterOffTemp, W
0536  025B  	SUBWF gbl_gBcdHeaterOnTemp, W
0537  1803  	BTFSC STATUS,C
0538  2D3B  	GOTO	label94
053B        label94

				gBcdHeaterOnTemp = gBcdHeaterOffTemp;
0539  085C  	MOVF gbl_gBcdHeaterOffTemp, W
053A  00DB  	MOVWF gbl_gBcdHeaterOnTemp

            gBcdHeaterOffTemp = bcdAdjust(gBcdHeaterOffTemp, 0x40, gBcdHeaterOnTemp);
053B  085C  	MOVF gbl_gBcdHeaterOffTemp, W
053C  00EE  	MOVWF bcdAdjust_00000_arg_bcd
053D  3040  	MOVLW 0x40
053E  00EF  	MOVWF bcdAdjust_00000_arg_bcdMax
053F  085B  	MOVF gbl_gBcdHeaterOnTemp, W
0540  00F0  	MOVWF bcdAdjust_00000_arg_bcdMin
0541  21F2  	CALL bcdAdjust_00000
0542  0871  	MOVF CompTempVarRet598, W
0543  00DC  	MOVWF gbl_gBcdHeaterOffTemp

            break;
    }
}
04C8  0008  	RETURN
04D1  0008  	RETURN
04DA  0008  	RETURN
04E3  0008  	RETURN
04EC  0008  	RETURN
04F5  0008  	RETURN
04FE  0008  	RETURN
0507  0008  	RETURN
0510  0008  	RETURN
051A  0008  	RETURN
052A  0008  	RETURN
0534  0008  	RETURN
0544  0008  	RETURN


/*********************************************************************************************
  void processKeys()
  Action a key press
*********************************************************************************************/
void processKeys() {

    switch (tm1638Keys) {

        case 0x1F:
0623  1283  	BCF STATUS, RP0
0624  1303  	BCF STATUS, RP1
0625  0865  	MOVF gbl_tm1638Keys, W
0626  3A1F  	XORLW 0x1F
0627  1903  	BTFSC STATUS,Z
0628  2E3F  	GOTO	label111
063F        label111

            // Toggle white light on/off
            WHITE_LED = !WHITE_LED;
063F  01EC  	CLRF CompTempVar603
0640  1C87  	BTFSS gbl_portc,1
0641  0AEC  	INCF CompTempVar603, F
0642  186C  	BTFSC CompTempVar603,0
0643  1487  	BSF gbl_portc,1
0644  1C6C  	BTFSS CompTempVar603,0
0645  1087  	BCF gbl_portc,1

            break;
        case 0x17:
0629  3A08  	XORLW 0x08
062A  1903  	BTFSC STATUS,Z
062B  2E47  	GOTO	label112
0647        label112

            // Toggle blue light on/off
            BLUE_LED = !BLUE_LED;
0647  01EC  	CLRF CompTempVar604
0648  1D07  	BTFSS gbl_portc,2
0649  0AEC  	INCF CompTempVar604, F
064A  186C  	BTFSC CompTempVar604,0
064B  1507  	BSF gbl_portc,2
064C  1C6C  	BTFSS CompTempVar604,0
064D  1107  	BCF gbl_portc,2

            break;
        case 0x0F:
062C  3A18  	XORLW 0x18
062D  1903  	BTFSC STATUS,Z
062E  2E4F  	GOTO	label113
064F        label113

            // Toggle fan on/off
            gbFanOn = !gbFanOn;
064F  01EC  	CLRF CompTempVar605
0650  1D4D  	BTFSS gbl_gbFanOn,2
0651  0AEC  	INCF CompTempVar605, F
0652  114D  	BCF gbl_gbFanOn,2
0653  086C  	MOVF CompTempVar605, W
0654  1D03  	BTFSS STATUS,Z
0655  154D  	BSF gbl_gbFanOn,2

            break;
        case 0x07:
062F  3A08  	XORLW 0x08
0630  1903  	BTFSC STATUS,Z
0631  2E57  	GOTO	label114
0657        label114

            // Exit other modes
            gcSetMode = 0;
0657  01CF  	CLRF gbl_gcSetMode

            gcTriggerMode = 0;
0658  01D0  	CLRF gbl_gcTriggerMode

            // Display temp C/temp F/date
            gcDisplayMode++;
0659  0ACE  	INCF gbl_gcDisplayMode, F

            if (gcDisplayMode > 2)
065A  084E  	MOVF gbl_gcDisplayMode, W
065B  3C02  	SUBLW 0x02
065C  1C03  	BTFSS STATUS,C

                gcDisplayMode = 0;
065D  01CE  	CLRF gbl_gcDisplayMode

            break;
        case 0x1B:
0632  3A1C  	XORLW 0x1C
0633  1903  	BTFSC STATUS,Z
0634  2E5F  	GOTO	label115
065F        label115

            // Exit other modes
            gcTriggerMode = 0;
065F  01D0  	CLRF gbl_gcTriggerMode

            // Adjust set mode
            gcSetMode++;
0660  0ACF  	INCF gbl_gcSetMode, F

            if (gcSetMode > 6) {
0661  084F  	MOVF gbl_gcSetMode, W
0662  3C06  	SUBLW 0x06
0663  1803  	BTFSC STATUS,C

                ds3231WriteDateTime();
0665  23E5  	CALL ds3231Writ_0001C

                gcSetMode = 0;
0666  01CF  	CLRF gbl_gcSetMode

            }
            break;
        case 0x13:
0635  3A08  	XORLW 0x08
0636  1903  	BTFSC STATUS,Z
0637  2E68  	GOTO	label116
0668        label116

            // Adjust down
            iBcdAdjustment = 0;
0668  01E9  	CLRF gbl_iBcdAdjustment

            if (gcSetMode) {
0669  08CF  	MOVF gbl_gcSetMode, F
066A  1903  	BTFSC STATUS,Z
066B  2E6E  	GOTO	label117
066E        label117

                adjustDateTime();
066C  2545  	CALL adjustDate_00026

            } else if (gcTriggerMode) {
066E  08D0  	MOVF gbl_gcTriggerMode, F
066F  1D03  	BTFSS STATUS,Z

                adjustTrigger();
0670  24A1  	CALL adjustTrig_00027

            }
            break;
        case 0x0B:
0638  3A18  	XORLW 0x18
0639  1903  	BTFSC STATUS,Z
063A  2E72  	GOTO	label118
0672        label118

            iBcdAdjustment = 1;
0672  3001  	MOVLW 0x01
0673  00E9  	MOVWF gbl_iBcdAdjustment

            // Adjust up
            if (gcSetMode) {
0674  08CF  	MOVF gbl_gcSetMode, F
0675  1903  	BTFSC STATUS,Z
0676  2E79  	GOTO	label119
0679        label119

                adjustDateTime();
0677  2545  	CALL adjustDate_00026

            } else if (gcTriggerMode) {
0679  08D0  	MOVF gbl_gcTriggerMode, F
067A  1D03  	BTFSS STATUS,Z

                adjustTrigger();
067B  24A1  	CALL adjustTrig_00027

            }
            break;
        case 0x03:
063B  3A08  	XORLW 0x08
063C  1903  	BTFSC STATUS,Z
063D  2E7D  	GOTO	label120
067D        label120

            // Exit set mode
            gcSetMode = 0;
067D  01CF  	CLRF gbl_gcSetMode

            // Adjust timer mode
            gcTriggerMode++;
067E  0AD0  	INCF gbl_gcTriggerMode, F

            if (gcTriggerMode > 12) {
067F  0850  	MOVF gbl_gcTriggerMode, W
0680  3C0C  	SUBLW 0x0C
0681  1803  	BTFSC STATUS,C

                gcTriggerMode = 0;
0683  01D0  	CLRF gbl_gcTriggerMode

                at24c32WriteAll(); // Exiting trigger mode, save the new triggers to EEPROM chip
0684  2421  	CALL at24c32Wri_00029

            }
            break;
    }
}
063E  0008  	RETURN
0646  0008  	RETURN
064E  0008  	RETURN
0656  0008  	RETURN
065E  0008  	RETURN
0664  0008  	RETURN
0667  0008  	RETURN
066D  0008  	RETURN
0671  0008  	RETURN
0678  0008  	RETURN
067C  0008  	RETURN
0682  0008  	RETURN
0685  0008  	RETURN


/*********************************************************************************************
  void interrupt()
  Interrupt handler
*********************************************************************************************/
void interrupt() {

    // Interrupt on timer0 - flash digit delay
    if (intcon.T0IF) {
0861  1D0B  	BTFSS gbl_intcon,2
0862  286A  	GOTO	label149
086A        label149

        iTimer0Counts++;
0863  1283  	BCF STATUS, RP0
0864  1303  	BCF STATUS, RP1
0865  0ABE  	INCF gbl_iTimer0Counts, F

        tmr0 = TMR0PRELOAD;
0866  303D  	MOVLW 0x3D
0867  0081  	MOVWF gbl_tmr0

        cTask.TASK_TIMER0 = 1;
0868  14CC  	BSF gbl_cTask,1

        // Clear interrupt flag
        intcon.T0IF = 0; 
0869  110B  	BCF gbl_intcon,2

    }
    // Handle timer1 interrupt - delay counter from DS3231
    if (pir1.TMR1IF) {
086A  1283  	BCF STATUS, RP0
086B  1303  	BCF STATUS, RP1
086C  1C0C  	BTFSS gbl_pir1,0
086D  2873  	GOTO	label150
0873        label150

        tmr1h = TMR1HV;      // preset for timer1 MSB register
086E  30FF  	MOVLW 0xFF
086F  008F  	MOVWF gbl_tmr1h

        tmr1l = TMR1LV;      // preset for timer1 LSB register
0870  008E  	MOVWF gbl_tmr1l


        pir1.TMR1IF = 0;     // Clear interrupt flag
0871  100C  	BCF gbl_pir1,0

        cTask.TASK_TIMER1 = 1;
0872  154C  	BSF gbl_cTask,2

    }
}
0873  0E32  	SWAPF Int1BContext+D'2', W
0874  0084  	MOVWF FSR
0875  0E31  	SWAPF Int1BContext+D'1', W
0876  008A  	MOVWF PCLATH
0877  0E30  	SWAPF Int1BContext, W
0878  0083  	MOVWF STATUS
0879  0EFF  	SWAPF Int1Context, F
087A  0E7F  	SWAPF Int1Context, W
087B  0009  	RETFIE


/*********************************************************************************************
  void initialise()
  Function called once only to initialise variables and
  setup the PIC registers
*********************************************************************************************/
void initialise() {

    //PIC16F73 doesn't have an internal oscillator
    //pcon.OSCF = 1; // 4MHz internal osc

    // Configure port A
    /*
    RA7     Doesn't exist
    RA6     Doesn't exist
    RA5     
    RA4     
    RA3     
    RA2     
    RA1     OUT FANS
    RA0     OUT HEATER
    */
    trisa = 0x00; // all outputs
069E  1683  	BSF STATUS, RP0
069F  1303  	BCF STATUS, RP1
06A0  0185  	CLRF gbl_trisa

    porta = 0x00; // All off
06A1  1283  	BCF STATUS, RP0
06A2  0185  	CLRF gbl_porta

    
    // Configure port B
    /*      
    RB7     ICSP PGD
    RB6     ICSP PGC
    RB5     
    RB4     
    RB3     OUT TM1638 STB
    RB2     OUT TM1638 CLK
    RB1     IN/OUT TM1638 DIO
    RB0     
    */
    trisb = 0x00; // all outputs by default
06A3  1683  	BSF STATUS, RP0
06A4  0186  	CLRF gbl_trisb

    portb = 0x0E; // default TM1638 pins high
06A5  300E  	MOVLW 0x0E
06A6  1283  	BCF STATUS, RP0
06A7  0086  	MOVWF gbl_portb


    // Configure port C
    /*      
    RC7     
    RC6     
    RC5     IN/OUT DS18B20
    RC4     IN/OUT DS3231M I2C SDA
    RC3     IN/OUT DS3231M I2C CLK
    RC2     OUT BLUE LIGHT PWM
    RC1     OUT WHITE LIGHT PWM
    RC0     IN SQW DS3231M
    */
    trisc = 0x21; // RC0 and RC5 inputs
06A8  3021  	MOVLW 0x21
06A9  1683  	BSF STATUS, RP0
06AA  0087  	MOVWF gbl_trisc

    portc = 0x38; // default DS18B20 and DS3231 pins high
06AB  3038  	MOVLW 0x38
06AC  1283  	BCF STATUS, RP0
06AD  0087  	MOVWF gbl_portc


    option_reg = 0;
06AE  1683  	BSF STATUS, RP0
06AF  0181  	CLRF gbl_option_reg

    option_reg.NOT_RBPU = 1; // disable port b pull ups
06B0  1781  	BSF gbl_option_reg,7


    // ADC setup
    // PIC16F73 doesn't have comparators
    //cmcon = 7; // disable all comparators so port a is usable as digital io
    adcon1 = 7; // Set RA0,RA1,RA2,RA5,RA3 all to digital I/O
06B1  3007  	MOVLW 0x07
06B2  009F  	MOVWF gbl_adcon1



    // Setup timer 0, used for flashing display
    // Timer calculator: http://eng-serve.com/pic/pic_timer.html
    // Timer0 Registers Prescaler= 256 - TMR0 Preset = 61 - Freq = 20.03 Hz - Period = 0.049920 seconds
    //option_reg.T0CS = 0; // bit 5  TMR0 Clock Source Select bit...0 = Internal Clock (CLKO) 1 = Transition on T0CKI pin
    //option_reg.T0SE = 0; // bit 4 TMR0 Source Edge Select bit 0 = low/high 1 = high/low
    //option_reg.PSA = 0; // bit 3  Prescaler Assignment bit...0 = Prescaler is assigned to the Timer0
    option_reg.PS2 = 1; // bits 2-0  PS2:PS0: Prescaler Rate Select bits
06B3  1501  	BSF gbl_option_reg,2

    option_reg.PS1 = 1;
06B4  1481  	BSF gbl_option_reg,1

    option_reg.PS0 = 1;
06B5  1401  	BSF gbl_option_reg,0

    tmr0 = TMR0PRELOAD; // preset for timer register (61)
06B6  303D  	MOVLW 0x3D
06B7  1283  	BCF STATUS, RP0
06B8  0081  	MOVWF gbl_tmr0

    intcon.T0IF = 0; // Clear timer 1 interrupt flag bit
06B9  110B  	BCF gbl_intcon,2

    intcon.T0IE = 1; // Timer 1 interrupt enabled
06BA  168B  	BSF gbl_intcon,5


    // Setup timer 1, used to update clock display and periodically ask for a temperature reading
    // Timer 1 setup - interrupt on DS3231 SQW 1Hz
    // Timer1 Registers Prescaler= 1 - TMR1 Preset = 65535 - Freq = 1 Hz
    // Bits 5-4 T1CKPS1:T1CKPS0 = 00: Prescaler Rate Select bits, 00 = 1:1 prescaler
    // Bit 3 T1OSCEN = 0: Timer1 LP Oscillator Enable Control bit, 0 = off
    // Bit 2 NOT_T1SYNC = 1: Timer1 External Clock Input Synchronization Control bit, 1 = Do not synchronize external clock input
    // Bit 1 TMR1CS = 1: Timer1 Clock Source Select bit, 1 = External clock from T1OSO/T1CKI pin (on the rising edge)
    // Bit 0 TMR1ON = 0: Timer1 On Bit, 0 = off
    t1con = 0b00000111;
06BB  3007  	MOVLW 0x07
06BC  0090  	MOVWF gbl_t1con

    tmr1h = TMR1HV;      // preset for timer1 MSB register
06BD  30FF  	MOVLW 0xFF
06BE  008F  	MOVWF gbl_tmr1h

    tmr1l = TMR1LV;      // preset for timer1 LSB register
06BF  008E  	MOVWF gbl_tmr1l

    pie1.TMR1IE = 1;     // Timer 1 interrupt
06C0  1683  	BSF STATUS, RP0
06C1  140C  	BSF gbl_pie1,0

    
    // No task at initialisation
    cTask = 0;
06C2  1283  	BCF STATUS, RP0
06C3  01CC  	CLRF gbl_cTask

    
    // Enable interrupts
    intcon.GIE = 1;
06C4  178B  	BSF gbl_intcon,7

    intcon.PEIE = 1;
06C5  170B  	BSF gbl_intcon,6


	// I2C Bus initialisation - baud rate divisor not applicable for software implementation
	i2c_init(1); 
06C6  3001  	MOVLW 0x01
06C7  00ED  	MOVWF i2c_INIT_00000_arg_i2c_divisor
06C8  23D2  	CALL i2c_INIT_00000


    // Read in variables from EEPROM
    at24c32ReadAll();
06C9  2455  	CALL at24c32Rea_0002A


    // Check if the DS3231 needs initilising
    char cStatus = ds3231ReadRegister(0x0F); // Read the status register
06CA  300F  	MOVLW 0x0F
06CB  00ED  	MOVWF ds3231Read_0001E_arg_cRegAddress
06CC  2401  	CALL ds3231Read_0001E
06CD  086F  	MOVF CompTempVarRet554, W
06CE  00EC  	MOVWF initialise_00000_1_cStatus

    // If the oscillator (OSF bit in status register) has stopped, then init and write a default date/time
    if (cStatus.7) {
06CF  1FEC  	BTFSS initialise_00000_1_cStatus,7
06D0  2ED3  	GOTO	label121
06D3        label121

        ds3231Init();
06D1  2416  	CALL ds3231Init_00000

        ds3231WriteDateTime();
06D2  23E5  	CALL ds3231Writ_0001C

    }
    
	tm1638DisplayOn();
06D3  23A5  	CALL tm1638Disp_00021

    tm1638UpdateDisplay();
06D4  221C  	CALL tm1638Upda_00022

}
06D5  0008  	RETURN


/*********************************************************************************************
  void main()
  Entry method. Loops infinitely with a simple task scheduler.
*********************************************************************************************/
void main() {

    initialise();
076F  269E  	CALL initialise_00000

    
    // Endless loop
    while(1) {
0770        label130

        // Task scheduler
        // If there are tasks to be performed, find out the
        // most recent task from the array and execute it
        while (cTask > 0) {
0770  084C  	MOVF gbl_cTask, W
0771  3C00  	SUBLW 0x00
0772  1803  	BTFSC STATUS,C
0773  2F70  	GOTO	label130

            if (cTask.TASK_TIMER1) {
0774  1D4C  	BTFSS gbl_cTask,2
0775  2FE6  	GOTO	label144
07E6        label144

                if (!gcSetMode) {
0776  08CF  	MOVF gbl_gcSetMode, F
0777  1D03  	BTFSS STATUS,Z
0778  2F8F  	GOTO	label134

                    // Don't read date/time when in set mode
                    ds3231ReadDateTime();
0779  26D6  	CALL ds3231Read_0001D

                    if ((gBcdSecond == 0x29) || (gBcdSecond == 0x59)) {
077A  0835  	MOVF gbl_gBcdSecond, W
077B  3A29  	XORLW 0x29
077C  1903  	BTFSC STATUS,Z
077D  2F82  	GOTO	label131
077E  0835  	MOVF gbl_gBcdSecond, W
077F  3A59  	XORLW 0x59
0780  1D03  	BTFSS STATUS,Z
0781  2F85  	GOTO	label132
0782        label131
0785        label132

                        // Ask to convert for temperature reading at 29 seconds or 59 seconds past the minute
                        oneWireBusReset();
0782  2686  	CALL oneWireBus_00017

                        startTemp();
0783  260D  	CALL startTemp_00000

                    } else if ((gBcdSecond == 0) || (gBcdSecond == 0x30)) {
0784  2F8F  	GOTO	label134
0785  08B5  	MOVF gbl_gBcdSecond, F
0786  1903  	BTFSC STATUS,Z
0787  2F8C  	GOTO	label133
0788  0835  	MOVF gbl_gBcdSecond, W
0789  3A30  	XORLW 0x30
078A  1D03  	BTFSS STATUS,Z
078B  2F8F  	GOTO	label134
078C        label133
078F        label134
07FE  2F70  	GOTO	label130

                        // 1 second later, read the converted temperature
                        oneWireBusReset();
078C  2686  	CALL oneWireBus_00017

                        readTemp(); 
078D  2615  	CALL readTemp_00000

                        // store it in the array, next display refresh will pick it up
                        convertTemp();
078E  2700  	CALL convertTem_0002B

                    }
                }
                if (!gcTriggerMode) {
078F  08D0  	MOVF gbl_gcTriggerMode, F
0790  1D03  	BTFSS STATUS,Z
0791  2FDE  	GOTO	label142

					// Don't activate triggers when in trigger set mode
					// Trigger white led
					// Don't activate/deactivate if on and off set hour/min are the same
					if ((gBcdWhiteOnHour != gBcdWhiteOffHour) || (gBcdWhiteOnMinute != gBcdWhiteOffMinute)) {
0792  0854  	MOVF gbl_gBcdWhiteOffHour, W
0793  0652  	XORWF gbl_gBcdWhiteOnHour, W
0794  1D03  	BTFSS STATUS,Z
0795  2F9A  	GOTO	label135
0796  0853  	MOVF gbl_gBcdWhiteOffMinute, W
0797  0651  	XORWF gbl_gBcdWhiteOnMinute, W
0798  1903  	BTFSC STATUS,Z
0799  2FAA  	GOTO	label137
079A        label135

						if ((gBcdHour == gBcdWhiteOnHour) && (gBcdMinute == gBcdWhiteOnMinute)) {
079A  0852  	MOVF gbl_gBcdWhiteOnHour, W
079B  0637  	XORWF gbl_gBcdHour, W
079C  1D03  	BTFSS STATUS,Z
079D  2FA2  	GOTO	label136
079E  0851  	MOVF gbl_gBcdWhiteOnMinute, W
079F  0636  	XORWF gbl_gBcdMinute, W
07A0  1903  	BTFSC STATUS,Z

							WHITE_LED = 1;
07A1  1487  	BSF gbl_portc,1
07A2        label136

						}
						if ((gBcdHour == gBcdWhiteOffHour) && (gBcdMinute == gBcdWhiteOffMinute)) {
07A2  0854  	MOVF gbl_gBcdWhiteOffHour, W
07A3  0637  	XORWF gbl_gBcdHour, W
07A4  1D03  	BTFSS STATUS,Z
07A5  2FAA  	GOTO	label137
07A6  0853  	MOVF gbl_gBcdWhiteOffMinute, W
07A7  0636  	XORWF gbl_gBcdMinute, W
07A8  1903  	BTFSC STATUS,Z

							WHITE_LED = 0;
07A9  1087  	BCF gbl_portc,1
07AA        label137

						}
					}
					// Trigger blue led
					// Don't activate/deactivate if on and off set hour/min are the same
					if ((gBcdBlueOnHour != gBcdBlueOffHour) || (gBcdBlueOnMinute != gBcdBlueOffMinute)) {
07AA  0858  	MOVF gbl_gBcdBlueOffHour, W
07AB  0656  	XORWF gbl_gBcdBlueOnHour, W
07AC  1D03  	BTFSS STATUS,Z
07AD  2FB2  	GOTO	label138
07AE  0857  	MOVF gbl_gBcdBlueOffMinute, W
07AF  0655  	XORWF gbl_gBcdBlueOnMinute, W
07B0  1903  	BTFSC STATUS,Z
07B1  2FC2  	GOTO	label140
07B2        label138

						if ((gBcdHour == gBcdBlueOnHour) && (gBcdMinute == gBcdBlueOnMinute)) {
07B2  0856  	MOVF gbl_gBcdBlueOnHour, W
07B3  0637  	XORWF gbl_gBcdHour, W
07B4  1D03  	BTFSS STATUS,Z
07B5  2FBA  	GOTO	label139
07B6  0855  	MOVF gbl_gBcdBlueOnMinute, W
07B7  0636  	XORWF gbl_gBcdMinute, W
07B8  1903  	BTFSC STATUS,Z

							BLUE_LED = 1;
07B9  1507  	BSF gbl_portc,2
07BA        label139

						}
						if ((gBcdHour == gBcdBlueOffHour) && (gBcdMinute == gBcdBlueOffMinute)) {
07BA  0858  	MOVF gbl_gBcdBlueOffHour, W
07BB  0637  	XORWF gbl_gBcdHour, W
07BC  1D03  	BTFSS STATUS,Z
07BD  2FC2  	GOTO	label140
07BE  0857  	MOVF gbl_gBcdBlueOffMinute, W
07BF  0636  	XORWF gbl_gBcdMinute, W
07C0  1903  	BTFSC STATUS,Z

							BLUE_LED = 0;
07C1  1107  	BCF gbl_portc,2
07C2        label140

						}
					}
					// Trigger fan
					char cTempTruncated = giDS3231ValueBCD >> 8;
07C2  0834  	MOVF gbl_giDS3231ValueBCD+D'1', W
07C3  00EC  	MOVWF main_26_cTempTruncated

					// Don't activate/deactivate if on and off temperature are the same
					if (gBcdFanOnTemp != gBcdFanOffTemp) {
07C4  085A  	MOVF gbl_gBcdFanOffTemp, W
07C5  0659  	XORWF gbl_gBcdFanOnTemp, W
07C6  1903  	BTFSC STATUS,Z
07C7  2FD0  	GOTO	label141

						if (cTempTruncated >= gBcdFanOnTemp) {
07C8  0859  	MOVF gbl_gBcdFanOnTemp, W
07C9  026C  	SUBWF main_26_cTempTruncated, W
07CA  1803  	BTFSC STATUS,C

							FAN = 1;
07CB  1485  	BSF gbl_porta,1

						}
						if (cTempTruncated <= gBcdFanOffTemp) {
07CC  086C  	MOVF main_26_cTempTruncated, W
07CD  025A  	SUBWF gbl_gBcdFanOffTemp, W
07CE  1803  	BTFSC STATUS,C

							FAN = 0;
07CF  1085  	BCF gbl_porta,1
07D0        label141

						}
					}
					// Forced on
					if (gbFanOn)
07D0  194D  	BTFSC gbl_gbFanOn,2

						FAN = 1;
07D1  1485  	BSF gbl_porta,1

					// Trigger heater
					// Don't activate/deactivate if on and off temperature are the same
					if (gBcdHeaterOnTemp != gBcdHeaterOffTemp) {
07D2  085C  	MOVF gbl_gBcdHeaterOffTemp, W
07D3  065B  	XORWF gbl_gBcdHeaterOnTemp, W
07D4  1903  	BTFSC STATUS,Z
07D5  2FDE  	GOTO	label142

						if (cTempTruncated <= gBcdHeaterOnTemp) {
07D6  086C  	MOVF main_26_cTempTruncated, W
07D7  025B  	SUBWF gbl_gBcdHeaterOnTemp, W
07D8  1803  	BTFSC STATUS,C

							HEATER = 1;
07D9  1405  	BSF gbl_porta,0

						}
						if (cTempTruncated >= gBcdHeaterOffTemp) {
07DA  085C  	MOVF gbl_gBcdHeaterOffTemp, W
07DB  026C  	SUBWF main_26_cTempTruncated, W
07DC  1803  	BTFSC STATUS,C

							HEATER = 0;
07DD  1005  	BCF gbl_porta,0
07DE        label142

						}
					}
				}
				// Display time and temperature or date on TM1638 after clock tick
				if (!gcTriggerMode && !gcSetMode) {
07DE  08D0  	MOVF gbl_gcTriggerMode, F
07DF  1D03  	BTFSS STATUS,Z
07E0  2FE5  	GOTO	label143
07E1  08CF  	MOVF gbl_gcSetMode, F
07E2  1D03  	BTFSS STATUS,Z
07E3  2FE5  	GOTO	label143
07E5        label143

					tm1638UpdateDisplay();
07E4  221C  	CALL tm1638Upda_00022

                }
                
                cTask.TASK_TIMER1 = 0;
07E5  114C  	BCF gbl_cTask,2

            }
            if (cTask.TASK_TIMER0) {
07E6  1CCC  	BTFSS gbl_cTask,1
07E7  2F70  	GOTO	label130

				// ~half second count
				if (iTimer0Counts > 9) {
07E8  083E  	MOVF gbl_iTimer0Counts, W
07E9  3C09  	SUBLW 0x09
07EA  1803  	BTFSC STATUS,C
07EB  2FF4  	GOTO	label146

					iFlashDigitOff++;
07EC  0ABF  	INCF gbl_iFlashDigitOff, F

					iTimer0Counts = 0;					
07ED  01BE  	CLRF gbl_iTimer0Counts

					// If in set or trigger mode, update the display every ~half second to flash a digit
					if (gcSetMode || gcTriggerMode)
07EE  08CF  	MOVF gbl_gcSetMode, F
07EF  1D03  	BTFSS STATUS,Z
07F0  2FF3  	GOTO	label145
07F1  08D0  	MOVF gbl_gcTriggerMode, F
07F2  1D03  	BTFSS STATUS,Z

						tm1638UpdateDisplay();
07F3  221C  	CALL tm1638Upda_00022
07F4        label146

				}
				// Poll keys every 50ms
				tm1638ReadKeys();
07F4  25EA  	CALL tm1638Read_00024

				if (tm1638Keys != tm1638KeysOld) {
07F5  0866  	MOVF gbl_tm1638KeysOld, W
07F6  0665  	XORWF gbl_tm1638Keys, W
07F7  1903  	BTFSC STATUS,Z
07F8  2FFD  	GOTO	label147
07FD        label147

					//if (tm1638Keys != 0) {
						processKeys();
07F9  2623  	CALL processKey_00028

						tm1638UpdateDisplay();
07FA  221C  	CALL tm1638Upda_00022

					//}
					tm1638KeysOld = tm1638Keys;
07FB  0865  	MOVF gbl_tm1638Keys, W
07FC  00E6  	MOVWF gbl_tm1638KeysOld

				}
                cTask.TASK_TIMER0 = 0;
07FD  10CC  	BCF gbl_cTask,1

            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
// I2C Communications Library for I2C MASTER
////////////////////////////////////////////////////////////////////////////
// Author(s): Andrew Smallridge
// Date 15 November 2004
//
// Copyright(C) 2004-2006 Andrew Smallridge
// Copyright(C) 2004-2010 Pavel Baranov
// Copyright(C) 2004-2010 David Hobday
// Existing constants predefined for i2c hardware driver and i2s software
// emulation for the PIC 18F2xx and 18F4xx processors. For hardware support
// on other PICs the constants must be mapped to the corresponding register
// map of the target device
////////////////////////////////////////////////////////////////////////////

/*
////////////////////////////////////////////////////////////////////////////
//	The following three sections should be copied to the user's program:
//		i2c master hardware / software mode definition
//		i2c software implementation template arguments and variables
// 		i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////
// i2c master hardware / software mode definition
//
// For i2c hardware support comment out the #define use_ic2_SW line
////////////////////////////////////////////////////////////////////////////
//#define use_i2c_SW

#if defined use_i2c_SW
////////////////////////////////////////////////////////////////////////////
// i2c software implementation template arguments and variables
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)

// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and software emalated i2c RAM locations. These constants are
// then used by the templated functions. When changing the address of an emulated
// register the corresponding constant mapping must also be changed.
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3					

#else
////////////////////////////////////////////////////////////////////////////
// i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP |i2c_HW)

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and PIC's i2c register locations. These constants are
// then used by the templated functions. 
#define PORTC		0x0f82
#define TRISC		0x0f94
#define e_SSPCON1	0xfc6
#define e_SSPCON2	0xfc5
#define e_SSPSTAT	0xfc7
#define e_SSPADD	0xfc8
#define e_SSPBUF	0xfc9
#define e_SSPIF_PIR	0xf9e
#define e_BCLIF_PIR	0xfa1
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3

#endif

*/


////////////////////////////////////////////////////////////////////////////
// Define the common i2c template structure
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL	template <unsigned char T_SCL_BIT, unsigned short T_SCL_PORT,	\
					unsigned short T_SCL_TRIS, unsigned char T_SDA_BIT, 			\
					unsigned short T_SDA_PORT, unsigned short T_SDA_TRIS,			\
					unsigned short T_i2c_SSPCON1, unsigned short T_i2c_SSPCON2, 	\
					unsigned short T_i2c_SSPSTAT, unsigned short T_i2c_SSPBUF, 		\
					unsigned char T_i2c_SSPIF_BIT, unsigned short T_i2c_SSPIF_PIR,	\
					unsigned char T_i2c_BCLIF_BIT, unsigned short T_i2c_BCLIF_PIR,	\
					unsigned char T_i2c_SMP_BIT, unsigned short T_i2c_SSPADD, 		\
					unsigned char T_MODE>

////////////////////////////////////////////////////////////////////////////
// Define the common i2c template parameters
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL_ARGS	T_SCL_BIT, T_SCL_PORT, T_SCL_TRIS, T_SDA_BIT, 			\
						T_SDA_PORT, T_SDA_TRIS, T_i2c_SSPCON1, T_i2c_SSPCON2, 	\
						T_i2c_SSPSTAT, T_i2c_SSPBUF, T_i2c_SSPIF_BIT, 			\
						T_i2c_SSPIF_PIR, T_i2c_BCLIF_BIT, T_i2c_BCLIF_PIR,		\
						T_i2c_SMP_BIT, T_i2c_SSPADD, T_MODE

////////////////////////////////////////////////////////////////////////////
// Helpers that hide template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_init	i2c_INIT<i2c_ARGS>
#define i2c_start	i2c_START<i2c_ARGS>
#define i2c_restart	i2c_RESTART<i2c_ARGS>
#define i2c_stop	i2c_STOP<i2c_ARGS>
#define i2c_read	i2c_READ<i2c_ARGS>
#define i2c_write	i2c_WRITE<i2c_ARGS>


////////////////////////////////////////////////////////////////////////////
// I2C Control Status Bits - Emulates the PIC18F hardware I2C implementation
////////////////////////////////////////////////////////////////////////////
// define I2C i2C_SSPCON1 control bits
#define	i2c_WCOL	7
#define	i2c_SSPOV	6
#define	i2c_SSPEN	5
#define	i2c_CKP		4
#define	i2c_SSPM3	3
#define	i2c_SSPM2	2
#define	i2c_SSPM1	1
#define	i2c_SSPM0	0

// define I2C SSPCON2 control bits
#define	i2c_GCEN 	7
#define	i2c_ACKSTAT	6
#define	i2c_ACKDT	5
#define	i2c_ACKEN	4
#define	i2c_RCEN	3
#define	i2c_PEN		2
#define	i2c_RSEN	1
#define	i2c_SEN		0

// define I2C SSPSTAT status bits
#define	i2c_DA		5
#define	i2c_P		4
#define	i2c_S		3
#define	i2c_RW		2
#define	i2c_UA		1
#define	i2c_BF		0


////////////////////////////////////////////////////////////////////////////
// I2C Control Flag Bits
////////////////////////////////////////////////////////////////////////////
// define I2C Mode bits
#define	i2c_HW			0x01
#define	i2c_400KHz		0x02	// 100KHz or 400KHz I2C clock (set = 400KHz)
#define	i2c_reset_wdt	0x04
#define i2c_SMP			0x80	


////////////////////////////////////////////////////////////////////////////
// I2C software constants
////////////////////////////////////////////////////////////////////////////
#define	dly 10	// number of 1us delay increments



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Start Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL 
void i2c_START(void)

{
	// Initiate the I2C START condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	delay_us(dly);
0126  300A  	MOVLW 0x0A
0127  1283  	BCF STATUS, RP0
0128  1303  	BCF STATUS, RP1
0129  00F2  	MOVWF delay_us_00000_arg_del
012A  2010  	CALL delay_us_00000

	l_bclif = 0; // initialise the collision flag for this command
012B  11C6  	BCF i2c_START_00000_1_l_bclif,3

	l_sspif = 0;
012C  11C5  	BCF i2c_START_00000_1_l_sspif,3

		
	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
			
		l_sen = 1; // initiate START condition	

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation			
		l_sen = 1; // initiate START condition
012D  1441  	BSF i2c_START_00000_1_l_sen,0

		l_scl_tris = 1; // ensure the SCL line is high
012E  1683  	BSF STATUS, RP0
012F  1587  	BSF i2c_START_00000_1_l_scl_tris,3

		l_sda_tris = 1; // ensure the SDA line is high	
0130  1607  	BSF i2c_START_00000_1_l_sda_tris,4

		l_scl = 0; // prepare to set SCL line low
0131  1283  	BCF STATUS, RP0
0132  1187  	BCF i2c_START_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low
0133  1207  	BCF i2c_START_00000_1_l_sda,4

		
		if (l_scl && l_sda)
0134  1D87  	BTFSS i2c_START_00000_1_l_scl,3
0135  2953  	GOTO	label24
0136  1E07  	BTFSS i2c_START_00000_1_l_sda,4
0137  2953  	GOTO	label24
0153        label24

		{
			// good sign - no collision detected
			delay_us(dly);
0138  300A  	MOVLW 0x0A
0139  00F2  	MOVWF delay_us_00000_arg_del
013A  2010  	CALL delay_us_00000

			
			if (!l_scl) // ensure the clock is still high
013B  1987  	BTFSC i2c_START_00000_1_l_scl,3
013C  2941  	GOTO	label23
0141        label23

			{
				l_bclif = 1;
013D  15C6  	BSF i2c_START_00000_1_l_bclif,3

				l_s = 1;
013E  15C2  	BSF i2c_START_00000_1_l_s,3

				l_sen = 0;
013F  1041  	BCF i2c_START_00000_1_l_sen,0

				return;
			}
					
			l_sda = 0; // prepare to set SDA line low
0141  1207  	BCF i2c_START_00000_1_l_sda,4

			l_sda_tris = 0; // SDA to output (driven low)
0142  1683  	BSF STATUS, RP0
0143  1207  	BCF i2c_START_00000_1_l_sda_tris,4


			delay_us(dly);					
0144  300A  	MOVLW 0x0A
0145  1283  	BCF STATUS, RP0
0146  00F2  	MOVWF delay_us_00000_arg_del
0147  2010  	CALL delay_us_00000

			l_scl = 0; // prepare to set SCL line low
0148  1187  	BCF i2c_START_00000_1_l_scl,3

			l_scl_tris = 0; // SCL to output (driven low)
0149  1683  	BSF STATUS, RP0
014A  1187  	BCF i2c_START_00000_1_l_scl_tris,3


			delay_us(dly);					
014B  300A  	MOVLW 0x0A
014C  1283  	BCF STATUS, RP0
014D  00F2  	MOVWF delay_us_00000_arg_del
014E  2010  	CALL delay_us_00000

			l_s = 1; // set 'S' bit flag (start bit detected)
014F  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0; // clear flag
0150  1041  	BCF i2c_START_00000_1_l_sen,0

			l_sspif = 1; // flag end of start condition interrupt	
0151  15C5  	BSF i2c_START_00000_1_l_sspif,3

		}
		else
		{
			// here is SDA or SCL are low at the start - indicates a bus collision
			l_bclif = 1;
0153  15C6  	BSF i2c_START_00000_1_l_bclif,3

			l_s = 1; // set 'S' bit flag (start bit detected)
0154  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0;
0155  1041  	BCF i2c_START_00000_1_l_sen,0

			l_rsen = 0;
0156  10C1  	BCF i2c_START_00000_1_l_rsen,1

			l_pen = 0;
0157  1141  	BCF i2c_START_00000_1_l_pen,2

			l_rcen = 0;								
0158  11C1  	BCF i2c_START_00000_1_l_rcen,3

			l_acken = 0;			
0159  1241  	BCF i2c_START_00000_1_l_acken,4

		}
	}
}
0140  0008  	RETURN
0152  0008  	RETURN
015A  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Restart Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_RESTART(void)
{
	// Initiate the I2C RESTART condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
			
	delay_us(dly);
	l_bclif = 0; // initialise the collision flag for this command
	l_sspif = 0;

	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_rsen = 1; // initiate RESTART condition
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation	
		l_rsen = 1;
		l_scl = 0;
		l_sda = 0;
		
		if (!l_scl)
		{
			// good sign - no other I2C activity in progress
			l_sda_tris = 1; // float SDA line high	(should already be in this condition)	
			delay_us(dly);
		
			// about to float the clock line
			// ensure the data line is still high
			if (!l_sda)
			{
				// problem - SDA is low, a bus collision has occurred				
				l_bclif = 1; // set the bus collision flag	
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_scl_tris = 1; // float SCL line (high)	
				return;
			}
												
			l_scl_tris = 1; // float SCL line (high)

			// wait until any clock stretching has finished
			while (!l_scl)
				if (T_MODE & i2c_reset_wdt)
					clear_wdt();	
			delay_us(dly);
			
			// here we are about to drive SDA low
			// first ensure SCL is still high
			if (!l_scl)
			{
				// problem - SCL is low, a bus collision has occurred
				l_bclif = 1; // set the bus collision flag
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_sda_tris = 1; // float SDA line (high)
				return;
			}
				
			l_sda_tris = 0; // drive SDA low
			l_s = 1; // set 'S' bit flag (start bit detected)

			delay_us(dly);
			l_scl_tris = 0; // drive SCL low
			l_rsen = 0;
			l_pen = 0;
			l_sen = 0;			
			l_rcen = 0;								
			l_acken = 0;			
			l_sspif = 1; // flag end of start condition interrupt
		}
		else
		{
			// SCL is high at the start
			// some other I2C activity in progress		
			l_rsen = 0; // clear flag
			// exit without further action
		}
	}
}



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Stop Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_STOP(void)

{ 
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_p@T_i2c_SSPSTAT.i2c_P; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;

	l_bclif = 0; // initialise the collision flag for this command
00F6  1283  	BCF STATUS, RP0
00F7  1303  	BCF STATUS, RP1
00F8  11C6  	BCF i2c_STOP_00000_1_l_bclif,3

	l_sspif = 0;
00F9  11C5  	BCF i2c_STOP_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_pen = 1; // initiate STOP condition on the I2C bus	
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
		
	}
	else
	{
		//	Software I2C implementation
		l_pen = 1; // initiate STOP condition on the I2C bus
00FA  1541  	BSF i2c_STOP_00000_1_l_pen,2

		delay_us(dly);
00FB  300A  	MOVLW 0x0A
00FC  00F2  	MOVWF delay_us_00000_arg_del
00FD  2010  	CALL delay_us_00000

		
		l_scl = 0; // prepare to set SCL line low
00FE  1187  	BCF i2c_STOP_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low
00FF  1207  	BCF i2c_STOP_00000_1_l_sda,4

		l_scl_tris = 0; // drive SCL line low (should already be low)
0100  1683  	BSF STATUS, RP0
0101  1187  	BCF i2c_STOP_00000_1_l_scl_tris,3

		l_sda_tris = 0; // drive SDA line low
0102  1207  	BCF i2c_STOP_00000_1_l_sda_tris,4


		delay_us(dly);		
0103  300A  	MOVLW 0x0A
0104  1283  	BCF STATUS, RP0
0105  00F2  	MOVWF delay_us_00000_arg_del
0106  2010  	CALL delay_us_00000

		l_scl_tris = 1; // float SCL line (high)
0107  1683  	BSF STATUS, RP0
0108  1587  	BSF i2c_STOP_00000_1_l_scl_tris,3

		
		// wait until any clock stretching has finished
		while (!l_scl)
0109        label19
0109  1283  	BCF STATUS, RP0
010A  1987  	BTFSC i2c_STOP_00000_1_l_scl,3
010B  290E  	GOTO	label20
010D  2909  	GOTO	label19
010E        label20

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
010C  0064  	CLRWDT

						
		delay_us(dly);
010E  300A  	MOVLW 0x0A
010F  00F2  	MOVWF delay_us_00000_arg_del
0110  2010  	CALL delay_us_00000

		l_sda_tris = 1; // float SDA line
0111  1683  	BSF STATUS, RP0
0112  1607  	BSF i2c_STOP_00000_1_l_sda_tris,4

		delay_us(dly);		
0113  300A  	MOVLW 0x0A
0114  1283  	BCF STATUS, RP0
0115  00F2  	MOVWF delay_us_00000_arg_del
0116  2010  	CALL delay_us_00000

		
		// here the SDA line should be high - if not a collision has occurred				
		if (!l_sda || !l_scl)
0117  1E07  	BTFSS i2c_STOP_00000_1_l_sda,4
0118  291B  	GOTO	label21
0119  1987  	BTFSC i2c_STOP_00000_1_l_scl,3
011A  291F  	GOTO	label22
011B        label21
011F        label22

		{
			// problem - SDA or SCL is low, a bus collision has occurred
			l_bclif = 1; // set the bus collision flag	
011B  15C6  	BSF i2c_STOP_00000_1_l_bclif,3

			l_s = 0; // clear 'S' bit flag
011C  11C2  	BCF i2c_STOP_00000_1_l_s,3

			l_pen = 0; // clear flag
011D  1141  	BCF i2c_STOP_00000_1_l_pen,2

		}
		else
		{		
			l_p = 1;
011F  1642  	BSF i2c_STOP_00000_1_l_p,4

			l_pen = 0;
0120  1141  	BCF i2c_STOP_00000_1_l_pen,2

			l_sen = 0;
0121  1041  	BCF i2c_STOP_00000_1_l_sen,0

			l_rsen = 0;			
0122  10C1  	BCF i2c_STOP_00000_1_l_rsen,1

			l_rcen = 0;								
0123  11C1  	BCF i2c_STOP_00000_1_l_rcen,3

			l_acken = 0;
0124  1241  	BCF i2c_STOP_00000_1_l_acken,4

		}
	}
}
011E  0008  	RETURN
0125  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Write Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_WRITE(unsigned char i2c_data)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;	
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
	
	char BitMask;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
00A5  11C6  	BCF i2c_WRITE_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
00A6  11C5  	BCF i2c_WRITE_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
				
		l_wcol = 0; // clear write collision flag	
		i2c_SSPBUF = i2c_data;

		// test if a write collision occurred
		if (l_wcol)
			return (1); // error exit	

		// wait until MSSP Tx register is empty
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
								
		return (0); // successful exit
	}

	// here for i2c software driver
	l_wcol = 0; // clear write collision flag	
00A7  13C0  	BCF i2c_WRITE_00000_1_l_wcol,7

	i2c_SSPBUF = i2c_data;
00A8  086F  	MOVF i2c_WRITE_00000_arg_i2c_data, W
00A9  00C4  	MOVWF i2c_WRITE_00000_1_i2c_SSPBUF

	
	l_scl = 0; // prepare to set SCL line low
00AA  1187  	BCF i2c_WRITE_00000_1_l_scl,3

	l_sda = 0; // prepare to set SDA line low
00AB  1207  	BCF i2c_WRITE_00000_1_l_sda,4

	l_rw = 0; // signal we are doing a write
00AC  1142  	BCF i2c_WRITE_00000_1_l_rw,2


	for (BitMask = 0x80; BitMask; BitMask>>=1)
00AD  3080  	MOVLW 0x80
00AE  00F0  	MOVWF i2c_WRITE_00000_1_BitMask
00AF        label11
00AF  08F0  	MOVF i2c_WRITE_00000_1_BitMask, F
00B0  1903  	BTFSC STATUS,Z
00B1  28D2  	GOTO	label16
00CF  1003  	BCF STATUS,C
00D0  0CF0  	RRF i2c_WRITE_00000_1_BitMask, F
00D1  28AF  	GOTO	label11
00D2        label16

	{
		if (i2c_data & BitMask)
00B2  0870  	MOVF i2c_WRITE_00000_1_BitMask, W
00B3  056F  	ANDWF i2c_WRITE_00000_arg_i2c_data, W
00B4  1903  	BTFSC STATUS,Z
00B5  28B9  	GOTO	label12
00B9        label12

			l_sda_tris = 1; // float SDA high	
00B6  1683  	BSF STATUS, RP0
00B7  1607  	BSF i2c_WRITE_00000_1_l_sda_tris,4

		else
00B8  28BB  	GOTO	label13
00BB        label13

			l_sda_tris = 0; // drive SDA low
00B9  1683  	BSF STATUS, RP0
00BA  1207  	BCF i2c_WRITE_00000_1_l_sda_tris,4

		delay_us(dly);
00BB  300A  	MOVLW 0x0A
00BC  1283  	BCF STATUS, RP0
00BD  00F2  	MOVWF delay_us_00000_arg_del
00BE  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
00BF  1683  	BSF STATUS, RP0
00C0  1587  	BSF i2c_WRITE_00000_1_l_scl_tris,3


		// wait until any clock stretching has finished
		while (!l_scl)
00C1        label14
00C1  1283  	BCF STATUS, RP0
00C2  1987  	BTFSC i2c_WRITE_00000_1_l_scl,3
00C3  28C6  	GOTO	label15
00C5  28C1  	GOTO	label14
00C6        label15

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
00C4  0064  	CLRWDT

		delay_us(dly);
00C6  300A  	MOVLW 0x0A
00C7  00F2  	MOVWF delay_us_00000_arg_del
00C8  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low	
00C9  1683  	BSF STATUS, RP0
00CA  1187  	BCF i2c_WRITE_00000_1_l_scl_tris,3

		delay_us(dly);
00CB  300A  	MOVLW 0x0A
00CC  1283  	BCF STATUS, RP0
00CD  00F2  	MOVWF delay_us_00000_arg_del
00CE  2010  	CALL delay_us_00000

	}
	// serialized out the data
	// now get the status		
	// set SSPIF
	l_sspif = 1;
00D2  15C5  	BSF i2c_WRITE_00000_1_l_sspif,3

	l_acken = 1;
00D3  1641  	BSF i2c_WRITE_00000_1_l_acken,4

	l_ackdt = 0;
00D4  12C1  	BCF i2c_WRITE_00000_1_l_ackdt,5

	l_sda_tris = 1; // float SDA high
00D5  1683  	BSF STATUS, RP0
00D6  1607  	BSF i2c_WRITE_00000_1_l_sda_tris,4

	
	delay_us(dly);
00D7  300A  	MOVLW 0x0A
00D8  1283  	BCF STATUS, RP0
00D9  00F2  	MOVWF delay_us_00000_arg_del
00DA  2010  	CALL delay_us_00000

	
	l_scl_tris = 1; // float SCL high
00DB  1683  	BSF STATUS, RP0
00DC  1587  	BSF i2c_WRITE_00000_1_l_scl_tris,3

	
	// wait until any clock stretching has finished
	while (!l_scl)
00DD        label17
00DD  1283  	BCF STATUS, RP0
00DE  1987  	BTFSC i2c_WRITE_00000_1_l_scl,3
00DF  28E2  	GOTO	label18
00E1  28DD  	GOTO	label17
00E2        label18

		if (T_MODE & i2c_reset_wdt)
			clear_wdt();	
00E0  0064  	CLRWDT

	delay_us(dly);
00E2  300A  	MOVLW 0x0A
00E3  00F2  	MOVWF delay_us_00000_arg_del
00E4  2010  	CALL delay_us_00000


	// get the status bit
	local_ack = l_sda;
00E5  1071  	BCF i2c_WRITE_00000_1_local_ack,0
00E6  1A07  	BTFSC i2c_WRITE_00000_1_l_sda,4
00E7  1471  	BSF i2c_WRITE_00000_1_local_ack,0

	delay_us(dly);
00E8  300A  	MOVLW 0x0A
00E9  00F2  	MOVWF delay_us_00000_arg_del
00EA  2010  	CALL delay_us_00000


	l_scl_tris = 0; // drive SCL low	
00EB  1683  	BSF STATUS, RP0
00EC  1187  	BCF i2c_WRITE_00000_1_l_scl_tris,3

	l_acken = 0;
00ED  1283  	BCF STATUS, RP0
00EE  1241  	BCF i2c_WRITE_00000_1_l_acken,4

	delay_us(dly);
00EF  300A  	MOVLW 0x0A
00F0  00F2  	MOVWF delay_us_00000_arg_del
00F1  2010  	CALL delay_us_00000

	return(local_ack);
00F2  01F2  	CLRF CompTempVarRet552
00F3  1871  	BTFSC i2c_WRITE_00000_1_local_ack,0
00F4  0AF2  	INCF CompTempVarRet552, F

}
00F5  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Read Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_READ(char ack_status)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	char BitMask;
	char i2c_data;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
018A  11C6  	BCF i2c_READ_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
018B  11C5  	BCF i2c_READ_00000_1_l_sspif,3

	l_wcol = 0; // clear write collision flag	
018C  13C0  	BCF i2c_READ_00000_1_l_wcol,7


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// enable master for 1 byte reception	
		l_rcen = 1;

		// wait until byte received
		while(!l_sspif || !l_bf)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// read the byte from the Rx register
		i2c_data = i2c_SSPBUF;			
			
		// wait until the bus is idle		
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		if (ack_status)
			l_ackdt = 1; // preset ack bit
		else
			l_ackdt = 0; // preset ack bit

		l_sspif = 0;
		l_acken = 1; // acknowledge sequence enable

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();								
	}
	else
	{
		// here for i2c software driver
		l_rcen = 1;
018D  15C1  	BSF i2c_READ_00000_1_l_rcen,3

		l_ackdt = ack_status;
018E  186F  	BTFSC i2c_READ_00000_arg_ack_status,0
018F  16C1  	BSF i2c_READ_00000_1_l_ackdt,5
0190  1C6F  	BTFSS i2c_READ_00000_arg_ack_status,0
0191  12C1  	BCF i2c_READ_00000_1_l_ackdt,5

		l_rw = 1;
0192  1542  	BSF i2c_READ_00000_1_l_rw,2

		l_scl = 0; // prepare to set SCL line low
0193  1187  	BCF i2c_READ_00000_1_l_scl,3

		l_sda = 0; // prepare to set SDA line low	
0194  1207  	BCF i2c_READ_00000_1_l_sda,4


		// prepare to serialize in the byte
		l_sda_tris = 1; // float SDA
0195  1683  	BSF STATUS, RP0
0196  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

		delay_us(dly);
0197  300A  	MOVLW 0x0A
0198  1283  	BCF STATUS, RP0
0199  00F2  	MOVWF delay_us_00000_arg_del
019A  2010  	CALL delay_us_00000

		i2c_data = 0;
019B  01F1  	CLRF i2c_READ_00000_1_i2c_data

		for (BitMask = 0x80; BitMask; BitMask>>=1)
019C  3080  	MOVLW 0x80
019D  00F0  	MOVWF i2c_READ_00000_1_BitMask
019E        label28
019E  08F0  	MOVF i2c_READ_00000_1_BitMask, F
019F  1903  	BTFSC STATUS,Z
01A0  29BB  	GOTO	label32
01B8  1003  	BCF STATUS,C
01B9  0CF0  	RRF i2c_READ_00000_1_BitMask, F
01BA  299E  	GOTO	label28
01BB        label32

		{
			l_scl_tris = 1; // float SCL high
01A1  1683  	BSF STATUS, RP0
01A2  1587  	BSF i2c_READ_00000_1_l_scl_tris,3

			// wait until any clock stretching has finished
			while (!l_scl)
01A3        label29
01A3  1283  	BCF STATUS, RP0
01A4  1987  	BTFSC i2c_READ_00000_1_l_scl,3
01A5  29A8  	GOTO	label30
01A7  29A3  	GOTO	label29
01A8        label30

				if (T_MODE & i2c_reset_wdt)
					clear_wdt();		
01A6  0064  	CLRWDT

			delay_us(dly);
01A8  300A  	MOVLW 0x0A
01A9  00F2  	MOVWF delay_us_00000_arg_del
01AA  2010  	CALL delay_us_00000


			// read the current bit
			l_sda_tris = 1; // float SDA
01AB  1683  	BSF STATUS, RP0
01AC  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

			if (l_sda)
01AD  1283  	BCF STATUS, RP0
01AE  1E07  	BTFSS i2c_READ_00000_1_l_sda,4
01AF  29B2  	GOTO	label31
01B2        label31

				i2c_data |= BitMask;
01B0  0870  	MOVF i2c_READ_00000_1_BitMask, W
01B1  04F1  	IORWF i2c_READ_00000_1_i2c_data, F

			l_scl_tris = 0; // drive SCL low
01B2  1683  	BSF STATUS, RP0
01B3  1187  	BCF i2c_READ_00000_1_l_scl_tris,3

			delay_us(dly);
01B4  300A  	MOVLW 0x0A
01B5  1283  	BCF STATUS, RP0
01B6  00F2  	MOVWF delay_us_00000_arg_del
01B7  2010  	CALL delay_us_00000

		}
		// flag receive complete			
		l_sspif = 1;
01BB  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		l_rcen = 0;
01BC  11C1  	BCF i2c_READ_00000_1_l_rcen,3

		
		// set the ACK state
		if (ack_status)	
01BD  08EF  	MOVF i2c_READ_00000_arg_ack_status, F
01BE  1903  	BTFSC STATUS,Z
01BF  29C3  	GOTO	label33
01C3        label33

			l_sda_tris = 1; // float SDA high
01C0  1683  	BSF STATUS, RP0
01C1  1607  	BSF i2c_READ_00000_1_l_sda_tris,4

		else
01C2  29C5  	GOTO	label34
01C5        label34

			l_sda_tris = 0; // drive SDA low
01C3  1683  	BSF STATUS, RP0
01C4  1207  	BCF i2c_READ_00000_1_l_sda_tris,4

		delay_us(dly);
01C5  300A  	MOVLW 0x0A
01C6  1283  	BCF STATUS, RP0
01C7  00F2  	MOVWF delay_us_00000_arg_del
01C8  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
01C9  1683  	BSF STATUS, RP0
01CA  1587  	BSF i2c_READ_00000_1_l_scl_tris,3


		// wait until any clock stretching has finished
		while (!l_scl)
01CB        label35
01CB  1283  	BCF STATUS, RP0
01CC  1987  	BTFSC i2c_READ_00000_1_l_scl,3
01CD  29D0  	GOTO	label36
01CF  29CB  	GOTO	label35
01D0        label36

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
01CE  0064  	CLRWDT

	
		l_sspif = 0; // clear SSPIF
01D0  11C5  	BCF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
01D1  300A  	MOVLW 0x0A
01D2  00F2  	MOVWF delay_us_00000_arg_del
01D3  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low		
01D4  1683  	BSF STATUS, RP0
01D5  1187  	BCF i2c_READ_00000_1_l_scl_tris,3

		l_sspif = 1;
01D6  1283  	BCF STATUS, RP0
01D7  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
01D8  300A  	MOVLW 0x0A
01D9  00F2  	MOVWF delay_us_00000_arg_del
01DA  2010  	CALL delay_us_00000

	}
	return(i2c_data);
01DB  0871  	MOVF i2c_READ_00000_1_i2c_data, W
01DC  00F2  	MOVWF CompTempVarRet553

}
01DD  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Initialization
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_INIT(unsigned char i2c_divisor)

{
	volatile unsigned char i2c_SSPADD@T_i2c_SSPADD, i2c_SSPSTAT@T_i2c_SSPSTAT;
	volatile unsigned char i2c_SSPCON1@T_i2c_SSPCON1,i2c_SSPCON2@T_i2c_SSPCON2;

	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_sspen@T_i2c_SSPCON1.i2c_SSPEN, l_smp@T_i2c_SSPSTAT.T_i2c_SMP_BIT;

	l_sda_tris = 1;
03D2  1683  	BSF STATUS, RP0
03D3  1607  	BSF i2c_INIT_00000_1_l_sda_tris,4

	l_scl_tris = 1;
03D4  1587  	BSF i2c_INIT_00000_1_l_scl_tris,3

	
	i2c_SSPCON1 = 0x00; // initialise the I2C control register (mirrors HW SSPCON1)	
03D5  1283  	BCF STATUS, RP0
03D6  01C0  	CLRF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPADD = i2c_divisor; // get the I2C baud rate divisor
03D7  086D  	MOVF i2c_INIT_00000_arg_i2c_divisor, W
03D8  00C3  	MOVWF i2c_INIT_00000_1_i2c_SSPADD

	i2c_SSPCON1 = 0x08; // initialise the I2C control register (mirrors HW SSPCON1)	
03D9  3008  	MOVLW 0x08
03DA  00C0  	MOVWF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPCON2 = 0x00; // initialise the I2C control register (mirrors HW SSPCON2)	
03DB  01C1  	CLRF i2c_INIT_00000_1_i2c_SSPCON2

	
	i2c_SSPSTAT = 0x00; // initialise the I2C status register (mirrors HW SSPSTAT)
03DC  01C2  	CLRF i2c_INIT_00000_1_i2c_SSPSTAT

	
	if (T_MODE & i2c_SMP)
		l_smp = 1;
03DD  17C2  	BSF i2c_INIT_00000_1_l_smp,7


	l_sspif = 0; // initialise the I2C SSP interrupt status
03DE  11C5  	BCF i2c_INIT_00000_1_l_sspif,3

	l_bclif = 0; // initialise the I2C BCL interrupt status
03DF  11C6  	BCF i2c_INIT_00000_1_l_bclif,3

	l_sda = 0;
03E0  1207  	BCF i2c_INIT_00000_1_l_sda,4

	l_scl = 0;
03E1  1187  	BCF i2c_INIT_00000_1_l_scl,3

	l_sspen = 1; // enable I2C
03E2  16C0  	BSF i2c_INIT_00000_1_l_sspen,5

	
	i2c_STOP<_I2C_TEMPL_ARGS>();
03E3  20F6  	CALL i2c_STOP_00000

}
03E4  0008  	RETURN







////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  2FFF  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B0  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00B1  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00B2  	MOVWF Int1BContext+D'2'
000D  158A  	BSF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2861  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010  3003  	MOVLW 0x03
0011  07F2  	ADDWF delay_us_00000_arg_del, F
0012  0CF2  	RRF delay_us_00000_arg_del, F
0013  0CF2  	RRF delay_us_00000_arg_del, F
0014  307F  	MOVLW 0x7F
0015  05F2  	ANDWF delay_us_00000_arg_del, F
0016        label1
0016  0000  	NOP
0017  0BF2  	DECFSZ delay_us_00000_arg_del, F
0018  2816  	GOTO	label1
0019  0008  	RETURN
001A        ; } delay_us function end

001A        __rom_get_00000
001A        ; { __rom_get ; function begin
001A  0874  	MOVF __rom_get_00000_arg_objNumb, W
001B  00F7  	MOVWF __rom_get_00000_1_romAddr+D'1'
001C  01F6  	CLRF __rom_get_00000_1_romAddr
001D  1003  	BCF STATUS,C
001E  0DF7  	RLF __rom_get_00000_1_romAddr+D'1', F
001F  0DF6  	RLF __rom_get_00000_1_romAddr, F
0020  0DF7  	RLF __rom_get_00000_1_romAddr+D'1', F
0021  0DF6  	RLF __rom_get_00000_1_romAddr, F
0022  07F7  	ADDWF __rom_get_00000_1_romAddr+D'1', F
0023  1803  	BTFSC STATUS,C
0024  0AF6  	INCF __rom_get_00000_1_romAddr, F
0025  07F7  	ADDWF __rom_get_00000_1_romAddr+D'1', F
0026  1803  	BTFSC STATUS,C
0027  0AF6  	INCF __rom_get_00000_1_romAddr, F
0028  3033  	MOVLW	LOW( label2 )
0029  07F7  	ADDWF __rom_get_00000_1_romAddr+D'1', F
002A  1803  	BTFSC STATUS,C
002B  0AF6  	INCF __rom_get_00000_1_romAddr, F
002C  3000  	MOVLW	HIGH( label2 )
002D  0776  	ADDWF __rom_get_00000_1_romAddr, W
002E  008A  	MOVWF PCLATH
002F  0875  	MOVF __rom_get_00000_arg_idx, W
0030  00F6  	MOVWF __rom_get_00000_1_romAddr
0031  0877  	MOVF __rom_get_00000_1_romAddr+D'1', W
0032  0082  	MOVWF PCL
0033        label2
0033  3000  	MOVLW	HIGH( label3 )
0034  008A  	MOVWF PCLATH
0035  3000  	MOVLW	HIGH( label4 )
0036  00F7  	MOVWF __rom_get_00000_1_romAddr+D'1'
0037  3049  	MOVLW	LOW( label4 )
0038  2842  	GOTO	label3
0039  3000  	MOVLW	HIGH( label3 )
003A  008A  	MOVWF PCLATH
003B  3000  	MOVLW	HIGH( label5 )
003C  00F7  	MOVWF __rom_get_00000_1_romAddr+D'1'
003D  3055  	MOVLW	LOW( label5 )
003E  2842  	GOTO	label3
003F  3000  	MOVLW	HIGH( label6 )
0040  00F7  	MOVWF __rom_get_00000_1_romAddr+D'1'
0041  306D  	MOVLW	LOW( label6 )
0042        label3
0042  07F6  	ADDWF __rom_get_00000_1_romAddr, F
0043  1803  	BTFSC STATUS,C
0044  0AF7  	INCF __rom_get_00000_1_romAddr+D'1', F
0045  0877  	MOVF __rom_get_00000_1_romAddr+D'1', W
0046  008A  	MOVWF PCLATH
0047  0876  	MOVF __rom_get_00000_1_romAddr, W
0048  0082  	MOVWF PCL
0049        label4
0049  3431  	RETLW 0x31
004A  3428  	RETLW 0x28
004B  3431  	RETLW 0x31
004C  3430  	RETLW 0x30
004D  3431  	RETLW 0x31
004E  3430  	RETLW 0x30
004F  3431  	RETLW 0x31
0050  3431  	RETLW 0x31
0051  3430  	RETLW 0x30
0052  3431  	RETLW 0x31
0053  3430  	RETLW 0x30
0054  3431  	RETLW 0x31
0055        label5
0055  3404  	RETLW 0x04
0056  3408  	RETLW 0x08
0057  3412  	RETLW 0x12
0058  3416  	RETLW 0x16
0059  3420  	RETLW 0x20
005A  3424  	RETLW 0x24
005B  3428  	RETLW 0x28
005C  3432  	RETLW 0x32
005D  3436  	RETLW 0x36
005E  3440  	RETLW 0x40
005F  3444  	RETLW 0x44
0060  3448  	RETLW 0x48
0061  3452  	RETLW 0x52
0062  3456  	RETLW 0x56
0063  3460  	RETLW 0x60
0064  3464  	RETLW 0x64
0065  3468  	RETLW 0x68
0066  3472  	RETLW 0x72
0067  3476  	RETLW 0x76
0068  3480  	RETLW 0x80
0069  3484  	RETLW 0x84
006A  3488  	RETLW 0x88
006B  3492  	RETLW 0x92
006C  3496  	RETLW 0x96
006D        label6
006D  343F  	RETLW 0x3F
006E  3406  	RETLW 0x06
006F  345B  	RETLW 0x5B
0070  344F  	RETLW 0x4F
0071  3466  	RETLW 0x66
0072  346D  	RETLW 0x6D
0073  347D  	RETLW 0x7D
0074  3407  	RETLW 0x07
0075  347F  	RETLW 0x7F
0076  346F  	RETLW 0x6F
0077        ; } __rom_get function end

0077        delay_10us_00000
0077        ; { delay_10us ; function begin
0077        label7
0077  0000  	NOP
0078  0000  	NOP
0079  0000  	NOP
007A  0000  	NOP
007B  0000  	NOP
007C  0000  	NOP
007D  0000  	NOP
007E  0BF1  	DECFSZ delay_10us_00000_arg_del, F
007F  2877  	GOTO	label7
0080  0008  	RETURN
0081        ; } delay_10us function end

0081        delay_ms_00000
0081        ; { delay_ms ; function begin
0081  08EC  	MOVF delay_ms_00000_arg_del, F
0082  1D03  	BTFSS STATUS,Z
0083  2885  	GOTO	label8
0084  0008  	RETURN
0085        label8
0085  30F9  	MOVLW 0xF9
0086        label9
0086  3EFF  	ADDLW 0xFF
0087  1D03  	BTFSS STATUS,Z
0088  2886  	GOTO	label9
0089  0000  	NOP
008A  0BEC  	DECFSZ delay_ms_00000_arg_del, F
008B  2885  	GOTO	label8
008C  0008  	RETURN
008D        ; } delay_ms function end





















05C1        __mul_16s__0000F
05C1        ; { __mul_16s_16s__16 ; function begin
05C1  01F6  	CLRF __mul_16s__0000F_1_i
05C2  01F9  	CLRF CompTempVarRet389
05C3  01FA  	CLRF CompTempVarRet389+D'1'
05C4  0872  	MOVF __mul_16s__0000F_arg_a, W
05C5  00F7  	MOVWF __mul_16s__0000F_1_t
05C6  0873  	MOVF __mul_16s__0000F_arg_a+D'1', W
05C7  00F8  	MOVWF __mul_16s__0000F_1_t+D'1'
05C8  1FF5  	BTFSS __mul_16s__0000F_arg_b+D'1',7
05C9  2DD0  	GOTO	label105
05CA  17F6  	BSF __mul_16s__0000F_1_i,7
05CB  09F4  	COMF __mul_16s__0000F_arg_b, F
05CC  09F5  	COMF __mul_16s__0000F_arg_b+D'1', F
05CD  0AF4  	INCF __mul_16s__0000F_arg_b, F
05CE  1903  	BTFSC gbl_status,2
05CF  0AF5  	INCF __mul_16s__0000F_arg_b+D'1', F
05D0        label105
05D0  1A76  	BTFSC __mul_16s__0000F_1_i,4
05D1  2DE2  	GOTO	label107
05D2  1C74  	BTFSS __mul_16s__0000F_arg_b,0
05D3  2DDA  	GOTO	label106
05D4  0877  	MOVF __mul_16s__0000F_1_t, W
05D5  07F9  	ADDWF CompTempVarRet389, F
05D6  0878  	MOVF __mul_16s__0000F_1_t+D'1', W
05D7  1803  	BTFSC gbl_status,0
05D8  0F78  	INCFSZ __mul_16s__0000F_1_t+D'1', W
05D9  07FA  	ADDWF CompTempVarRet389+D'1', F
05DA        label106
05DA  1003  	BCF gbl_status,0
05DB  0CF5  	RRF __mul_16s__0000F_arg_b+D'1', F
05DC  0CF4  	RRF __mul_16s__0000F_arg_b, F
05DD  1003  	BCF gbl_status,0
05DE  0DF7  	RLF __mul_16s__0000F_1_t, F
05DF  0DF8  	RLF __mul_16s__0000F_1_t+D'1', F
05E0  0AF6  	INCF __mul_16s__0000F_1_i, F
05E1  2DD0  	GOTO	label105
05E2        label107
05E2  1FF6  	BTFSS __mul_16s__0000F_1_i,7
05E3  0008  	RETURN
05E4  09F9  	COMF CompTempVarRet389, F
05E5  09FA  	COMF CompTempVarRet389+D'1', F
05E6  0AF9  	INCF CompTempVarRet389, F
05E7  1903  	BTFSC gbl_status,2
05E8  0AFA  	INCF CompTempVarRet389+D'1', F
05E9  0008  	RETURN
05EA        ; } __mul_16s_16s__16 function end























07FF        _startup

085E  118A  	BCF PCLATH,3
085F  120A  	BCF PCLATH,4
0860  2F6F  	GOTO	main

2007  3FB1  	DW 0x3FB1
