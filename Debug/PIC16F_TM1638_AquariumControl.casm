;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 8.01
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

#ifndef _PIC16F_TM1638_AquariumControl_H_
#define _PIC16F_TM1638_AquariumControl_H_

#define TASK_TIMER1 2
#define TASK_TIMER1_START 3
#define TASK_TIMER1_READ 4
#define TASK_TIMER2 5

#define oneWireBus (porta.6)
#define oneWireTris (trisa.6)
#define tm1638dio (porta.1)
#define tm1638clk (porta.0)
#define tm1638dioTris (trisa.1)
#define tm1638strobe (porta.7)
#define WHITE_LED (portb.5)
#define BLUE_LED (portb.4)
#define FAN (portb.3)
#define HEATER (portb.2)

// This means timer 1 will overflow when 1 cycle completes, generating the interrupt
#define TMR1HV 0xFF
#define TMR1LV 0xFF

// i2c options
#define use_i2c_SW
// clock SCL on GP0, data SDA on GP1
#define i2c_ARGS	2, PORTA, TRISA, 3, PORTA, TRISA, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)
// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3

#define ds3231_addr 0xD0

// Time and date variables
char gBcdSeconds = 0; // 0 to 59
0444  1283  	BCF STATUS, RP0
0445  1303  	BCF STATUS, RP1
0446  01CB  	CLRF gbl_gBcdSeconds

char gBcdMinute = 0; // 0 to 59
0447  01CC  	CLRF gbl_gBcdMinute

char gBcdHour = 0; // 0 to 23 or 1 to 12. Also contains 12/24 setting at bit 6. If 12 hour, AM/PM uses bit 5
0448  01CD  	CLRF gbl_gBcdHour

char gDayOfWeek = 1; // 1 to 7
0449  3001  	MOVLW 0x01
044A  00CE  	MOVWF gbl_gDayOfWeek

char gBcdDayOfMonth = 1; // 1 to 31
044B  3001  	MOVLW 0x01
044C  00CF  	MOVWF gbl_gBcdDayOfMonth

char gBcdMonth = 1; // 1 to 12 + century at bit 7
044D  3001  	MOVLW 0x01
044E  00D0  	MOVWF gbl_gBcdMonth

char gBcdYear = 0x23; // Init to 2023
044F  3023  	MOVLW 0x23
0450  00D1  	MOVWF gbl_gBcdYear


// Timer variables
char iTimer2Counts = 0;
0451  01D2  	CLRF gbl_iTimer2Counts

char iFlashDigitOff = 0;
0452  01D3  	CLRF gbl_iFlashDigitOff

char iDigitToFlash = 8; // 8 = no digit to flash
0453  3008  	MOVLW 0x08
0454  00D4  	MOVWF gbl_iDigitToFlash


// Hold the upper and lower bytes from the ds18b20
char cTempH = 0;
0455  01D5  	CLRF gbl_cTempH

char cTempL = 0;
0456  01D6  	CLRF gbl_cTempL

char iDecimalPosition = 2;
0457  3002  	MOVLW 0x02
0458  00D7  	MOVWF gbl_iDecimalPosition


char oneWireIsPresent = 0;
0459  01D8  	CLRF gbl_oneWireIsPresent

char oneWireResetStage = 0;
045A  01D9  	CLRF gbl_oneWireResetStage

void oneWireBusReset();
void oneWireTxByte(char data);
void oneWireTxBytes(char data, char data2);
char oneWireRxByte();

void ds3231Write(char ds3231Reg, char bWrite);
void ds3231Init();
void ds3231Start();
void ds3231Stop();
void ds3231WriteDateTime();
void ds3231ReadDateTime();

int giDS3231ValueBCD = 0;
045B  01BE  	CLRF gbl_giDS3231ValueBCD
045C  01BF  	CLRF gbl_giDS3231ValueBCD+D'1'

char gbDS3231IsMinus = 0;
045D  01DA  	CLRF gbl_gbDS3231IsMinus


char cTask = 0; // Used for task scheduler
045E  01DB  	CLRF gbl_cTask

bool gbWhiteOn = 0;
045F  105C  	BCF gbl_gbWhiteOn,0

bool gbBlueOn = 0;
0460  10DC  	BCF gbl_gbBlueOn,1

bool gbFanOn = 0;
0461  115C  	BCF gbl_gbFanOn,2

bool gbHeaterOn = 0;
0462  11DC  	BCF gbl_gbHeaterOn,3

bool gbFlashOff = 0;
0463  125C  	BCF gbl_gbFlashOff,4

char gcDisplayMode = 0;
0464  01DD  	CLRF gbl_gcDisplayMode

char gcSetMode = 0;
0465  01DE  	CLRF gbl_gcSetMode


// Used to output the segments from numbers
char tm1638MaxDigits = 8;
0466  3008  	MOVLW 0x08
0467  00DF  	MOVWF gbl_tm1638MaxDigits

char tm1638DisplayNumtoSeg[] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f};
0468  303F  	MOVLW 0x3F
0469  00A0  	MOVWF gbl_tm1638DisplayNumtoSeg
046A  3006  	MOVLW 0x06
046B  00A1  	MOVWF gbl_tm1638DisplayNumtoSeg+D'1'
046C  305B  	MOVLW 0x5B
046D  00A2  	MOVWF gbl_tm1638DisplayNumtoSeg+D'2'
046E  304F  	MOVLW 0x4F
046F  00A3  	MOVWF gbl_tm1638DisplayNumtoSeg+D'3'
0470  3066  	MOVLW 0x66
0471  00A4  	MOVWF gbl_tm1638DisplayNumtoSeg+D'4'
0472  306D  	MOVLW 0x6D
0473  00A5  	MOVWF gbl_tm1638DisplayNumtoSeg+D'5'
0474  307D  	MOVLW 0x7D
0475  00A6  	MOVWF gbl_tm1638DisplayNumtoSeg+D'6'
0476  3007  	MOVLW 0x07
0477  00A7  	MOVWF gbl_tm1638DisplayNumtoSeg+D'7'
0478  307F  	MOVLW 0x7F
0479  00A8  	MOVWF gbl_tm1638DisplayNumtoSeg+D'8'
047A  306F  	MOVLW 0x6F
047B  00A9  	MOVWF gbl_tm1638DisplayNumtoSeg+D'9'

char tm1638Dot = 0x80;
047C  3080  	MOVLW 0x80
047D  00E0  	MOVWF gbl_tm1638Dot

char tm1638Brightness = 7; // 0 to 7
047E  3007  	MOVLW 0x07
047F  00E1  	MOVWF gbl_tm1638Brightness

// 0x40 [01000000] = indicate command to display data
char tm1638ByteSetData = 0x40;
0480  3040  	MOVLW 0x40
0481  00E2  	MOVWF gbl_tm1638ByteSetData

// 0x42 [01000010] = indicate command to read data
char tm1638ByteReadData = 0x42;
0482  3042  	MOVLW 0x42
0483  00E3  	MOVWF gbl_tm1638ByteReadData

// 0xC0 [11000000] = write out all bytes
char tm1638ByteSetAddr = 0xC0;
0484  30C0  	MOVLW 0xC0
0485  00E4  	MOVWF gbl_tm1638ByteSetAddr

// 0x88 [10001000] - Display ON, plus brightness
char tm1638ByteSetOn = 0x88;
0486  3088  	MOVLW 0x88
0487  00E5  	MOVWF gbl_tm1638ByteSetOn


// Copy of the data to write / on the display
char tm1638Data[] = {0, 0, 0, 0, 0, 0, 0, 0};
0488  01AA  	CLRF gbl_tm1638Data
0489  01AB  	CLRF gbl_tm1638Data+D'1'
048A  01AC  	CLRF gbl_tm1638Data+D'2'
048B  01AD  	CLRF gbl_tm1638Data+D'3'
048C  01AE  	CLRF gbl_tm1638Data+D'4'
048D  01AF  	CLRF gbl_tm1638Data+D'5'
048E  01B0  	CLRF gbl_tm1638Data+D'6'
048F  01B1  	CLRF gbl_tm1638Data+D'7'

// Copy of the LED status
char tm1638LEDs[] = {0, 0, 0, 0, 0, 0, 0, 0};
0490  01B2  	CLRF gbl_tm1638LEDs
0491  01B3  	CLRF gbl_tm1638LEDs+D'1'
0492  01B4  	CLRF gbl_tm1638LEDs+D'2'
0493  01B5  	CLRF gbl_tm1638LEDs+D'3'
0494  01B6  	CLRF gbl_tm1638LEDs+D'4'
0495  01B7  	CLRF gbl_tm1638LEDs+D'5'
0496  01B8  	CLRF gbl_tm1638LEDs+D'6'
0497  01B9  	CLRF gbl_tm1638LEDs+D'7'

// Copy of the keys
char tm1638Keys = 0;
0498  01E6  	CLRF gbl_tm1638Keys

// Copy of translated temperature data
char tm1638TherData[] = {0, 0, 0, 0};
0499  01BA  	CLRF gbl_tm1638TherData
049A  01BB  	CLRF gbl_tm1638TherData+D'1'
049B  01BC  	CLRF gbl_tm1638TherData+D'2'
049C  01BD  	CLRF gbl_tm1638TherData+D'3'


void tm1638ByteWrite(char bWrite);
void tm1638UpdateDisplay();
void tm1638ReadKeys();

void displayTemp();
void storeTempDigits4(int iValue);
void startTemp();
void readTemp();
void processKeys();

#endif

#include <system.h>
#include <i2c_driver.h>
#include "PIC16F_TM1638_AquariumControl.h"

//Target PIC16F628A configuration word
#pragma DATA _CONFIG, _PWRTE_OFF & _WDT_OFF & _INTRC_OSC_NOCLKOUT & _CP_OFF & _LVP_OFF & _BODEN_OFF & _MCLRE_OFF

//Set clock frequency
#pragma CLOCK_FREQ	4000000

/*********************************************************************************************
  oneWireBusReset()
  First part of the reset routine - drive the bus low for 500us
*********************************************************************************************/
void oneWireBusReset() {

    char isPresent;
    oneWireTris = 1; // start with high
0339  1683  	BSF STATUS, RP0
033A  1303  	BCF STATUS, RP1
033B  1705  	BSF gbl_trisa,6

    isPresent = 0;
033C  1283  	BCF STATUS, RP0
033D  01E7  	CLRF oneWireBus_00015_1_isPresent

    // Send the reset pulse - drive low for 500us
    oneWireBus = 0;      
033E  1305  	BCF gbl_porta,6

    oneWireTris = 0;
033F  1683  	BSF STATUS, RP0
0340  1305  	BCF gbl_trisa,6

    delay_10us(50);
0341  3032  	MOVLW 0x32
0342  1283  	BCF STATUS, RP0
0343  00EC  	MOVWF delay_10us_00000_arg_del
0344  201A  	CALL delay_10us_00000

    // Release line and wait 70us for PD Pulse
    oneWireTris = 1;
0345  1683  	BSF STATUS, RP0
0346  1705  	BSF gbl_trisa,6

    delay_10us(7);
0347  3007  	MOVLW 0x07
0348  1283  	BCF STATUS, RP0
0349  00EC  	MOVWF delay_10us_00000_arg_del
034A  201A  	CALL delay_10us_00000

    // Now sample, if there is a sensor on the bus, the line should be low
    if (oneWireBus) {
034B  1B05  	BTFSC gbl_porta,6

        oneWireIsPresent = 0; // no devices
034C  01D8  	CLRF gbl_oneWireIsPresent

    }
    delay_10us(50);
034D  3032  	MOVLW 0x32
034E  00EC  	MOVWF delay_10us_00000_arg_del
034F  201A  	CALL delay_10us_00000

}
0350  0008  	RETURN


/*********************************************************************************************
  oneWireTxByte(char data)
  Transmits a single byte from the bus
*********************************************************************************************/
void oneWireTxByte(char cData) {

    char cTemp = 1;
00DA  3001  	MOVLW 0x01
00DB  00EA  	MOVWF oneWireTxB_00016_1_cTemp

    // Loop through the eight bits in the byte
    for (char i = 0; i < 8; i++) {
00DC  01EB  	CLRF oneWireTxB_00016_2_i
00DD        label17
00DD  3008  	MOVLW 0x08
00DE  026B  	SUBWF oneWireTxB_00016_2_i, W
00DF  1803  	BTFSC STATUS,C
00F4  0AEB  	INCF oneWireTxB_00016_2_i, F
00F5  28DD  	GOTO	label17

        // Send the LSB first

        // Drive the line low initially for 3us
        oneWireTris = 0;
00E1  1683  	BSF STATUS, RP0
00E2  1305  	BCF gbl_trisa,6

        oneWireBus = 0;
00E3  1283  	BCF STATUS, RP0
00E4  1305  	BCF gbl_porta,6


        // Delay not needed for 4MHz PIC
        //delay_us(3); // Delay 3us
        
        if (cData & cTemp) {
00E5  086A  	MOVF oneWireTxB_00016_1_cTemp, W
00E6  0569  	ANDWF oneWireTxB_00016_arg_cData, W
00E7  1903  	BTFSC STATUS,Z
00E8  28EB  	GOTO	label18

            oneWireTris = 1; // Release the bus
00E9  1683  	BSF STATUS, RP0
00EA  1705  	BSF gbl_trisa,6

        }
        
        delay_10us(5); // Delay 60us - 50us works fine with code delays
00EB  3005  	MOVLW 0x05
00EC  1283  	BCF STATUS, RP0
00ED  00EC  	MOVWF delay_10us_00000_arg_del
00EE  201A  	CALL delay_10us_00000

        oneWireTris = 1; // Release the bus
00EF  1683  	BSF STATUS, RP0
00F0  1705  	BSF gbl_trisa,6

        
        // move the test bit
        cTemp <<= 1;
00F1  1003  	BCF STATUS,C
00F2  1283  	BCF STATUS, RP0
00F3  0DEA  	RLF oneWireTxB_00016_1_cTemp, F

    }
}
00E0  0008  	RETURN


/*********************************************************************************************
  oneWireTxBytes(char data, char data2)
  Transmits a 2 bytes from the bus
*********************************************************************************************/
void oneWireTxBytes(char cData, char cData2) {

    // Reset first - done in main
    //oneWireBusReset();
    // Send first byte
    oneWireTxByte(cData);
0115  0867  	MOVF oneWireTxB_00017_arg_cData, W
0116  00E9  	MOVWF oneWireTxB_00016_arg_cData
0117  20DA  	CALL oneWireTxB_00016

    // Send second byte
    oneWireTxByte(cData2);
0118  0868  	MOVF oneWireTxB_00017_arg_cData2, W
0119  00E9  	MOVWF oneWireTxB_00016_arg_cData
011A  20DA  	CALL oneWireTxB_00016

}
011B  0008  	RETURN


/*********************************************************************************************
  oneWireRxByte()
  Receives a single byte from the bus
*********************************************************************************************/
char oneWireRxByte() {

    char cDataIn = 0;
011C  1283  	BCF STATUS, RP0
011D  1303  	BCF STATUS, RP1
011E  01E7  	CLRF oneWireRxB_00018_1_cDataIn

    // Loop through the eight bits in the byte
    for(char i = 0; i < 8; i++) {
011F  01E8  	CLRF oneWireRxB_00018_2_i
0120        label20
0120  3008  	MOVLW 0x08
0121  0268  	SUBWF oneWireRxB_00018_2_i, W
0122  1803  	BTFSC STATUS,C
0123  2937  	GOTO	label21
0135  0AE8  	INCF oneWireRxB_00018_2_i, F
0136  2920  	GOTO	label20
0137        label21

        // Bring bus low for 15us
        oneWireTris = 0;
0124  1683  	BSF STATUS, RP0
0125  1305  	BCF gbl_trisa,6

        oneWireBus = 0;
0126  1283  	BCF STATUS, RP0
0127  1305  	BCF gbl_porta,6


        // Delay not needed for 4MHz PIC
        //delay_us(15); // Delay 15us

        // Release bus for 6us, this is enough time for the slave to respond
        oneWireTris = 1;
0128  1683  	BSF STATUS, RP0
0129  1705  	BSF gbl_trisa,6

        delay_us(6); // Delay 6us
012A  3006  	MOVLW 0x06
012B  1283  	BCF STATUS, RP0
012C  00EC  	MOVWF delay_us_00000_arg_del
012D  2010  	CALL delay_us_00000

        
        // Shift data already received left
        cDataIn >>= 1;
012E  1003  	BCF STATUS,C
012F  0CE7  	RRF oneWireRxB_00018_1_cDataIn, F

        // Check the value of the onewire bus - set the MSB of cDataIn if so
        if (oneWireBus)
0130  1B05  	BTFSC gbl_porta,6

            cDataIn.7 = 1;
0131  17E7  	BSF oneWireRxB_00018_1_cDataIn,7


        // To finish time slot
        delay_10us(6); // 60us
0132  3006  	MOVLW 0x06
0133  00EC  	MOVWF delay_10us_00000_arg_del
0134  201A  	CALL delay_10us_00000

    } 
    
    return cDataIn;
0137  0867  	MOVF oneWireRxB_00018_1_cDataIn, W
0138  00E8  	MOVWF CompTempVarRet548

}
0139  0008  	RETURN


/*********************************************************************************************
 ds3231Write(char ds3231Reg, char bWrite)
 Write one byte
*********************************************************************************************/
void ds3231Write(char ds3231Reg, char bWrite) {

	i2c_start();
00F6  20A5  	CALL i2c_START_00000

	i2c_write(ds3231_addr); // address + write
00F7  30D0  	MOVLW 0xD0
00F8  00E9  	MOVWF i2c_WRITE_00000_arg_i2c_data
00F9  2024  	CALL i2c_WRITE_00000

	i2c_write(ds3231Reg); // start at address
00FA  0867  	MOVF ds3231Writ_00019_arg_ds3231Reg, W
00FB  00E9  	MOVWF i2c_WRITE_00000_arg_i2c_data
00FC  2024  	CALL i2c_WRITE_00000

	i2c_write(bWrite); // start at address
00FD  0868  	MOVF ds3231Writ_00019_arg_bWrite, W
00FE  00E9  	MOVWF i2c_WRITE_00000_arg_i2c_data
00FF  2024  	CALL i2c_WRITE_00000

	i2c_stop();
0100  2075  	CALL i2c_STOP_00000

}
0101  0008  	RETURN


/*********************************************************************************************
 ds3231Init()
 Initialise the DS3231
*********************************************************************************************/
void ds3231Init() {

	/* control register 0Eh
    bit7 EOSC   Enable Oscillator (1 if oscillator must be stopped when on battery)
    bit6 BBSQW  Battery Backed Square Wave
    bit5 CONV   Convert temperature (1 forces a conversion NOW)
    bit4 RS2    Rate select - frequency of square wave output
    bit3 RS1    Rate select
    bit2 INTCN  Interrupt control (1 for use of the alarms and to disable square wave)
    bit1 A2IE   Alarm2 interrupt enable (1 to enable)
    bit0 A1IE   Alarm1 interrupt enable (1 to enable)
    */
	ds3231Write(0x0E, 0x80);
01BD  300E  	MOVLW 0x0E
01BE  1283  	BCF STATUS, RP0
01BF  1303  	BCF STATUS, RP1
01C0  00E7  	MOVWF ds3231Writ_00019_arg_ds3231Reg
01C1  3080  	MOVLW 0x80
01C2  00E8  	MOVWF ds3231Writ_00019_arg_bWrite
01C3  20F6  	CALL ds3231Writ_00019

	/* Status Register 0Fh
    bit7 OSF     Oscillator Stop Flag
    bit3 EN32kHz Enable 32kHz Output
    bit2 BSY     Busy
    bit1 A2F     Alarm 2 Flag
    bit0 A1F     Alarm 1 Flag
    */
	ds3231Write(0x0F, 0x80);
01C4  300F  	MOVLW 0x0F
01C5  00E7  	MOVWF ds3231Writ_00019_arg_ds3231Reg
01C6  3080  	MOVLW 0x80
01C7  00E8  	MOVWF ds3231Writ_00019_arg_bWrite
01C8  20F6  	CALL ds3231Writ_00019

}
01C9  0008  	RETURN


/*********************************************************************************************
 ds3231Start()
 Start the DS3231
*********************************************************************************************/
void ds3231Start() {
	ds3231Write(0x0F, 0x00);
}

/*********************************************************************************************
 ds3231Stop()
 Stop the DS3231
*********************************************************************************************/
void ds3231Stop() {
	ds3231Write(0x0F, 0x80);
}

/*********************************************************************************************
 ds3231WriteDateTime()
 Write the date to the DS3231
*********************************************************************************************/
void ds3231WriteDateTime() {

	i2c_start();
01A1  20A5  	CALL i2c_START_00000

	i2c_write(ds3231_addr); // address + write
01A2  30D0  	MOVLW 0xD0
01A3  00E9  	MOVWF i2c_WRITE_00000_arg_i2c_data
01A4  2024  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
01A5  01E9  	CLRF i2c_WRITE_00000_arg_i2c_data
01A6  2024  	CALL i2c_WRITE_00000

	i2c_write(0); // seconds
01A7  01E9  	CLRF i2c_WRITE_00000_arg_i2c_data
01A8  2024  	CALL i2c_WRITE_00000

	i2c_write(gBcdMinute); // minutes
01A9  084C  	MOVF gbl_gBcdMinute, W
01AA  00E9  	MOVWF i2c_WRITE_00000_arg_i2c_data
01AB  2024  	CALL i2c_WRITE_00000

	i2c_write(gBcdHour); // hours
01AC  084D  	MOVF gbl_gBcdHour, W
01AD  00E9  	MOVWF i2c_WRITE_00000_arg_i2c_data
01AE  2024  	CALL i2c_WRITE_00000

	i2c_write(gDayOfWeek); // day of week
01AF  084E  	MOVF gbl_gDayOfWeek, W
01B0  00E9  	MOVWF i2c_WRITE_00000_arg_i2c_data
01B1  2024  	CALL i2c_WRITE_00000

	i2c_write(gBcdDayOfMonth); // day of month
01B2  084F  	MOVF gbl_gBcdDayOfMonth, W
01B3  00E9  	MOVWF i2c_WRITE_00000_arg_i2c_data
01B4  2024  	CALL i2c_WRITE_00000

	i2c_write(gBcdMonth); // month + century
01B5  0850  	MOVF gbl_gBcdMonth, W
01B6  00E9  	MOVWF i2c_WRITE_00000_arg_i2c_data
01B7  2024  	CALL i2c_WRITE_00000

	i2c_write(gBcdYear); // year
01B8  0851  	MOVF gbl_gBcdYear, W
01B9  00E9  	MOVWF i2c_WRITE_00000_arg_i2c_data
01BA  2024  	CALL i2c_WRITE_00000

	i2c_stop();
01BB  2075  	CALL i2c_STOP_00000

}
01BC  0008  	RETURN


/*********************************************************************************************
 ds3231ReadDateTime()
 Write the date to the DS3231
*********************************************************************************************/
void ds3231ReadDateTime() {

	i2c_start();
037A  20A5  	CALL i2c_START_00000

	i2c_write(ds3231_addr); // address + read
037B  30D0  	MOVLW 0xD0
037C  00E9  	MOVWF i2c_WRITE_00000_arg_i2c_data
037D  2024  	CALL i2c_WRITE_00000

	i2c_write(0); // start at address 0
037E  01E9  	CLRF i2c_WRITE_00000_arg_i2c_data
037F  2024  	CALL i2c_WRITE_00000

	i2c_stop();
0380  2075  	CALL i2c_STOP_00000

	
	i2c_start();
0381  20A5  	CALL i2c_START_00000

	i2c_write(ds3231_addr + 1); // address + read
0382  30D1  	MOVLW 0xD1
0383  00E9  	MOVWF i2c_WRITE_00000_arg_i2c_data
0384  2024  	CALL i2c_WRITE_00000

	gBcdSeconds = i2c_read(0); // ack
0385  01E7  	CLRF i2c_READ_00000_arg_ack_status
0386  213A  	CALL i2c_READ_00000
0387  086A  	MOVF CompTempVarRet550, W
0388  00CB  	MOVWF gbl_gBcdSeconds

	gBcdMinute = i2c_read(0); // ack
0389  01E7  	CLRF i2c_READ_00000_arg_ack_status
038A  213A  	CALL i2c_READ_00000
038B  086A  	MOVF CompTempVarRet550, W
038C  00CC  	MOVWF gbl_gBcdMinute

	gBcdHour = i2c_read(0); // ack
038D  01E7  	CLRF i2c_READ_00000_arg_ack_status
038E  213A  	CALL i2c_READ_00000
038F  086A  	MOVF CompTempVarRet550, W
0390  00CD  	MOVWF gbl_gBcdHour

	gDayOfWeek = i2c_read(0); // ack
0391  01E7  	CLRF i2c_READ_00000_arg_ack_status
0392  213A  	CALL i2c_READ_00000
0393  086A  	MOVF CompTempVarRet550, W
0394  00CE  	MOVWF gbl_gDayOfWeek

	gBcdDayOfMonth = i2c_read(0); // ack
0395  01E7  	CLRF i2c_READ_00000_arg_ack_status
0396  213A  	CALL i2c_READ_00000
0397  086A  	MOVF CompTempVarRet550, W
0398  00CF  	MOVWF gbl_gBcdDayOfMonth

	gBcdMonth = i2c_read(0); // ack
0399  01E7  	CLRF i2c_READ_00000_arg_ack_status
039A  213A  	CALL i2c_READ_00000
039B  086A  	MOVF CompTempVarRet550, W
039C  00D0  	MOVWF gbl_gBcdMonth

	gBcdYear = i2c_read(1); // nack
039D  3001  	MOVLW 0x01
039E  00E7  	MOVWF i2c_READ_00000_arg_ack_status
039F  213A  	CALL i2c_READ_00000
03A0  086A  	MOVF CompTempVarRet550, W
03A1  00D1  	MOVWF gbl_gBcdYear

	i2c_stop();
03A2  2075  	CALL i2c_STOP_00000

}
03A3  0008  	RETURN


/*********************************************************************************************
 tm1638ByteWrite(char bWrite)
 Write one byte
*********************************************************************************************/
void tm1638ByteWrite(char bWrite) {

    for (char i = 0; i < 8; i++) {
0102  01EA  	CLRF tm1638Byte_0001D_2_i
0103        label19
0103  3008  	MOVLW 0x08
0104  026A  	SUBWF tm1638Byte_0001D_2_i, W
0105  1803  	BTFSC STATUS,C
0113  0AEA  	INCF tm1638Byte_0001D_2_i, F
0114  2903  	GOTO	label19

        tm1638dio = (bWrite & 0x01);
0107  3001  	MOVLW 0x01
0108  0569  	ANDWF tm1638Byte_0001D_arg_bWrite, W
0109  00EB  	MOVWF CompTempVar551
010A  186B  	BTFSC CompTempVar551,0
010B  1485  	BSF gbl_porta,1
010C  1C6B  	BTFSS CompTempVar551,0
010D  1085  	BCF gbl_porta,1

        tm1638clk = 0;
010E  1005  	BCF gbl_porta,0

        bWrite = (bWrite >> 1);
010F  08E9  	MOVF tm1638Byte_0001D_arg_bWrite, F
0110  1003  	BCF STATUS,C
0111  0CE9  	RRF tm1638Byte_0001D_arg_bWrite, F

        tm1638clk = 1;
0112  1405  	BSF gbl_porta,0

    }
}
0106  0008  	RETURN


/*********************************************************************************************
 tm1638UpdateDisplay()
 Publish the tm1638Data and tm1638LEDs arrays to the display
*********************************************************************************************/
void tm1638UpdateDisplay() {

    
    if (!gcDisplayMode && !gcSetMode) {
01F5  1283  	BCF STATUS, RP0
01F6  1303  	BCF STATUS, RP1
01F7  08DD  	MOVF gbl_gcDisplayMode, F
01F8  1D03  	BTFSS STATUS,Z
01F9  2A4B  	GOTO	label36
01FA  08DE  	MOVF gbl_gcSetMode, F
01FB  1D03  	BTFSS STATUS,Z
01FC  2A4B  	GOTO	label36
024B        label36

        // translate DS3231 temperature to digit values
        tm1638Data[0] = tm1638DisplayNumtoSeg[giDS3231ValueBCD >> 12];
01FD  1383  	BCF	STATUS,IRP
01FE  3020  	MOVLW LOW(gbl_tm1638DisplayNumtoSeg+D'0')
01FF  0084  	MOVWF FSR
0200  083F  	MOVF gbl_giDS3231ValueBCD+D'1', W
0201  00EA  	MOVWF CompTempVar558
0202  0D3F  	RLF gbl_giDS3231ValueBCD+D'1', W
0203  0CEA  	RRF CompTempVar558, F
0204  0D3F  	RLF gbl_giDS3231ValueBCD+D'1', W
0205  0CEA  	RRF CompTempVar558, F
0206  0D3F  	RLF gbl_giDS3231ValueBCD+D'1', W
0207  0CEA  	RRF CompTempVar558, F
0208  0D3F  	RLF gbl_giDS3231ValueBCD+D'1', W
0209  0C6A  	RRF CompTempVar558, W
020A  0784  	ADDWF FSR, F
020B  0800  	MOVF INDF, W
020C  00AA  	MOVWF gbl_tm1638Data

        tm1638Data[1] = tm1638DisplayNumtoSeg[giDS3231ValueBCD >> 8] + tm1638Dot;
020D  3020  	MOVLW LOW(gbl_tm1638DisplayNumtoSeg+D'0')
020E  0084  	MOVWF FSR
020F  083F  	MOVF gbl_giDS3231ValueBCD+D'1', W
0210  0784  	ADDWF FSR, F
0211  0860  	MOVF gbl_tm1638Dot, W
0212  0700  	ADDWF INDF, W
0213  00AB  	MOVWF gbl_tm1638Data+D'1'

        tm1638Data[2] = tm1638DisplayNumtoSeg[giDS3231ValueBCD >> 4];
0214  3020  	MOVLW LOW(gbl_tm1638DisplayNumtoSeg+D'0')
0215  0084  	MOVWF FSR
0216  083E  	MOVF gbl_giDS3231ValueBCD, W
0217  00EA  	MOVWF CompTempVar564
0218  0C3F  	RRF gbl_giDS3231ValueBCD+D'1', W
0219  00EB  	MOVWF CompTempVar565
021A  0CEA  	RRF CompTempVar564, F
021B  0CEB  	RRF CompTempVar565, F
021C  0CEA  	RRF CompTempVar564, F
021D  0CEB  	RRF CompTempVar565, F
021E  0CEA  	RRF CompTempVar564, F
021F  0CEB  	RRF CompTempVar565, F
0220  0CEA  	RRF CompTempVar564, F
0221  086A  	MOVF CompTempVar564, W
0222  0784  	ADDWF FSR, F
0223  0800  	MOVF INDF, W
0224  00AC  	MOVWF gbl_tm1638Data+D'2'

        tm1638Data[3] = tm1638DisplayNumtoSeg[giDS3231ValueBCD & 0x0F] + tm1638Dot;
0225  3020  	MOVLW LOW(gbl_tm1638DisplayNumtoSeg+D'0')
0226  0084  	MOVWF FSR
0227  300F  	MOVLW 0x0F
0228  053E  	ANDWF gbl_giDS3231ValueBCD, W
0229  0784  	ADDWF FSR, F
022A  0860  	MOVF gbl_tm1638Dot, W
022B  0700  	ADDWF INDF, W
022C  00AD  	MOVWF gbl_tm1638Data+D'3'


        // left fill zeroes with blanks up to the digit before the decimal place
        if ((giDS3231ValueBCD & 0xF000) == 0) {
022D  3000  	MOVLW 0x00
022E  053E  	ANDWF gbl_giDS3231ValueBCD, W
022F  00E8  	MOVWF CompTempVar553
0230  083F  	MOVF gbl_giDS3231ValueBCD+D'1', W
0231  39F0  	ANDLW 0xF0
0232  00E9  	MOVWF CompTempVar554
0233  08E8  	MOVF CompTempVar553, F
0234  1D03  	BTFSS STATUS,Z
0235  2A3A  	GOTO	label34
0236  08E9  	MOVF CompTempVar554, F
0237  1D03  	BTFSS STATUS,Z
0238  2A3A  	GOTO	label34
023A        label34

            tm1638Data[0] = 0;
0239  01AA  	CLRF gbl_tm1638Data

        }

        if (gbDS3231IsMinus) {
023A  08DA  	MOVF gbl_gbDS3231IsMinus, F
023B  1903  	BTFSC STATUS,Z
023C  2A74  	GOTO	label39

            // If minus and value less than or equal -10 (checked as >1000), shift the digits right
            if (giDS3231ValueBCD & 0xF000) {
023D  30F0  	MOVLW 0xF0
023E  053F  	ANDWF gbl_giDS3231ValueBCD+D'1', W
023F  1903  	BTFSC STATUS,Z
0240  2A48  	GOTO	label35
0248        label35

                tm1638Data[1] = tm1638Data[0];
0241  082A  	MOVF gbl_tm1638Data, W
0242  00AB  	MOVWF gbl_tm1638Data+D'1'

                tm1638Data[2] = tm1638Data[1];
0243  082B  	MOVF gbl_tm1638Data+D'1', W
0244  00AC  	MOVWF gbl_tm1638Data+D'2'

                tm1638Data[3] = tm1638Data[2] + tm1638Dot;
0245  0860  	MOVF gbl_tm1638Dot, W
0246  072C  	ADDWF gbl_tm1638Data+D'2', W
0247  00AD  	MOVWF gbl_tm1638Data+D'3'

            }
            // If minus, overwrite left most digit with minus sign
            tm1638Data[0] = 0x40;
0248  3040  	MOVLW 0x40
0249  00AA  	MOVWF gbl_tm1638Data

        }
    } else {
024A  2A74  	GOTO	label39
0274        label39

        // Display date DD.YY.
        if (gBcdDayOfMonth & 0xF0)
024B  30F0  	MOVLW 0xF0
024C  054F  	ANDWF gbl_gBcdDayOfMonth, W
024D  1903  	BTFSC STATUS,Z
024E  2A58  	GOTO	label37
0258        label37

            tm1638Data[0] = tm1638DisplayNumtoSeg[gBcdDayOfMonth >> 4];
024F  1383  	BCF	STATUS,IRP
0250  3020  	MOVLW LOW(gbl_tm1638DisplayNumtoSeg+D'0')
0251  0084  	MOVWF FSR
0252  0E4F  	SWAPF gbl_gBcdDayOfMonth, W
0253  390F  	ANDLW 0x0F
0254  0784  	ADDWF FSR, F
0255  0800  	MOVF INDF, W
0256  00AA  	MOVWF gbl_tm1638Data

        else
0257  2A59  	GOTO	label38
0259        label38

            tm1638Data[0] = 0;
0258  01AA  	CLRF gbl_tm1638Data

        tm1638Data[1] = tm1638DisplayNumtoSeg[gBcdDayOfMonth & 0x0F] + tm1638Dot;
0259  1383  	BCF	STATUS,IRP
025A  3020  	MOVLW LOW(gbl_tm1638DisplayNumtoSeg+D'0')
025B  0084  	MOVWF FSR
025C  300F  	MOVLW 0x0F
025D  054F  	ANDWF gbl_gBcdDayOfMonth, W
025E  0784  	ADDWF FSR, F
025F  0860  	MOVF gbl_tm1638Dot, W
0260  0700  	ADDWF INDF, W
0261  00AB  	MOVWF gbl_tm1638Data+D'1'

        tm1638Data[2] = tm1638DisplayNumtoSeg[(gBcdMonth >> 4) & 0x01];
0262  3020  	MOVLW LOW(gbl_tm1638DisplayNumtoSeg+D'0')
0263  0084  	MOVWF FSR
0264  0E50  	SWAPF gbl_gBcdMonth, W
0265  390F  	ANDLW 0x0F
0266  00E8  	MOVWF CompTempVar586
0267  3001  	MOVLW 0x01
0268  0568  	ANDWF CompTempVar586, W
0269  0784  	ADDWF FSR, F
026A  0800  	MOVF INDF, W
026B  00AC  	MOVWF gbl_tm1638Data+D'2'

        tm1638Data[3] = tm1638DisplayNumtoSeg[gBcdMonth & 0x0F] + tm1638Dot;
026C  3020  	MOVLW LOW(gbl_tm1638DisplayNumtoSeg+D'0')
026D  0084  	MOVWF FSR
026E  300F  	MOVLW 0x0F
026F  0550  	ANDWF gbl_gBcdMonth, W
0270  0784  	ADDWF FSR, F
0271  0860  	MOVF gbl_tm1638Dot, W
0272  0700  	ADDWF INDF, W
0273  00AD  	MOVWF gbl_tm1638Data+D'3'

    }

    // HH.MM in last 4 digits of TM1638
    tm1638Data[4] = tm1638DisplayNumtoSeg[gBcdHour >> 4];
0274  1383  	BCF	STATUS,IRP
0275  3020  	MOVLW LOW(gbl_tm1638DisplayNumtoSeg+D'0')
0276  0084  	MOVWF FSR
0277  0E4D  	SWAPF gbl_gBcdHour, W
0278  390F  	ANDLW 0x0F
0279  0784  	ADDWF FSR, F
027A  0800  	MOVF INDF, W
027B  00AE  	MOVWF gbl_tm1638Data+D'4'

    tm1638Data[5] = tm1638DisplayNumtoSeg[gBcdHour & 0x0F] + tm1638Dot;
027C  3020  	MOVLW LOW(gbl_tm1638DisplayNumtoSeg+D'0')
027D  0084  	MOVWF FSR
027E  300F  	MOVLW 0x0F
027F  054D  	ANDWF gbl_gBcdHour, W
0280  0784  	ADDWF FSR, F
0281  0860  	MOVF gbl_tm1638Dot, W
0282  0700  	ADDWF INDF, W
0283  00AF  	MOVWF gbl_tm1638Data+D'5'

    tm1638Data[6] = tm1638DisplayNumtoSeg[gBcdMinute >> 4];
0284  3020  	MOVLW LOW(gbl_tm1638DisplayNumtoSeg+D'0')
0285  0084  	MOVWF FSR
0286  0E4C  	SWAPF gbl_gBcdMinute, W
0287  390F  	ANDLW 0x0F
0288  0784  	ADDWF FSR, F
0289  0800  	MOVF INDF, W
028A  00B0  	MOVWF gbl_tm1638Data+D'6'

    tm1638Data[7] = tm1638DisplayNumtoSeg[gBcdMinute & 0x0F];
028B  3020  	MOVLW LOW(gbl_tm1638DisplayNumtoSeg+D'0')
028C  0084  	MOVWF FSR
028D  300F  	MOVLW 0x0F
028E  054C  	ANDWF gbl_gBcdMinute, W
028F  0784  	ADDWF FSR, F
0290  0800  	MOVF INDF, W
0291  00B1  	MOVWF gbl_tm1638Data+D'7'


    // Write 0x40 [01000000] to indicate command to display data - [Write data to display register]
    tm1638strobe = 0;
0292  1385  	BCF gbl_porta,7

    tm1638ByteWrite(tm1638ByteSetData);
0293  0862  	MOVF gbl_tm1638ByteSetData, W
0294  00E9  	MOVWF tm1638Byte_0001D_arg_bWrite
0295  2102  	CALL tm1638Byte_0001D

    tm1638strobe = 1;
0296  1785  	BSF gbl_porta,7

    
    tm1638strobe = 0;
0297  1385  	BCF gbl_porta,7

    // Specify the display address 0xC0 [11000000] then write out all 8 bytes
    tm1638ByteWrite(tm1638ByteSetAddr);
0298  0864  	MOVF gbl_tm1638ByteSetAddr, W
0299  00E9  	MOVWF tm1638Byte_0001D_arg_bWrite
029A  2102  	CALL tm1638Byte_0001D

    for (char i = 0; i < tm1638MaxDigits; i++) {
029B  01E7  	CLRF tm1638Upda_0001E_2_i
029C        label40
029C  085F  	MOVF gbl_tm1638MaxDigits, W
029D  0267  	SUBWF tm1638Upda_0001E_2_i, W
029E  1803  	BTFSC STATUS,C
029F  2ABB  	GOTO	label43
02B9  0AE7  	INCF tm1638Upda_0001E_2_i, F
02BA  2A9C  	GOTO	label40
02BB        label43

        if (iFlashDigitOff.0 && (i == iDigitToFlash))
02A0  1C53  	BTFSS gbl_iFlashDigitOff,0
02A1  2AA9  	GOTO	label41
02A2  0854  	MOVF gbl_iDigitToFlash, W
02A3  0667  	XORWF tm1638Upda_0001E_2_i, W
02A4  1D03  	BTFSS STATUS,Z
02A5  2AA9  	GOTO	label41
02A9        label41

            tm1638ByteWrite(0);
02A6  01E9  	CLRF tm1638Byte_0001D_arg_bWrite
02A7  2102  	CALL tm1638Byte_0001D

        else
02A8  2AB1  	GOTO	label42
02B1        label42

            tm1638ByteWrite(tm1638Data[i]);
02A9  1383  	BCF	STATUS,IRP
02AA  302A  	MOVLW LOW(gbl_tm1638Data+D'0')
02AB  0084  	MOVWF FSR
02AC  0867  	MOVF tm1638Upda_0001E_2_i, W
02AD  0784  	ADDWF FSR, F
02AE  0800  	MOVF INDF, W
02AF  00E9  	MOVWF tm1638Byte_0001D_arg_bWrite
02B0  2102  	CALL tm1638Byte_0001D

        tm1638ByteWrite(tm1638LEDs[i]);
02B1  1383  	BCF	STATUS,IRP
02B2  3032  	MOVLW LOW(gbl_tm1638LEDs+D'0')
02B3  0084  	MOVWF FSR
02B4  0867  	MOVF tm1638Upda_0001E_2_i, W
02B5  0784  	ADDWF FSR, F
02B6  0800  	MOVF INDF, W
02B7  00E9  	MOVWF tm1638Byte_0001D_arg_bWrite
02B8  2102  	CALL tm1638Byte_0001D

    }
    tm1638strobe = 1;
02BB  1785  	BSF gbl_porta,7

}
02BC  0008  	RETURN


/*********************************************************************************************
 tm1638ReadKeys()
 Reads the keys status into tm1638Keys
*********************************************************************************************/
void tm1638ReadKeys() {

    // Write 0x42 [01000010] to indicate command to read data
    tm1638strobe = 0;
02BD  1283  	BCF STATUS, RP0
02BE  1303  	BCF STATUS, RP1
02BF  1385  	BCF gbl_porta,7

    tm1638ByteWrite(tm1638ByteReadData);
02C0  0863  	MOVF gbl_tm1638ByteReadData, W
02C1  00E9  	MOVWF tm1638Byte_0001D_arg_bWrite
02C2  2102  	CALL tm1638Byte_0001D

    
    tm1638dioTris = 1; // Set data pin to input
02C3  1683  	BSF STATUS, RP0
02C4  1485  	BSF gbl_trisa,1

    char tm1638KeysTemp = 32;
02C5  3020  	MOVLW 0x20
02C6  1283  	BCF STATUS, RP0
02C7  00E7  	MOVWF tm1638Read_0001F_1_tm1638K_00020

    // Read 4 bytes
    for (char i = 0; i < 32; i++) {
02C8  01E8  	CLRF tm1638Read_0001F_2_i
02C9        label44
02C9  3020  	MOVLW 0x20
02CA  0268  	SUBWF tm1638Read_0001F_2_i, W
02CB  1803  	BTFSC STATUS,C
02CC  2ADA  	GOTO	label46
02D8  0AE8  	INCF tm1638Read_0001F_2_i, F
02D9  2AC9  	GOTO	label44
02DA        label46

        tm1638KeysTemp--;
02CD  03E7  	DECF tm1638Read_0001F_1_tm1638K_00020, F

        tm1638clk = 0;
02CE  1005  	BCF gbl_porta,0

        delay_us(1);
02CF  3001  	MOVLW 0x01
02D0  00EC  	MOVWF delay_us_00000_arg_del
02D1  2010  	CALL delay_us_00000

        if(tm1638dio)
02D2  1C85  	BTFSS gbl_porta,1
02D3  2AD7  	GOTO	label45
02D7        label45

            tm1638KeysTemp = (tm1638KeysTemp << 1);
02D4  08E7  	MOVF tm1638Read_0001F_1_tm1638K_00020, F
02D5  1003  	BCF STATUS,C
02D6  0DE7  	RLF tm1638Read_0001F_1_tm1638K_00020, F

        tm1638clk = 1;
02D7  1405  	BSF gbl_porta,0

    }
    tm1638dioTris = 0; // Set data pin to output
02DA  1683  	BSF STATUS, RP0
02DB  1085  	BCF gbl_trisa,1

    tm1638strobe = 1;
02DC  1283  	BCF STATUS, RP0
02DD  1785  	BSF gbl_porta,7


    tm1638Keys = tm1638KeysTemp;
02DE  0867  	MOVF tm1638Read_0001F_1_tm1638K_00020, W
02DF  00E6  	MOVWF gbl_tm1638Keys

}
02E0  0008  	RETURN


/*********************************************************************************************
  Function called once only to initialise variables and
  setup the PIC registers
*********************************************************************************************/
void initialise() {

    pcon.OSCF = 1; // 4MHz internal osc
0351  1683  	BSF STATUS, RP0
0352  1303  	BCF STATUS, RP1
0353  158E  	BSF gbl_pcon,3


    // Configure port A
    /*
    RA7     OUT TM1638 STB
    RA6     IN/OUT DS18B20
    RA5     
    RA4     ICSP VPP
    RA3     IN/OUT DS3231M I2C SDA
    RA2     IN/OUT DS3231M I2C CLK
    RA1     IN/OUT TM1638 DIO
    RA0     OUT TM1638 CLK
    */
    trisa = 0x0C;
0354  300C  	MOVLW 0x0C
0355  0085  	MOVWF gbl_trisa

    porta = 0x00; // 
0356  1283  	BCF STATUS, RP0
0357  0185  	CLRF gbl_porta

    
    // Configure port B
    /*      
    RB7     ICSP PGD
    RB6     IN SQW DS3231M + ICSP PGC
    RB5     OUT WHITE LIGHT PWM
    RB4     OUT BLUE LIGHT PWM
    RB3     OUT FANS
    RB2     OUT HEATER
    RB1     
    RB0     
    */
    trisb = 0x00; // all outputs
0358  1683  	BSF STATUS, RP0
0359  0186  	CLRF gbl_trisb

    portb = 0x00; // all off by default
035A  1283  	BCF STATUS, RP0
035B  0186  	CLRF gbl_portb


    option_reg = 0;
035C  1683  	BSF STATUS, RP0
035D  0181  	CLRF gbl_option_reg

    option_reg.NOT_RBPU = 1; // disable port b pull ups
035E  1781  	BSF gbl_option_reg,7


    // ADC setup
    cmcon = 7; // disable all comparators so port a is usable as digital io
035F  3007  	MOVLW 0x07
0360  1283  	BCF STATUS, RP0
0361  009F  	MOVWF gbl_cmcon



    // Setup timer 0, used for PWM
    // https://labprojectsbd.com/2021/03/31/pwm-pulse-generation-using-pic12f675-micro-controller/
    // Timer calculator: http://eng-serve.com/pic/pic_timer.html
    // Timer0 Registers Prescaler= 16 - TMR0 Preset = 0 - Freq = 244.14 Hz - Period = 0.004096 seconds
    //option_reg.T0CS = 0; // bit 5  TMR0 Clock Source Select bit...0 = Internal Clock (CLKO) 1 = Transition on T0CKI pin
    //option_reg.T0SE = 0; // bit 4 TMR0 Source Edge Select bit 0 = low/high 1 = high/low
    //option_reg.PSA = 0; // bit 3  Prescaler Assignment bit...0 = Prescaler is assigned to the Timer0
    //option_reg.PS2 = 0; // bits 2-0  PS2:PS0: Prescaler Rate Select bits
    /*option_reg.PS1 = 1;
    option_reg.PS0 = 1;
    tmr0 = 0; // preset for timer register
    intcon.T0IF = 0; // Clear timer 1 interrupt flag bit
    intcon.T0IE = 1; // Timer 1 interrupt enabled*/

    // Setup timer 1, used to update clock display and periodically ask for a temperature reading
    // Timer 1 setup - interrupt on DS3231 SQW 1Hz
    // Timer1 Registers Prescaler= 1 - TMR1 Preset = 65535 - Freq = 1 Hz
    // Bits 5-4 T1CKPS1:T1CKPS0 = 00: Prescaler Rate Select bits, 00 = 1:1 prescaler
    // Bit 3 T1OSCEN = 0: Timer1 LP Oscillator Enable Control bit, 0 = off
    // Bit 2 NOT_T1SYNC = 1: Timer1 External Clock Input Synchronization Control bit, 1 = Do not synchronize external clock input
    // Bit 1 TMR1CS = 1: Timer1 Clock Source Select bit, 1 = External clock from T1OSO/T1CKI pin (on the rising edge)
    // Bit 0 TMR1ON = 0: Timer1 On Bit, 0 = off
    t1con = 0b00000110;
0362  3006  	MOVLW 0x06
0363  0090  	MOVWF gbl_t1con

    tmr1h = TMR1HV;      // preset for timer1 MSB register
0364  30FF  	MOVLW 0xFF
0365  008F  	MOVWF gbl_tmr1h

    tmr1l = TMR1LV;      // preset for timer1 LSB register
0366  008E  	MOVWF gbl_tmr1l

    pie1.TMR1IE = 1;     // Timer 1 interrupt
0367  1683  	BSF STATUS, RP0
0368  140C  	BSF gbl_pie1,0

    
    // Setup timer 2, used for flashing display
    // Timer calculator: http://eng-serve.com/pic/pic_timer.html
    //Timer2 Registers Prescaler= 16 - TMR2 PostScaler = 16 - PR2 = 195 - Freq = 20.03 Hz - Period = 0.049920 seconds
    t2con |= 120; // bits 6-3 Post scaler 1:1 thru 1:16
0369  3078  	MOVLW 0x78
036A  1283  	BCF STATUS, RP0
036B  0492  	IORWF gbl_t2con, F

    t2con.TMR2ON = 1; // bit 2 turn timer2 on;
036C  1512  	BSF gbl_t2con,2

    t2con.T2CKPS1 = 1; // bits 1-0  Prescaler Rate Select bits
036D  1492  	BSF gbl_t2con,1

    //t2con.T2CKPS0 = 0;
    pr2 = 195; // PR2 (Timer2 Match value)
036E  30C3  	MOVLW 0xC3
036F  1683  	BSF STATUS, RP0
0370  0092  	MOVWF gbl_pr2


    // No task at initialisation
    cTask = 0;
0371  1283  	BCF STATUS, RP0
0372  01DB  	CLRF gbl_cTask

    
    // Enable interrupts
    intcon.GIE = 1;
0373  178B  	BSF gbl_intcon,7

    intcon.PEIE = 1;
0374  170B  	BSF gbl_intcon,6


	i2c_init(1); 
0375  3001  	MOVLW 0x01
0376  00E7  	MOVWF i2c_INIT_00000_arg_i2c_divisor
0377  218E  	CALL i2c_INIT_00000

	//ds3231WriteDateTime();
	ds3231Init();
0378  21BD  	CALL ds3231Init_00000


}
0379  0008  	RETURN



/*********************************************************************************************
  interrupt()
  Interrupt handler
*********************************************************************************************/
void interrupt() {

    // Handle timer1 interrupt - delay counter from DS3231
    if (pir1.TMR1IF) {
04A0  1283  	BCF STATUS, RP0
04A1  1303  	BCF STATUS, RP1
04A2  1C0C  	BTFSS gbl_pir1,0
04A3  2CA9  	GOTO	label69
04A9        label69

        tmr1h = TMR1HV;      // preset for timer1 MSB register
04A4  30FF  	MOVLW 0xFF
04A5  008F  	MOVWF gbl_tmr1h

        tmr1l = TMR1LV;      // preset for timer1 LSB register
04A6  008E  	MOVWF gbl_tmr1l


        pir1.TMR1IF = 0;     // Clear interrupt flag
04A7  100C  	BCF gbl_pir1,0

        cTask.TASK_TIMER1 = 1;
04A8  155B  	BSF gbl_cTask,2

    }
    
    // Interrupt on timer2 - flash digit delay
    if (pir1.TMR2IF) {
04A9  1C8C  	BTFSS gbl_pir1,1
04AA  2CB4  	GOTO	label71
04B4        label71

        iTimer2Counts++;
04AB  0AD2  	INCF gbl_iTimer2Counts, F

        if (iTimer2Counts > 9) {
04AC  0852  	MOVF gbl_iTimer2Counts, W
04AD  3C09  	SUBLW 0x09
04AE  1803  	BTFSC STATUS,C
04AF  2CB3  	GOTO	label70
04B3        label70

            iFlashDigitOff++;
04B0  0AD3  	INCF gbl_iFlashDigitOff, F

            iTimer2Counts = 0;
04B1  01D2  	CLRF gbl_iTimer2Counts

            cTask.TASK_TIMER2 = 1;
04B2  16DB  	BSF gbl_cTask,5

        }
        // Clear interrupt flag
        pir1.TMR2IF = 0; 
04B3  108C  	BCF gbl_pir1,1

    }
}
04B4  0E4A  	SWAPF Int1BContext+D'2', W
04B5  0084  	MOVWF FSR
04B6  0E49  	SWAPF Int1BContext+D'1', W
04B7  008A  	MOVWF PCLATH
04B8  0E48  	SWAPF Int1BContext, W
04B9  0083  	MOVWF STATUS
04BA  0EFF  	SWAPF Int1Context, F
04BB  0E7F  	SWAPF Int1Context, W
04BC  0009  	RETFIE


/*********************************************************************************************
  displayTemp()
  Used to split the 16 bit integer returned from the ds18b20 into parts for display
  cTempH - upper 8 bits
  cTempL - lower 8 bits
*********************************************************************************************/
void convertTemp() {

    // convert both bytes to a 16bit int - e.g. 0000 0001 0100 0110 (1 and 70, gives 326)
    
    signed int iTemp = (cTempH << 8) | cTempL;
03A4  1283  	BCF STATUS, RP0
03A5  1303  	BCF STATUS, RP1
03A6  01E7  	CLRF convertTem_00022_1_iTemp
03A7  0855  	MOVF gbl_cTempH, W
03A8  00E8  	MOVWF convertTem_00022_1_iTemp+D'1'
03A9  0856  	MOVF gbl_cTempL, W
03AA  04E7  	IORWF convertTem_00022_1_iTemp, F

    
    // Celcius
    gbDS3231IsMinus = (iTemp < 0);
03AB  01DA  	CLRF gbl_gbDS3231IsMinus
03AC  1BE8  	BTFSC convertTem_00022_1_iTemp+D'1',7
03AD  0ADA  	INCF gbl_gbDS3231IsMinus, F

    if (gbDS3231IsMinus) {
03AE  08DA  	MOVF gbl_gbDS3231IsMinus, F
03AF  1903  	BTFSC STATUS,Z
03B0  2BB6  	GOTO	label52

        iTemp = ~iTemp + 1;
03B1  09E7  	COMF convertTem_00022_1_iTemp, F
03B2  09E8  	COMF convertTem_00022_1_iTemp+D'1', F
03B3  0AE7  	INCF convertTem_00022_1_iTemp, F
03B4  1903  	BTFSC STATUS,Z
03B5  0AE8  	INCF convertTem_00022_1_iTemp+D'1', F
03B6        label52

    }
    // this gets celcius * 100 - https://www.phanderson.com/PIC/PICC/sourceboost/ds18b20_1.html
    int iValue = (6 * iTemp) + (iTemp / 4);
03B6  3006  	MOVLW 0x06
03B7  00ED  	MOVWF __mul_16s__0000F_arg_a
03B8  01EE  	CLRF __mul_16s__0000F_arg_a+D'1'
03B9  0867  	MOVF convertTem_00022_1_iTemp, W
03BA  00EF  	MOVWF __mul_16s__0000F_arg_b
03BB  0868  	MOVF convertTem_00022_1_iTemp+D'1', W
03BC  00F0  	MOVWF __mul_16s__0000F_arg_b+D'1'
03BD  21CA  	CALL __mul_16s__0000F
03BE  0874  	MOVF CompTempVarRet386, W
03BF  00E9  	MOVWF convertTem_00022_1_iValue
03C0  0875  	MOVF CompTempVarRet386+D'1', W
03C1  00EC  	MOVWF CompTempVar614
03C2  0867  	MOVF convertTem_00022_1_iTemp, W
03C3  00EB  	MOVWF CompTempVar611
03C4  0868  	MOVF convertTem_00022_1_iTemp+D'1', W
03C5  00EA  	MOVWF convertTem_00022_1_iValue+D'1'
03C6  0D68  	RLF convertTem_00022_1_iTemp+D'1', W
03C7  0CEA  	RRF convertTem_00022_1_iValue+D'1', F
03C8  0CEB  	RRF CompTempVar611, F
03C9  0D68  	RLF convertTem_00022_1_iTemp+D'1', W
03CA  0CEA  	RRF convertTem_00022_1_iValue+D'1', F
03CB  0CEB  	RRF CompTempVar611, F
03CC  086B  	MOVF CompTempVar611, W
03CD  07E9  	ADDWF convertTem_00022_1_iValue, F
03CE  086C  	MOVF CompTempVar614, W
03CF  1803  	BTFSC STATUS,C
03D0  0AEA  	INCF convertTem_00022_1_iValue+D'1', F
03D1  07EA  	ADDWF convertTem_00022_1_iValue+D'1', F


    // Split the temperature reading into digits
    
    // simple way, but more program memory needed for PIC12 or PIC16 (more than 100 words more)
    //char cDig3 = iValue / 1000;
    //char cDig2 = (iValue / 100) % 10;
    //char cDig1 = (iValue / 10) % 10;
    //char cDig0 = iValue % 10;
    
    // less program memory needed - may be slower executing
    // https://electronics.stackexchange.com/questions/158563/how-to-split-a-floating-point-number-into-individual-digits
    giDS3231ValueBCD = 0;
03D2  01BE  	CLRF gbl_giDS3231ValueBCD
03D3  01BF  	CLRF gbl_giDS3231ValueBCD+D'1'


    // incrementing variables for each digit
    // determine to thousands digit
    while (iValue >= 1000) {
03D4        label53
03D4  3003  	MOVLW 0x03
03D5  026A  	SUBWF convertTem_00022_1_iValue+D'1', W
03D6  1D03  	BTFSS STATUS,Z
03D7  2BDA  	GOTO	label54
03D8  30E8  	MOVLW 0xE8
03D9  0269  	SUBWF convertTem_00022_1_iValue, W
03DA        label54
03DA  1C03  	BTFSS STATUS,C
03DB  2BE7  	GOTO	label55
03DC  1BEA  	BTFSC convertTem_00022_1_iValue+D'1',7
03DD  2BE7  	GOTO	label55
03E6  2BD4  	GOTO	label53
03E7        label55

        iValue = iValue - 1000;
03DE  30E8  	MOVLW 0xE8
03DF  02E9  	SUBWF convertTem_00022_1_iValue, F
03E0  3003  	MOVLW 0x03
03E1  1C03  	BTFSS STATUS,C
03E2  3004  	MOVLW 0x04
03E3  02EA  	SUBWF convertTem_00022_1_iValue+D'1', F

        // each time we take off 1000, the digit is incremented
        giDS3231ValueBCD += 0x1000;
03E4  3010  	MOVLW 0x10
03E5  07BF  	ADDWF gbl_giDS3231ValueBCD+D'1', F

    }

    // determine to hundreds digit
    while (iValue >= 100) {
03E7  086A  	MOVF convertTem_00022_1_iValue+D'1', W
03E8  3A80  	XORLW 0x80
03E9  00ED  	MOVWF CompTempVar624
03EA  3080  	MOVLW 0x80
03EB  026D  	SUBWF CompTempVar624, W
03EC  1D03  	BTFSS STATUS,Z
03ED  2BF0  	GOTO	label56
03EE  3064  	MOVLW 0x64
03EF  0269  	SUBWF convertTem_00022_1_iValue, W
03F0        label56
03F0  1C03  	BTFSS STATUS,C
03F1  2BF9  	GOTO	label57
03F8  2BE7  	GOTO	label55
03F9        label57

        iValue = iValue - 100;
03F2  3064  	MOVLW 0x64
03F3  02E9  	SUBWF convertTem_00022_1_iValue, F
03F4  08EA  	MOVF convertTem_00022_1_iValue+D'1', F
03F5  1C03  	BTFSS STATUS,C
03F6  03EA  	DECF convertTem_00022_1_iValue+D'1', F

        // each time we take off 100, the digit is incremented
        giDS3231ValueBCD += 0x100;
03F7  0ABF  	INCF gbl_giDS3231ValueBCD+D'1', F

    }

    // determine to tens digit
    while (iValue >= 10) {
03F9  086A  	MOVF convertTem_00022_1_iValue+D'1', W
03FA  3A80  	XORLW 0x80
03FB  00ED  	MOVWF CompTempVar627
03FC  3080  	MOVLW 0x80
03FD  026D  	SUBWF CompTempVar627, W
03FE  1D03  	BTFSS STATUS,Z
03FF  2C02  	GOTO	label58
0400  300A  	MOVLW 0x0A
0401  0269  	SUBWF convertTem_00022_1_iValue, W
0402        label58
0402  1C03  	BTFSS STATUS,C
0403  2C0E  	GOTO	label59
040D  2BF9  	GOTO	label57
040E        label59

        iValue = iValue - 10;
0404  300A  	MOVLW 0x0A
0405  02E9  	SUBWF convertTem_00022_1_iValue, F
0406  08EA  	MOVF convertTem_00022_1_iValue+D'1', F
0407  1C03  	BTFSS STATUS,C
0408  03EA  	DECF convertTem_00022_1_iValue+D'1', F

        // each time we take off 10, the left most digit is incremented
        giDS3231ValueBCD += 0x10;
0409  3010  	MOVLW 0x10
040A  07BE  	ADDWF gbl_giDS3231ValueBCD, F
040B  1803  	BTFSC STATUS,C
040C  0ABF  	INCF gbl_giDS3231ValueBCD+D'1', F

    }

    // the last digit is what's left on iValue
    giDS3231ValueBCD += iValue;
040E  0869  	MOVF convertTem_00022_1_iValue, W
040F  07BE  	ADDWF gbl_giDS3231ValueBCD, F
0410  086A  	MOVF convertTem_00022_1_iValue+D'1', W
0411  1803  	BTFSC STATUS,C
0412  0ABF  	INCF gbl_giDS3231ValueBCD+D'1', F
0413  07BF  	ADDWF gbl_giDS3231ValueBCD+D'1', F

}
0414  0008  	RETURN


/*********************************************************************************************
  startTemp()
  Sends the Convert T [44h] function command to the ds18b20
*********************************************************************************************/
void startTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // 44 is the convert function
    oneWireTxBytes(0xCC, 0x44);
02E1  30CC  	MOVLW 0xCC
02E2  1283  	BCF STATUS, RP0
02E3  1303  	BCF STATUS, RP1
02E4  00E7  	MOVWF oneWireTxB_00017_arg_cData
02E5  3044  	MOVLW 0x44
02E6  00E8  	MOVWF oneWireTxB_00017_arg_cData2
02E7  2115  	CALL oneWireTxB_00017

}
02E8  0008  	RETURN


/*********************************************************************************************
  startTemp()
  Sends the Read Scratchpad [BEh] function command to the ds18b20
*********************************************************************************************/
void readTemp() {

    // CC indicates to skip rom - addressing all devices (there is only one)
    // BE indicates to read scratchpad
    oneWireTxBytes(0xCC, 0xBE);
02E9  30CC  	MOVLW 0xCC
02EA  1283  	BCF STATUS, RP0
02EB  1303  	BCF STATUS, RP1
02EC  00E7  	MOVWF oneWireTxB_00017_arg_cData
02ED  30BE  	MOVLW 0xBE
02EE  00E8  	MOVWF oneWireTxB_00017_arg_cData2
02EF  2115  	CALL oneWireTxB_00017

    // Now get the temperature from the scratchpad
    // This is in the first two bytes - so get those only and ignore the rest
    cTempL = oneWireRxByte();
02F0  211C  	CALL oneWireRxB_00018
02F1  0868  	MOVF CompTempVarRet548, W
02F2  00D6  	MOVWF gbl_cTempL

    cTempH = oneWireRxByte();
02F3  211C  	CALL oneWireRxB_00018
02F4  0868  	MOVF CompTempVarRet548, W
02F5  00D5  	MOVWF gbl_cTempH

}
02F6  0008  	RETURN


void processKeys() {

    switch (tm1638Keys) {

        case 1:
02F7  1283  	BCF STATUS, RP0
02F8  1303  	BCF STATUS, RP1
02F9  0866  	MOVF gbl_tm1638Keys, W
02FA  3A01  	XORLW 0x01
02FB  1903  	BTFSC STATUS,Z
02FC  2B13  	GOTO	label47
0313        label47

            // Toggle white light on/off
            gbWhiteOn = !gbWhiteOn;
0313  01E7  	CLRF CompTempVar604
0314  1C5C  	BTFSS gbl_gbWhiteOn,0
0315  0AE7  	INCF CompTempVar604, F
0316  105C  	BCF gbl_gbWhiteOn,0
0317  0867  	MOVF CompTempVar604, W
0318  1D03  	BTFSS STATUS,Z
0319  145C  	BSF gbl_gbWhiteOn,0

            break;
        case 2:
02FD  3A03  	XORLW 0x03
02FE  1903  	BTFSC STATUS,Z
02FF  2B1B  	GOTO	label48
031B        label48

            // Toggle blue light on/off
            gbBlueOn = !gbBlueOn;
031B  01E7  	CLRF CompTempVar605
031C  1CDC  	BTFSS gbl_gbBlueOn,1
031D  0AE7  	INCF CompTempVar605, F
031E  10DC  	BCF gbl_gbBlueOn,1
031F  0867  	MOVF CompTempVar605, W
0320  1D03  	BTFSS STATUS,Z
0321  14DC  	BSF gbl_gbBlueOn,1

            break;
        case 3:
0300  3A01  	XORLW 0x01
0301  1903  	BTFSC STATUS,Z
0302  2B23  	GOTO	label49
0323        label49

            // Toggle fan on/off
            gbFanOn = !gbFanOn;
0323  01E7  	CLRF CompTempVar606
0324  1D5C  	BTFSS gbl_gbFanOn,2
0325  0AE7  	INCF CompTempVar606, F
0326  115C  	BCF gbl_gbFanOn,2
0327  0867  	MOVF CompTempVar606, W
0328  1D03  	BTFSS STATUS,Z
0329  155C  	BSF gbl_gbFanOn,2

            break;
        case 4:
0303  3A07  	XORLW 0x07
0304  1903  	BTFSC STATUS,Z
0305  2B2B  	GOTO	label50
032B        label50

            // Display temp C/temp F/date
            gcDisplayMode++;
032B  0ADD  	INCF gbl_gcDisplayMode, F

            if (gcDisplayMode > 2)
032C  085D  	MOVF gbl_gcDisplayMode, W
032D  3C02  	SUBLW 0x02
032E  1C03  	BTFSS STATUS,C

                gcDisplayMode = 0;
032F  01DD  	CLRF gbl_gcDisplayMode

            break;
        case 5:
0306  3A01  	XORLW 0x01
0307  1903  	BTFSC STATUS,Z
0308  2B31  	GOTO	label51
0331        label51

            // Set
            gcSetMode++;
0331  0ADE  	INCF gbl_gcSetMode, F

            if (gcSetMode > 6) {
0332  085E  	MOVF gbl_gcSetMode, W
0333  3C06  	SUBLW 0x06
0334  1803  	BTFSC STATUS,C

                ds3231WriteDateTime();
0336  21A1  	CALL ds3231Writ_0001B

                gcSetMode = 0;
0337  01DE  	CLRF gbl_gcSetMode

            }
            break;
        case 6:
0309  3A03  	XORLW 0x03
030A  1903  	BTFSC STATUS,Z

            // Adjust down
            break;
        case 7:
030C  3A01  	XORLW 0x01
030D  1903  	BTFSC STATUS,Z

            // Adjust up
            break;
        case 8:
030F  3A0F  	XORLW 0x0F
0310  1903  	BTFSC STATUS,Z

            // Timer
            break;
    }
}
030B  0008  	RETURN
030E  0008  	RETURN
0311  0008  	RETURN
0312  0008  	RETURN
031A  0008  	RETURN
0322  0008  	RETURN
032A  0008  	RETURN
0330  0008  	RETURN
0335  0008  	RETURN
0338  0008  	RETURN


void main() {

    initialise();
0415  2351  	CALL initialise_00000

    //convertTemp();
    tm1638UpdateDisplay();
0416  21F5  	CALL tm1638Upda_0001E


    // Endless loop
    while(1) {
0417        label60

        // Task scheduler
        // If there are tasks to be performed, find out the
        // most recent task from the array and execute it
        while (cTask > 0) {
0417  085B  	MOVF gbl_cTask, W
0418  3C00  	SUBLW 0x00
0419  1803  	BTFSC STATUS,C
041A  2C17  	GOTO	label60

            if (cTask.TASK_TIMER1) {
041B  1D5B  	BTFSS gbl_cTask,2
041C  2C38  	GOTO	label66
0438        label66

                if (gcSetMode == 0) {
041D  08DE  	MOVF gbl_gcSetMode, F
041E  1D03  	BTFSS STATUS,Z
041F  2C37  	GOTO	label65
0437        label65

                    ds3231ReadDateTime();
0420  237A  	CALL ds3231Read_0001C

                    if ((gBcdSeconds == 0x29) || (gBcdSeconds == 0x59)) {
0421  084B  	MOVF gbl_gBcdSeconds, W
0422  3A29  	XORLW 0x29
0423  1903  	BTFSC STATUS,Z
0424  2C29  	GOTO	label61
0425  084B  	MOVF gbl_gBcdSeconds, W
0426  3A59  	XORLW 0x59
0427  1D03  	BTFSS STATUS,Z
0428  2C2C  	GOTO	label62
0429        label61
042C        label62

                        // Ask to convert for temperature reading at 29 seconds or 59 seconds past the minute
                        oneWireBusReset();
0429  2339  	CALL oneWireBus_00015

                        startTemp();
042A  22E1  	CALL startTemp_00000

                    } else if ((gBcdSeconds == 0) || (gBcdSeconds == 0x30)) {
042B  2C36  	GOTO	label64
042C  08CB  	MOVF gbl_gBcdSeconds, F
042D  1903  	BTFSC STATUS,Z
042E  2C33  	GOTO	label63
042F  084B  	MOVF gbl_gBcdSeconds, W
0430  3A30  	XORLW 0x30
0431  1D03  	BTFSS STATUS,Z
0432  2C36  	GOTO	label64
0433        label63
0436        label64
0443  2C17  	GOTO	label60

                        // 1 second later, read the converted temperature
                        oneWireBusReset();
0433  2339  	CALL oneWireBus_00015

                        readTemp(); 
0434  22E9  	CALL readTemp_00000

                        // store it in the array, next display refresh will pick it up
                        convertTemp();
0435  23A4  	CALL convertTem_00022

                    }
                    // Display time and temp or date on TM1638
                    tm1638UpdateDisplay();
0436  21F5  	CALL tm1638Upda_0001E

                }
                
                cTask.TASK_TIMER1 = 0;
0437  115B  	BCF gbl_cTask,2

            }
            if (cTask.TASK_TIMER2) {
0438  1EDB  	BTFSS gbl_cTask,5
0439  2C3F  	GOTO	label67
043F        label67

                // If in set mode, update the display every ~half second to flash a digit
                if (gcSetMode > 0)
043A  085E  	MOVF gbl_gcSetMode, W
043B  3C00  	SUBLW 0x00
043C  1C03  	BTFSS STATUS,C

                    tm1638UpdateDisplay();
043D  21F5  	CALL tm1638Upda_0001E

                cTask.TASK_TIMER2 = 0;
043E  12DB  	BCF gbl_cTask,5

            }
            // Poll keys
            tm1638ReadKeys();
043F  22BD  	CALL tm1638Read_0001F

            if (tm1638Keys != 0) {
0440  08E6  	MOVF gbl_tm1638Keys, F
0441  1D03  	BTFSS STATUS,Z

                processKeys();
0442  22F7  	CALL processKey_00021

            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
// I2C Communications Library for I2C MASTER
////////////////////////////////////////////////////////////////////////////
// Author(s): Andrew Smallridge
// Date 15 November 2004
//
// Copyright(C) 2004-2006 Andrew Smallridge
// Copyright(C) 2004-2010 Pavel Baranov
// Copyright(C) 2004-2010 David Hobday
// Existing constants predefined for i2c hardware driver and i2s software
// emulation for the PIC 18F2xx and 18F4xx processors. For hardware support
// on other PICs the constants must be mapped to the corresponding register
// map of the target device
////////////////////////////////////////////////////////////////////////////

/*
////////////////////////////////////////////////////////////////////////////
//	The following three sections should be copied to the user's program:
//		i2c master hardware / software mode definition
//		i2c software implementation template arguments and variables
// 		i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////
// i2c master hardware / software mode definition
//
// For i2c hardware support comment out the #define use_ic2_SW line
////////////////////////////////////////////////////////////////////////////
//#define use_i2c_SW

#if defined use_i2c_SW
////////////////////////////////////////////////////////////////////////////
// i2c software implementation template arguments and variables
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP)

// RAM used by the software i2c driver to emulate the equivalent i2c hardware registers					
unsigned short swi2c_SSPCON1@0x40;	// define location for the emulated SSPCON1
unsigned short swi2c_SSPCON2@0x41;	// define location for the emulated SSPCON2
unsigned short swi2c_SSPSTAT@0x42;	// define location for the emulated SSPSTAT
unsigned short swi2c_SSPBUF@0x43;	// define location for the emulated SSPBUF
unsigned short swi2c_SSPIF_PIR@0x44;// define location for the emulated SSPIF_PIR
unsigned short swi2c_BCLIF_PIR@0x45;// define location for the emulated BCLIF_PIR
unsigned short swi2c_SSPADD@0x46;	// define location for the emulated SSPADD

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and software emalated i2c RAM locations. These constants are
// then used by the templated functions. When changing the address of an emulated
// register the corresponding constant mapping must also be changed.
#define e_SSPCON1	0x40
#define e_SSPCON2	0x41
#define e_SSPSTAT	0x42
#define e_SSPADD	0x43
#define e_SSPBUF	0x44
#define e_SSPIF_PIR	0x45
#define e_BCLIF_PIR	0x46
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3					

#else
////////////////////////////////////////////////////////////////////////////
// i2c hardwareware implementation template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_ARGS	3, PORTC, TRISC, 4, PORTC, TRISC, e_SSPCON1, e_SSPCON2, \
					e_SSPSTAT, e_SSPBUF, e_SSPIF_BIT, e_SSPIF_PIR,			\
					e_BCLIF_BIT, e_BCLIF_PIR, 7, e_SSPADD, (i2c_reset_wdt | i2c_SMP |i2c_HW)

// variables cannot be passed as template arguments. The following constants map to
// the PIC registers and PIC's i2c register locations. These constants are
// then used by the templated functions. 
#define PORTC		0x0f82
#define TRISC		0x0f94
#define e_SSPCON1	0xfc6
#define e_SSPCON2	0xfc5
#define e_SSPSTAT	0xfc7
#define e_SSPADD	0xfc8
#define e_SSPBUF	0xfc9
#define e_SSPIF_PIR	0xf9e
#define e_BCLIF_PIR	0xfa1
#define e_SSPIF_BIT	3
#define e_BCLIF_BIT	3

#endif

*/


////////////////////////////////////////////////////////////////////////////
// Define the common i2c template structure
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL	template <unsigned char T_SCL_BIT, unsigned short T_SCL_PORT,	\
					unsigned short T_SCL_TRIS, unsigned char T_SDA_BIT, 			\
					unsigned short T_SDA_PORT, unsigned short T_SDA_TRIS,			\
					unsigned short T_i2c_SSPCON1, unsigned short T_i2c_SSPCON2, 	\
					unsigned short T_i2c_SSPSTAT, unsigned short T_i2c_SSPBUF, 		\
					unsigned char T_i2c_SSPIF_BIT, unsigned short T_i2c_SSPIF_PIR,	\
					unsigned char T_i2c_BCLIF_BIT, unsigned short T_i2c_BCLIF_PIR,	\
					unsigned char T_i2c_SMP_BIT, unsigned short T_i2c_SSPADD, 		\
					unsigned char T_MODE>

////////////////////////////////////////////////////////////////////////////
// Define the common i2c template parameters
////////////////////////////////////////////////////////////////////////////
#define _I2C_TEMPL_ARGS	T_SCL_BIT, T_SCL_PORT, T_SCL_TRIS, T_SDA_BIT, 			\
						T_SDA_PORT, T_SDA_TRIS, T_i2c_SSPCON1, T_i2c_SSPCON2, 	\
						T_i2c_SSPSTAT, T_i2c_SSPBUF, T_i2c_SSPIF_BIT, 			\
						T_i2c_SSPIF_PIR, T_i2c_BCLIF_BIT, T_i2c_BCLIF_PIR,		\
						T_i2c_SMP_BIT, T_i2c_SSPADD, T_MODE

////////////////////////////////////////////////////////////////////////////
// Helpers that hide template arguments
////////////////////////////////////////////////////////////////////////////
#define i2c_init	i2c_INIT<i2c_ARGS>
#define i2c_start	i2c_START<i2c_ARGS>
#define i2c_restart	i2c_RESTART<i2c_ARGS>
#define i2c_stop	i2c_STOP<i2c_ARGS>
#define i2c_read	i2c_READ<i2c_ARGS>
#define i2c_write	i2c_WRITE<i2c_ARGS>


////////////////////////////////////////////////////////////////////////////
// I2C Control Status Bits - Emulates the PIC18F hardware I2C implementation
////////////////////////////////////////////////////////////////////////////
// define I2C i2C_SSPCON1 control bits
#define	i2c_WCOL	7
#define	i2c_SSPOV	6
#define	i2c_SSPEN	5
#define	i2c_CKP		4
#define	i2c_SSPM3	3
#define	i2c_SSPM2	2
#define	i2c_SSPM1	1
#define	i2c_SSPM0	0

// define I2C SSPCON2 control bits
#define	i2c_GCEN 	7
#define	i2c_ACKSTAT	6
#define	i2c_ACKDT	5
#define	i2c_ACKEN	4
#define	i2c_RCEN	3
#define	i2c_PEN		2
#define	i2c_RSEN	1
#define	i2c_SEN		0

// define I2C SSPSTAT status bits
#define	i2c_DA		5
#define	i2c_P		4
#define	i2c_S		3
#define	i2c_RW		2
#define	i2c_UA		1
#define	i2c_BF		0


////////////////////////////////////////////////////////////////////////////
// I2C Control Flag Bits
////////////////////////////////////////////////////////////////////////////
// define I2C Mode bits
#define	i2c_HW			0x01
#define	i2c_400KHz		0x02	// 100KHz or 400KHz I2C clock (set = 400KHz)
#define	i2c_reset_wdt	0x04
#define i2c_SMP			0x80	


////////////////////////////////////////////////////////////////////////////
// I2C software constants
////////////////////////////////////////////////////////////////////////////
#define	dly 10	// number of 1us delay increments



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Start Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL 
void i2c_START(void)

{
	// Initiate the I2C START condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	delay_us(dly);
00A5  300A  	MOVLW 0x0A
00A6  1283  	BCF STATUS, RP0
00A7  1303  	BCF STATUS, RP1
00A8  00EC  	MOVWF delay_us_00000_arg_del
00A9  2010  	CALL delay_us_00000

	l_bclif = 0; // initialise the collision flag for this command
00AA  11C6  	BCF i2c_START_00000_1_l_bclif,3

	l_sspif = 0;
00AB  11C5  	BCF i2c_START_00000_1_l_sspif,3

		
	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
			
		l_sen = 1; // initiate START condition	

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation			
		l_sen = 1; // initiate START condition
00AC  1441  	BSF i2c_START_00000_1_l_sen,0

		l_scl_tris = 1; // ensure the SCL line is high
00AD  1683  	BSF STATUS, RP0
00AE  1505  	BSF i2c_START_00000_1_l_scl_tris,2

		l_sda_tris = 1; // ensure the SDA line is high	
00AF  1585  	BSF i2c_START_00000_1_l_sda_tris,3

		l_scl = 0; // prepare to set SCL line low
00B0  1283  	BCF STATUS, RP0
00B1  1105  	BCF i2c_START_00000_1_l_scl,2

		l_sda = 0; // prepare to set SDA line low
00B2  1185  	BCF i2c_START_00000_1_l_sda,3

		
		if (l_scl && l_sda)
00B3  1D05  	BTFSS i2c_START_00000_1_l_scl,2
00B4  28D2  	GOTO	label16
00B5  1D85  	BTFSS i2c_START_00000_1_l_sda,3
00B6  28D2  	GOTO	label16
00D2        label16

		{
			// good sign - no collision detected
			delay_us(dly);
00B7  300A  	MOVLW 0x0A
00B8  00EC  	MOVWF delay_us_00000_arg_del
00B9  2010  	CALL delay_us_00000

			
			if (!l_scl) // ensure the clock is still high
00BA  1905  	BTFSC i2c_START_00000_1_l_scl,2
00BB  28C0  	GOTO	label15
00C0        label15

			{
				l_bclif = 1;
00BC  15C6  	BSF i2c_START_00000_1_l_bclif,3

				l_s = 1;
00BD  15C2  	BSF i2c_START_00000_1_l_s,3

				l_sen = 0;
00BE  1041  	BCF i2c_START_00000_1_l_sen,0

				return;
			}
					
			l_sda = 0; // prepare to set SDA line low
00C0  1185  	BCF i2c_START_00000_1_l_sda,3

			l_sda_tris = 0; // SDA to output (driven low)
00C1  1683  	BSF STATUS, RP0
00C2  1185  	BCF i2c_START_00000_1_l_sda_tris,3


			delay_us(dly);					
00C3  300A  	MOVLW 0x0A
00C4  1283  	BCF STATUS, RP0
00C5  00EC  	MOVWF delay_us_00000_arg_del
00C6  2010  	CALL delay_us_00000

			l_scl = 0; // prepare to set SCL line low
00C7  1105  	BCF i2c_START_00000_1_l_scl,2

			l_scl_tris = 0; // SCL to output (driven low)
00C8  1683  	BSF STATUS, RP0
00C9  1105  	BCF i2c_START_00000_1_l_scl_tris,2


			delay_us(dly);					
00CA  300A  	MOVLW 0x0A
00CB  1283  	BCF STATUS, RP0
00CC  00EC  	MOVWF delay_us_00000_arg_del
00CD  2010  	CALL delay_us_00000

			l_s = 1; // set 'S' bit flag (start bit detected)
00CE  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0; // clear flag
00CF  1041  	BCF i2c_START_00000_1_l_sen,0

			l_sspif = 1; // flag end of start condition interrupt	
00D0  15C5  	BSF i2c_START_00000_1_l_sspif,3

		}
		else
		{
			// here is SDA or SCL are low at the start - indicates a bus collision
			l_bclif = 1;
00D2  15C6  	BSF i2c_START_00000_1_l_bclif,3

			l_s = 1; // set 'S' bit flag (start bit detected)
00D3  15C2  	BSF i2c_START_00000_1_l_s,3

			l_sen = 0;
00D4  1041  	BCF i2c_START_00000_1_l_sen,0

			l_rsen = 0;
00D5  10C1  	BCF i2c_START_00000_1_l_rsen,1

			l_pen = 0;
00D6  1141  	BCF i2c_START_00000_1_l_pen,2

			l_rcen = 0;								
00D7  11C1  	BCF i2c_START_00000_1_l_rcen,3

			l_acken = 0;			
00D8  1241  	BCF i2c_START_00000_1_l_acken,4

		}
	}
}
00BF  0008  	RETURN
00D1  0008  	RETURN
00D9  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Restart Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_RESTART(void)
{
	// Initiate the I2C RESTART condition
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
			
	delay_us(dly);
	l_bclif = 0; // initialise the collision flag for this command
	l_sspif = 0;

	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_rsen = 1; // initiate RESTART condition
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
	}
	else
	{
		//	Software I2C implementation	
		l_rsen = 1;
		l_scl = 0;
		l_sda = 0;
		
		if (!l_scl)
		{
			// good sign - no other I2C activity in progress
			l_sda_tris = 1; // float SDA line high	(should already be in this condition)	
			delay_us(dly);
		
			// about to float the clock line
			// ensure the data line is still high
			if (!l_sda)
			{
				// problem - SDA is low, a bus collision has occurred				
				l_bclif = 1; // set the bus collision flag	
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_scl_tris = 1; // float SCL line (high)	
				return;
			}
												
			l_scl_tris = 1; // float SCL line (high)

			// wait until any clock stretching has finished
			while (!l_scl)
				if (T_MODE & i2c_reset_wdt)
					clear_wdt();	
			delay_us(dly);
			
			// here we are about to drive SDA low
			// first ensure SCL is still high
			if (!l_scl)
			{
				// problem - SCL is low, a bus collision has occurred
				l_bclif = 1; // set the bus collision flag
				l_s = 0; // clear 'S' bit flag
				l_rsen = 0;
				l_sda_tris = 1; // float SDA line (high)
				return;
			}
				
			l_sda_tris = 0; // drive SDA low
			l_s = 1; // set 'S' bit flag (start bit detected)

			delay_us(dly);
			l_scl_tris = 0; // drive SCL low
			l_rsen = 0;
			l_pen = 0;
			l_sen = 0;			
			l_rcen = 0;								
			l_acken = 0;			
			l_sspif = 1; // flag end of start condition interrupt
		}
		else
		{
			// SCL is high at the start
			// some other I2C activity in progress		
			l_rsen = 0; // clear flag
			// exit without further action
		}
	}
}



////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Stop Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_STOP(void)

{ 
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW, l_s@T_i2c_SSPSTAT.i2c_S, l_p@T_i2c_SSPSTAT.i2c_P; 
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;

	l_bclif = 0; // initialise the collision flag for this command
0075  1283  	BCF STATUS, RP0
0076  1303  	BCF STATUS, RP1
0077  11C6  	BCF i2c_STOP_00000_1_l_bclif,3

	l_sspif = 0;
0078  11C5  	BCF i2c_STOP_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
					
		l_pen = 1; // initiate STOP condition on the I2C bus	
	
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
		
	}
	else
	{
		//	Software I2C implementation
		l_pen = 1; // initiate STOP condition on the I2C bus
0079  1541  	BSF i2c_STOP_00000_1_l_pen,2

		delay_us(dly);
007A  300A  	MOVLW 0x0A
007B  00EC  	MOVWF delay_us_00000_arg_del
007C  2010  	CALL delay_us_00000

		
		l_scl = 0; // prepare to set SCL line low
007D  1105  	BCF i2c_STOP_00000_1_l_scl,2

		l_sda = 0; // prepare to set SDA line low
007E  1185  	BCF i2c_STOP_00000_1_l_sda,3

		l_scl_tris = 0; // drive SCL line low (should already be low)
007F  1683  	BSF STATUS, RP0
0080  1105  	BCF i2c_STOP_00000_1_l_scl_tris,2

		l_sda_tris = 0; // drive SDA line low
0081  1185  	BCF i2c_STOP_00000_1_l_sda_tris,3


		delay_us(dly);		
0082  300A  	MOVLW 0x0A
0083  1283  	BCF STATUS, RP0
0084  00EC  	MOVWF delay_us_00000_arg_del
0085  2010  	CALL delay_us_00000

		l_scl_tris = 1; // float SCL line (high)
0086  1683  	BSF STATUS, RP0
0087  1505  	BSF i2c_STOP_00000_1_l_scl_tris,2

		
		// wait until any clock stretching has finished
		while (!l_scl)
0088        label11
0088  1283  	BCF STATUS, RP0
0089  1905  	BTFSC i2c_STOP_00000_1_l_scl,2
008A  288D  	GOTO	label12
008C  2888  	GOTO	label11
008D        label12

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
008B  0064  	CLRWDT

						
		delay_us(dly);
008D  300A  	MOVLW 0x0A
008E  00EC  	MOVWF delay_us_00000_arg_del
008F  2010  	CALL delay_us_00000

		l_sda_tris = 1; // float SDA line
0090  1683  	BSF STATUS, RP0
0091  1585  	BSF i2c_STOP_00000_1_l_sda_tris,3

		delay_us(dly);		
0092  300A  	MOVLW 0x0A
0093  1283  	BCF STATUS, RP0
0094  00EC  	MOVWF delay_us_00000_arg_del
0095  2010  	CALL delay_us_00000

		
		// here the SDA line should be high - if not a collision has occurred				
		if (!l_sda || !l_scl)
0096  1D85  	BTFSS i2c_STOP_00000_1_l_sda,3
0097  289A  	GOTO	label13
0098  1905  	BTFSC i2c_STOP_00000_1_l_scl,2
0099  289E  	GOTO	label14
009A        label13
009E        label14

		{
			// problem - SDA or SCL is low, a bus collision has occurred
			l_bclif = 1; // set the bus collision flag	
009A  15C6  	BSF i2c_STOP_00000_1_l_bclif,3

			l_s = 0; // clear 'S' bit flag
009B  11C2  	BCF i2c_STOP_00000_1_l_s,3

			l_pen = 0; // clear flag
009C  1141  	BCF i2c_STOP_00000_1_l_pen,2

		}
		else
		{		
			l_p = 1;
009E  1642  	BSF i2c_STOP_00000_1_l_p,4

			l_pen = 0;
009F  1141  	BCF i2c_STOP_00000_1_l_pen,2

			l_sen = 0;
00A0  1041  	BCF i2c_STOP_00000_1_l_sen,0

			l_rsen = 0;			
00A1  10C1  	BCF i2c_STOP_00000_1_l_rsen,1

			l_rcen = 0;								
00A2  11C1  	BCF i2c_STOP_00000_1_l_rcen,3

			l_acken = 0;
00A3  1241  	BCF i2c_STOP_00000_1_l_acken,4

		}
	}
}
009D  0008  	RETURN
00A4  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Write Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_WRITE(unsigned char i2c_data)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;	
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
	
	char BitMask;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
0024  11C6  	BCF i2c_WRITE_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
0025  11C5  	BCF i2c_WRITE_00000_1_l_sspif,3


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
				
		l_wcol = 0; // clear write collision flag	
		i2c_SSPBUF = i2c_data;

		// test if a write collision occurred
		if (l_wcol)
			return (1); // error exit	

		// wait until MSSP Tx register is empty
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)	
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();
								
		return (0); // successful exit
	}

	// here for i2c software driver
	l_wcol = 0; // clear write collision flag	
0026  13C0  	BCF i2c_WRITE_00000_1_l_wcol,7

	i2c_SSPBUF = i2c_data;
0027  0869  	MOVF i2c_WRITE_00000_arg_i2c_data, W
0028  00C4  	MOVWF i2c_WRITE_00000_1_i2c_SSPBUF

	
	l_scl = 0; // prepare to set SCL line low
0029  1105  	BCF i2c_WRITE_00000_1_l_scl,2

	l_sda = 0; // prepare to set SDA line low
002A  1185  	BCF i2c_WRITE_00000_1_l_sda,3

	l_rw = 0; // signal we are doing a write
002B  1142  	BCF i2c_WRITE_00000_1_l_rw,2


	for (BitMask = 0x80; BitMask; BitMask>>=1)
002C  3080  	MOVLW 0x80
002D  00EA  	MOVWF i2c_WRITE_00000_1_BitMask
002E        label3
002E  08EA  	MOVF i2c_WRITE_00000_1_BitMask, F
002F  1903  	BTFSC STATUS,Z
0030  2851  	GOTO	label8
004E  1003  	BCF STATUS,C
004F  0CEA  	RRF i2c_WRITE_00000_1_BitMask, F
0050  282E  	GOTO	label3
0051        label8

	{
		if (i2c_data & BitMask)
0031  086A  	MOVF i2c_WRITE_00000_1_BitMask, W
0032  0569  	ANDWF i2c_WRITE_00000_arg_i2c_data, W
0033  1903  	BTFSC STATUS,Z
0034  2838  	GOTO	label4
0038        label4

			l_sda_tris = 1; // float SDA high	
0035  1683  	BSF STATUS, RP0
0036  1585  	BSF i2c_WRITE_00000_1_l_sda_tris,3

		else
0037  283A  	GOTO	label5
003A        label5

			l_sda_tris = 0; // drive SDA low
0038  1683  	BSF STATUS, RP0
0039  1185  	BCF i2c_WRITE_00000_1_l_sda_tris,3

		delay_us(dly);
003A  300A  	MOVLW 0x0A
003B  1283  	BCF STATUS, RP0
003C  00EC  	MOVWF delay_us_00000_arg_del
003D  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
003E  1683  	BSF STATUS, RP0
003F  1505  	BSF i2c_WRITE_00000_1_l_scl_tris,2


		// wait until any clock stretching has finished
		while (!l_scl)
0040        label6
0040  1283  	BCF STATUS, RP0
0041  1905  	BTFSC i2c_WRITE_00000_1_l_scl,2
0042  2845  	GOTO	label7
0044  2840  	GOTO	label6
0045        label7

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
0043  0064  	CLRWDT

		delay_us(dly);
0045  300A  	MOVLW 0x0A
0046  00EC  	MOVWF delay_us_00000_arg_del
0047  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low	
0048  1683  	BSF STATUS, RP0
0049  1105  	BCF i2c_WRITE_00000_1_l_scl_tris,2

		delay_us(dly);
004A  300A  	MOVLW 0x0A
004B  1283  	BCF STATUS, RP0
004C  00EC  	MOVWF delay_us_00000_arg_del
004D  2010  	CALL delay_us_00000

	}
	// serialized out the data
	// now get the status		
	// set SSPIF
	l_sspif = 1;
0051  15C5  	BSF i2c_WRITE_00000_1_l_sspif,3

	l_acken = 1;
0052  1641  	BSF i2c_WRITE_00000_1_l_acken,4

	l_ackdt = 0;
0053  12C1  	BCF i2c_WRITE_00000_1_l_ackdt,5

	l_sda_tris = 1; // float SDA high
0054  1683  	BSF STATUS, RP0
0055  1585  	BSF i2c_WRITE_00000_1_l_sda_tris,3

	
	delay_us(dly);
0056  300A  	MOVLW 0x0A
0057  1283  	BCF STATUS, RP0
0058  00EC  	MOVWF delay_us_00000_arg_del
0059  2010  	CALL delay_us_00000

	
	l_scl_tris = 1; // float SCL high
005A  1683  	BSF STATUS, RP0
005B  1505  	BSF i2c_WRITE_00000_1_l_scl_tris,2

	
	// wait until any clock stretching has finished
	while (!l_scl)
005C        label9
005C  1283  	BCF STATUS, RP0
005D  1905  	BTFSC i2c_WRITE_00000_1_l_scl,2
005E  2861  	GOTO	label10
0060  285C  	GOTO	label9
0061        label10

		if (T_MODE & i2c_reset_wdt)
			clear_wdt();	
005F  0064  	CLRWDT

	delay_us(dly);
0061  300A  	MOVLW 0x0A
0062  00EC  	MOVWF delay_us_00000_arg_del
0063  2010  	CALL delay_us_00000


	// get the status bit
	local_ack = l_sda;
0064  106B  	BCF i2c_WRITE_00000_1_local_ack,0
0065  1985  	BTFSC i2c_WRITE_00000_1_l_sda,3
0066  146B  	BSF i2c_WRITE_00000_1_local_ack,0

	delay_us(dly);
0067  300A  	MOVLW 0x0A
0068  00EC  	MOVWF delay_us_00000_arg_del
0069  2010  	CALL delay_us_00000


	l_scl_tris = 0; // drive SCL low	
006A  1683  	BSF STATUS, RP0
006B  1105  	BCF i2c_WRITE_00000_1_l_scl_tris,2

	l_acken = 0;
006C  1283  	BCF STATUS, RP0
006D  1241  	BCF i2c_WRITE_00000_1_l_acken,4

	delay_us(dly);
006E  300A  	MOVLW 0x0A
006F  00EC  	MOVWF delay_us_00000_arg_del
0070  2010  	CALL delay_us_00000

	return(local_ack);
0071  01EC  	CLRF CompTempVarRet549
0072  186B  	BTFSC i2c_WRITE_00000_1_local_ack,0
0073  0AEC  	INCF CompTempVarRet549, F

}
0074  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Read Condition
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
unsigned char i2c_READ(char ack_status)

{
	volatile unsigned char i2c_SSPBUF@T_i2c_SSPBUF;
	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_bf@T_i2c_SSPSTAT.i2c_BF, l_ackdt@T_i2c_SSPCON2.i2c_ACKDT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_rw@T_i2c_SSPSTAT.i2c_RW,l_wcol@T_i2c_SSPCON1.i2c_WCOL;
	volatile bit l_rcen@T_i2c_SSPCON2.i2c_RCEN, l_pen@T_i2c_SSPCON2.i2c_PEN, l_sen@T_i2c_SSPCON2.i2c_SEN;
	volatile bit l_rsen@T_i2c_SSPCON2.i2c_RSEN, l_acken@T_i2c_SSPCON2.i2c_ACKEN;
		
	char BitMask;
	char i2c_data;
	bit local_ack;

	l_bclif = 0; // initialise the collision flag for this command
013A  11C6  	BCF i2c_READ_00000_1_l_bclif,3

	l_sspif = 0; // clear the operation completed
013B  11C5  	BCF i2c_READ_00000_1_l_sspif,3

	l_wcol = 0; // clear write collision flag	
013C  13C0  	BCF i2c_READ_00000_1_l_wcol,7


	if (T_MODE & i2c_HW)
	{
		//	Hardware I2C implementation
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// enable master for 1 byte reception	
		l_rcen = 1;

		// wait until byte received
		while(!l_sspif || !l_bf)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		// read the byte from the Rx register
		i2c_data = i2c_SSPBUF;			
			
		// wait until the bus is idle		
		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw)
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();

		if (ack_status)
			l_ackdt = 1; // preset ack bit
		else
			l_ackdt = 0; // preset ack bit

		l_sspif = 0;
		l_acken = 1; // acknowledge sequence enable

		while (l_acken || l_rcen || l_pen || l_rsen || l_sen || l_rw || !l_sspif)			
			if (T_MODE & i2c_reset_wdt)
				clear_wdt();								
	}
	else
	{
		// here for i2c software driver
		l_rcen = 1;
013D  15C1  	BSF i2c_READ_00000_1_l_rcen,3

		l_ackdt = ack_status;
013E  1867  	BTFSC i2c_READ_00000_arg_ack_status,0
013F  16C1  	BSF i2c_READ_00000_1_l_ackdt,5
0140  1C67  	BTFSS i2c_READ_00000_arg_ack_status,0
0141  12C1  	BCF i2c_READ_00000_1_l_ackdt,5

		l_rw = 1;
0142  1542  	BSF i2c_READ_00000_1_l_rw,2

		l_scl = 0; // prepare to set SCL line low
0143  1105  	BCF i2c_READ_00000_1_l_scl,2

		l_sda = 0; // prepare to set SDA line low	
0144  1185  	BCF i2c_READ_00000_1_l_sda,3


		// prepare to serialize in the byte
		l_sda_tris = 1; // float SDA
0145  1683  	BSF STATUS, RP0
0146  1585  	BSF i2c_READ_00000_1_l_sda_tris,3

		delay_us(dly);
0147  300A  	MOVLW 0x0A
0148  1283  	BCF STATUS, RP0
0149  00EC  	MOVWF delay_us_00000_arg_del
014A  2010  	CALL delay_us_00000

		i2c_data = 0;
014B  01E9  	CLRF i2c_READ_00000_1_i2c_data

		for (BitMask = 0x80; BitMask; BitMask>>=1)
014C  3080  	MOVLW 0x80
014D  00E8  	MOVWF i2c_READ_00000_1_BitMask
014E        label22
014E  08E8  	MOVF i2c_READ_00000_1_BitMask, F
014F  1903  	BTFSC STATUS,Z
0150  296B  	GOTO	label26
0168  1003  	BCF STATUS,C
0169  0CE8  	RRF i2c_READ_00000_1_BitMask, F
016A  294E  	GOTO	label22
016B        label26

		{
			l_scl_tris = 1; // float SCL high
0151  1683  	BSF STATUS, RP0
0152  1505  	BSF i2c_READ_00000_1_l_scl_tris,2

			// wait until any clock stretching has finished
			while (!l_scl)
0153        label23
0153  1283  	BCF STATUS, RP0
0154  1905  	BTFSC i2c_READ_00000_1_l_scl,2
0155  2958  	GOTO	label24
0157  2953  	GOTO	label23
0158        label24

				if (T_MODE & i2c_reset_wdt)
					clear_wdt();		
0156  0064  	CLRWDT

			delay_us(dly);
0158  300A  	MOVLW 0x0A
0159  00EC  	MOVWF delay_us_00000_arg_del
015A  2010  	CALL delay_us_00000


			// read the current bit
			l_sda_tris = 1; // float SDA
015B  1683  	BSF STATUS, RP0
015C  1585  	BSF i2c_READ_00000_1_l_sda_tris,3

			if (l_sda)
015D  1283  	BCF STATUS, RP0
015E  1D85  	BTFSS i2c_READ_00000_1_l_sda,3
015F  2962  	GOTO	label25
0162        label25

				i2c_data |= BitMask;
0160  0868  	MOVF i2c_READ_00000_1_BitMask, W
0161  04E9  	IORWF i2c_READ_00000_1_i2c_data, F

			l_scl_tris = 0; // drive SCL low
0162  1683  	BSF STATUS, RP0
0163  1105  	BCF i2c_READ_00000_1_l_scl_tris,2

			delay_us(dly);
0164  300A  	MOVLW 0x0A
0165  1283  	BCF STATUS, RP0
0166  00EC  	MOVWF delay_us_00000_arg_del
0167  2010  	CALL delay_us_00000

		}
		// flag receive complete			
		l_sspif = 1;
016B  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		l_rcen = 0;
016C  11C1  	BCF i2c_READ_00000_1_l_rcen,3

		
		// set the ACK state
		if (ack_status)	
016D  08E7  	MOVF i2c_READ_00000_arg_ack_status, F
016E  1903  	BTFSC STATUS,Z
016F  2973  	GOTO	label27
0173        label27

			l_sda_tris = 1; // float SDA high
0170  1683  	BSF STATUS, RP0
0171  1585  	BSF i2c_READ_00000_1_l_sda_tris,3

		else
0172  2975  	GOTO	label28
0175        label28

			l_sda_tris = 0; // drive SDA low
0173  1683  	BSF STATUS, RP0
0174  1185  	BCF i2c_READ_00000_1_l_sda_tris,3

		delay_us(dly);
0175  300A  	MOVLW 0x0A
0176  1283  	BCF STATUS, RP0
0177  00EC  	MOVWF delay_us_00000_arg_del
0178  2010  	CALL delay_us_00000


		l_scl_tris = 1; // float SCL high
0179  1683  	BSF STATUS, RP0
017A  1505  	BSF i2c_READ_00000_1_l_scl_tris,2


		// wait until any clock stretching has finished
		while (!l_scl)
017B        label29
017B  1283  	BCF STATUS, RP0
017C  1905  	BTFSC i2c_READ_00000_1_l_scl,2
017D  2980  	GOTO	label30
017F  297B  	GOTO	label29
0180        label30

			if (T_MODE & i2c_reset_wdt)
				clear_wdt();		
017E  0064  	CLRWDT

	
		l_sspif = 0; // clear SSPIF
0180  11C5  	BCF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
0181  300A  	MOVLW 0x0A
0182  00EC  	MOVWF delay_us_00000_arg_del
0183  2010  	CALL delay_us_00000

	
		l_scl_tris = 0; // drive SCL low		
0184  1683  	BSF STATUS, RP0
0185  1105  	BCF i2c_READ_00000_1_l_scl_tris,2

		l_sspif = 1;
0186  1283  	BCF STATUS, RP0
0187  15C5  	BSF i2c_READ_00000_1_l_sspif,3

		delay_us(dly);
0188  300A  	MOVLW 0x0A
0189  00EC  	MOVWF delay_us_00000_arg_del
018A  2010  	CALL delay_us_00000

	}
	return(i2c_data);
018B  0869  	MOVF i2c_READ_00000_1_i2c_data, W
018C  00EA  	MOVWF CompTempVarRet550

}
018D  0008  	RETURN




////////////////////////////////////////////////////////////////////////////
// Generates the I2C Bus Initialization
////////////////////////////////////////////////////////////////////////////
_I2C_TEMPL
void i2c_INIT(unsigned char i2c_divisor)

{
	volatile unsigned char i2c_SSPADD@T_i2c_SSPADD, i2c_SSPSTAT@T_i2c_SSPSTAT;
	volatile unsigned char i2c_SSPCON1@T_i2c_SSPCON1,i2c_SSPCON2@T_i2c_SSPCON2;

	volatile bit l_scl@T_SCL_PORT.T_SCL_BIT, l_sda@T_SDA_PORT.T_SDA_BIT;
	volatile bit l_scl_tris@T_SCL_TRIS.T_SCL_BIT, l_sda_tris@T_SDA_TRIS.T_SDA_BIT;
	volatile bit l_sspif@T_i2c_SSPIF_PIR.T_i2c_SSPIF_BIT, l_bclif@T_i2c_BCLIF_PIR.T_i2c_BCLIF_BIT;
	volatile bit l_sspen@T_i2c_SSPCON1.i2c_SSPEN, l_smp@T_i2c_SSPSTAT.T_i2c_SMP_BIT;

	l_sda_tris = 1;
018E  1683  	BSF STATUS, RP0
018F  1585  	BSF i2c_INIT_00000_1_l_sda_tris,3

	l_scl_tris = 1;
0190  1505  	BSF i2c_INIT_00000_1_l_scl_tris,2

	
	i2c_SSPCON1 = 0x00; // initialise the I2C control register (mirrors HW SSPCON1)	
0191  1283  	BCF STATUS, RP0
0192  01C0  	CLRF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPADD = i2c_divisor; // get the I2C baud rate divisor
0193  0867  	MOVF i2c_INIT_00000_arg_i2c_divisor, W
0194  00C3  	MOVWF i2c_INIT_00000_1_i2c_SSPADD

	i2c_SSPCON1 = 0x08; // initialise the I2C control register (mirrors HW SSPCON1)	
0195  3008  	MOVLW 0x08
0196  00C0  	MOVWF i2c_INIT_00000_1_i2c_SSPCON1

	i2c_SSPCON2 = 0x00; // initialise the I2C control register (mirrors HW SSPCON2)	
0197  01C1  	CLRF i2c_INIT_00000_1_i2c_SSPCON2

	
	i2c_SSPSTAT = 0x00; // initialise the I2C status register (mirrors HW SSPSTAT)
0198  01C2  	CLRF i2c_INIT_00000_1_i2c_SSPSTAT

	
	if (T_MODE & i2c_SMP)
		l_smp = 1;
0199  17C2  	BSF i2c_INIT_00000_1_l_smp,7


	l_sspif = 0; // initialise the I2C SSP interrupt status
019A  11C5  	BCF i2c_INIT_00000_1_l_sspif,3

	l_bclif = 0; // initialise the I2C BCL interrupt status
019B  11C6  	BCF i2c_INIT_00000_1_l_bclif,3

	l_sda = 0;
019C  1185  	BCF i2c_INIT_00000_1_l_sda,3

	l_scl = 0;
019D  1105  	BCF i2c_INIT_00000_1_l_scl,2

	l_sspen = 1; // enable I2C
019E  16C0  	BSF i2c_INIT_00000_1_l_sspen,5

	
	i2c_STOP<_I2C_TEMPL_ARGS>();
019F  2075  	CALL i2c_STOP_00000

}
01A0  0008  	RETURN







////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  2C44  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00C8  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00C9  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00CA  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2CA0  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010  3003  	MOVLW 0x03
0011  07EC  	ADDWF delay_us_00000_arg_del, F
0012  0CEC  	RRF delay_us_00000_arg_del, F
0013  0CEC  	RRF delay_us_00000_arg_del, F
0014  307F  	MOVLW 0x7F
0015  05EC  	ANDWF delay_us_00000_arg_del, F
0016        label1
0016  0000  	NOP
0017  0BEC  	DECFSZ delay_us_00000_arg_del, F
0018  2816  	GOTO	label1
0019  0008  	RETURN
001A        ; } delay_us function end

001A        delay_10us_00000
001A        ; { delay_10us ; function begin
001A        label2
001A  0000  	NOP
001B  0000  	NOP
001C  0000  	NOP
001D  0000  	NOP
001E  0000  	NOP
001F  0000  	NOP
0020  0000  	NOP
0021  0BEC  	DECFSZ delay_10us_00000_arg_del, F
0022  281A  	GOTO	label2
0023  0008  	RETURN
0024        ; } delay_10us function end














01CA        __mul_16s__0000F
01CA        ; { __mul_16s_16s__16 ; function begin
01CA  01F1  	CLRF __mul_16s__0000F_1_i
01CB  01F4  	CLRF CompTempVarRet386
01CC  01F5  	CLRF CompTempVarRet386+D'1'
01CD  1283  	BCF STATUS, RP0
01CE  1303  	BCF STATUS, RP1
01CF  086D  	MOVF __mul_16s__0000F_arg_a, W
01D0  00F2  	MOVWF __mul_16s__0000F_1_t
01D1  086E  	MOVF __mul_16s__0000F_arg_a+D'1', W
01D2  00F3  	MOVWF __mul_16s__0000F_1_t+D'1'
01D3  1FF0  	BTFSS __mul_16s__0000F_arg_b+D'1',7
01D4  29DB  	GOTO	label31
01D5  17F1  	BSF __mul_16s__0000F_1_i,7
01D6  09EF  	COMF __mul_16s__0000F_arg_b, F
01D7  09F0  	COMF __mul_16s__0000F_arg_b+D'1', F
01D8  0AEF  	INCF __mul_16s__0000F_arg_b, F
01D9  1903  	BTFSC gbl_status,2
01DA  0AF0  	INCF __mul_16s__0000F_arg_b+D'1', F
01DB        label31
01DB  1A71  	BTFSC __mul_16s__0000F_1_i,4
01DC  29ED  	GOTO	label33
01DD  1C6F  	BTFSS __mul_16s__0000F_arg_b,0
01DE  29E5  	GOTO	label32
01DF  0872  	MOVF __mul_16s__0000F_1_t, W
01E0  07F4  	ADDWF CompTempVarRet386, F
01E1  0873  	MOVF __mul_16s__0000F_1_t+D'1', W
01E2  1803  	BTFSC gbl_status,0
01E3  0F73  	INCFSZ __mul_16s__0000F_1_t+D'1', W
01E4  07F5  	ADDWF CompTempVarRet386+D'1', F
01E5        label32
01E5  1003  	BCF gbl_status,0
01E6  0CF0  	RRF __mul_16s__0000F_arg_b+D'1', F
01E7  0CEF  	RRF __mul_16s__0000F_arg_b, F
01E8  1003  	BCF gbl_status,0
01E9  0DF2  	RLF __mul_16s__0000F_1_t, F
01EA  0DF3  	RLF __mul_16s__0000F_1_t+D'1', F
01EB  0AF1  	INCF __mul_16s__0000F_1_i, F
01EC  29DB  	GOTO	label31
01ED        label33
01ED  1FF1  	BTFSS __mul_16s__0000F_1_i,7
01EE  0008  	RETURN
01EF  09F4  	COMF CompTempVarRet386, F
01F0  09F5  	COMF CompTempVarRet386+D'1', F
01F1  0AF4  	INCF CompTempVarRet386, F
01F2  1903  	BTFSC gbl_status,2
01F3  0AF5  	INCF CompTempVarRet386+D'1', F
01F4  0008  	RETURN
01F5        ; } __mul_16s_16s__16 function end














0444        _startup

049D  118A  	BCF PCLATH,3
049E  120A  	BCF PCLATH,4
049F  2C15  	GOTO	main

2007  3F18  	DW 0x3F18
